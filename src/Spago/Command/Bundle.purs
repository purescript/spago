module Spago.Command.Bundle where

import Spago.Prelude

import Data.Array (all, fold, take)
import Data.String as Str
import Data.String.Utils (startsWith)
import Node.Path as Path
import Spago.Cmd as Cmd
import Spago.Config (BundlePlatform(..), BundleType(..), Workspace, WorkspacePackage)
import Spago.Esbuild (Esbuild)
import Spago.FS as FS
import Spago.Generated.BuildInfo as BuildInfo

type BundleEnv a =
  { esbuild :: Esbuild
  , logOptions :: LogOptions
  , bundleOptions :: BundleOptions
  , workspace :: Workspace
  , selected :: WorkspacePackage
  | a
  }

type BundleOptions =
  { minify :: Boolean
  , sourceMaps :: Boolean
  , module :: String
  , outfile :: FilePath
  , forceOverwrite :: Boolean
  , platform :: BundlePlatform
  , type :: BundleType
  , extraArgs :: Array String
  }

type RawBundleOptions =
  { minify :: Boolean
  , module :: String
  , outfile :: FilePath
  , platform :: String
  , type :: String
  , extraArgs :: Array String
  }

run :: ∀ a. Spago (BundleEnv a) Unit
run = do
  { esbuild, selected, workspace, bundleOptions: opts } <- ask
  logDebug $ "Bundle options: " <> show opts
  let
    minify = if opts.minify then [ "--minify" ] else []
    sourceMap = if opts.sourceMaps then [ "--sourcemap" ] else []
    outfile = Path.concat [ selected.path, opts.outfile ]
    format = case opts.platform, opts.type of
      BundleBrowser, BundleApp -> "--format=iife"
      _, _ -> "--format=esm"

    onlyForNode s = case opts.platform of
      BundleNode -> s
      BundleBrowser -> ""

    output = workspace.buildOptions.output # fromMaybe "output"
    -- TODO: we might need to use `Path.relative selected.path output` instead of just output there
    mainPath = withForwardSlashes $ Path.concat [ output, opts.module, "index.js" ]

    { input, entrypoint } = case opts.type of
      BundleApp ->
        { entrypoint: []
        , input: Cmd.StdinWrite $ fold [ onlyForNode "#!/usr/bin/env node\n\n", "import { main } from './", mainPath, "';main();" ]
        }
      BundleModule ->
        { entrypoint: [ mainPath ]
        , input: Cmd.StdinNewPipe
        }

    execOptions = Cmd.defaultExecOptions { pipeStdin = input }

    banner = fold
      [ spagoGeneratedFilePrefix
      , " v"
      , BuildInfo.packages."spago-bin"
      , " */"
      , onlyForNode nodeTargetPolyfill
      ]

    args = fold
      [ [ "--bundle"
        , "--outfile=" <> outfile
        , "--platform=" <> show opts.platform
        , "--banner:js=" <> banner
        , "--loader:.node=file" -- See https://github.com/evanw/esbuild/issues/1051
        , format
        ]
      , opts.extraArgs
      , minify
      , sourceMap
      , entrypoint
      ]

  unless opts.forceOverwrite
    $ whenM (isNotSpagoGeneratedFile outfile)
    $ die [ "Target file " <> opts.outfile <> " was not previously generated by Spago. Use --force-overwrite to overwrite anyway." ]

  logInfo "Bundling..."
  logDebug $ "Running esbuild: " <> show args
  Cmd.exec esbuild.cmd args execOptions >>= case _ of
    Right _ -> logSuccess "Bundle succeeded."
    Left r -> do
      logDebug $ Cmd.printExecResult r
      die [ "Failed to bundle." ]

isNotSpagoGeneratedFile :: ∀ a. String -> Spago (BundleEnv a) Boolean
isNotSpagoGeneratedFile path = do
  exists <- FS.exists path
  if not exists then
    pure false
  else
    -- The first line of the file could be the marker, or it could the shebang
    -- if the bundle was compiled for Node, in which case the marker will be the
    -- second line. So we check the first two lines.
    FS.readTextFile path
      <#> Str.split (Str.Pattern "\n")
      >>> take 2
      >>> all (not startsWith spagoGeneratedFilePrefix)

spagoGeneratedFilePrefix :: String
spagoGeneratedFilePrefix = "/* Generated by Spago"

-- A polyfill inserted when building for Node to work around this esbuild issue:
-- https://github.com/evanw/esbuild/issues/1921
nodeTargetPolyfill :: String
nodeTargetPolyfill = Str.joinWith ";"
  [ "import __module from 'module'"
  , "import __path from 'path'"
  , "import __url from 'url'"
  , "const require = __module.createRequire(import.meta.url)"
  , "const __dirname = __path.dirname(__url.fileURLToPath(import.meta.url))"
  , "const __filename=new URL(import.meta.url).pathname"
  ]
