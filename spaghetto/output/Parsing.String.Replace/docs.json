{"comments":"This module is for finding patterns in a `String`, and also\nreplacing or splitting on the found patterns.\nThis activity is traditionally done with\n[__Regex__](https://pursuit.purescript.org/packages/purescript-strings/docs/Data.String.Regex),\nbut this module uses parsers instead for the pattern matching.\n\nFunctions in this module are *ways to run a parser* on an input `String`,\nlike `runParser` or `runParserT`.\n\n#### Why would we want to do pattern matching and substitution with parsers instead of regular expressions?\n\n* Monadic parsers have a nicer syntax than\n  [regular expressions](https://en.wikipedia.org/wiki/Regular_expression),\n  which are notoriously\n  [difficult to read](https://en.wikipedia.org/wiki/Write-only_language).\n  With monadic parsers we can perform textual pattern-matching in plain\n  PureScript rather than using a special regex domain-specific\n  programming language.\n\n* Regular expressions can do “group capture” on sections of the matched\n  pattern, but they can only return stringy lists of the capture groups. Parsers\n  can construct typed data structures based on the capture groups, guaranteeing\n  no disagreement between the pattern rules and the rules that we're using\n  to build data structures based on the pattern matches.\n\n  For example, consider\n  scanning a string for numbers. A lot of different things can look like a number,\n  and can have leading plus or minus signs, or be in scientific notation, or\n  have commas, or whatever. If we try to parse all of the numbers out of a string\n  using regular expressions, then we have to make sure that the regular expression\n  and the string-to-number conversion function agree about exactly what is\n  and what isn't a numeric string. We can get into an awkward situation in which\n  the regular expression says it has found a numeric string but the\n  string-to-number conversion function fails. A typed parser will perform both\n  the pattern match and the conversion, so it will never be in that situation.\n  [Parse, don't validate.](https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/)\n\n* Regular expressions are only able to pattern-match\n  [regular grammars](https://en.wikipedia.org/wiki/Chomsky_hierarchy#The_hierarchy).\n  Monadic parsers are able pattern-match context-free (by recursion)\n  or context-sensitive (by monad transformer) grammars.\n\n* The replacement expression for a traditional regular expression-based\n  substitution command is usually just a string template in which\n  the *Nth* “capture group” can be inserted with the syntax `\\N`. With\n  this library, instead of a template, we\n  can perform any replacement computation, including `Effect`s.\n\n#### Implementation Notes\n\nAll of the functions in this module work by calling `runParserT`\nwith the `anyTill` combinator.\nWe can expect the speed of parser-based pattern matching to be\nabout 10× worse than regex-based pattern matching in a JavaScript\nruntime environment.\nThis module is based on the Haskell packages\n[__replace-megaparsec__](https://hackage.haskell.org/package/replace-megaparsec)\nand\n[__replace-attoparsec__](https://hackage.haskell.org/package/replace-attoparsec).\n\n","declarations":[{"children":[],"comments":"#### Break on and capture one pattern\n\nFind the first occurence of a pattern in the input `String`, capture the found\npattern, and break the input `String` on the found pattern.\n\nThis function can be used instead of\n[Data.String.indexOf](https://pursuit.purescript.org/packages/purescript-strings/docs/Data.String#v:indexOf)\nor\n[Data.String.Regex.search](https://pursuit.purescript.org/packages/purescript-strings/docs/Data.String.Regex#v:search)\nor\n[Data.String.Regex.replace](https://pursuit.purescript.org/packages/purescript-strings/docs/Data.String.Regex#v:replace)\nand it allows using a parser for the pattern search.\n\nThis function can be used instead of\n[Data.String.takeWhile](https://pursuit.purescript.org/packages/purescript-strings/docs/Data.String#v:takeWhile)\nor\n[Data.String.dropWhile](https://pursuit.purescript.org/packages/purescript-strings/docs/Data.String#v:dropWhile)\nand it is predicated beyond more than just the next single `CodePoint`.\n\n#### Output\n\n- `Nothing` when no pattern match was found.\n- `Just (prefix /\\ parse_result /\\ suffix)` for the result of parsing the\n  pattern match, and the `prefix` string before and the `suffix` string\n  after the pattern match. `prefix` and `suffix` may be zero-length strings.\n\n#### Access the matched section of text\n\nTo capture the matched string combine the pattern\nparser `sep` with the `match` combinator.\n\nWith the matched string, we can reconstruct the input string.\nFor all `input`, `sep`, if\n\n```purescript\nlet (Just (prefix /\\ (infix /\\ _) /\\ suffix)) =\n      breakCap input (match sep)\n```\n\nthen\n\n```purescript\ninput == prefix <> infix <> suffix\n```\n#### Example\n\nFind the first pattern match and break the input string on the pattern.\n\n```purescript\nbreakCap \"hay needle hay\" (string \"needle\")\n```\n\nResult:\n\n```purescript\nJust (\"hay \" /\\ \"needle\" /\\ \" hay\")\n```\n\n#### Example\n\nFind the first pattern match, capture the matched text and the parsed result.\n\n```purescript\nbreakCap \"abc 123 def\" (match intDecimal)\n```\n\nResult:\n\n```purescript\nJust (\"abc \" /\\ (\"123\" /\\ 123) /\\ \" def\")\n```\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Parsing"],"Parser"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Maybe"],"Maybe"],"tag":"TypeConstructor"},{"annotation":[],"contents":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Tuple","Nested"],"T3"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},"tag":"ParensInType"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"TypeApp"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[190,32],"name":".spago/packages/parsing-10.2.0/src/Parsing/String/Replace.purs","start":[186,1]},"title":"breakCap"},{"children":[],"comments":"Monad transformer version of `breakCap`. The `sep` parser will run\nin the monad context.\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"m","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"m","tag":"TypeVar"}],"constraintClass":[["Control","Monad"],"Monad"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"m","tag":"TypeVar"}],"constraintClass":[["Control","Monad","Rec","Class"],"MonadRec"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Parsing"],"ParserT"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":"m","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":"m","tag":"TypeVar"},{"annotation":[],"contents":{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Maybe"],"Maybe"],"tag":"TypeConstructor"},{"annotation":[],"contents":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Tuple","Nested"],"T3"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},"tag":"ParensInType"}],"tag":"TypeApp"},"tag":"ParensInType"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"ConstrainedType"}],"tag":"ConstrainedType"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[106,36],"name":".spago/packages/parsing-10.2.0/src/Parsing/String/Replace.purs","start":[100,1]},"title":"breakCapT"},{"children":[],"comments":"#### Split on and capture all patterns\n\nFind all occurences of the pattern parser `sep`, split the\ninput `String`, capture all the matched patterns and the splits.\n\nThis function can be used instead of\n[Data.String.Common.split](https://pursuit.purescript.org/packages/purescript-strings/docs/Data.String.Common#v:split)\nor\n[Data.String.Regex.split](https://pursuit.purescript.org/packages/purescript-strings/docs/Data.String.Regex#v:split)\nor\n[Data.String.Regex.match](https://pursuit.purescript.org/packages/purescript-strings/docs/Data.String.Regex#v:match)\nor\n[Data.String.Regex.search](https://pursuit.purescript.org/packages/purescript-strings/docs/Data.String.Regex#v:search).\n\nThe input string will be split on every leftmost non-overlapping occurence\nof the pattern `sep`. The output list will contain\nthe parsed result of input string sections which match the `sep` pattern\nin `Right a`, and non-matching sections in `Left String`.\n\n#### Access the matched section of text\n\nTo capture the matched strings combine the pattern\nparser `sep` with the `match` combinator.\n\nWith the matched strings, we can reconstruct the input string.\nFor all `input`, `sep`, if\n\n```purescript\nlet output = splitCap input (match sep)\n```\n\nthen\n\n```purescript\ninput == fold (either identity fst <$> output)\n```\n\n#### Example\n\nSplit the input string on all `Int` pattern matches.\n\n```purescript\nsplitCap \"hay 1 straw 2 hay\" intDecimal\n```\n\nResult:\n\n```\n[Left \"hay \", Right 1, Left \" straw \", Right 2, Left \" hay\"]\n```\n\n#### Example\n\nFind the beginning positions of all pattern matches in the input.\n\n```purescript\ncatMaybes $ hush <$> splitCap \".𝝺...\\n...𝝺.\" (position <* string \"𝝺\")\n```\n\nResult:\n\n```purescript\n[ Position {index: 1, line: 1, column: 2 }\n, Position { index: 9, line: 2, column: 4 }\n]\n```\n\n#### Example\n\nFind groups of balanced nested parentheses. This pattern is an example of\na “context-free” grammar, a pattern that\n[can't be expressed by a regular expression](https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454).\nWe can express the pattern with a recursive parser.\n\n```purescript\nbalancedParens :: Parser String Unit\nbalancedParens = do\n  void $ char '('\n  void $ manyTill (balancedParens <|> void anyCodePoint) (char ')')\n\nrmap fst <$> splitCap \"((🌼)) (()())\" (match balancedParens)\n```\n\nResult:\n\n```purescript\n[Right \"((🌼))\", Left \" \", Right \"(()())\"]\n```\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Parsing"],"Parser"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","List","Types"],"NonEmptyList"],"tag":"TypeConstructor"},{"annotation":[],"contents":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Either"],"Either"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"},"tag":"ParensInType"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"TypeApp"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[410,36],"name":".spago/packages/parsing-10.2.0/src/Parsing/String/Replace.purs","start":[406,1]},"title":"splitCap"},{"children":[],"comments":"Monad transformer version of `splitCap`. The `sep` parser will run in the\nmonad context.\n\n#### Example\n\nCount the pattern matches.\n\nParse in a `State` monad to remember state in the parser. This\nstateful `letterCount` parser counts\nthe number of pattern matches which occur in the input, and also\ntags each match with its index.\n\n\n```purescript\nletterCount :: ParserT String (State Int) (Tuple Char Int)\nletterCount = do\n  x <- letter\n  i <- modify (_+1)\n  pure (x /\\ i)\n\nflip runState 0 $ splitCapT \"A B\" letterCount\n```\n\nResult:\n\n```purescript\n[Right ('A' /\\ 1), Left \" \", Right ('B' /\\ 2)] /\\ 2\n```\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"m","kind":null,"skolem":null,"type":{"annotation":[],"contents":{"identifier":"a","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"m","tag":"TypeVar"}],"constraintClass":[["Control","Monad"],"Monad"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"m","tag":"TypeVar"}],"constraintClass":[["Control","Monad","Rec","Class"],"MonadRec"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Parsing"],"ParserT"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":"m","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":"m","tag":"TypeVar"},{"annotation":[],"contents":{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","List","Types"],"NonEmptyList"],"tag":"TypeConstructor"},{"annotation":[],"contents":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Data","Either"],"Either"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":"a","tag":"TypeVar"}],"tag":"TypeApp"},"tag":"ParensInType"}],"tag":"TypeApp"},"tag":"ParensInType"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"ConstrainedType"}],"tag":"ConstrainedType"},"visibility":"TypeVarInvisible"},"tag":"ForAll"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[227,40],"name":".spago/packages/parsing-10.2.0/src/Parsing/String/Replace.purs","start":[221,1]},"title":"splitCapT"},{"children":[],"comments":"\n#### Find-and-replace\n\nAlso called “match-and-substitute”. Find all\nof the leftmost non-overlapping sections of the input string which match\nthe pattern parser `sep`, and\nreplace them with the result of the parser.\nThe `sep` parser must return a result of type `String` for the replacement.\n\nThis function can be used instead of\n[Data.String.replaceAll](https://pursuit.purescript.org/packages/purescript-strings/docs/Data.String#v:replaceAll)\nor\n[Data.String.Regex.replace'](https://pursuit.purescript.org/packages/purescript-strings/docs/Data.String.Regex#v:replace').\n\n#### Access the matched section of the input string\n\nTo get access to the matched string for calculating the replacement,\ncombine the pattern parser `sep`\nwith the `match` combinator.\nThis allows us to write a `sep` parser which can choose to not\nreplace the match and just leave it as it is.\n\nSo, for all `sep`:\n\n```purescript\nreplace input (fst <$> match sep) == input\n```\n\n#### Example\n\nFind and uppercase the `\"needle\"` pattern.\n\n```purescript\nreplace \"hay needle hay\" (toUpper <$> string \"needle\")\n```\n\nResult:\n\n```purescript\n\"hay NEEDLE hay\"\n```\n\n#### Example\n\nFind integers and double them.\n\n```purescript\nreplace \"1 6 21 107\" (show <$> (_*2) <$> intDecimal)\n```\n\nResult:\n\n```purescript\n\"2 12 42 214\"\n```\n","info":{"declType":"value","type":{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Parsing"],"Parser"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"}],"tag":"TypeApp"}},"kind":null,"sourceSpan":{"end":[545,12],"name":".spago/packages/parsing-10.2.0/src/Parsing/String/Replace.purs","start":[542,1]},"title":"replace"},{"children":[],"comments":"Monad transformer version of `replace`.\n\n#### Example\n\nFind an environment variable in curly braces and replace it with its value\nfrom the environment.\nWe can read from the environment with `lookupEnv` because `replaceT` is\nrunning the `sep` parser in `Effect`.\n\n```purescript\nreplaceT \"◀ {HOME} ▶\" do\n  _ <- string \"{\"\n  Tuple variable _ <- anyTill (string \"}\")\n  lift (lookupEnv variable) >>= maybe empty pure\n```\n\nResult:\n\n```purescript\n\"◀ /home/jbrock ▶\"\n```\n\n[![Perl Problems](https://imgs.xkcd.com/comics/perl_problems.png)](https://xkcd.com/1171/)\n","info":{"declType":"value","type":{"annotation":[],"contents":{"identifier":"m","kind":null,"skolem":null,"type":{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"m","tag":"TypeVar"}],"constraintClass":[["Control","Monad"],"Monad"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"constraintAnn":[],"constraintArgs":[{"annotation":[],"contents":"m","tag":"TypeVar"}],"constraintClass":[["Control","Monad","Rec","Class"],"MonadRec"],"constraintData":null,"constraintKindArgs":[]},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Prim"],"Function"],"tag":"TypeConstructor"},{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[{"annotation":[],"contents":[["Parsing"],"ParserT"],"tag":"TypeConstructor"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"},{"annotation":[],"contents":"m","tag":"TypeVar"}],"tag":"TypeApp"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"}],"tag":"TypeApp"},{"annotation":[],"contents":[{"annotation":[],"contents":"m","tag":"TypeVar"},{"annotation":[],"contents":[["Prim"],"String"],"tag":"TypeConstructor"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"TypeApp"}],"tag":"ConstrainedType"}],"tag":"ConstrainedType"},"visibility":"TypeVarInvisible"},"tag":"ForAll"}},"kind":null,"sourceSpan":{"end":[442,14],"name":".spago/packages/parsing-10.2.0/src/Parsing/String/Replace.purs","start":[436,1]},"title":"replaceT"}],"name":"Parsing.String.Replace","reExports":[]}