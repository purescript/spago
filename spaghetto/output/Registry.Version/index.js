// Generated by purs version 0.15.10
import * as Control_Applicative from "../Control.Applicative/index.js";
import * as Control_Bind from "../Control.Bind/index.js";
import * as Data_Array from "../Data.Array/index.js";
import * as Data_Array_NonEmpty from "../Data.Array.NonEmpty/index.js";
import * as Data_Bifunctor from "../Data.Bifunctor/index.js";
import * as Data_Codec_Argonaut from "../Data.Codec.Argonaut/index.js";
import * as Data_Either from "../Data.Either/index.js";
import * as Data_Function from "../Data.Function/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_Int from "../Data.Int/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Ord from "../Data.Ord/index.js";
import * as Data_Ordering from "../Data.Ordering/index.js";
import * as Data_Show from "../Data.Show/index.js";
import * as Data_String_CodeUnits from "../Data.String.CodeUnits/index.js";
import * as Data_String_Common from "../Data.String.Common/index.js";
import * as Parsing from "../Parsing/index.js";
import * as Parsing_Combinators_Array from "../Parsing.Combinators.Array/index.js";
import * as Parsing_String from "../Parsing.String/index.js";
import * as Parsing_String_Basic from "../Parsing.String.Basic/index.js";
var compare = /* #__PURE__ */ Data_Ord.compare(Data_Ord.ordInt);
var map = /* #__PURE__ */ Data_Functor.map(Data_Functor.functorArray);
var bind = /* #__PURE__ */ Control_Bind.bind(Parsing.bindParserT);
var pure = /* #__PURE__ */ Control_Applicative.pure(Parsing.applicativeParserT);
var discard = /* #__PURE__ */ Control_Bind.discard(Control_Bind.discardUnit)(Parsing.bindParserT);
var when = /* #__PURE__ */ Control_Applicative.when(Parsing.applicativeParserT);
var show = /* #__PURE__ */ Data_Show.show(Data_Show.showInt);
var Version = function (x) {
    return x;
};
var eqVersion = {
    eq: function (v) {
        return function (v1) {
            var v2 = v.major === v1.major;
            if (v2) {
                var v3 = v.minor === v1.minor;
                if (v3) {
                    return v.patch === v1.patch;
                };
                return v3;
            };
            return v2;
        };
    }
};
var ordVersion = {
    compare: function (v) {
        return function (v1) {
            var v2 = compare(v.major)(v1.major);
            if (v2 instanceof Data_Ordering.EQ) {
                var v3 = compare(v.minor)(v1.minor);
                if (v3 instanceof Data_Ordering.EQ) {
                    return compare(v.patch)(v1.patch);
                };
                return v3;
            };
            return v2;
        };
    },
    Eq0: function () {
        return eqVersion;
    }
};
var print = function (v) {
    var places = map(Data_Int.toStringAs(Data_Int.decimal))([ v.major, v.minor, v.patch ]);
    return Data_String_Common.joinWith(".")(places);
};
var patch = function (v) {
    return v.patch;
};
var parser = /* #__PURE__ */ (function () {
    var nonNegativeInt = bind(Parsing_Combinators_Array.many1(Parsing_String_Basic.digit))(function (digitChars) {
        var zeroCount = Data_Array.length(Data_Array_NonEmpty.takeWhile(function (v) {
            return v === "0";
        })(digitChars));
        var digitString = Data_String_CodeUnits.fromCharArray(Data_Array_NonEmpty.toArray(digitChars));
        var failInteger = Parsing.fail("Invalid 32-bit integer: " + digitString);
        return bind(Data_Maybe.maybe(failInteger)(pure)(Data_Int.fromString(digitString)))(function (integer) {
            return discard(when(zeroCount > 1 || zeroCount === 1 && integer !== 0)(Parsing.fail("Leading zeros are not allowed: " + digitString)))(function () {
                return discard(when(integer < 0)(Parsing.fail("Invalid non-negative integer: " + show(integer))))(function () {
                    return pure(integer);
                });
            });
        });
    });
    return bind(nonNegativeInt)(function (major$prime) {
        return bind(Parsing_String["char"]("."))(function () {
            return bind(nonNegativeInt)(function (minor$prime) {
                return bind(Parsing_String["char"]("."))(function () {
                    return bind(nonNegativeInt)(function (patch$prime) {
                        return discard(Parsing_String.eof)(function () {
                            return pure({
                                major: major$prime,
                                minor: minor$prime,
                                patch: patch$prime
                            });
                        });
                    });
                });
            });
        });
    });
})();
var parse = /* #__PURE__ */ (function () {
    var $64 = Data_Bifunctor.lmap(Data_Bifunctor.bifunctorEither)(Parsing.parseErrorMessage);
    var $65 = Data_Function.flip(Parsing.runParser)(parser);
    return function ($66) {
        return $64($65($66));
    };
})();
var minor = function (v) {
    return v.minor;
};
var major = function (v) {
    return v.major;
};
var codec = /* #__PURE__ */ Data_Codec_Argonaut.prismaticCodec("Version")(function ($67) {
    return Data_Either.hush(parse($67));
})(print)(Data_Codec_Argonaut.string);
var bumpPatch = function (v) {
    return {
        major: v.major,
        minor: v.minor,
        patch: v.patch + 1 | 0
    };
};
var bumpMinor = function (v) {
    return {
        major: v.major,
        minor: v.minor + 1 | 0,
        patch: 0
    };
};
var bumpMajor = function (v) {
    return {
        major: v.major + 1 | 0,
        minor: 0,
        patch: 0
    };
};
var bumpHighest = function (v) {
    var $62 = v.major >= 1;
    if ($62) {
        return bumpMajor(v);
    };
    var $63 = v.minor >= 1;
    if ($63) {
        return bumpMinor(v);
    };
    return bumpPatch(v);
};
export {
    bumpHighest,
    bumpMajor,
    bumpMinor,
    bumpPatch,
    codec,
    major,
    minor,
    parse,
    parser,
    patch,
    print,
    eqVersion,
    ordVersion
};
//# sourceMappingURL=index.js.map
