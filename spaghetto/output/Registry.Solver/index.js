// Generated by purs version 0.15.10
import * as Control_Alternative from "../Control.Alternative/index.js";
import * as Control_Applicative from "../Control.Applicative/index.js";
import * as Control_Bind from "../Control.Bind/index.js";
import * as Control_Category from "../Control.Category/index.js";
import * as Data_Array from "../Data.Array/index.js";
import * as Data_Array_NonEmpty from "../Data.Array.NonEmpty/index.js";
import * as Data_Array_NonEmpty_Internal from "../Data.Array.NonEmpty.Internal/index.js";
import * as Data_Bifunctor from "../Data.Bifunctor/index.js";
import * as Data_Either from "../Data.Either/index.js";
import * as Data_Eq from "../Data.Eq/index.js";
import * as Data_Foldable from "../Data.Foldable/index.js";
import * as Data_FoldableWithIndex from "../Data.FoldableWithIndex/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_Functor_App from "../Data.Functor.App/index.js";
import * as Data_FunctorWithIndex from "../Data.FunctorWithIndex/index.js";
import * as Data_HeytingAlgebra from "../Data.HeytingAlgebra/index.js";
import * as Data_List_NonEmpty from "../Data.List.NonEmpty/index.js";
import * as Data_List_Types from "../Data.List.Types/index.js";
import * as Data_Map from "../Data.Map/index.js";
import * as Data_Map_Internal from "../Data.Map.Internal/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Monoid from "../Data.Monoid/index.js";
import * as Data_Monoid_Disj from "../Data.Monoid.Disj/index.js";
import * as Data_Monoid_Endo from "../Data.Monoid.Endo/index.js";
import * as Data_Newtype from "../Data.Newtype/index.js";
import * as Data_Ord from "../Data.Ord/index.js";
import * as Data_Ordering from "../Data.Ordering/index.js";
import * as Data_Semigroup from "../Data.Semigroup/index.js";
import * as Data_Semigroup_Foldable from "../Data.Semigroup.Foldable/index.js";
import * as Data_Set from "../Data.Set/index.js";
import * as Data_Set_NonEmpty from "../Data.Set.NonEmpty/index.js";
import * as Data_Traversable from "../Data.Traversable/index.js";
import * as Data_TraversableWithIndex from "../Data.TraversableWithIndex/index.js";
import * as Data_Tuple from "../Data.Tuple/index.js";
import * as Data_Unit from "../Data.Unit/index.js";
import * as Registry_PackageName from "../Registry.PackageName/index.js";
import * as Registry_Range from "../Registry.Range/index.js";
import * as Registry_Version from "../Registry.Version/index.js";
import * as Safe_Coerce from "../Safe.Coerce/index.js";
var $runtime_lazy = function (name, moduleName, init) {
    var state = 0;
    var val;
    return function (lineNumber) {
        if (state === 2) return val;
        if (state === 1) throw new ReferenceError(name + " was needed before it finished initializing (module " + moduleName + ", line " + lineNumber + ")", moduleName, lineNumber);
        state = 1;
        val = init();
        state = 2;
        return val;
    };
};
var versionIsSymbol = {
    reflectSymbol: function () {
        return "version";
    }
};
var packageIsSymbol = {
    reflectSymbol: function () {
        return "package";
    }
};
var append = /* #__PURE__ */ Data_Semigroup.append(/* #__PURE__ */ Data_Set_NonEmpty.semigroupNonEmptySet(/* #__PURE__ */ Data_Ord.ordRecord()(/* #__PURE__ */ Data_Ord.ordRecordCons(/* #__PURE__ */ Data_Ord.ordRecordCons(Data_Ord.ordRecordNil)()(versionIsSymbol)(Registry_Version.ordVersion))()(packageIsSymbol)(Registry_PackageName.ordPackageName))));
var append1 = /* #__PURE__ */ Data_Semigroup.append(/* #__PURE__ */ Data_Set.semigroupSet(Registry_PackageName.ordPackageName));
var compare = /* #__PURE__ */ Data_Ord.compare(Registry_Version.ordVersion);
var semigroupRecord = /* #__PURE__ */ Data_Semigroup.semigroupRecord();
var lowerIsSymbol = {
    reflectSymbol: function () {
        return "lower";
    }
};
var semigroupRecordCons = /* #__PURE__ */ Data_Semigroup.semigroupRecordCons(lowerIsSymbol)();
var upperIsSymbol = {
    reflectSymbol: function () {
        return "upper";
    }
};
var semigroupRecordCons1 = /* #__PURE__ */ Data_Semigroup.semigroupRecordCons(upperIsSymbol)()(Data_Semigroup.semigroupRecordNil);
var over = /* #__PURE__ */ Data_Newtype.over()();
var map = /* #__PURE__ */ Data_Functor.map(Data_Functor.functorFn);
var lmap = /* #__PURE__ */ Data_Bifunctor.lmap(Data_Bifunctor.bifunctorEither);
var eqRec = /* #__PURE__ */ Data_Eq.eqRec();
var eqRowCons = /* #__PURE__ */ Data_Eq.eqRowCons(Data_Eq.eqRowNil)();
var eq = /* #__PURE__ */ Data_Eq.eq(/* #__PURE__ */ Data_Set_NonEmpty.eqNonEmptySet(/* #__PURE__ */ eqRec(/* #__PURE__ */ Data_Eq.eqRowCons(/* #__PURE__ */ eqRowCons(versionIsSymbol)(Registry_Version.eqVersion))()(packageIsSymbol)(Registry_PackageName.eqPackageName))));
var eq1 = /* #__PURE__ */ Data_Eq.eq(/* #__PURE__ */ Data_Set.eqSet(Registry_PackageName.eqPackageName));
var eq2 = /* #__PURE__ */ Data_Eq.eq(Registry_Version.eqVersion);
var eq3 = /* #__PURE__ */ Data_Eq.eq(Registry_PackageName.eqPackageName);
var eqMap = /* #__PURE__ */ Data_Map_Internal.eqMap(Registry_Version.eqVersion);
var intercalateMap = /* #__PURE__ */ Data_Semigroup_Foldable.intercalateMap(Data_Set_NonEmpty.foldable1NonEmptySet)(Data_Semigroup.semigroupString);
var fromFoldable = /* #__PURE__ */ Data_Array_NonEmpty.fromFoldable(Data_Set.foldableSet);
var difference = /* #__PURE__ */ Data_Set.difference(Registry_PackageName.ordPackageName);
var map1 = /* #__PURE__ */ Data_Set.map(Registry_PackageName.ordPackageName);
var mempty = /* #__PURE__ */ Data_Monoid.mempty(Data_Monoid.monoidString);
var intercalateMap1 = /* #__PURE__ */ Data_Semigroup_Foldable.intercalateMap(Data_Array_NonEmpty_Internal.foldable1NonEmptyArray)(Data_Semigroup.semigroupString);
var unwrap = /* #__PURE__ */ Data_Newtype.unwrap();
var greaterThanOrEq = /* #__PURE__ */ Data_Ord.greaterThanOrEq(Registry_Version.ordVersion);
var fold = /* #__PURE__ */ Data_Array.fold(Data_Monoid.monoidString);
var intercalate = /* #__PURE__ */ Data_Foldable.intercalate(Data_Map_Internal.foldableMap)(Data_Monoid.monoidString);
var mapWithIndex = /* #__PURE__ */ Data_FunctorWithIndex.mapWithIndex(Data_Map_Internal.functorWithIndexMap);
var fold1 = /* #__PURE__ */ Data_Foldable.fold(Data_Map_Internal.foldableMap)(Data_Monoid.monoidString);
var foldMapWithIndex = /* #__PURE__ */ Data_FoldableWithIndex.foldMapWithIndex(Data_Map.foldableWithIndexSemigroupMap);
var monoidSemigroupMap = /* #__PURE__ */ Data_Map.monoidSemigroupMap(Registry_PackageName.ordPackageName);
var semigroupSemigroupMap = /* #__PURE__ */ Data_Map.semigroupSemigroupMap(Registry_PackageName.ordPackageName);
var lookup = /* #__PURE__ */ Data_Map_Internal.lookup(Registry_PackageName.ordPackageName);
var lessThan = /* #__PURE__ */ Data_Ord.lessThan(Registry_Version.ordVersion);
var greaterThan = /* #__PURE__ */ Data_Ord.greaterThan(Registry_Version.ordVersion);
var mapWithIndex1 = /* #__PURE__ */ Data_FunctorWithIndex.mapWithIndex(Data_Map.functorWithIndexSemigroupMap);
var filterWithKey = /* #__PURE__ */ Data_Map_Internal.filterWithKey(Registry_Version.ordVersion);
var coerce = /* #__PURE__ */ Safe_Coerce.coerce();
var map2 = /* #__PURE__ */ Data_Functor.map(Data_Map_Internal.functorMap);
var pure = /* #__PURE__ */ Control_Applicative.pure(Control_Applicative.applicativeArray);
var filterKeys = /* #__PURE__ */ Data_Map_Internal.filterKeys(Registry_Version.ordVersion);
var heytingAlgebraFunction = /* #__PURE__ */ Data_HeytingAlgebra.heytingAlgebraFunction(Data_HeytingAlgebra.heytingAlgebraBoolean);
var not1 = /* #__PURE__ */ Data_HeytingAlgebra.not(/* #__PURE__ */ Data_HeytingAlgebra.heytingAlgebraFunction(heytingAlgebraFunction));
var member = /* #__PURE__ */ Data_Set.member(Registry_Version.ordVersion);
var foldMap = /* #__PURE__ */ Data_Foldable.foldMap(Data_Map_Internal.foldableMap)(/* #__PURE__ */ monoidSemigroupMap(Data_Semigroup.semigroupArray));
var append3 = /* #__PURE__ */ Data_Semigroup.append(/* #__PURE__ */ Data_Set.semigroupSet(Registry_Version.ordVersion));
var $$delete = /* #__PURE__ */ Data_Map_Internal["delete"](Registry_PackageName.ordPackageName);
var insert = /* #__PURE__ */ Data_Map_Internal.insert(Registry_PackageName.ordPackageName);
var append4 = /* #__PURE__ */ Data_Semigroup.append(/* #__PURE__ */ semigroupSemigroupMap(Data_Semigroup.semigroupArray));
var wrap = /* #__PURE__ */ Data_Newtype.wrap();
var map3 = /* #__PURE__ */ Data_Functor.map(Data_Map.functorSemigroupMap);
var anyWithIndex = /* #__PURE__ */ Data_FoldableWithIndex.anyWithIndex(Data_Map.foldableWithIndexSemigroupMap)(/* #__PURE__ */ Data_HeytingAlgebra.heytingAlgebraRecord()(/* #__PURE__ */ Data_HeytingAlgebra.heytingAlgebraRecordCons({
    reflectSymbol: function () {
        return "added";
    }
})()(/* #__PURE__ */ Data_HeytingAlgebra.heytingAlgebraRecordCons({
    reflectSymbol: function () {
        return "failedAlready";
    }
})()(/* #__PURE__ */ Data_HeytingAlgebra.heytingAlgebraRecordCons({
    reflectSymbol: function () {
        return "failedNow";
    }
})()(Data_HeytingAlgebra.heytingAlgebraRecordNil)(Data_HeytingAlgebra.heytingAlgebraBoolean))(Data_HeytingAlgebra.heytingAlgebraBoolean))(Data_HeytingAlgebra.heytingAlgebraBoolean)));
var not2 = /* #__PURE__ */ Data_HeytingAlgebra.not(heytingAlgebraFunction);
var $$for = /* #__PURE__ */ Data_Traversable["for"](Data_Maybe.applicativeMaybe)(Data_Map_Internal.traversableMap);
var bind = /* #__PURE__ */ Control_Bind.bind(Data_Maybe.bindMaybe);
var pure1 = /* #__PURE__ */ Control_Applicative.pure(Data_Maybe.applicativeMaybe);
var discard = /* #__PURE__ */ Control_Bind.discard(Control_Bind.discardUnit);
var discard1 = /* #__PURE__ */ discard(Data_Maybe.bindMaybe);
var forWithIndex_ = /* #__PURE__ */ Data_FoldableWithIndex.forWithIndex_(Data_Maybe.applicativeMaybe)(Data_Map.foldableWithIndexSemigroupMap);
var guard = /* #__PURE__ */ Control_Alternative.guard(Data_Maybe.alternativeMaybe);
var join = /* #__PURE__ */ Control_Bind.join(Control_Bind.bindFn);
var eqSemigroupMap = /* #__PURE__ */ Data_Map.eqSemigroupMap(Registry_PackageName.eqPackageName);
var insert1 = /* #__PURE__ */ Data_Map_Internal.insert(Registry_Version.ordVersion);
var alter = /* #__PURE__ */ Data_Map_Internal.alter(Registry_PackageName.ordPackageName);
var traverseWithIndex = /* #__PURE__ */ Data_TraversableWithIndex.traverseWithIndex(Data_Map_Internal.traversableWithIndexMap)(Data_Either.applicativeEither);
var pure2 = /* #__PURE__ */ Control_Applicative.pure(Data_Either.applicativeEither);
var forWithIndex = /* #__PURE__ */ Data_TraversableWithIndex.forWithIndex(Data_Either.applicativeEither)(Data_Map_Internal.traversableWithIndexMap);
var filterWithKey1 = /* #__PURE__ */ Data_Map_Internal.filterWithKey(Registry_PackageName.ordPackageName);
var foldlWithIndex = /* #__PURE__ */ Data_FoldableWithIndex.foldlWithIndex(Data_Map.foldableWithIndexSemigroupMap);
var traverse = /* #__PURE__ */ Data_Traversable.traverse(Data_Map.traversableSemigroupMap)(Data_Maybe.applicativeMaybe);
var fromFoldable1 = /* #__PURE__ */ Data_Array.fromFoldable(Data_Map.foldableSemigroupMap);
var map4 = /* #__PURE__ */ Data_Functor.map(Data_Array_NonEmpty_Internal.functorNonEmptyArray);
var un = /* #__PURE__ */ Data_Newtype.un();
var mapFlipped = /* #__PURE__ */ Data_Functor.mapFlipped(Data_Map_Internal.functorMap);
var mapMaybeWithKey = /* #__PURE__ */ Data_Map_Internal.mapMaybeWithKey(Registry_PackageName.ordPackageName);
var monoidEndo = /* #__PURE__ */ Data_Monoid_Endo.monoidEndo(Control_Category.categoryFn);
var traverseWithIndex1 = /* #__PURE__ */ Data_TraversableWithIndex.traverseWithIndex(Data_Map.traversableWithIndexSemigroupMap)(/* #__PURE__ */ Data_Tuple.applicativeTuple(monoidEndo));
var mempty1 = /* #__PURE__ */ Data_Monoid.mempty(monoidEndo);
var discard2 = /* #__PURE__ */ discard(Data_Either.bindEither);
var pure3 = /* #__PURE__ */ Control_Applicative.pure(Data_List_Types.applicativeNonEmptyList);
var Root = /* #__PURE__ */ (function () {
    function Root() {

    };
    Root.value = new Root();
    return Root;
})();
var Trial = /* #__PURE__ */ (function () {
    function Trial() {

    };
    Trial.value = new Trial();
    return Trial;
})();
var Solving = /* #__PURE__ */ (function () {
    function Solving(value0) {
        this.value0 = value0;
    };
    Solving.create = function (value0) {
        return new Solving(value0);
    };
    return Solving;
})();
var Pos = /* #__PURE__ */ (function () {
    function Pos(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    Pos.create = function (value0) {
        return function (value1) {
            return new Pos(value0, value1);
        };
    };
    return Pos;
})();
var Sourced = /* #__PURE__ */ (function () {
    function Sourced(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    Sourced.create = function (value0) {
        return function (value1) {
            return new Sourced(value0, value1);
        };
    };
    return Sourced;
})();
var MaxSourced = function (x) {
    return x;
};
var MinSourced = function (x) {
    return x;
};
var Loose = function (x) {
    return x;
};
var LastSuccess = function (x) {
    return x;
};
var Intersection = function (x) {
    return x;
};
var Conflicts = /* #__PURE__ */ (function () {
    function Conflicts(value0) {
        this.value0 = value0;
    };
    Conflicts.create = function (value0) {
        return new Conflicts(value0);
    };
    return Conflicts;
})();
var WhileSolving = /* #__PURE__ */ (function () {
    function WhileSolving(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    WhileSolving.create = function (value0) {
        return function (value1) {
            return new WhileSolving(value0, value1);
        };
    };
    return WhileSolving;
})();
var semigroupLocalSolverPosit = {
    append: function (v) {
        return function (v1) {
            if (v instanceof Trial) {
                return Trial.value;
            };
            if (v1 instanceof Trial) {
                return Trial.value;
            };
            if (v instanceof Root) {
                return Root.value;
            };
            if (v1 instanceof Root) {
                return Root.value;
            };
            if (v instanceof Solving && v1 instanceof Solving) {
                return new Solving(append(v.value0)(v1.value0));
            };
            throw new Error("Failed pattern match at Registry.Solver (line 573, column 1 - line 578, column 56): " + [ v.constructor.name, v1.constructor.name ]);
        };
    }
};
var append5 = /* #__PURE__ */ Data_Semigroup.append(semigroupLocalSolverPosit);
var semigroupSolverPosition = {
    append: function (v) {
        return function (v1) {
            return new Pos(append5(v.value0)(v1.value0), append1(v.value1)(v1.value1));
        };
    }
};
var append6 = /* #__PURE__ */ Data_Semigroup.append(semigroupSolverPosition);
var semigroupMaxSourced = {
    append: function (v) {
        return function (v1) {
            var v2 = compare(v.value0)(v1.value0);
            if (v2 instanceof Data_Ordering.GT) {
                return v;
            };
            if (v2 instanceof Data_Ordering.LT) {
                return v1;
            };
            if (v2 instanceof Data_Ordering.EQ) {
                return new Sourced(v.value0, append6(v.value1)(v1.value1));
            };
            throw new Error("Failed pattern match at Registry.Solver (line 632, column 5 - line 635, column 47): " + [ v2.constructor.name ]);
        };
    }
};
var semigroupMinSourced = {
    append: function (v) {
        return function (v1) {
            var v2 = compare(v.value0)(v1.value0);
            if (v2 instanceof Data_Ordering.LT) {
                return v;
            };
            if (v2 instanceof Data_Ordering.GT) {
                return v1;
            };
            if (v2 instanceof Data_Ordering.EQ) {
                return new Sourced(v.value0, append6(v.value1)(v1.value1));
            };
            throw new Error("Failed pattern match at Registry.Solver (line 621, column 5 - line 624, column 47): " + [ v2.constructor.name ]);
        };
    }
};
var semigroupLoose = /* #__PURE__ */ semigroupRecord(/* #__PURE__ */ semigroupRecordCons(/* #__PURE__ */ semigroupRecordCons1(semigroupMaxSourced))(semigroupMinSourced));
var foldMap1 = /* #__PURE__ */ Data_Array_NonEmpty.foldMap1(/* #__PURE__ */ Data_Functor_App.semigroupApp(/* #__PURE__ */ Data_Map_Internal.applyMap(Registry_PackageName.ordPackageName))(semigroupLoose));
var semigroupIntersection = /* #__PURE__ */ semigroupRecord(/* #__PURE__ */ semigroupRecordCons(/* #__PURE__ */ semigroupRecordCons1(semigroupMinSourced))(semigroupMaxSourced));
var semigroupSemigroupMap1 = /* #__PURE__ */ semigroupSemigroupMap(semigroupIntersection);
var semigroupSemigroupMap2 = /* #__PURE__ */ Data_Map.semigroupSemigroupMap(Registry_Version.ordVersion)(semigroupSemigroupMap1);
var monoidSemigroupMap1 = /* #__PURE__ */ monoidSemigroupMap(semigroupSemigroupMap2);
var foldMapWithIndex1 = /* #__PURE__ */ foldMapWithIndex(monoidSemigroupMap1);
var mempty2 = /* #__PURE__ */ Data_Monoid.mempty(monoidSemigroupMap1);
var foldMap2 = /* #__PURE__ */ Data_Foldable.foldMap(Data_Map.foldableSemigroupMap)(monoidSemigroupMap1);
var semigroupSemigroupMap3 = /* #__PURE__ */ semigroupSemigroupMap(semigroupSemigroupMap2);
var mempty3 = /* #__PURE__ */ Data_Monoid.mempty(/* #__PURE__ */ Data_Map.monoidSemigroupMap(Registry_Version.ordVersion)(semigroupSemigroupMap1));
var monoidSemigroupMap2 = /* #__PURE__ */ monoidSemigroupMap(semigroupIntersection);
var mempty4 = /* #__PURE__ */ Data_Monoid.mempty(monoidSemigroupMap2);
var append7 = /* #__PURE__ */ Data_Semigroup.append(semigroupIntersection);
var monoidTuple = /* #__PURE__ */ Data_Tuple.monoidTuple(/* #__PURE__ */ Data_Monoid_Disj.monoidDisj(Data_HeytingAlgebra.heytingAlgebraBoolean))(monoidSemigroupMap2);
var mempty5 = /* #__PURE__ */ Data_Monoid.mempty(monoidTuple);
var foldMapWithIndex2 = /* #__PURE__ */ foldMapWithIndex(monoidTuple);
var append8 = /* #__PURE__ */ Data_Semigroup.append(semigroupSemigroupMap1);
var foldMapWithIndex3 = /* #__PURE__ */ foldMapWithIndex(monoidSemigroupMap2);
var append9 = /* #__PURE__ */ Data_Semigroup.append(semigroupSemigroupMap3);
var newtypeMinSourced_ = {
    Coercible0: function () {
        return undefined;
    }
};
var newtypeMaxSourced_ = {
    Coercible0: function () {
        return undefined;
    }
};
var newtypeLoose_ = {
    Coercible0: function () {
        return undefined;
    }
};
var newtypeLastSuccess_ = {
    Coercible0: function () {
        return undefined;
    }
};
var newtypeIntersection_ = {
    Coercible0: function () {
        return undefined;
    }
};
var functorLastSuccess = {
    map: function (f) {
        return over(LastSuccess)(map(lmap(f)));
    }
};
var eqLocalSolverPosition = {
    eq: function (x) {
        return function (y) {
            if (x instanceof Root && y instanceof Root) {
                return true;
            };
            if (x instanceof Trial && y instanceof Trial) {
                return true;
            };
            if (x instanceof Solving && y instanceof Solving) {
                return eq(x.value0)(y.value0);
            };
            return false;
        };
    }
};
var eq4 = /* #__PURE__ */ Data_Eq.eq(eqLocalSolverPosition);
var eqSolverPosition = {
    eq: function (x) {
        return function (y) {
            return eq4(x.value0)(y.value0) && eq1(x.value1)(y.value1);
        };
    }
};
var eq5 = /* #__PURE__ */ Data_Eq.eq(eqSolverPosition);
var eqSourced = {
    eq: function (x) {
        return function (y) {
            return eq2(x.value0)(y.value0) && eq5(x.value1)(y.value1);
        };
    }
};
var eqMaxSourced = eqSourced;
var eqMinSourced = eqSourced;
var eqIntersection = /* #__PURE__ */ eqRec(/* #__PURE__ */ Data_Eq.eqRowCons(/* #__PURE__ */ eqRowCons(upperIsSymbol)(eqMinSourced))()(lowerIsSymbol)(eqMaxSourced));
var eq6 = /* #__PURE__ */ Data_Eq.eq(/* #__PURE__ */ Data_Map_Internal.eqMap(Registry_PackageName.eqPackageName)(eqIntersection));
var eqSolverError = {
    eq: function (x) {
        return function (y) {
            if (x instanceof Conflicts && y instanceof Conflicts) {
                return eq6(x.value0)(y.value0);
            };
            if (x instanceof WhileSolving && y instanceof WhileSolving) {
                return eq3(x.value0)(y.value0) && Data_Eq.eq(eqMap(eqSolverError))(x.value1)(y.value1);
            };
            return false;
        };
    }
};
var applyLastSuccess = {
    apply: function (v) {
        return function (v1) {
            return function (u) {
                var v2 = v1(u);
                if (v2 instanceof Data_Either.Right) {
                    return new Data_Either.Right(v2.value0);
                };
                if (v2 instanceof Data_Either.Left) {
                    var v3 = v(u);
                    if (v3 instanceof Data_Either.Right) {
                        return new Data_Either.Right(v3.value0);
                    };
                    if (v3 instanceof Data_Either.Left) {
                        return new Data_Either.Left(v3.value0(v2.value0));
                    };
                    throw new Error("Failed pattern match at Registry.Solver (line 730, column 9 - line 732, column 31): " + [ v3.constructor.name ]);
                };
                throw new Error("Failed pattern match at Registry.Solver (line 727, column 5 - line 732, column 31): " + [ v2.constructor.name ]);
            };
        };
    },
    Functor0: function () {
        return functorLastSuccess;
    }
};
var applicativeLastSuccess = {
    pure: /* #__PURE__ */ (function () {
        var $601 = Control_Applicative.pure(Control_Applicative.applicativeFn);
        return function ($602) {
            return LastSuccess($601(Data_Either.Left.create($602)));
        };
    })(),
    Apply0: function () {
        return applyLastSuccess;
    }
};
var sequence = /* #__PURE__ */ Data_Traversable.sequence(Data_Map_Internal.traversableMap)(applicativeLastSuccess);
var upperBound = function (v) {
    return v.upper.value0;
};
var unSource = function (v) {
    return v.value0;
};
var solveSeed = function (v) {
    return {
        registry: v.registry,
        required: v.required,
        updated: v.registry
    };
};
var soleVersion = function (v) {
    return {
        lower: new Sourced(v, new Pos(Trial.value, Data_Set.empty)),
        upper: new Sourced(Registry_Version.bumpPatch(v), new Pos(Trial.value, Data_Set.empty))
    };
};
var soleVersionOf = function ($$package) {
    return function (v) {
        return Data_Map_Internal.singleton($$package)(soleVersion(v));
    };
};
var printPackageVersion = function (v) {
    return Registry_PackageName.print(v["package"]) + ("@" + Registry_Version.print(v.version));
};
var printSolverPosition = function (v) {
    if (v.value0 instanceof Root) {
        return " (declared dependency)";
    };
    if (v.value0 instanceof Trial) {
        return " (attempted version)";
    };
    if (v.value0 instanceof Solving) {
        return " seen in " + (intercalateMap(", ")(printPackageVersion)(v.value0.value0) + (function () {
            var v1 = fromFoldable(difference(v.value1)(map1(function (v2) {
                return v2["package"];
            })(Data_Set_NonEmpty.toSet(v.value0.value0))));
            if (v1 instanceof Data_Maybe.Nothing) {
                return mempty;
            };
            if (v1 instanceof Data_Maybe.Just) {
                return " from declared dependencies " + intercalateMap1(", ")(Registry_PackageName.print)(v1.value0);
            };
            throw new Error("Failed pattern match at Registry.Solver (line 165, column 10 - line 167, column 94): " + [ v1.constructor.name ]);
        })());
    };
    throw new Error("Failed pattern match at Registry.Solver (line 160, column 23 - line 167, column 94): " + [ v.constructor.name ]);
};
var printSourced = function () {
    return function ($603) {
        return (function (v) {
            return Registry_Version.print(v.value0) + printSolverPosition(v.value1);
        })(unwrap($603));
    };
};
var printSourced1 = /* #__PURE__ */ printSourced();
var noUpdates = function (v) {
    return Data_Map_Internal.isEmpty(v.updated);
};
var lowerBound = function (v) {
    return v.lower.value0;
};
var printConflict = function (v) {
    return function (v1) {
        return function (v2) {
            if (greaterThanOrEq(lowerBound(v2))(upperBound(v2))) {
                return fold([ "Conflict in version ranges for ", Registry_PackageName.print(v1), ":", "\x0a", v, "  >=", printSourced1((unwrap(v2)).lower), "\x0a", v, "  <", printSourced1((unwrap(v2)).upper) ]);
            };
            return fold([ "No versions found in the registry for ", Registry_PackageName.print(v1), " in range", "\x0a", v, "  >=", printSourced1((unwrap(v2)).lower), "\x0a", v, "  <", printSourced1((unwrap(v2)).upper) ]);
        };
    };
};
var printErrorAt = function (indent) {
    return function (v) {
        if (v instanceof Conflicts) {
            return intercalate("\x0a" + indent)(mapWithIndex(printConflict(indent))(v.value0));
        };
        if (v instanceof WhileSolving) {
            return fold([ "While solving ", Registry_PackageName.print(v.value0), " each version could not be solved:", fold1(mapWithIndex(function (version) {
                return function (nested) {
                    return fold([ "\x0a", indent, "- ", Registry_Version.print(version), ": ", "\x0a", indent + "  ", printErrorAt(indent + "  ")(nested) ]);
                };
            })(v.value1)) ]);
        };
        throw new Error("Failed pattern match at Registry.Solver (line 181, column 23 - line 199, column 6): " + [ v.constructor.name ]);
    };
};
var printSolverError = /* #__PURE__ */ printErrorAt("");
var requirementUpdates = function (v) {
    return foldMapWithIndex1(function ($$package) {
        return function (newRange) {
            var changed = (function () {
                var v1 = lookup($$package)(v.required);
                if (v1 instanceof Data_Maybe.Nothing) {
                    return true;
                };
                if (v1 instanceof Data_Maybe.Just) {
                    return lessThan(lowerBound(v1.value0))(lowerBound(newRange)) || greaterThan(upperBound(v1.value0))(upperBound(newRange));
                };
                throw new Error("Failed pattern match at Registry.Solver (line 514, column 9 - line 520, column 56): " + [ v1.constructor.name ]);
            })();
            var $471 = !changed;
            if ($471) {
                return mempty2;
            };
            var v1 = lookup($$package)(v.registry);
            if (v1 instanceof Data_Maybe.Just) {
                return Data_Map_Internal.singleton($$package)(v1.value0);
            };
            if (v1 instanceof Data_Maybe.Nothing) {
                return mempty2;
            };
            throw new Error("Failed pattern match at Registry.Solver (line 527, column 9 - line 529, column 28): " + [ v1.constructor.name ]);
        };
    });
};
var satisfies = function (v) {
    return function (r) {
        return greaterThanOrEq(v)(lowerBound(r)) && lessThan(v)(upperBound(r));
    };
};
var trimReachable = function (r) {
    var $478 = {};
    for (var $479 in r) {
        if ({}.hasOwnProperty.call(r, $479)) {
            $478[$479] = r[$479];
        };
    };
    $478.registry = mapWithIndex1(function ($$package) {
        return over(Data_Map.SemigroupMap)(filterWithKey(function (version) {
            return function (v1) {
                var v2 = lookup($$package)(unwrap(r.required));
                if (v2 instanceof Data_Maybe.Nothing) {
                    return true;
                };
                if (v2 instanceof Data_Maybe.Just) {
                    return satisfies(version)(v2.value0);
                };
                throw new Error("Failed pattern match at Registry.Solver (line 549, column 9 - line 551, column 48): " + [ v2.constructor.name ]);
            };
        }));
    })(r.registry);
    return $478;
};
var toLoose = function (v) {
    if (lessThan(lowerBound(v))(upperBound(v))) {
        return new Data_Maybe.Just(coerce(v));
    };
    return Data_Maybe.Nothing.value;
};
var wouldUpdate = function (j) {
    return function (i) {
        return greaterThan(lowerBound(j))(lowerBound(i)) || lessThan(upperBound(j))(upperBound(i));
    };
};
var loadIndex = function (dictMonad) {
    var Bind1 = dictMonad.Bind1();
    var map5 = Data_Functor.map((Bind1.Apply0()).Functor0());
    var pure4 = Control_Applicative.pure(dictMonad.Applicative0());
    var bind1 = Control_Bind.bind(Bind1);
    return function (loader) {
        return function (required) {
            var need = (function () {
                var $604 = map2(pure);
                return function ($605) {
                    return Data_Map.SemigroupMap($604($605));
                };
            })();
            var needMore = function (v) {
                return function (needed) {
                    var isNeeded = function (k) {
                        return Data_Array.any(function (r) {
                            return Registry_Range.includes(r)(k);
                        })(needed);
                    };
                    var more = filterKeys(function (k) {
                        return not1(member)(k)(v.found) && isNeeded(k);
                    })(v.known);
                    return {
                        needed: foldMap(need)(more),
                        found: append3(v.found)(Data_Map.keys(more))
                    };
                };
            };
            var loadNew = function ($$package) {
                return function (v) {
                    return map5(function (v1) {
                        return {
                            found: Data_Set.empty,
                            known: v1
                        };
                    })(loader($$package));
                };
            };
            var go = function (v) {
                return function (v1) {
                    var v2 = function (v3) {
                        return pure4(v);
                    };
                    var $492 = Data_Map_Internal.findMin(v1);
                    if ($492 instanceof Data_Maybe.Just) {
                        return bind1(Data_Maybe["maybe$prime"](loadNew($492.value0.key))(pure4)(lookup($492.value0.key)(v)))(function (loaded) {
                            var needed$prime = $$delete($492.value0.key)(v1);
                            var v3 = needMore(loaded)($492.value0.value);
                            var loaded$prime = {
                                found: append3(loaded.found)(v3.found),
                                known: loaded.known
                            };
                            var acc$prime = insert($492.value0.key)(loaded$prime)(v);
                            return go(acc$prime)(append4(needed$prime)(v3.needed));
                        });
                    };
                    return v2(true);
                };
            };
            return map5(map2(function (v) {
                return v.known;
            }))(go(Data_Map_Internal.empty)(need(required)));
        };
    };
};
var intersectionFromRange$prime = function ($$package) {
    return function (range) {
        var mkSourced = function (v) {
            return new Sourced(v, new Pos(Root.value, Data_Set.singleton($$package)));
        };
        return {
            lower: wrap(mkSourced(Registry_Range.greaterThanOrEq(range))),
            upper: wrap(mkSourced(Registry_Range.lessThan(range)))
        };
    };
};
var intersectionFromRange = function ($$package) {
    return function (version) {
        return function (range) {
            var mkSourced = function (v) {
                return new Sourced(v, new Pos(new Solving(Data_Set_NonEmpty.singleton({
                    "package": $$package,
                    version: version
                })), Data_Set.empty));
            };
            return {
                lower: wrap(mkSourced(Registry_Range.greaterThanOrEq(range))),
                upper: wrap(mkSourced(Registry_Range.lessThan(range)))
            };
        };
    };
};
var initializeRequired = /* #__PURE__ */ (function () {
    var $606 = mapWithIndex1(intersectionFromRange$prime);
    return function ($607) {
        return $606(coerce($607));
    };
})();
var initializeRegistry = /* #__PURE__ */ (function () {
    var $608 = mapWithIndex1(function ($$package) {
        return mapWithIndex1(function (version) {
            return map3(intersectionFromRange($$package)(version));
        });
    });
    return function ($609) {
        return $608(coerce($609));
    };
})();
var good = function (i) {
    return greaterThan(upperBound(i))(lowerBound(i));
};
var majorUpdate = function (v) {
    return function (v1) {
        return function (updated) {
            var minor = {
                added: false,
                failedAlready: false,
                failedNow: false
            };
            var info = anyWithIndex(function ($$package) {
                return function (range) {
                    var v2 = lookup($$package)(v1);
                    if (v2 instanceof Data_Maybe.Nothing) {
                        var v3 = lookup($$package)(v);
                        if (v3 instanceof Data_Maybe.Nothing) {
                            return {
                                added: true,
                                failedAlready: minor.failedAlready,
                                failedNow: minor.failedNow
                            };
                        };
                        if (v3 instanceof Data_Maybe.Just) {
                            return {
                                added: greaterThan(lowerBound(range))(lowerBound(v3.value0)) || lessThan(upperBound(range))(upperBound(v3.value0)),
                                failedAlready: minor.failedAlready,
                                failedNow: minor.failedNow
                            };
                        };
                        throw new Error("Failed pattern match at Registry.Solver (line 493, column 11 - line 495, column 122): " + [ v3.constructor.name ]);
                    };
                    if (v2 instanceof Data_Maybe.Just) {
                        return {
                            failedAlready: not2(good)(v2.value0),
                            failedNow: not2(good)(range),
                            added: minor.added
                        };
                    };
                    throw new Error("Failed pattern match at Registry.Solver (line 491, column 7 - line 496, column 83): " + [ v2.constructor.name ]);
                };
            })(updated);
            if (info.added) {
                return true;
            };
            if (info.failedNow && !info.failedAlready) {
                return true;
            };
            return false;
        };
    };
};
var getPos = function () {
    return function ($610) {
        return (function (v) {
            return v.value1;
        })(unwrap($610));
    };
};
var getPos1 = /* #__PURE__ */ getPos();
var getPackageRange = function (v) {
    return function ($$package) {
        return function (range) {
            var v1 = lookup($$package)(v);
            if (v1 instanceof Data_Maybe.Nothing) {
                return Data_Map_Internal.empty;
            };
            if (v1 instanceof Data_Maybe.Just) {
                return filterKeys(function (v2) {
                    return satisfies(v2)(range);
                })(v1.value0);
            };
            throw new Error("Failed pattern match at Registry.Solver (line 676, column 3 - line 679, column 73): " + [ v1.constructor.name ]);
        };
    };
};
var withInRange = function (r) {
    return {
        registry: r.registry,
        required: r.required,
        inRange: mapWithIndex1(getPackageRange(r.registry))(r.required)
    };
};
var getLatest = function (v) {
    return $$for(v.inRange)(function (v1) {
        return bind(Data_Map_Internal.findMax(v1))(function (v2) {
            return pure1({
                version: v2.key,
                dependencies: v2.value
            });
        });
    });
};
var tryLatest = function (r) {
    return bind(getLatest(r))(function (sol) {
        return $$for(sol)(function (v) {
            return discard1(forWithIndex_(v.dependencies)(function (dep) {
                return function (range) {
                    return bind(lookup(dep)(sol))(function (v1) {
                        return guard(satisfies(v1.version)(range));
                    });
                };
            }))(function () {
                return pure1(v.version);
            });
        });
    });
};
var fromLoose = coerce;
var fixEqM = function (dictSemigroup) {
    var append10 = Data_Semigroup.append(dictSemigroup);
    return function (dictEq) {
        var eq7 = Data_Eq.eq(dictEq);
        return function (f) {
            var go = function ($copy_acc) {
                return function ($copy_lastAdded) {
                    var $tco_var_acc = $copy_acc;
                    var $tco_done = false;
                    var $tco_result;
                    function $tco_loop(acc, lastAdded) {
                        var moreAdded = f(lastAdded);
                        var moreAcc = append10(acc)(moreAdded);
                        var $529 = eq7(moreAcc)(acc);
                        if ($529) {
                            $tco_done = true;
                            return acc;
                        };
                        $tco_var_acc = moreAcc;
                        $copy_lastAdded = moreAdded;
                        return;
                    };
                    while (!$tco_done) {
                        $tco_result = $tco_loop($tco_var_acc, $copy_lastAdded);
                    };
                    return $tco_result;
                };
            };
            return join(go);
        };
    };
};
var fixEqM1 = /* #__PURE__ */ fixEqM(semigroupSemigroupMap3)(/* #__PURE__ */ eqSemigroupMap(/* #__PURE__ */ Data_Map.eqSemigroupMap(Registry_Version.eqVersion)(/* #__PURE__ */ eqSemigroupMap(eqIntersection))));
var gatherReachable = function (v) {
    var reachable0 = mapWithIndex1(getPackageRange(v.registry))(v.required);
    var moreReachable = foldMap2(foldMap2(mapWithIndex1(getPackageRange(v.registry))));
    var reachable = fixEqM1(moreReachable)(reachable0);
    return reachable;
};
var fixEq = function (dictEq) {
    var eq7 = Data_Eq.eq(dictEq);
    return function (f) {
        return function (a) {
            var b = f(a);
            var $533 = eq7(b)(a);
            if ($533) {
                return a;
            };
            return fixEq(dictEq)(f)(b);
        };
    };
};
var doubleton = function ($$package) {
    return function (version) {
        return function (dat) {
            var helper = function (v) {
                if (v instanceof Data_Maybe.Nothing) {
                    return Data_Map_Internal.singleton(version)(dat);
                };
                if (v instanceof Data_Maybe.Just) {
                    return insert1(version)(dat)(v.value0);
                };
                throw new Error("Failed pattern match at Registry.Solver (line 743, column 3 - line 743, column 45): " + [ v.constructor.name ]);
            };
            return coerce(alter(function ($611) {
                return Data_Maybe.Just.create(helper($611));
            })($$package));
        };
    };
};
var dependency = function (v) {
    return function (v1) {
        return new Pos(v1.value0, append1(v.value1)(v1.value1));
    };
};
var dependencyOf = function () {
    return function (p1) {
        return coerce(function (v) {
            return new Sourced(v.value0, dependency(p1)(v.value1));
        });
    };
};
var dependencyOf1 = /* #__PURE__ */ dependencyOf();
var checkSolved = function (v) {
    var v1 = function (v2) {
        return traverseWithIndex(function ($$package) {
            return function (v3) {
                var v4 = Data_Map_Internal.findMax(v3);
                var v5 = Data_Map_Internal.size(v3);
                if (v5 === 1 && v4 instanceof Data_Maybe.Just) {
                    return pure2(v4.value0.key);
                };
                return new Data_Either.Left({
                    "package": $$package,
                    versions: v3
                });
            };
        })(v.inRange);
    };
    var $553 = tryLatest(v);
    if ($553 instanceof Data_Maybe.Just) {
        return pure2($553.value0);
    };
    return v1(true);
};
var checkRequired = function (v) {
    var checkRequirementShallow = function ($$package) {
        return function (range) {
            var versions = unwrap(getPackageRange(v.registry)($$package)(range));
            return Data_Map_Internal.isEmpty(versions);
        };
    };
    var checkRequirement = function ($$package) {
        return function (range) {
            return function (previous) {
                var versions = unwrap(map3(unwrap)(Data_Maybe.fromMaybe(mempty3)(lookup($$package)(v.inRange))));
                var noVersions = Data_Map_Internal.isEmpty(versions);
                var hasErrored = forWithIndex(versions)(function (v1) {
                    return function (deps) {
                        var failedDeps = filterWithKey1(checkRequirementShallow)(deps);
                        var $556 = Data_Map_Internal.isEmpty(failedDeps);
                        if ($556) {
                            return new Data_Either.Left(Data_Unit.unit);
                        };
                        return new Data_Either.Right(failedDeps);
                    };
                });
                if (noVersions && (previous instanceof Data_Either.Left && previous.value0 instanceof Conflicts)) {
                    return new Data_Either.Left(new Conflicts(insert($$package)(range)(previous.value0.value0)));
                };
                if (noVersions) {
                    return new Data_Either.Left(new Conflicts(Data_Map_Internal.singleton($$package)(range)));
                };
                if (!noVersions && (hasErrored instanceof Data_Either.Right && previous instanceof Data_Either.Right)) {
                    return new Data_Either.Left(new WhileSolving($$package, map2(Conflicts.create)(hasErrored.value0)));
                };
                if (!noVersions) {
                    return previous;
                };
                throw new Error("Failed pattern match at Registry.Solver (line 322, column 7 - line 327, column 32): " + [ noVersions.constructor.name, hasErrored.constructor.name, previous.constructor.name ]);
            };
        };
    };
    return foldlWithIndex(function (i) {
        return function (b) {
            return function (a) {
                return checkRequirement(i)(a)(b);
            };
        };
    })(new Data_Either.Right(Data_Unit.unit))(v.required);
};
var asDependencyOf = function (v) {
    return function (v1) {
        var pos = append6(getPos1(v.lower))(getPos1(v.upper));
        return {
            lower: dependencyOf1(pos)(v1.lower),
            upper: dependencyOf1(pos)(v1.upper)
        };
    };
};
var commonDependencies = function (registry) {
    return function ($$package) {
        return function (range) {
            var inRange = getPackageRange(registry)($$package)(range);
            var solvableInRange = Data_Array.mapMaybe(traverse(toLoose))(fromFoldable1(inRange));
            var v = Data_Array_NonEmpty.fromArray(solvableInRange);
            if (v instanceof Data_Maybe.Nothing) {
                return mempty4;
            };
            if (v instanceof Data_Maybe.Just) {
                var v1 = foldMap1(Data_Functor_App.App)(map4(un(Data_Map.SemigroupMap))(v.value0));
                return mapFlipped(v1)((function () {
                    var $612 = asDependencyOf(range);
                    return function ($613) {
                        return $612(fromLoose($613));
                    };
                })());
            };
            throw new Error("Failed pattern match at Registry.Solver (line 424, column 5 - line 429, column 71): " + [ v.constructor.name ]);
        };
    };
};
var addFrom = function (v) {
    return over(Data_Map.SemigroupMap)(mapMaybeWithKey(function ($$package) {
        var v1 = lookup($$package)(v);
        if (v1 instanceof Data_Maybe.Nothing) {
            return Data_Maybe.Just.create;
        };
        if (v1 instanceof Data_Maybe.Just) {
            return function (j) {
                var $574 = wouldUpdate(j)(v1.value0);
                if ($574) {
                    return new Data_Maybe.Just(append7(j)(v1.value0));
                };
                return Data_Maybe.Nothing.value;
            };
        };
        throw new Error("Failed pattern match at Registry.Solver (line 391, column 87 - line 395, column 17): " + [ v1.constructor.name ]);
    }));
};
var withReachable = function (r) {
    var $576 = {};
    for (var $577 in r) {
        if ({}.hasOwnProperty.call(r, $577)) {
            $576[$577] = r[$577];
        };
    };
    $576.registry = map3(map3(addFrom(r.required)))(gatherReachable(r));
    return $576;
};
var accumulated = function (dictMonoid) {
    var mempty6 = Data_Monoid.mempty(dictMonoid);
    return function (v) {
        return v(mempty6);
    };
};
var accumulated1 = /* #__PURE__ */ accumulated(monoidSemigroupMap1);
var exploreTransitiveDependencies = function (lastTick) {
    return (function (t) {
        return {
            required: lastTick.required,
            updated: accumulated1(Data_Tuple.fst(t)),
            registry: Data_Tuple.snd(t)
        };
    })(traverseWithIndex1(function ($$package) {
        return traverseWithIndex1(function (version) {
            return function (deps) {
                var updateOne = function (depName) {
                    return function (depRange) {
                        var v = Data_Map_Internal.isEmpty(unwrap(getPackageRange(lastTick.updated)(depName)(depRange)));
                        if (v) {
                            return mempty5;
                        };
                        if (!v) {
                            return new Data_Tuple.Tuple(true, commonDependencies(lastTick.registry)(depName)(depRange));
                        };
                        throw new Error("Failed pattern match at Registry.Solver (line 466, column 36 - line 468, column 91): " + [ v.constructor.name ]);
                    };
                };
                var v = foldMapWithIndex2(updateOne)(deps);
                var dependencies = (function () {
                    if (v.value0) {
                        return append8(deps)(v.value1);
                    };
                    return deps;
                })();
                var updated = (function () {
                    var v1 = v.value0 && majorUpdate(lastTick.required)(deps)(dependencies);
                    if (v1) {
                        return doubleton($$package)(version)(dependencies);
                    };
                    if (!v1) {
                        return mempty1;
                    };
                    throw new Error("Failed pattern match at Registry.Solver (line 472, column 17 - line 474, column 24): " + [ v1.constructor.name ]);
                })();
                return new Data_Tuple.Tuple(updated, dependencies);
            };
        });
    })(lastTick.registry));
};
var exploreAllTransitiveDependencies = function (registry) {
    var go = function ($copy_v) {
        var $tco_done = false;
        var $tco_result;
        function $tco_loop(v) {
            if (noUpdates(v)) {
                $tco_done = true;
                return v.registry;
            };
            $copy_v = exploreTransitiveDependencies(v);
            return;
        };
        while (!$tco_done) {
            $tco_result = $tco_loop($copy_v);
        };
        return $tco_result;
    };
    return go({
        registry: registry,
        updated: registry,
        required: mempty4
    });
};
var solveStep = function (initial) {
    var moreRequired = foldMapWithIndex3(commonDependencies(initial.registry))(initial.required);
    var updatedOfReqs = requirementUpdates(initial)(moreRequired);
    var v = exploreTransitiveDependencies({
        registry: map3(map3(addFrom(moreRequired)))(initial.registry),
        required: initial.required,
        updated: initial.updated
    });
    return {
        required: append8(initial.required)(moreRequired),
        registry: v.registry,
        updated: append9(v.updated)(updatedOfReqs)
    };
};
var solveSteps = function (r0) {
    var go = function ($copy_v) {
        var $tco_done = false;
        var $tco_result;
        function $tco_loop(v) {
            if (noUpdates(v)) {
                $tco_done = true;
                return {
                    registry: v.registry,
                    required: v.required
                };
            };
            $copy_v = solveStep(v);
            return;
        };
        while (!$tco_done) {
            $tco_result = $tco_loop($copy_v);
        };
        return $tco_result;
    };
    return go(r0);
};
var solveFull = /* #__PURE__ */ (function () {
    var applyPackage = function (r) {
        return function ($$package) {
            return function (version) {
                return function (dependencies) {
                    var updated = Data_Maybe.maybe(Data_Map_Internal.empty)(Data_Map_Internal.singleton($$package))(lookup($$package)(unwrap(r.registry)));
                    var required = append8(r.required)(append8(soleVersionOf($$package)(version))(dependencies));
                    return {
                        required: required,
                        registry: r.registry,
                        updated: updated
                    };
                };
            };
        };
    };
    var solvePackage = function (r) {
        return function ($$package) {
            return function (version) {
                return function (dependencies) {
                    return $lazy_solveAux(289)(trimReachable(applyPackage(r)($$package)(version)(dependencies)));
                };
            };
        };
    };
    var $lazy_solveAux = $runtime_lazy("solveAux", "Registry.Solver", function () {
        return function ($614) {
            return (function (r) {
                var rScanned = withInRange(r);
                return discard2(lmap(pure3)(checkRequired(rScanned)))(function () {
                    var v = checkSolved(rScanned);
                    if (v instanceof Data_Either.Right) {
                        return new Data_Either.Right(v.value0);
                    };
                    if (v instanceof Data_Either.Left) {
                        var sols = mapWithIndex(function (version) {
                            return function (deps) {
                                return function (v1) {
                                    return solvePackage(r)(v["value0"]["package"])(version)(deps);
                                };
                            };
                        })(v.value0.versions);
                        var v1 = unwrap(sequence(sols))(Data_Unit.unit);
                        if (v1 instanceof Data_Either.Right) {
                            return new Data_Either.Right(v1.value0);
                        };
                        if (v1 instanceof Data_Either.Left) {
                            return new Data_Either.Left(pure3(new WhileSolving(v["value0"]["package"], map2(Data_List_NonEmpty.head)(v1.value0))));
                        };
                        throw new Error("Failed pattern match at Registry.Solver (line 274, column 11 - line 281, column 36): " + [ v1.constructor.name ]);
                    };
                    throw new Error("Failed pattern match at Registry.Solver (line 267, column 5 - line 281, column 36): " + [ v.constructor.name ]);
                });
            })(solveSteps($614));
        };
    });
    var solveAux = $lazy_solveAux(258);
    return function ($615) {
        return solveAux(solveSeed(withReachable($615)));
    };
})();
var loadAndSolve = function (dictMonad) {
    var mapFlipped1 = Data_Functor.mapFlipped(((dictMonad.Bind1()).Apply0()).Functor0());
    var loadIndex1 = loadIndex(dictMonad);
    return function (loader) {
        return function (required) {
            return mapFlipped1(loadIndex1(loader)(required))(function (index) {
                return solveFull({
                    registry: initializeRegistry(index),
                    required: initializeRequired(required)
                });
            });
        };
    };
};
var solve = function (index) {
    return function (required) {
        return solveFull({
            registry: initializeRegistry(index),
            required: initializeRequired(required)
        });
    };
};
export {
    solve,
    loadAndSolve,
    loadIndex,
    initializeRegistry,
    initializeRequired,
    intersectionFromRange,
    intersectionFromRange$prime,
    Conflicts,
    WhileSolving,
    printSolverPosition,
    printPackageVersion,
    printSolverError,
    printErrorAt,
    printSourced,
    printConflict,
    solveFull,
    checkRequired,
    getLatest,
    tryLatest,
    checkSolved,
    addFrom,
    wouldUpdate,
    commonDependencies,
    solveSteps,
    solveStep,
    exploreTransitiveDependencies,
    majorUpdate,
    requirementUpdates,
    gatherReachable,
    trimReachable,
    Root,
    Trial,
    Solving,
    Pos,
    dependency,
    dependencyOf,
    asDependencyOf,
    Sourced,
    unSource,
    getPos,
    MinSourced,
    MaxSourced,
    Intersection,
    upperBound,
    lowerBound,
    good,
    satisfies,
    soleVersion,
    soleVersionOf,
    getPackageRange,
    Loose,
    toLoose,
    fromLoose,
    withReachable,
    withInRange,
    solveSeed,
    LastSuccess,
    doubleton,
    accumulated,
    fixEq,
    fixEqM,
    noUpdates,
    exploreAllTransitiveDependencies,
    eqSolverError,
    eqLocalSolverPosition,
    semigroupLocalSolverPosit,
    eqSolverPosition,
    semigroupSolverPosition,
    eqSourced,
    newtypeMinSourced_,
    eqMinSourced,
    semigroupMinSourced,
    newtypeMaxSourced_,
    eqMaxSourced,
    semigroupMaxSourced,
    newtypeIntersection_,
    eqIntersection,
    semigroupIntersection,
    newtypeLoose_,
    semigroupLoose,
    newtypeLastSuccess_,
    functorLastSuccess,
    applyLastSuccess,
    applicativeLastSuccess
};
//# sourceMappingURL=index.js.map
