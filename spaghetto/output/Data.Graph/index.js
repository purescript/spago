// Generated by purs version 0.15.10
import * as Control_Category from "../Control.Category/index.js";
import * as Data_Bifunctor from "../Data.Bifunctor/index.js";
import * as Data_Boolean from "../Data.Boolean/index.js";
import * as Data_CatList from "../Data.CatList/index.js";
import * as Data_Foldable from "../Data.Foldable/index.js";
import * as Data_FoldableWithIndex from "../Data.FoldableWithIndex/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_List from "../Data.List/index.js";
import * as Data_List_Types from "../Data.List.Types/index.js";
import * as Data_Map_Internal from "../Data.Map.Internal/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Monoid from "../Data.Monoid/index.js";
import * as Data_Semigroup from "../Data.Semigroup/index.js";
import * as Data_Traversable from "../Data.Traversable/index.js";
import * as Data_Tuple from "../Data.Tuple/index.js";
var map = /* #__PURE__ */ Data_Functor.map(Data_List_Types.functorList);
var mempty = /* #__PURE__ */ Data_Monoid.mempty(Data_List_Types.monoidList);
var append = /* #__PURE__ */ Data_Semigroup.append(Data_CatList.semigroupCatList);
var fromFoldable = /* #__PURE__ */ Data_CatList.fromFoldable(Data_List_Types.foldableList);
var fromFoldable1 = /* #__PURE__ */ Data_CatList.fromFoldable(Data_Foldable.foldableArray);
var map1 = /* #__PURE__ */ Data_Functor.map(Data_Maybe.functorMaybe);
var map2 = /* #__PURE__ */ Data_Functor.map(Data_Map_Internal.functorMap);
var lmap = /* #__PURE__ */ Data_Bifunctor.lmap(Data_Bifunctor.bifunctorTuple);
var foldl = /* #__PURE__ */ Data_Foldable.foldl(Data_List_Types.foldableList);
var foldr = /* #__PURE__ */ Data_Foldable.foldr(Data_List_Types.foldableList);
var foldMap = /* #__PURE__ */ Data_Foldable.foldMap(Data_List_Types.foldableList);
var traverse = /* #__PURE__ */ Data_Traversable.traverse(Data_Map_Internal.traversableMap);
var identity = /* #__PURE__ */ Control_Category.identity(Control_Category.categoryFn);
var foldlWithIndex = /* #__PURE__ */ Data_FoldableWithIndex.foldlWithIndex(Data_Map_Internal.foldableWithIndexMap);
var Emit = /* #__PURE__ */ (function () {
    function Emit(value0) {
        this.value0 = value0;
    };
    Emit.create = function (value0) {
        return new Emit(value0);
    };
    return Emit;
})();
var Visit = /* #__PURE__ */ (function () {
    function Visit(value0) {
        this.value0 = value0;
    };
    Visit.create = function (value0) {
        return new Visit(value0);
    };
    return Visit;
})();
var Graph = function (x) {
    return x;
};
var vertices = function (v) {
    return map(Data_Tuple.fst)(Data_Map_Internal.values(v));
};
var unfoldGraph = function (dictOrd) {
    var fromFoldable2 = Data_Map_Internal.fromFoldable(dictOrd);
    return function (dictFunctor) {
        var map3 = Data_Functor.map(dictFunctor);
        return function (dictFoldable) {
            var fromFoldable3 = fromFoldable2(dictFoldable);
            return function (dictFoldable1) {
                var fromFoldable4 = Data_List.fromFoldable(dictFoldable1);
                return function (ks) {
                    return function (label) {
                        return function (theEdges) {
                            return fromFoldable3(map3(function (k) {
                                return new Data_Tuple.Tuple(k, new Data_Tuple.Tuple(label(k), fromFoldable4(theEdges(k))));
                            })(ks));
                        };
                    };
                };
            };
        };
    };
};
var topologicalSort = function (dictOrd) {
    var member = Data_Map_Internal.member(dictOrd);
    var $$delete = Data_Map_Internal["delete"](dictOrd);
    var lookup1 = Data_Map_Internal.lookup(dictOrd);
    return function (v) {
        var visit = function ($copy_state) {
            return function ($copy_stack) {
                var $tco_var_state = $copy_state;
                var $tco_done = false;
                var $tco_result;
                function $tco_loop(state, stack) {
                    var v1 = Data_CatList.uncons(stack);
                    if (v1 instanceof Data_Maybe.Nothing) {
                        $tco_done = true;
                        return state;
                    };
                    if (v1 instanceof Data_Maybe.Just && v1.value0.value0 instanceof Emit) {
                        var state$prime = {
                            result: new Data_List_Types.Cons(v1.value0.value0.value0, state.result),
                            unvisited: state.unvisited
                        };
                        $tco_var_state = state$prime;
                        $copy_stack = v1.value0.value1;
                        return;
                    };
                    if (v1 instanceof Data_Maybe.Just && v1.value0.value0 instanceof Visit) {
                        if (member(v1.value0.value0.value0)(state.unvisited)) {
                            var start = {
                                result: state.result,
                                unvisited: $$delete(v1.value0.value0.value0)(state.unvisited)
                            };
                            var next = Data_Maybe.maybe(mempty)(Data_Tuple.snd)(lookup1(v1.value0.value0.value0)(v));
                            $tco_var_state = start;
                            $copy_stack = append(fromFoldable(map(Visit.create)(next)))(Data_CatList.cons(new Emit(v1.value0.value0.value0))(v1.value0.value1));
                            return;
                        };
                        if (Data_Boolean.otherwise) {
                            $tco_var_state = state;
                            $copy_stack = v1.value0.value1;
                            return;
                        };
                    };
                    throw new Error("Failed pattern match at Data.Graph (line 126, column 7 - line 144, column 40): " + [ v1.constructor.name ]);
                };
                while (!$tco_done) {
                    $tco_result = $tco_loop($tco_var_state, $copy_stack);
                };
                return $tco_result;
            };
        };
        var initialState = {
            unvisited: v,
            result: Data_List_Types.Nil.value
        };
        var go = function ($copy_v1) {
            var $tco_done1 = false;
            var $tco_result;
            function $tco_loop(v1) {
                var v2 = Data_Map_Internal.findMin(v1.unvisited);
                if (v2 instanceof Data_Maybe.Just) {
                    $copy_v1 = visit(v1)(fromFoldable1([ new Visit(v2.value0.key) ]));
                    return;
                };
                if (v2 instanceof Data_Maybe.Nothing) {
                    $tco_done1 = true;
                    return v1.result;
                };
                throw new Error("Failed pattern match at Data.Graph (line 120, column 7 - line 122, column 26): " + [ v2.constructor.name ]);
            };
            while (!$tco_done1) {
                $tco_result = $tco_loop($copy_v1);
            };
            return $tco_result;
        };
        return go(initialState);
    };
};
var toMap = function (v) {
    return v;
};
var outEdges = function (dictOrd) {
    var lookup1 = Data_Map_Internal.lookup(dictOrd);
    return function (k) {
        return function (v) {
            return map1(Data_Tuple.snd)(lookup1(k)(v));
        };
    };
};
var lookup = function (dictOrd) {
    var lookup1 = Data_Map_Internal.lookup(dictOrd);
    return function (k) {
        return function (v) {
            return map1(Data_Tuple.fst)(lookup1(k)(v));
        };
    };
};
var functorGraph = {
    map: function (f) {
        return function (v) {
            return map2(lmap(f))(v);
        };
    }
};
var fromMap = Graph;
var foldableGraph = {
    foldl: function (f) {
        return function (z) {
            return function (v) {
                return foldl(function (acc) {
                    return function (v1) {
                        return f(acc)(v1.value0);
                    };
                })(z)(Data_Map_Internal.values(v));
            };
        };
    },
    foldr: function (f) {
        return function (z) {
            return function (v) {
                return foldr(function (v1) {
                    return function (acc) {
                        return f(v1.value0)(acc);
                    };
                })(z)(Data_Map_Internal.values(v));
            };
        };
    },
    foldMap: function (dictMonoid) {
        var foldMap1 = foldMap(dictMonoid);
        return function (f) {
            return function (v) {
                return foldMap1(function ($107) {
                    return f(Data_Tuple.fst($107));
                })(Data_Map_Internal.values(v));
            };
        };
    }
};
var traversableGraph = {
    traverse: function (dictApplicative) {
        var map3 = Data_Functor.map((dictApplicative.Apply0()).Functor0());
        var traverse1 = traverse(dictApplicative);
        return function (f) {
            return function (v) {
                return map3(Graph)(traverse1(function (v1) {
                    return map3(function (v3) {
                        return new Data_Tuple.Tuple(v3, v1.value1);
                    })(f(v1.value0));
                })(v));
            };
        };
    },
    sequence: function (dictApplicative) {
        return Data_Traversable.traverse(traversableGraph)(dictApplicative)(identity);
    },
    Functor0: function () {
        return functorGraph;
    },
    Foldable1: function () {
        return foldableGraph;
    }
};
var edges = function (v) {
    var mkEdge = function (src) {
        return function (acc) {
            return function (dest) {
                return new Data_List_Types.Cons({
                    start: src,
                    end: dest
                }, acc);
            };
        };
    };
    var edges$prime = function (src) {
        return function (acc) {
            return function (v1) {
                return foldl(mkEdge(src))(acc)(v1.value1);
            };
        };
    };
    return foldlWithIndex(edges$prime)(Data_List_Types.Nil.value)(v);
};
export {
    unfoldGraph,
    fromMap,
    toMap,
    vertices,
    edges,
    lookup,
    outEdges,
    topologicalSort,
    functorGraph,
    foldableGraph,
    traversableGraph
};
//# sourceMappingURL=index.js.map
