// Generated by purs version 0.15.10
import * as Control_Applicative from "../Control.Applicative/index.js";
import * as Control_Bind from "../Control.Bind/index.js";
import * as Control_Monad_ST_Internal from "../Control.Monad.ST.Internal/index.js";
import * as Data_Bifunctor from "../Data.Bifunctor/index.js";
import * as Data_Bounded from "../Data.Bounded/index.js";
import * as Data_Codec from "../Data.Codec/index.js";
import * as Data_Codec_Argonaut from "../Data.Codec.Argonaut/index.js";
import * as Data_DateTime from "../Data.DateTime/index.js";
import * as Data_Either from "../Data.Either/index.js";
import * as Data_Foldable from "../Data.Foldable/index.js";
import * as Data_FoldableWithIndex from "../Data.FoldableWithIndex/index.js";
import * as Data_Formatter_DateTime from "../Data.Formatter.DateTime/index.js";
import * as Data_Function from "../Data.Function/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_Int from "../Data.Int/index.js";
import * as Data_Map_Internal from "../Data.Map.Internal/index.js";
import * as Data_Semigroup from "../Data.Semigroup/index.js";
import * as Data_String_CodePoints from "../Data.String.CodePoints/index.js";
import * as Data_Time from "../Data.Time/index.js";
import * as Data_Traversable from "../Data.Traversable/index.js";
import * as Data_Tuple from "../Data.Tuple/index.js";
import * as Data_Unfoldable from "../Data.Unfoldable/index.js";
import * as Foreign_Object from "../Foreign.Object/index.js";
import * as Foreign_Object_ST from "../Foreign.Object.ST/index.js";
import * as Parsing from "../Parsing/index.js";
import * as Registry_Internal_Format from "../Registry.Internal.Format/index.js";
import * as Registry_PackageName from "../Registry.PackageName/index.js";
import * as Registry_Version from "../Registry.Version/index.js";
var forWithIndex_ = /* #__PURE__ */ Data_FoldableWithIndex.forWithIndex_(Control_Monad_ST_Internal.applicativeST)(Data_Map_Internal.foldableWithIndexMap);
var bind1 = /* #__PURE__ */ Control_Bind.bind(Data_Either.bindEither);
var map = /* #__PURE__ */ Data_Functor.map(Data_Either.functorEither);
var toUnfoldable = /* #__PURE__ */ Foreign_Object.toUnfoldable(Data_Unfoldable.unfoldableArray);
var $$for = /* #__PURE__ */ Data_Traversable["for"](Data_Either.applicativeEither)(Data_Traversable.traversableArray);
var lmap = /* #__PURE__ */ Data_Bifunctor.lmap(Data_Bifunctor.bifunctorEither);
var pure1 = /* #__PURE__ */ Control_Applicative.pure(Data_Either.applicativeEither);
var append = /* #__PURE__ */ Data_Semigroup.append(Data_Semigroup.semigroupString);
var strMap = function (dictOrd) {
    var fromFoldable = Data_Map_Internal.fromFoldable(dictOrd)(Data_Foldable.foldableArray);
    return function (type_) {
        return function (parse) {
            return function (print) {
                return function (valueCodec) {
                    var encode = function (m) {
                        return Data_Codec.encode(Data_Codec_Argonaut.jobject)(Foreign_Object.runST(function __do() {
                            var obj = Foreign_Object_ST["new"]();
                            forWithIndex_(m)(function (k) {
                                return function (v) {
                                    return Foreign_Object_ST.poke(print(k))(Data_Codec.encode(valueCodec)(v))(obj);
                                };
                            })();
                            return obj;
                        }));
                    };
                    var decode = function (json) {
                        return bind1(map(toUnfoldable)(Data_Codec.decode(Data_Codec_Argonaut.jobject)(json)))(function (v) {
                            return bind1($$for(v)(function (v1) {
                                return bind1(Data_Either.note(new Data_Codec_Argonaut.AtKey(v1.value0, new Data_Codec_Argonaut.TypeMismatch(type_)))(parse(v1.value0)))(function (key) {
                                    return bind1(lmap(Data_Codec_Argonaut.AtKey.create(v1.value0))(Data_Codec.decode(valueCodec)(v1.value1)))(function (val) {
                                        return pure1(new Data_Tuple.Tuple(key, val));
                                    });
                                });
                            }))(function (parsed) {
                                return pure1(fromFoldable(parsed));
                            });
                        });
                    };
                    return Data_Codec["codec$prime"](decode)(encode);
                };
            };
        };
    };
};
var versionMap = /* #__PURE__ */ strMap(Registry_Version.ordVersion)("Version")(function ($38) {
    return Data_Either.hush(Registry_Version.parse($38));
})(Registry_Version.print);
var parsedString = function (label) {
    return function (parser) {
        var encode = Data_Codec.encode(Data_Codec_Argonaut.string);
        var decode = function (json) {
            return bind1(Data_Codec.decode(Data_Codec_Argonaut.string)(json))(function (string) {
                var v = Parsing.runParser(string)(parser);
                if (v instanceof Data_Either.Left) {
                    return new Data_Either.Left(new Data_Codec_Argonaut.TypeMismatch(label + (": " + Parsing.parseErrorMessage(v.value0))));
                };
                if (v instanceof Data_Either.Right) {
                    return pure1(v.value0);
                };
                throw new Error("Failed pattern match at Registry.Internal.Codec (line 116, column 5 - line 118, column 32): " + [ v.constructor.name ]);
            });
        };
        return Data_Codec["codec$prime"](decode)(encode);
    };
};
var packageMap = /* #__PURE__ */ strMap(Registry_PackageName.ordPackageName)("PackageName")(function ($39) {
    return Data_Either.hush(Registry_PackageName.parse($39));
})(Registry_PackageName.print);
var limitedString = function (limit) {
    var encode = Data_Codec.encode(Data_Codec_Argonaut.string);
    var decode = function (json) {
        return bind1(Data_Codec.decode(Data_Codec_Argonaut.string)(json))(function (string) {
            var $34 = Data_String_CodePoints.length(string) > limit;
            if ($34) {
                return new Data_Either.Left(new Data_Codec_Argonaut.TypeMismatch("LimitedString: Exceeds limit of " + (Data_Int.toStringAs(Data_Int.decimal)(limit) + " characters.")));
            };
            return new Data_Either.Right(string);
        });
    };
    return Data_Codec["codec$prime"](decode)(encode);
};
var iso8601DateTime = /* #__PURE__ */ (function () {
    var encode = (function () {
        var $40 = Data_Codec.encode(Data_Codec_Argonaut.string);
        var $41 = Data_Formatter_DateTime.format(Registry_Internal_Format.iso8601DateTime);
        return function ($42) {
            return $40($41($42));
        };
    })();
    var decode = function (json) {
        return bind1(Data_Codec.decode(Data_Codec_Argonaut.string)(json))(function (string) {
            var v = Registry_Internal_Format.rfc3339ToISO8601(string);
            if (v instanceof Data_Either.Left) {
                return new Data_Either.Left(new Data_Codec_Argonaut.TypeMismatch("Unable to parse input as ISO8601: " + v.value0));
            };
            if (v instanceof Data_Either.Right) {
                return lmap((function () {
                    var $43 = append("ISO8601: ");
                    return function ($44) {
                        return Data_Codec_Argonaut.TypeMismatch.create($43($44));
                    };
                })())(Data_Formatter_DateTime.unformat(Registry_Internal_Format.iso8601DateTime)(v.value0));
            };
            throw new Error("Failed pattern match at Registry.Internal.Codec (line 62, column 5 - line 65, column 122): " + [ v.constructor.name ]);
        });
    };
    return Data_Codec["codec$prime"](decode)(encode);
})();
var iso8601Date = /* #__PURE__ */ (function () {
    var encode = (function () {
        var $45 = Data_Codec.encode(Data_Codec_Argonaut.string);
        var $46 = Data_Formatter_DateTime.format(Registry_Internal_Format.iso8601Date);
        var $47 = Data_Function.flip(Data_DateTime.DateTime.create)(Data_Bounded.bottom(Data_Time.boundedTime));
        return function ($48) {
            return $45($46($47($48)));
        };
    })();
    var decode = function (json) {
        return bind1(Data_Codec.decode(Data_Codec_Argonaut.string)(json))(function (string) {
            return bind1(lmap((function () {
                var $49 = append("YYYY-MM-DD: ");
                return function ($50) {
                    return Data_Codec_Argonaut.TypeMismatch.create($49($50));
                };
            })())(Data_Formatter_DateTime.unformat(Registry_Internal_Format.iso8601Date)(string)))(function (dateTime) {
                return pure1(Data_DateTime.date(dateTime));
            });
        });
    };
    return Data_Codec["codec$prime"](decode)(encode);
})();
export {
    iso8601Date,
    iso8601DateTime,
    limitedString,
    packageMap,
    parsedString,
    versionMap,
    strMap
};
//# sourceMappingURL=index.js.map
