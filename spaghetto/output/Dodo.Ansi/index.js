// Generated by purs version 0.15.10
import * as Ansi_Codes from "../Ansi.Codes/index.js";
import * as Control_Applicative from "../Control.Applicative/index.js";
import * as Data_Eq from "../Data.Eq/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_List from "../Data.List/index.js";
import * as Data_List_NonEmpty from "../Data.List.NonEmpty/index.js";
import * as Data_List_Types from "../Data.List.Types/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Dodo from "../Dodo/index.js";
var pure = /* #__PURE__ */ Control_Applicative.pure(Data_List_Types.applicativeNonEmptyList);
var eq = /* #__PURE__ */ Data_Eq.eq(Ansi_Codes.eqRenderingMode);
var notEq = /* #__PURE__ */ Data_Eq.notEq(Ansi_Codes.eqGraphicsParam);
var AnsiBuffer = function (x) {
    return x;
};
var underline = /* #__PURE__ */ (function () {
    return Dodo.annotate(new Ansi_Codes.PMode(Ansi_Codes.Underline.value));
})();
var strikethrough = /* #__PURE__ */ (function () {
    return Dodo.annotate(new Ansi_Codes.PMode(Ansi_Codes.Strikethrough.value));
})();
var reset = /* #__PURE__ */ (function () {
    return Dodo.annotate(Ansi_Codes.Reset.value);
})();
var italic = /* #__PURE__ */ (function () {
    return Dodo.annotate(new Ansi_Codes.PMode(Ansi_Codes.Italic.value));
})();
var inverse = /* #__PURE__ */ (function () {
    return Dodo.annotate(new Ansi_Codes.PMode(Ansi_Codes.Inverse.value));
})();
var foreground = function (color) {
    return Dodo.annotate(new Ansi_Codes.PForeground(color));
};
var dim = /* #__PURE__ */ (function () {
    return Dodo.annotate(new Ansi_Codes.PMode(Ansi_Codes.Dim.value));
})();
var bold = /* #__PURE__ */ (function () {
    return Dodo.annotate(new Ansi_Codes.PMode(Ansi_Codes.Bold.value));
})();
var background = function (color) {
    return Dodo.annotate(new Ansi_Codes.PBackground(color));
};
var ansiGraphics = /* #__PURE__ */ (function () {
    var writePendingGraphics = function (v) {
        if (v.pending instanceof Data_Maybe.Nothing) {
            return v;
        };
        if (v.pending instanceof Data_Maybe.Just) {
            return {
                output: v.output + Ansi_Codes.escapeCodeToString(new Ansi_Codes.Graphics(v.pending.value0)),
                pending: Data_Maybe.Nothing.value,
                current: v.current,
                previous: v.previous
            };
        };
        throw new Error("Failed pattern match at Dodo.Ansi (line 136, column 5 - line 143, column 12): " + [ v.pending.constructor.name ]);
    };
    var writeText = function (v) {
        return function (text) {
            return function (output) {
                var v1 = writePendingGraphics(output);
                return {
                    output: v1.output + text,
                    pending: v1.pending,
                    current: v1.current,
                    previous: Data_List_Types.Nil.value
                };
            };
        };
    };
    var writeIndent = function (v) {
        return function (text) {
            return function (v1) {
                return {
                    output: v1.output + text,
                    pending: v1.pending,
                    current: v1.current,
                    previous: v1.previous
                };
            };
        };
    };
    var resetCode = Ansi_Codes.escapeCodeToString(new Ansi_Codes.Graphics(pure(Ansi_Codes.Reset.value)));
    var graphicsConflict = function (v) {
        return function (v1) {
            if (v instanceof Ansi_Codes.Reset && v1 instanceof Ansi_Codes.Reset) {
                return true;
            };
            if (v instanceof Ansi_Codes.PForeground && v1 instanceof Ansi_Codes.PForeground) {
                return true;
            };
            if (v instanceof Ansi_Codes.PBackground && v1 instanceof Ansi_Codes.PBackground) {
                return true;
            };
            if (v instanceof Ansi_Codes.PMode && v1 instanceof Ansi_Codes.PMode) {
                return eq(v.value0)(v1.value0);
            };
            return false;
        };
    };
    var getPendingGraphics = (function () {
        var $50 = Data_Functor.map(Data_Maybe.functorMaybe)(Data_List_NonEmpty.cons(Ansi_Codes.Reset.value));
        return function ($51) {
            return $50(Data_List_NonEmpty.fromList($51));
        };
    })();
    var writeBreak = function (v) {
        var pending = getPendingGraphics(v.current);
        var resetOrEmpty = (function () {
            var $42 = Data_Maybe.isNothing(pending) && Data_List["null"](v.previous);
            if ($42) {
                return "";
            };
            return resetCode;
        })();
        return {
            output: v.output + (resetOrEmpty + "\x0a"),
            pending: pending,
            current: v.current,
            previous: v.previous
        };
    };
    var getCurrentGraphics = (function () {
        var $52 = Data_List.nubByEq(graphicsConflict);
        var $53 = Data_List.takeWhile(function (v) {
            return notEq(v)(Ansi_Codes.Reset.value);
        });
        return function ($54) {
            return Data_List.reverse($52($53($54)));
        };
    })();
    var leaveAnnotation = function (v) {
        return function (as) {
            return function (v1) {
                var current = getCurrentGraphics(as);
                return {
                    output: v1.output,
                    pending: new Data_Maybe.Just(Data_Maybe.fromMaybe(pure(Ansi_Codes.Reset.value))(getPendingGraphics(current))),
                    current: current,
                    previous: v1.current
                };
            };
        };
    };
    var flushBuffer = function (ansiBuffer) {
        var v = writePendingGraphics(ansiBuffer);
        return v.output;
    };
    var enterAnnotation = function (a) {
        return function (as) {
            return function (v) {
                var current = getCurrentGraphics(new Data_List_Types.Cons(a, as));
                return {
                    output: v.output,
                    pending: getPendingGraphics(current),
                    current: current,
                    previous: v.current
                };
            };
        };
    };
    var emptyBuffer = {
        output: "",
        pending: Data_Maybe.Nothing.value,
        current: Data_List_Types.Nil.value,
        previous: Data_List_Types.Nil.value
    };
    return {
        emptyBuffer: emptyBuffer,
        writeText: writeText,
        writeIndent: writeIndent,
        writeBreak: writeBreak,
        enterAnnotation: enterAnnotation,
        leaveAnnotation: leaveAnnotation,
        flushBuffer: flushBuffer
    };
})();
export {
    AnsiBuffer,
    ansiGraphics,
    background,
    bold,
    dim,
    foreground,
    inverse,
    italic,
    reset,
    strikethrough,
    underline
};
export {
    Black,
    Blue,
    BrightBlack,
    BrightBlue,
    BrightCyan,
    BrightGreen,
    BrightMagenta,
    BrightRed,
    BrightWhite,
    BrightYellow,
    Cyan,
    Green,
    Magenta,
    Red,
    White,
    Yellow
} from "../Ansi.Codes/index.js";
//# sourceMappingURL=index.js.map
