// Generated by purs version 0.15.10
import * as $foreign from "./foreign.js";
import * as Control_Applicative from "../Control.Applicative/index.js";
import * as Control_Bind from "../Control.Bind/index.js";
import * as Control_Monad_Reader_Class from "../Control.Monad.Reader.Class/index.js";
import * as Control_Parallel from "../Control.Parallel/index.js";
import * as Control_Parallel_Class from "../Control.Parallel.Class/index.js";
import * as Data_Argonaut_Core from "../Data.Argonaut.Core/index.js";
import * as Data_Array from "../Data.Array/index.js";
import * as Data_DateTime_Instant from "../Data.DateTime.Instant/index.js";
import * as Data_Either from "../Data.Either/index.js";
import * as Data_Foldable from "../Data.Foldable/index.js";
import * as Data_Function_Uncurried from "../Data.Function.Uncurried/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_Int from "../Data.Int/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Monoid from "../Data.Monoid/index.js";
import * as Data_Show from "../Data.Show/index.js";
import * as Data_String_CodeUnits from "../Data.String.CodeUnits/index.js";
import * as Data_String_Common from "../Data.String.Common/index.js";
import * as Data_Traversable from "../Data.Traversable/index.js";
import * as Effect_Aff from "../Effect.Aff/index.js";
import * as Effect_Aff_Class from "../Effect.Aff.Class/index.js";
import * as Effect_Class from "../Effect.Class/index.js";
import * as Effect_Now from "../Effect.Now/index.js";
import * as Node_Buffer from "../Node.Buffer/index.js";
import * as Node_Buffer_Class from "../Node.Buffer.Class/index.js";
import * as Node_Encoding from "../Node.Encoding/index.js";
import * as Node_Path from "../Node.Path/index.js";
import * as Partial_Unsafe from "../Partial.Unsafe/index.js";
import * as Registry_Sha256 from "../Registry.Sha256/index.js";
import * as Registry_Version from "../Registry.Version/index.js";
import * as Spago_Core_Prelude from "../Spago.Core.Prelude/index.js";
import * as Spago_Paths from "../Spago.Paths/index.js";
var bind = /* #__PURE__ */ Control_Bind.bind(Effect_Aff.bindAff);
var pure = /* #__PURE__ */ Control_Applicative.pure(Effect_Aff.applicativeAff);
var sequential = /* #__PURE__ */ Control_Parallel_Class.sequential(Effect_Aff.parallelAff);
var oneOf = /* #__PURE__ */ Data_Foldable.oneOf(Data_Foldable.foldableArray)(Effect_Aff.plusParAff);
var parallel = /* #__PURE__ */ Control_Parallel_Class.parallel(Effect_Aff.parallelAff);
var map = /* #__PURE__ */ Data_Functor.map(Effect_Aff.functorAff);
var fromString = /* #__PURE__ */ Node_Buffer_Class.fromString(Node_Buffer.mutableBufferEffect);
var toString = /* #__PURE__ */ Node_Buffer_Class.toString(Node_Buffer.mutableBufferEffect);
var map1 = /* #__PURE__ */ Data_Functor.map(Data_Maybe.functorMaybe);
var map2 = /* #__PURE__ */ Data_Functor.map(Data_Functor.functorArray);
var bind2 = /* #__PURE__ */ Control_Bind.bind(Spago_Core_Prelude.bindSpago);
var ask = /* #__PURE__ */ Control_Monad_Reader_Class.ask(Spago_Core_Prelude.monadAskSpago);
var liftAff = /* #__PURE__ */ Effect_Aff_Class.liftAff(Spago_Core_Prelude.monadAffSpago);
var parSequence = /* #__PURE__ */ Control_Parallel.parSequence(Effect_Aff.parallelAff)(Data_Traversable.traversableArray);
var runSpago = /* #__PURE__ */ Spago_Core_Prelude.runSpago(Effect_Aff_Class.monadAffAff);
var for_ = /* #__PURE__ */ Data_Foldable.for_(Effect_Aff.applicativeAff)(Data_Foldable.foldableArray);
var liftEffect = /* #__PURE__ */ Effect_Class.liftEffect(Effect_Aff.monadEffectAff);
var hashString = /* #__PURE__ */ Registry_Sha256.hashString(Effect_Class.monadEffectEffect);
var show = /* #__PURE__ */ Data_Show.show(Data_DateTime_Instant.showInstant);
var HexString = function (x) {
    return x;
};
var withBackoff = function (v) {
    var runTimeout = function (attempt) {
        return function (ms) {
            return bind(Effect_Aff.delay(Data_Int.toNumber(ms)))(function () {
                return bind(v.shouldCancel(attempt))(function (v1) {
                    if (v1) {
                        return pure(Data_Maybe.Nothing.value);
                    };
                    return runTimeout(attempt)(ms * 2 | 0);
                });
            });
        };
    };
    var runAction = function (attempt) {
        return function (action$prime) {
            return function (ms) {
                return sequential(oneOf([ parallel(map(Data_Maybe.Just.create)(action$prime)), parallel(runTimeout(attempt)(ms)) ]));
            };
        };
    };
    var loop = function (attempt) {
        return function (v1) {
            if (v1 instanceof Data_Maybe.Nothing) {
                return bind(v.shouldRetry(attempt))(function (maybeRetry) {
                    if (maybeRetry instanceof Data_Maybe.Nothing) {
                        return pure(Data_Maybe.Nothing.value);
                    };
                    if (maybeRetry instanceof Data_Maybe.Just) {
                        var newTimeout = Data_Int.pow(Data_Int.floor(v.delay))(attempt + 1 | 0);
                        return bind(runAction(attempt)(maybeRetry.value0)(newTimeout))(function (maybeResult) {
                            return loop(attempt + 1 | 0)(maybeResult);
                        });
                    };
                    throw new Error("Failed pattern match at Spago.Prelude (line 126, column 9 - line 131, column 43): " + [ maybeRetry.constructor.name ]);
                });
            };
            if (v1 instanceof Data_Maybe.Just) {
                return pure(new Data_Maybe.Just(v1.value0));
            };
            throw new Error("Failed pattern match at Spago.Prelude (line 123, column 20 - line 133, column 33): " + [ v1.constructor.name ]);
        };
    };
    return bind(runAction(0)(v.action)(Data_Int.floor(v.delay)))(function (maybeResult) {
        return loop(1)(maybeResult);
    });
};
var withBackoff$prime = function (action) {
    return withBackoff({
        delay: 5000.0,
        action: action,
        shouldCancel: function (v) {
            return pure(true);
        },
        shouldRetry: function (attempt) {
            var $64 = attempt > 3;
            if ($64) {
                return pure(Data_Maybe.Nothing.value);
            };
            return pure(new Data_Maybe.Just(action));
        }
    });
};
var unsafeStringify = function (a) {
    return Data_Argonaut_Core.stringify(a);
};
var unsafeFromRight = function (v) {
    return Data_Either["fromRight$prime"](function (v1) {
        return Partial_Unsafe.unsafeCrashWith("Unexpected Left: " + unsafeStringify(v));
    })(v);
};
var shaToHex = function (s) {
    return function __do() {
        var v = fromString(Registry_Sha256.print(s))(Node_Encoding.UTF8.value)();
        var string = toString(Node_Encoding.Hex.value)(v)();
        return string;
    };
};
var partitionEithers = /* #__PURE__ */ Data_Array.foldMap(/* #__PURE__ */ Data_Monoid.monoidRecord()(/* #__PURE__ */ Data_Monoid.monoidRecordCons({
    reflectSymbol: function () {
        return "fail";
    }
})(Data_Monoid.monoidArray)()(/* #__PURE__ */ Data_Monoid.monoidRecordCons({
    reflectSymbol: function () {
        return "success";
    }
})(Data_Monoid.monoidArray)()(Data_Monoid.monoidRecordNil))))(function (v) {
    if (v instanceof Data_Either.Left) {
        return {
            fail: [ v.value0 ],
            success: [  ]
        };
    };
    if (v instanceof Data_Either.Right) {
        return {
            fail: [  ],
            success: [ v.value0 ]
        };
    };
    throw new Error("Failed pattern match at Spago.Prelude (line 67, column 34 - line 69, column 53): " + [ v.constructor.name ]);
});
var parseUrl = /* #__PURE__ */ (function () {
    return Data_Function_Uncurried.runFn3($foreign.parseUrlImpl)(Data_Either.Left.create)(function ($70) {
        return Data_Either.Right.create($70);
    });
})();
var parseLenientVersion = function (input) {
    var maybeIdentity = function (k) {
        return function (x) {
            return Data_Maybe.fromMaybe(x)(k(x));
        };
    };
    var dropLeadingZeros = (function () {
        var $71 = map1(Data_Int.toStringAs(Data_Int.decimal));
        return function ($72) {
            return $71(Data_Int.fromString($72));
        };
    })();
    return Registry_Version.parse(Data_String_Common.joinWith(".")(map2(maybeIdentity(dropLeadingZeros))(Data_String_Common.split(".")(maybeIdentity(Data_String_CodeUnits.stripPrefix("v"))(Data_String_Common.trim(input))))));
};
var parallelise = function (actions) {
    return bind2(ask)(function (env) {
        return bind2(liftAff(parSequence(map2((function () {
            var $73 = runSpago(env);
            return function ($74) {
                return Effect_Aff.forkAff($73($74));
            };
        })())(actions))))(function (fibers) {
            return liftAff(for_(fibers)(Effect_Aff.joinFiber));
        });
    });
};
var mkTemp$prime = function (dictMonadAff) {
    var liftAff1 = Effect_Aff_Class.liftAff(dictMonadAff);
    return function (maybeSuffix) {
        return liftAff1(bind(liftEffect(function __do() {
            var now = Effect_Now.now();
            var sha = hashString(show(now) + Data_Maybe.fromMaybe("")(maybeSuffix))();
            return shaToHex(sha)();
        }))(function (v) {
            var tempDirPath = Node_Path.concat([ Spago_Paths.paths.temp, v ]);
            return pure(tempDirPath);
        }));
    };
};
var mkTemp = function (dictMonadAff) {
    return mkTemp$prime(dictMonadAff)(Data_Maybe.Nothing.value);
};
export {
    unsafeLog
} from "./foreign.js";
export {
    HexString,
    parseLenientVersion,
    parallelise,
    parseUrl,
    partitionEithers,
    shaToHex,
    unsafeFromRight,
    unsafeStringify,
    withBackoff$prime,
    mkTemp,
    mkTemp$prime
};
export {
    Left,
    Right,
    ASCII,
    Base64,
    Binary,
    Hex,
    Latin1,
    UCS2,
    UTF16LE,
    UTF8,
    Identity,
    Manifest,
    Just,
    Nothing,
    Metadata,
    EQ,
    GT,
    LT,
    OutputJson,
    OutputLines,
    OutputTable,
    Spago,
    Tuple,
    absurd,
    add,
    and,
    ap,
    append,
    apply,
    ask,
    asks,
    between,
    bimap,
    bind,
    bottom,
    catchError,
    clamp,
    compare,
    comparing,
    compose,
    conj,
    const,
    degree,
    die,
    die$prime,
    discard,
    disj,
    div,
    either,
    eq,
    flap,
    flip,
    foldMap,
    foldl,
    for,
    forWithIndex,
    for_,
    fromMaybe,
    fst,
    gcd,
    genericShow,
    hush,
    identity,
    ifM,
    indent,
    indent2,
    isJust,
    isLeft,
    isNothing,
    isRight,
    join,
    lcm,
    liftA1,
    liftAff,
    liftEffect,
    liftM1,
    lmap,
    logDebug,
    logError,
    logInfo,
    logSuccess,
    logWarn,
    map,
    max,
    maybe,
    mempty,
    min,
    mod,
    mul,
    negate,
    not,
    notEq,
    one,
    or,
    otherwise,
    output,
    parseJson,
    parseYaml,
    partition,
    partitionMap,
    printJson,
    printYaml,
    pure,
    recip,
    rmap,
    runSpago,
    show,
    snd,
    sub,
    toDoc,
    top,
    traverse,
    try,
    unit,
    unless,
    unlessM,
    unsafeFromJust,
    unsafeThrow,
    unwrap,
    void,
    when,
    whenM,
    zero
} from "../Spago.Core.Prelude/index.js";
//# sourceMappingURL=index.js.map
