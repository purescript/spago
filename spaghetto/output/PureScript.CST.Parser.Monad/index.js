// Generated by purs version 0.15.10
import * as Control_Alt from "../Control.Alt/index.js";
import * as Control_Applicative from "../Control.Applicative/index.js";
import * as Data_Array from "../Data.Array/index.js";
import * as Data_Either from "../Data.Either/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_Lazy from "../Data.Lazy/index.js";
import * as Data_List from "../Data.List/index.js";
import * as Data_List_Types from "../Data.List.Types/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Tuple from "../Data.Tuple/index.js";
import * as Data_Unfoldable from "../Data.Unfoldable/index.js";
import * as Data_Unit from "../Data.Unit/index.js";
import * as PureScript_CST_Errors from "../PureScript.CST.Errors/index.js";
import * as PureScript_CST_TokenStream from "../PureScript.CST.TokenStream/index.js";
var $runtime_lazy = function (name, moduleName, init) {
    var state = 0;
    var val;
    return function (lineNumber) {
        if (state === 2) return val;
        if (state === 1) throw new ReferenceError(name + " was needed before it finished initializing (module " + moduleName + ", line " + lineNumber + ")", moduleName, lineNumber);
        state = 1;
        val = init();
        state = 2;
        return val;
    };
};
var toUnfoldable = /* #__PURE__ */ Data_List.toUnfoldable(Data_Unfoldable.unfoldableArray);
var More = /* #__PURE__ */ (function () {
    function More(value0) {
        this.value0 = value0;
    };
    More.create = function (value0) {
        return new More(value0);
    };
    return More;
})();
var Done = /* #__PURE__ */ (function () {
    function Done(value0) {
        this.value0 = value0;
    };
    Done.create = function (value0) {
        return new Done(value0);
    };
    return Done;
})();
var ParseFail = /* #__PURE__ */ (function () {
    function ParseFail(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    ParseFail.create = function (value0) {
        return function (value1) {
            return new ParseFail(value0, value1);
        };
    };
    return ParseFail;
})();
var ParseSucc = /* #__PURE__ */ (function () {
    function ParseSucc(value0, value1) {
        this.value0 = value0;
        this.value1 = value1;
    };
    ParseSucc.create = function (value0) {
        return function (value1) {
            return new ParseSucc(value0, value1);
        };
    };
    return ParseSucc;
})();
var Parser = function (x) {
    return x;
};
var lazyParser = {
    defer: function (k) {
        var parser = Data_Lazy.defer(k);
        return function (state, more, resume, done) {
            var v = Data_Lazy.force(parser);
            return v(state, more, resume, done);
        };
    }
};
var functorParser = {
    map: function (f) {
        return function (v) {
            return function (state1, more, resume, done) {
                return v(state1, more, resume, function (state2, a) {
                    return done(state2, f(a));
                });
            };
        };
    }
};
var map = /* #__PURE__ */ Data_Functor.map(functorParser);
var applyParser = {
    apply: function (v) {
        return function (v1) {
            return function (state1, more, resume, done) {
                return v(state1, more, resume, function (state2, f) {
                    return more(function (v2) {
                        return v1(state2, more, resume, function (state3, a) {
                            return done(state3, f(a));
                        });
                    });
                });
            };
        };
    },
    Functor0: function () {
        return functorParser;
    }
};
var bindParser = {
    bind: function (v) {
        return function (k) {
            return function (state1, more, resume, done) {
                return v(state1, more, resume, function (state2, a) {
                    return more(function (v1) {
                        var v2 = k(a);
                        return v2(state2, more, resume, done);
                    });
                });
            };
        };
    },
    Apply0: function () {
        return applyParser;
    }
};
var applicativeParser = {
    pure: function (a) {
        return function (state1, v, v1, done) {
            return done(state1, a);
        };
    },
    Apply0: function () {
        return applyParser;
    }
};
var pure = /* #__PURE__ */ Control_Applicative.pure(applicativeParser);
var monadParser = {
    Applicative0: function () {
        return applicativeParser;
    },
    Bind1: function () {
        return bindParser;
    }
};
var altParser = {
    alt: function (v) {
        return function (v1) {
            return function (state1, more, resume, done) {
                var state2 = (function () {
                    if (state1.consumed) {
                        return {
                            consumed: false,
                            errors: state1.errors,
                            stream: state1.stream
                        };
                    };
                    return state1;
                })();
                return v(state2, more, function (state3, error) {
                    if (state3.consumed) {
                        return resume(state3, error);
                    };
                    return v1(state1, more, resume, done);
                }, done);
            };
        };
    },
    Functor0: function () {
        return functorParser;
    }
};
var alt = /* #__PURE__ */ Control_Alt.alt(altParser);
var $$try = function (v) {
    return function (state1, more, resume, done) {
        return v(state1, more, function (state2, error) {
            return resume({
                consumed: state1.consumed,
                errors: state2.errors,
                stream: state2.stream
            }, error);
        }, done);
    };
};
var take = function (k) {
    return function (state, v, resume, done) {
        var v1 = PureScript_CST_TokenStream.step(state.stream);
        if (v1 instanceof PureScript_CST_TokenStream.TokenError) {
            return resume(state, {
                error: v1.value1,
                position: v1.value0
            });
        };
        if (v1 instanceof PureScript_CST_TokenStream.TokenEOF) {
            return resume(state, {
                error: PureScript_CST_Errors.UnexpectedEof.value,
                position: v1.value0
            });
        };
        if (v1 instanceof PureScript_CST_TokenStream.TokenCons) {
            var v2 = k(v1.value0);
            if (v2 instanceof Data_Either.Left) {
                return resume(state, {
                    error: v2.value0,
                    position: v1.value0.range.start
                });
            };
            if (v2 instanceof Data_Either.Right) {
                return done({
                    consumed: true,
                    stream: v1.value2,
                    errors: state.errors
                }, v2.value0);
            };
            throw new Error("Failed pattern match at PureScript.CST.Parser.Monad (line 172, column 11 - line 182, column 18): " + [ v2.constructor.name ]);
        };
        throw new Error("Failed pattern match at PureScript.CST.Parser.Monad (line 166, column 7 - line 182, column 18): " + [ v1.constructor.name ]);
    };
};
var runParser$prime = function (state1) {
    return function (v) {
        var run = function ($copy_v1) {
            var $tco_done = false;
            var $tco_result;
            function $tco_loop(v1) {
                if (v1 instanceof More) {
                    $copy_v1 = v1.value0(Data_Unit.unit);
                    return;
                };
                if (v1 instanceof Done) {
                    $tco_done = true;
                    return v1.value0;
                };
                throw new Error("Failed pattern match at PureScript.CST.Parser.Monad (line 241, column 9 - line 243, column 16): " + [ v1.constructor.name ]);
            };
            while (!$tco_done) {
                $tco_result = $tco_loop($copy_v1);
            };
            return $tco_result;
        };
        return run(v(state1, More.create, function (state2, error) {
            return new Done(new ParseFail(error, state2));
        }, function (state2, value) {
            return new Done(new ParseSucc(value, state2));
        }));
    };
};
var recover = function (k) {
    return function (v) {
        return function (state1, more, resume, done) {
            return v({
                consumed: false,
                errors: state1.errors,
                stream: state1.stream
            }, more, function (state2, error) {
                var v1 = k(error)(state1.stream);
                if (v1 instanceof Data_Maybe.Nothing) {
                    return resume({
                        consumed: state1.consumed,
                        errors: state2.errors,
                        stream: state2.stream
                    }, error);
                };
                if (v1 instanceof Data_Maybe.Just) {
                    return done({
                        consumed: true,
                        errors: Data_Array.snoc(state2.errors)(error),
                        stream: v1.value0.value1
                    }, v1.value0.value0);
                };
                throw new Error("Failed pattern match at PureScript.CST.Parser.Monad (line 149, column 13 - line 158, column 20): " + [ v1.constructor.name ]);
            }, done);
        };
    };
};
var optional = function (p) {
    return alt(map(Data_Maybe.Just.create)(p))(pure(Data_Maybe.Nothing.value));
};
var many = function (v) {
    return function (state1, more, resume, done) {
        var $lazy_go = $runtime_lazy("go", "PureScript.CST.Parser.Monad", function () {
            return function (acc, state2) {
                var state2$prime = (function () {
                    if (state2.consumed) {
                        return {
                            consumed: false,
                            errors: state2.errors,
                            stream: state2.stream
                        };
                    };
                    return state2;
                })();
                return v(state2$prime, more, function (state3, error) {
                    if (state3.consumed) {
                        return resume(state3, error);
                    };
                    return done(state2, Data_Array.reverse(toUnfoldable(acc)));
                }, function (state3, value) {
                    return $lazy_go(225)(new Data_List_Types.Cons(value, acc), state3);
                });
            };
        });
        var go = $lazy_go(212);
        return go(Data_List_Types.Nil.value, state1);
    };
};
var lookAhead = function (v) {
    return function (state1, more, resume, done) {
        return v(state1, more, function (v1, error) {
            return resume(state1, error);
        }, function (v1, value) {
            return done(state1, value);
        });
    };
};
var initialParserState = function (stream) {
    return {
        consumed: false,
        errors: [  ],
        stream: stream
    };
};
var fromParserResult = function (v) {
    if (v instanceof ParseFail) {
        return new Data_Either.Left(v.value0);
    };
    if (v instanceof ParseSucc) {
        return new Data_Either.Right(new Data_Tuple.Tuple(v.value0, v.value1.errors));
    };
    throw new Error("Failed pattern match at PureScript.CST.Parser.Monad (line 253, column 20 - line 257, column 29): " + [ v.constructor.name ]);
};
var runParser = function (stream) {
    var $109 = runParser$prime(initialParserState(stream));
    return function ($110) {
        return fromParserResult($109($110));
    };
};
var fail = function (error) {
    return function (state, v, resume, v1) {
        return resume(state, error);
    };
};
var eof = function (state, v, resume, done) {
    var v1 = PureScript_CST_TokenStream.step(state.stream);
    if (v1 instanceof PureScript_CST_TokenStream.TokenError) {
        return resume(state, {
            error: v1.value1,
            position: v1.value0
        });
    };
    if (v1 instanceof PureScript_CST_TokenStream.TokenEOF) {
        return done({
            consumed: true,
            stream: state.stream,
            errors: state.errors
        }, new Data_Tuple.Tuple(v1.value0, v1.value1));
    };
    if (v1 instanceof PureScript_CST_TokenStream.TokenCons) {
        return resume(state, {
            error: new PureScript_CST_Errors.ExpectedEof(v1.value0.value),
            position: v1.value0.range.start
        });
    };
    throw new Error("Failed pattern match at PureScript.CST.Parser.Monad (line 188, column 7 - line 197, column 14): " + [ v1.constructor.name ]);
};
export {
    ParseFail,
    ParseSucc,
    initialParserState,
    fromParserResult,
    runParser,
    runParser$prime,
    take,
    fail,
    $$try as try,
    lookAhead,
    many,
    optional,
    eof,
    recover,
    functorParser,
    applyParser,
    applicativeParser,
    bindParser,
    monadParser,
    altParser,
    lazyParser
};
//# sourceMappingURL=index.js.map
