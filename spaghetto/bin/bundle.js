#!/usr/bin/env node
import __module from 'module';import __path from 'path';import __url from 'url';const require = __module.createRequire(import.meta.url);const __dirname = __path.dirname(__url.fileURLToPath(import.meta.url));
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod6) => function __require2() {
  return mod6 || (0, cb[__getOwnPropNames(cb)[0]])((mod6 = { exports: {} }).exports, mod6), mod6.exports;
};
var __copyProps = (to2, from3, except2, desc) => {
  if (from3 && typeof from3 === "object" || typeof from3 === "function") {
    for (let key of __getOwnPropNames(from3))
      if (!__hasOwnProp.call(to2, key) && key !== except2)
        __defProp(to2, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc(from3, key)) || desc.enumerable });
  }
  return to2;
};
var __toESM = (mod6, isNodeMode, target) => (target = mod6 != null ? __create(__getProtoOf(mod6)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod6 || !mod6.__esModule ? __defProp(target, "default", { value: mod6, enumerable: true }) : target,
  mod6
));

// node_modules/spdx-license-ids/index.json
var require_spdx_license_ids = __commonJS({
  "node_modules/spdx-license-ids/index.json"(exports, module) {
    module.exports = [
      "0BSD",
      "AAL",
      "ADSL",
      "AFL-1.1",
      "AFL-1.2",
      "AFL-2.0",
      "AFL-2.1",
      "AFL-3.0",
      "AGPL-1.0-only",
      "AGPL-1.0-or-later",
      "AGPL-3.0-only",
      "AGPL-3.0-or-later",
      "AMDPLPA",
      "AML",
      "AMPAS",
      "ANTLR-PD",
      "ANTLR-PD-fallback",
      "APAFML",
      "APL-1.0",
      "APSL-1.0",
      "APSL-1.1",
      "APSL-1.2",
      "APSL-2.0",
      "Abstyles",
      "AdaCore-doc",
      "Adobe-2006",
      "Adobe-Glyph",
      "Afmparse",
      "Aladdin",
      "Apache-1.0",
      "Apache-1.1",
      "Apache-2.0",
      "App-s2p",
      "Arphic-1999",
      "Artistic-1.0",
      "Artistic-1.0-Perl",
      "Artistic-1.0-cl8",
      "Artistic-2.0",
      "BSD-1-Clause",
      "BSD-2-Clause",
      "BSD-2-Clause-Patent",
      "BSD-2-Clause-Views",
      "BSD-3-Clause",
      "BSD-3-Clause-Attribution",
      "BSD-3-Clause-Clear",
      "BSD-3-Clause-LBNL",
      "BSD-3-Clause-Modification",
      "BSD-3-Clause-No-Military-License",
      "BSD-3-Clause-No-Nuclear-License",
      "BSD-3-Clause-No-Nuclear-License-2014",
      "BSD-3-Clause-No-Nuclear-Warranty",
      "BSD-3-Clause-Open-MPI",
      "BSD-4-Clause",
      "BSD-4-Clause-Shortened",
      "BSD-4-Clause-UC",
      "BSD-4.3RENO",
      "BSD-4.3TAHOE",
      "BSD-Advertising-Acknowledgement",
      "BSD-Attribution-HPND-disclaimer",
      "BSD-Protection",
      "BSD-Source-Code",
      "BSL-1.0",
      "BUSL-1.1",
      "Baekmuk",
      "Bahyph",
      "Barr",
      "Beerware",
      "BitTorrent-1.0",
      "BitTorrent-1.1",
      "Bitstream-Charter",
      "Bitstream-Vera",
      "BlueOak-1.0.0",
      "Borceux",
      "Brian-Gladman-3-Clause",
      "C-UDA-1.0",
      "CAL-1.0",
      "CAL-1.0-Combined-Work-Exception",
      "CATOSL-1.1",
      "CC-BY-1.0",
      "CC-BY-2.0",
      "CC-BY-2.5",
      "CC-BY-2.5-AU",
      "CC-BY-3.0",
      "CC-BY-3.0-AT",
      "CC-BY-3.0-DE",
      "CC-BY-3.0-IGO",
      "CC-BY-3.0-NL",
      "CC-BY-3.0-US",
      "CC-BY-4.0",
      "CC-BY-NC-1.0",
      "CC-BY-NC-2.0",
      "CC-BY-NC-2.5",
      "CC-BY-NC-3.0",
      "CC-BY-NC-3.0-DE",
      "CC-BY-NC-4.0",
      "CC-BY-NC-ND-1.0",
      "CC-BY-NC-ND-2.0",
      "CC-BY-NC-ND-2.5",
      "CC-BY-NC-ND-3.0",
      "CC-BY-NC-ND-3.0-DE",
      "CC-BY-NC-ND-3.0-IGO",
      "CC-BY-NC-ND-4.0",
      "CC-BY-NC-SA-1.0",
      "CC-BY-NC-SA-2.0",
      "CC-BY-NC-SA-2.0-DE",
      "CC-BY-NC-SA-2.0-FR",
      "CC-BY-NC-SA-2.0-UK",
      "CC-BY-NC-SA-2.5",
      "CC-BY-NC-SA-3.0",
      "CC-BY-NC-SA-3.0-DE",
      "CC-BY-NC-SA-3.0-IGO",
      "CC-BY-NC-SA-4.0",
      "CC-BY-ND-1.0",
      "CC-BY-ND-2.0",
      "CC-BY-ND-2.5",
      "CC-BY-ND-3.0",
      "CC-BY-ND-3.0-DE",
      "CC-BY-ND-4.0",
      "CC-BY-SA-1.0",
      "CC-BY-SA-2.0",
      "CC-BY-SA-2.0-UK",
      "CC-BY-SA-2.1-JP",
      "CC-BY-SA-2.5",
      "CC-BY-SA-3.0",
      "CC-BY-SA-3.0-AT",
      "CC-BY-SA-3.0-DE",
      "CC-BY-SA-4.0",
      "CC-PDDC",
      "CC0-1.0",
      "CDDL-1.0",
      "CDDL-1.1",
      "CDL-1.0",
      "CDLA-Permissive-1.0",
      "CDLA-Permissive-2.0",
      "CDLA-Sharing-1.0",
      "CECILL-1.0",
      "CECILL-1.1",
      "CECILL-2.0",
      "CECILL-2.1",
      "CECILL-B",
      "CECILL-C",
      "CERN-OHL-1.1",
      "CERN-OHL-1.2",
      "CERN-OHL-P-2.0",
      "CERN-OHL-S-2.0",
      "CERN-OHL-W-2.0",
      "CFITSIO",
      "CMU-Mach",
      "CNRI-Jython",
      "CNRI-Python",
      "CNRI-Python-GPL-Compatible",
      "COIL-1.0",
      "CPAL-1.0",
      "CPL-1.0",
      "CPOL-1.02",
      "CUA-OPL-1.0",
      "Caldera",
      "ClArtistic",
      "Clips",
      "Community-Spec-1.0",
      "Condor-1.1",
      "Cornell-Lossless-JPEG",
      "Crossword",
      "CrystalStacker",
      "Cube",
      "D-FSL-1.0",
      "DL-DE-BY-2.0",
      "DOC",
      "DRL-1.0",
      "DSDP",
      "Dotseqn",
      "ECL-1.0",
      "ECL-2.0",
      "EFL-1.0",
      "EFL-2.0",
      "EPICS",
      "EPL-1.0",
      "EPL-2.0",
      "EUDatagrid",
      "EUPL-1.0",
      "EUPL-1.1",
      "EUPL-1.2",
      "Elastic-2.0",
      "Entessa",
      "ErlPL-1.1",
      "Eurosym",
      "FDK-AAC",
      "FSFAP",
      "FSFUL",
      "FSFULLR",
      "FSFULLRWD",
      "FTL",
      "Fair",
      "Frameworx-1.0",
      "FreeBSD-DOC",
      "FreeImage",
      "GD",
      "GFDL-1.1-invariants-only",
      "GFDL-1.1-invariants-or-later",
      "GFDL-1.1-no-invariants-only",
      "GFDL-1.1-no-invariants-or-later",
      "GFDL-1.1-only",
      "GFDL-1.1-or-later",
      "GFDL-1.2-invariants-only",
      "GFDL-1.2-invariants-or-later",
      "GFDL-1.2-no-invariants-only",
      "GFDL-1.2-no-invariants-or-later",
      "GFDL-1.2-only",
      "GFDL-1.2-or-later",
      "GFDL-1.3-invariants-only",
      "GFDL-1.3-invariants-or-later",
      "GFDL-1.3-no-invariants-only",
      "GFDL-1.3-no-invariants-or-later",
      "GFDL-1.3-only",
      "GFDL-1.3-or-later",
      "GL2PS",
      "GLWTPL",
      "GPL-1.0-only",
      "GPL-1.0-or-later",
      "GPL-2.0-only",
      "GPL-2.0-or-later",
      "GPL-3.0-only",
      "GPL-3.0-or-later",
      "Giftware",
      "Glide",
      "Glulxe",
      "Graphics-Gems",
      "HP-1986",
      "HPND",
      "HPND-Markus-Kuhn",
      "HPND-export-US",
      "HPND-sell-variant",
      "HPND-sell-variant-MIT-disclaimer",
      "HTMLTIDY",
      "HaskellReport",
      "Hippocratic-2.1",
      "IBM-pibs",
      "ICU",
      "IEC-Code-Components-EULA",
      "IJG",
      "IJG-short",
      "IPA",
      "IPL-1.0",
      "ISC",
      "ImageMagick",
      "Imlib2",
      "Info-ZIP",
      "Intel",
      "Intel-ACPI",
      "Interbase-1.0",
      "JPL-image",
      "JPNIC",
      "JSON",
      "Jam",
      "JasPer-2.0",
      "Kazlib",
      "Knuth-CTAN",
      "LAL-1.2",
      "LAL-1.3",
      "LGPL-2.0-only",
      "LGPL-2.0-or-later",
      "LGPL-2.1-only",
      "LGPL-2.1-or-later",
      "LGPL-3.0-only",
      "LGPL-3.0-or-later",
      "LGPLLR",
      "LOOP",
      "LPL-1.0",
      "LPL-1.02",
      "LPPL-1.0",
      "LPPL-1.1",
      "LPPL-1.2",
      "LPPL-1.3a",
      "LPPL-1.3c",
      "LZMA-SDK-9.11-to-9.20",
      "LZMA-SDK-9.22",
      "Latex2e",
      "Leptonica",
      "LiLiQ-P-1.1",
      "LiLiQ-R-1.1",
      "LiLiQ-Rplus-1.1",
      "Libpng",
      "Linux-OpenIB",
      "Linux-man-pages-copyleft",
      "MIT",
      "MIT-0",
      "MIT-CMU",
      "MIT-Modern-Variant",
      "MIT-Wu",
      "MIT-advertising",
      "MIT-enna",
      "MIT-feh",
      "MIT-open-group",
      "MITNFA",
      "MPL-1.0",
      "MPL-1.1",
      "MPL-2.0",
      "MPL-2.0-no-copyleft-exception",
      "MS-LPL",
      "MS-PL",
      "MS-RL",
      "MTLL",
      "MakeIndex",
      "Martin-Birgmeier",
      "Minpack",
      "MirOS",
      "Motosoto",
      "MulanPSL-1.0",
      "MulanPSL-2.0",
      "Multics",
      "Mup",
      "NAIST-2003",
      "NASA-1.3",
      "NBPL-1.0",
      "NCGL-UK-2.0",
      "NCSA",
      "NGPL",
      "NICTA-1.0",
      "NIST-PD",
      "NIST-PD-fallback",
      "NLOD-1.0",
      "NLOD-2.0",
      "NLPL",
      "NOSL",
      "NPL-1.0",
      "NPL-1.1",
      "NPOSL-3.0",
      "NRL",
      "NTP",
      "NTP-0",
      "Naumen",
      "Net-SNMP",
      "NetCDF",
      "Newsletr",
      "Nokia",
      "Noweb",
      "O-UDA-1.0",
      "OCCT-PL",
      "OCLC-2.0",
      "ODC-By-1.0",
      "ODbL-1.0",
      "OFFIS",
      "OFL-1.0",
      "OFL-1.0-RFN",
      "OFL-1.0-no-RFN",
      "OFL-1.1",
      "OFL-1.1-RFN",
      "OFL-1.1-no-RFN",
      "OGC-1.0",
      "OGDL-Taiwan-1.0",
      "OGL-Canada-2.0",
      "OGL-UK-1.0",
      "OGL-UK-2.0",
      "OGL-UK-3.0",
      "OGTSL",
      "OLDAP-1.1",
      "OLDAP-1.2",
      "OLDAP-1.3",
      "OLDAP-1.4",
      "OLDAP-2.0",
      "OLDAP-2.0.1",
      "OLDAP-2.1",
      "OLDAP-2.2",
      "OLDAP-2.2.1",
      "OLDAP-2.2.2",
      "OLDAP-2.3",
      "OLDAP-2.4",
      "OLDAP-2.5",
      "OLDAP-2.6",
      "OLDAP-2.7",
      "OLDAP-2.8",
      "OML",
      "OPL-1.0",
      "OPUBL-1.0",
      "OSET-PL-2.1",
      "OSL-1.0",
      "OSL-1.1",
      "OSL-2.0",
      "OSL-2.1",
      "OSL-3.0",
      "OpenPBS-2.3",
      "OpenSSL",
      "PDDL-1.0",
      "PHP-3.0",
      "PHP-3.01",
      "PSF-2.0",
      "Parity-6.0.0",
      "Parity-7.0.0",
      "Plexus",
      "PolyForm-Noncommercial-1.0.0",
      "PolyForm-Small-Business-1.0.0",
      "PostgreSQL",
      "Python-2.0",
      "Python-2.0.1",
      "QPL-1.0",
      "QPL-1.0-INRIA-2004",
      "Qhull",
      "RHeCos-1.1",
      "RPL-1.1",
      "RPL-1.5",
      "RPSL-1.0",
      "RSA-MD",
      "RSCPL",
      "Rdisc",
      "Ruby",
      "SAX-PD",
      "SCEA",
      "SGI-B-1.0",
      "SGI-B-1.1",
      "SGI-B-2.0",
      "SHL-0.5",
      "SHL-0.51",
      "SISSL",
      "SISSL-1.2",
      "SMLNJ",
      "SMPPL",
      "SNIA",
      "SPL-1.0",
      "SSH-OpenSSH",
      "SSH-short",
      "SSPL-1.0",
      "SWL",
      "Saxpath",
      "SchemeReport",
      "Sendmail",
      "Sendmail-8.23",
      "SimPL-2.0",
      "Sleepycat",
      "Spencer-86",
      "Spencer-94",
      "Spencer-99",
      "SugarCRM-1.1.3",
      "SunPro",
      "Symlinks",
      "TAPR-OHL-1.0",
      "TCL",
      "TCP-wrappers",
      "TMate",
      "TORQUE-1.1",
      "TOSL",
      "TPDL",
      "TPL-1.0",
      "TTWL",
      "TU-Berlin-1.0",
      "TU-Berlin-2.0",
      "UCAR",
      "UCL-1.0",
      "UPL-1.0",
      "Unicode-DFS-2015",
      "Unicode-DFS-2016",
      "Unicode-TOU",
      "Unlicense",
      "VOSTROM",
      "VSL-1.0",
      "Vim",
      "W3C",
      "W3C-19980720",
      "W3C-20150513",
      "WTFPL",
      "Watcom-1.0",
      "Wsuipa",
      "X11",
      "X11-distribute-modifications-variant",
      "XFree86-1.1",
      "XSkat",
      "Xerox",
      "Xnet",
      "YPL-1.0",
      "YPL-1.1",
      "ZPL-1.1",
      "ZPL-2.0",
      "ZPL-2.1",
      "Zed",
      "Zend-2.0",
      "Zimbra-1.3",
      "Zimbra-1.4",
      "Zlib",
      "blessing",
      "bzip2-1.0.6",
      "checkmk",
      "copyleft-next-0.3.0",
      "copyleft-next-0.3.1",
      "curl",
      "diffmark",
      "dvipdfm",
      "eGenix",
      "etalab-2.0",
      "gSOAP-1.3b",
      "gnuplot",
      "iMatix",
      "libpng-2.0",
      "libselinux-1.0",
      "libtiff",
      "libutil-David-Nugent",
      "mpi-permissive",
      "mpich2",
      "mplus",
      "psfrag",
      "psutils",
      "snprintf",
      "w3m",
      "xinetd",
      "xlock",
      "xpp",
      "zlib-acknowledgement"
    ];
  }
});

// node_modules/spdx-license-ids/deprecated.json
var require_deprecated = __commonJS({
  "node_modules/spdx-license-ids/deprecated.json"(exports, module) {
    module.exports = [
      "AGPL-1.0",
      "AGPL-3.0",
      "BSD-2-Clause-FreeBSD",
      "BSD-2-Clause-NetBSD",
      "GFDL-1.1",
      "GFDL-1.2",
      "GFDL-1.3",
      "GPL-1.0",
      "GPL-2.0",
      "GPL-2.0-with-GCC-exception",
      "GPL-2.0-with-autoconf-exception",
      "GPL-2.0-with-bison-exception",
      "GPL-2.0-with-classpath-exception",
      "GPL-2.0-with-font-exception",
      "GPL-3.0",
      "GPL-3.0-with-GCC-exception",
      "GPL-3.0-with-autoconf-exception",
      "LGPL-2.0",
      "LGPL-2.1",
      "LGPL-3.0",
      "Nunit",
      "StandardML-NJ",
      "bzip2-1.0.5",
      "eCos-2.0",
      "wxWindows"
    ];
  }
});

// node_modules/spdx-exceptions/index.json
var require_spdx_exceptions = __commonJS({
  "node_modules/spdx-exceptions/index.json"(exports, module) {
    module.exports = [
      "389-exception",
      "Autoconf-exception-2.0",
      "Autoconf-exception-3.0",
      "Bison-exception-2.2",
      "Bootloader-exception",
      "Classpath-exception-2.0",
      "CLISP-exception-2.0",
      "DigiRule-FOSS-exception",
      "eCos-exception-2.0",
      "Fawkes-Runtime-exception",
      "FLTK-exception",
      "Font-exception-2.0",
      "freertos-exception-2.0",
      "GCC-exception-2.0",
      "GCC-exception-3.1",
      "gnu-javamail-exception",
      "GPL-3.0-linking-exception",
      "GPL-3.0-linking-source-exception",
      "GPL-CC-1.0",
      "i2p-gpl-java-exception",
      "Libtool-exception",
      "Linux-syscall-note",
      "LLVM-exception",
      "LZMA-exception",
      "mif-exception",
      "Nokia-Qt-exception-1.1",
      "OCaml-LGPL-linking-exception",
      "OCCT-exception-1.0",
      "OpenJDK-assembly-exception-1.0",
      "openvpn-openssl-exception",
      "PS-or-PDF-font-exception-20170817",
      "Qt-GPL-exception-1.0",
      "Qt-LGPL-exception-1.1",
      "Qwt-exception-1.0",
      "Swift-exception",
      "u-boot-exception-2.0",
      "Universal-FOSS-exception-1.0",
      "WxWindows-exception-3.1"
    ];
  }
});

// node_modules/spdx-expression-parse/scan.js
var require_scan = __commonJS({
  "node_modules/spdx-expression-parse/scan.js"(exports, module) {
    "use strict";
    var licenses = [].concat(require_spdx_license_ids()).concat(require_deprecated());
    var exceptions = require_spdx_exceptions();
    module.exports = function(source2) {
      var index4 = 0;
      function hasMore() {
        return index4 < source2.length;
      }
      function read7(value4) {
        if (value4 instanceof RegExp) {
          var chars2 = source2.slice(index4);
          var match4 = chars2.match(value4);
          if (match4) {
            index4 += match4[0].length;
            return match4[0];
          }
        } else {
          if (source2.indexOf(value4, index4) === index4) {
            index4 += value4.length;
            return value4;
          }
        }
      }
      function skipWhitespace() {
        read7(/[ ]*/);
      }
      function operator() {
        var string7;
        var possibilities = ["WITH", "AND", "OR", "(", ")", ":", "+"];
        for (var i = 0; i < possibilities.length; i++) {
          string7 = read7(possibilities[i]);
          if (string7) {
            break;
          }
        }
        if (string7 === "+" && index4 > 1 && source2[index4 - 2] === " ") {
          throw new Error("Space before `+`");
        }
        return string7 && {
          type: "OPERATOR",
          string: string7
        };
      }
      function idstring() {
        return read7(/[A-Za-z0-9-.]+/);
      }
      function expectIdstring() {
        var string7 = idstring();
        if (!string7) {
          throw new Error("Expected idstring at offset " + index4);
        }
        return string7;
      }
      function documentRef() {
        if (read7("DocumentRef-")) {
          var string7 = expectIdstring();
          return { type: "DOCUMENTREF", string: string7 };
        }
      }
      function licenseRef() {
        if (read7("LicenseRef-")) {
          var string7 = expectIdstring();
          return { type: "LICENSEREF", string: string7 };
        }
      }
      function identifier() {
        var begin = index4;
        var string7 = idstring();
        if (licenses.indexOf(string7) !== -1) {
          return {
            type: "LICENSE",
            string: string7
          };
        } else if (exceptions.indexOf(string7) !== -1) {
          return {
            type: "EXCEPTION",
            string: string7
          };
        }
        index4 = begin;
      }
      function parseToken() {
        return operator() || documentRef() || licenseRef() || identifier();
      }
      var tokens = [];
      while (hasMore()) {
        skipWhitespace();
        if (!hasMore()) {
          break;
        }
        var token2 = parseToken();
        if (!token2) {
          throw new Error("Unexpected `" + source2[index4] + "` at offset " + index4);
        }
        tokens.push(token2);
      }
      return tokens;
    };
  }
});

// node_modules/spdx-expression-parse/parse.js
var require_parse = __commonJS({
  "node_modules/spdx-expression-parse/parse.js"(exports, module) {
    "use strict";
    module.exports = function(tokens) {
      var index4 = 0;
      function hasMore() {
        return index4 < tokens.length;
      }
      function token2() {
        return hasMore() ? tokens[index4] : null;
      }
      function next2() {
        if (!hasMore()) {
          throw new Error();
        }
        index4++;
      }
      function parseOperator2(operator) {
        var t = token2();
        if (t && t.type === "OPERATOR" && operator === t.string) {
          next2();
          return t.string;
        }
      }
      function parseWith() {
        if (parseOperator2("WITH")) {
          var t = token2();
          if (t && t.type === "EXCEPTION") {
            next2();
            return t.string;
          }
          throw new Error("Expected exception after `WITH`");
        }
      }
      function parseLicenseRef() {
        var begin = index4;
        var string7 = "";
        var t = token2();
        if (t.type === "DOCUMENTREF") {
          next2();
          string7 += "DocumentRef-" + t.string + ":";
          if (!parseOperator2(":")) {
            throw new Error("Expected `:` after `DocumentRef-...`");
          }
        }
        t = token2();
        if (t.type === "LICENSEREF") {
          next2();
          string7 += "LicenseRef-" + t.string;
          return { license: string7 };
        }
        index4 = begin;
      }
      function parseLicense() {
        var t = token2();
        if (t && t.type === "LICENSE") {
          next2();
          var node2 = { license: t.string };
          if (parseOperator2("+")) {
            node2.plus = true;
          }
          var exception = parseWith();
          if (exception) {
            node2.exception = exception;
          }
          return node2;
        }
      }
      function parseParenthesizedExpression() {
        var left2 = parseOperator2("(");
        if (!left2) {
          return;
        }
        var expr = parseExpression();
        if (!parseOperator2(")")) {
          throw new Error("Expected `)`");
        }
        return expr;
      }
      function parseAtom() {
        return parseParenthesizedExpression() || parseLicenseRef() || parseLicense();
      }
      function makeBinaryOpParser(operator, nextParser) {
        return function parseBinaryOp() {
          var left2 = nextParser();
          if (!left2) {
            return;
          }
          if (!parseOperator2(operator)) {
            return left2;
          }
          var right2 = parseBinaryOp();
          if (!right2) {
            throw new Error("Expected expression");
          }
          return {
            left: left2,
            conjunction: operator.toLowerCase(),
            right: right2
          };
        };
      }
      var parseAnd = makeBinaryOpParser("AND", parseAtom);
      var parseExpression = makeBinaryOpParser("OR", parseAnd);
      var node = parseExpression();
      if (!node || hasMore()) {
        throw new Error("Syntax error");
      }
      return node;
    };
  }
});

// node_modules/spdx-expression-parse/index.js
var require_spdx_expression_parse = __commonJS({
  "node_modules/spdx-expression-parse/index.js"(exports, module) {
    "use strict";
    var scan = require_scan();
    var parse10 = require_parse();
    module.exports = function(source2) {
      return parse10(scan(source2));
    };
  }
});

// node_modules/yaml/dist/nodes/identity.js
var require_identity = __commonJS({
  "node_modules/yaml/dist/nodes/identity.js"(exports) {
    "use strict";
    var ALIAS = Symbol.for("yaml.alias");
    var DOC = Symbol.for("yaml.document");
    var MAP = Symbol.for("yaml.map");
    var PAIR = Symbol.for("yaml.pair");
    var SCALAR = Symbol.for("yaml.scalar");
    var SEQ = Symbol.for("yaml.seq");
    var NODE_TYPE = Symbol.for("yaml.node.type");
    var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
    var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
    var isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
    var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
    var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
    var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
    function isCollection(node) {
      if (node && typeof node === "object")
        switch (node[NODE_TYPE]) {
          case MAP:
          case SEQ:
            return true;
        }
      return false;
    }
    function isNode(node) {
      if (node && typeof node === "object")
        switch (node[NODE_TYPE]) {
          case ALIAS:
          case MAP:
          case SCALAR:
          case SEQ:
            return true;
        }
      return false;
    }
    var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
    exports.ALIAS = ALIAS;
    exports.DOC = DOC;
    exports.MAP = MAP;
    exports.NODE_TYPE = NODE_TYPE;
    exports.PAIR = PAIR;
    exports.SCALAR = SCALAR;
    exports.SEQ = SEQ;
    exports.hasAnchor = hasAnchor;
    exports.isAlias = isAlias;
    exports.isCollection = isCollection;
    exports.isDocument = isDocument;
    exports.isMap = isMap;
    exports.isNode = isNode;
    exports.isPair = isPair;
    exports.isScalar = isScalar;
    exports.isSeq = isSeq;
  }
});

// node_modules/yaml/dist/visit.js
var require_visit = __commonJS({
  "node_modules/yaml/dist/visit.js"(exports) {
    "use strict";
    var identity33 = require_identity();
    var BREAK = Symbol("break visit");
    var SKIP = Symbol("skip children");
    var REMOVE = Symbol("remove node");
    function visit(node, visitor) {
      const visitor_ = initVisitor(visitor);
      if (identity33.isDocument(node)) {
        const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE)
          node.contents = null;
      } else
        visit_(null, node, visitor_, Object.freeze([]));
    }
    visit.BREAK = BREAK;
    visit.SKIP = SKIP;
    visit.REMOVE = REMOVE;
    function visit_(key, node, visitor, path5) {
      const ctrl = callVisitor(key, node, visitor, path5);
      if (identity33.isNode(ctrl) || identity33.isPair(ctrl)) {
        replaceNode(key, path5, ctrl);
        return visit_(key, ctrl, visitor, path5);
      }
      if (typeof ctrl !== "symbol") {
        if (identity33.isCollection(node)) {
          path5 = Object.freeze(path5.concat(node));
          for (let i = 0; i < node.items.length; ++i) {
            const ci = visit_(i, node.items[i], visitor, path5);
            if (typeof ci === "number")
              i = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              node.items.splice(i, 1);
              i -= 1;
            }
          }
        } else if (identity33.isPair(node)) {
          path5 = Object.freeze(path5.concat(node));
          const ck = visit_("key", node.key, visitor, path5);
          if (ck === BREAK)
            return BREAK;
          else if (ck === REMOVE)
            node.key = null;
          const cv = visit_("value", node.value, visitor, path5);
          if (cv === BREAK)
            return BREAK;
          else if (cv === REMOVE)
            node.value = null;
        }
      }
      return ctrl;
    }
    async function visitAsync(node, visitor) {
      const visitor_ = initVisitor(visitor);
      if (identity33.isDocument(node)) {
        const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE)
          node.contents = null;
      } else
        await visitAsync_(null, node, visitor_, Object.freeze([]));
    }
    visitAsync.BREAK = BREAK;
    visitAsync.SKIP = SKIP;
    visitAsync.REMOVE = REMOVE;
    async function visitAsync_(key, node, visitor, path5) {
      const ctrl = await callVisitor(key, node, visitor, path5);
      if (identity33.isNode(ctrl) || identity33.isPair(ctrl)) {
        replaceNode(key, path5, ctrl);
        return visitAsync_(key, ctrl, visitor, path5);
      }
      if (typeof ctrl !== "symbol") {
        if (identity33.isCollection(node)) {
          path5 = Object.freeze(path5.concat(node));
          for (let i = 0; i < node.items.length; ++i) {
            const ci = await visitAsync_(i, node.items[i], visitor, path5);
            if (typeof ci === "number")
              i = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              node.items.splice(i, 1);
              i -= 1;
            }
          }
        } else if (identity33.isPair(node)) {
          path5 = Object.freeze(path5.concat(node));
          const ck = await visitAsync_("key", node.key, visitor, path5);
          if (ck === BREAK)
            return BREAK;
          else if (ck === REMOVE)
            node.key = null;
          const cv = await visitAsync_("value", node.value, visitor, path5);
          if (cv === BREAK)
            return BREAK;
          else if (cv === REMOVE)
            node.value = null;
        }
      }
      return ctrl;
    }
    function initVisitor(visitor) {
      if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
        return Object.assign({
          Alias: visitor.Node,
          Map: visitor.Node,
          Scalar: visitor.Node,
          Seq: visitor.Node
        }, visitor.Value && {
          Map: visitor.Value,
          Scalar: visitor.Value,
          Seq: visitor.Value
        }, visitor.Collection && {
          Map: visitor.Collection,
          Seq: visitor.Collection
        }, visitor);
      }
      return visitor;
    }
    function callVisitor(key, node, visitor, path5) {
      if (typeof visitor === "function")
        return visitor(key, node, path5);
      if (identity33.isMap(node))
        return visitor.Map?.(key, node, path5);
      if (identity33.isSeq(node))
        return visitor.Seq?.(key, node, path5);
      if (identity33.isPair(node))
        return visitor.Pair?.(key, node, path5);
      if (identity33.isScalar(node))
        return visitor.Scalar?.(key, node, path5);
      if (identity33.isAlias(node))
        return visitor.Alias?.(key, node, path5);
      return void 0;
    }
    function replaceNode(key, path5, node) {
      const parent = path5[path5.length - 1];
      if (identity33.isCollection(parent)) {
        parent.items[key] = node;
      } else if (identity33.isPair(parent)) {
        if (key === "key")
          parent.key = node;
        else
          parent.value = node;
      } else if (identity33.isDocument(parent)) {
        parent.contents = node;
      } else {
        const pt = identity33.isAlias(parent) ? "alias" : "scalar";
        throw new Error(`Cannot replace node with ${pt} parent`);
      }
    }
    exports.visit = visit;
    exports.visitAsync = visitAsync;
  }
});

// node_modules/yaml/dist/doc/directives.js
var require_directives = __commonJS({
  "node_modules/yaml/dist/doc/directives.js"(exports) {
    "use strict";
    var identity33 = require_identity();
    var visit = require_visit();
    var escapeChars = {
      "!": "%21",
      ",": "%2C",
      "[": "%5B",
      "]": "%5D",
      "{": "%7B",
      "}": "%7D"
    };
    var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
    var Directives = class _Directives {
      constructor(yaml, tags) {
        this.docStart = null;
        this.docEnd = false;
        this.yaml = Object.assign({}, _Directives.defaultYaml, yaml);
        this.tags = Object.assign({}, _Directives.defaultTags, tags);
      }
      clone() {
        const copy3 = new _Directives(this.yaml, this.tags);
        copy3.docStart = this.docStart;
        return copy3;
      }
      /**
       * During parsing, get a Directives instance for the current document and
       * update the stream state according to the current version's spec.
       */
      atDocument() {
        const res = new _Directives(this.yaml, this.tags);
        switch (this.yaml.version) {
          case "1.1":
            this.atNextDocument = true;
            break;
          case "1.2":
            this.atNextDocument = false;
            this.yaml = {
              explicit: _Directives.defaultYaml.explicit,
              version: "1.2"
            };
            this.tags = Object.assign({}, _Directives.defaultTags);
            break;
        }
        return res;
      }
      /**
       * @param onError - May be called even if the action was successful
       * @returns `true` on success
       */
      add(line2, onError3) {
        if (this.atNextDocument) {
          this.yaml = { explicit: _Directives.defaultYaml.explicit, version: "1.1" };
          this.tags = Object.assign({}, _Directives.defaultTags);
          this.atNextDocument = false;
        }
        const parts = line2.trim().split(/[ \t]+/);
        const name4 = parts.shift();
        switch (name4) {
          case "%TAG": {
            if (parts.length !== 2) {
              onError3(0, "%TAG directive should contain exactly two parts");
              if (parts.length < 2)
                return false;
            }
            const [handle, prefix4] = parts;
            this.tags[handle] = prefix4;
            return true;
          }
          case "%YAML": {
            this.yaml.explicit = true;
            if (parts.length !== 1) {
              onError3(0, "%YAML directive should contain exactly one part");
              return false;
            }
            const [version] = parts;
            if (version === "1.1" || version === "1.2") {
              this.yaml.version = version;
              return true;
            } else {
              const isValid2 = /^\d+\.\d+$/.test(version);
              onError3(6, `Unsupported YAML version ${version}`, isValid2);
              return false;
            }
          }
          default:
            onError3(0, `Unknown directive ${name4}`, true);
            return false;
        }
      }
      /**
       * Resolves a tag, matching handles to those defined in %TAG directives.
       *
       * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
       *   `'!local'` tag, or `null` if unresolvable.
       */
      tagName(source2, onError3) {
        if (source2 === "!")
          return "!";
        if (source2[0] !== "!") {
          onError3(`Not a valid tag: ${source2}`);
          return null;
        }
        if (source2[1] === "<") {
          const verbatim = source2.slice(2, -1);
          if (verbatim === "!" || verbatim === "!!") {
            onError3(`Verbatim tags aren't resolved, so ${source2} is invalid.`);
            return null;
          }
          if (source2[source2.length - 1] !== ">")
            onError3("Verbatim tags must end with a >");
          return verbatim;
        }
        const [, handle, suffix2] = source2.match(/^(.*!)([^!]*)$/);
        if (!suffix2)
          onError3(`The ${source2} tag has no suffix`);
        const prefix4 = this.tags[handle];
        if (prefix4)
          return prefix4 + decodeURIComponent(suffix2);
        if (handle === "!")
          return source2;
        onError3(`Could not resolve tag: ${source2}`);
        return null;
      }
      /**
       * Given a fully resolved tag, returns its printable string form,
       * taking into account current tag prefixes and defaults.
       */
      tagString(tag) {
        for (const [handle, prefix4] of Object.entries(this.tags)) {
          if (tag.startsWith(prefix4))
            return handle + escapeTagName(tag.substring(prefix4.length));
        }
        return tag[0] === "!" ? tag : `!<${tag}>`;
      }
      toString(doc) {
        const lines6 = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
        const tagEntries = Object.entries(this.tags);
        let tagNames;
        if (doc && tagEntries.length > 0 && identity33.isNode(doc.contents)) {
          const tags = {};
          visit.visit(doc.contents, (_key, node) => {
            if (identity33.isNode(node) && node.tag)
              tags[node.tag] = true;
          });
          tagNames = Object.keys(tags);
        } else
          tagNames = [];
        for (const [handle, prefix4] of tagEntries) {
          if (handle === "!!" && prefix4 === "tag:yaml.org,2002:")
            continue;
          if (!doc || tagNames.some((tn) => tn.startsWith(prefix4)))
            lines6.push(`%TAG ${handle} ${prefix4}`);
        }
        return lines6.join("\n");
      }
    };
    Directives.defaultYaml = { explicit: false, version: "1.2" };
    Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
    exports.Directives = Directives;
  }
});

// node_modules/yaml/dist/doc/anchors.js
var require_anchors = __commonJS({
  "node_modules/yaml/dist/doc/anchors.js"(exports) {
    "use strict";
    var identity33 = require_identity();
    var visit = require_visit();
    function anchorIsValid(anchor) {
      if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
        const sa = JSON.stringify(anchor);
        const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
        throw new Error(msg);
      }
      return true;
    }
    function anchorNames(root2) {
      const anchors = /* @__PURE__ */ new Set();
      visit.visit(root2, {
        Value(_key, node) {
          if (node.anchor)
            anchors.add(node.anchor);
        }
      });
      return anchors;
    }
    function findNewAnchor(prefix4, exclude) {
      for (let i = 1; true; ++i) {
        const name4 = `${prefix4}${i}`;
        if (!exclude.has(name4))
          return name4;
      }
    }
    function createNodeAnchors(doc, prefix4) {
      const aliasObjects = [];
      const sourceObjects = /* @__PURE__ */ new Map();
      let prevAnchors = null;
      return {
        onAnchor: (source2) => {
          aliasObjects.push(source2);
          if (!prevAnchors)
            prevAnchors = anchorNames(doc);
          const anchor = findNewAnchor(prefix4, prevAnchors);
          prevAnchors.add(anchor);
          return anchor;
        },
        /**
         * With circular references, the source node is only resolved after all
         * of its child nodes are. This is why anchors are set only after all of
         * the nodes have been created.
         */
        setAnchors: () => {
          for (const source2 of aliasObjects) {
            const ref2 = sourceObjects.get(source2);
            if (typeof ref2 === "object" && ref2.anchor && (identity33.isScalar(ref2.node) || identity33.isCollection(ref2.node))) {
              ref2.node.anchor = ref2.anchor;
            } else {
              const error4 = new Error("Failed to resolve repeated object (this should not happen)");
              error4.source = source2;
              throw error4;
            }
          }
        },
        sourceObjects
      };
    }
    exports.anchorIsValid = anchorIsValid;
    exports.anchorNames = anchorNames;
    exports.createNodeAnchors = createNodeAnchors;
    exports.findNewAnchor = findNewAnchor;
  }
});

// node_modules/yaml/dist/doc/applyReviver.js
var require_applyReviver = __commonJS({
  "node_modules/yaml/dist/doc/applyReviver.js"(exports) {
    "use strict";
    function applyReviver(reviver, obj, key, val) {
      if (val && typeof val === "object") {
        if (Array.isArray(val)) {
          for (let i = 0, len = val.length; i < len; ++i) {
            const v0 = val[i];
            const v1 = applyReviver(reviver, val, String(i), v0);
            if (v1 === void 0)
              delete val[i];
            else if (v1 !== v0)
              val[i] = v1;
          }
        } else if (val instanceof Map) {
          for (const k of Array.from(val.keys())) {
            const v0 = val.get(k);
            const v1 = applyReviver(reviver, val, k, v0);
            if (v1 === void 0)
              val.delete(k);
            else if (v1 !== v0)
              val.set(k, v1);
          }
        } else if (val instanceof Set) {
          for (const v0 of Array.from(val)) {
            const v1 = applyReviver(reviver, val, v0, v0);
            if (v1 === void 0)
              val.delete(v0);
            else if (v1 !== v0) {
              val.delete(v0);
              val.add(v1);
            }
          }
        } else {
          for (const [k, v0] of Object.entries(val)) {
            const v1 = applyReviver(reviver, val, k, v0);
            if (v1 === void 0)
              delete val[k];
            else if (v1 !== v0)
              val[k] = v1;
          }
        }
      }
      return reviver.call(obj, key, val);
    }
    exports.applyReviver = applyReviver;
  }
});

// node_modules/yaml/dist/nodes/toJS.js
var require_toJS = __commonJS({
  "node_modules/yaml/dist/nodes/toJS.js"(exports) {
    "use strict";
    var identity33 = require_identity();
    function toJS(value4, arg, ctx) {
      if (Array.isArray(value4))
        return value4.map((v, i) => toJS(v, String(i), ctx));
      if (value4 && typeof value4.toJSON === "function") {
        if (!ctx || !identity33.hasAnchor(value4))
          return value4.toJSON(arg, ctx);
        const data = { aliasCount: 0, count: 1, res: void 0 };
        ctx.anchors.set(value4, data);
        ctx.onCreate = (res2) => {
          data.res = res2;
          delete ctx.onCreate;
        };
        const res = value4.toJSON(arg, ctx);
        if (ctx.onCreate)
          ctx.onCreate(res);
        return res;
      }
      if (typeof value4 === "bigint" && !ctx?.keep)
        return Number(value4);
      return value4;
    }
    exports.toJS = toJS;
  }
});

// node_modules/yaml/dist/nodes/Node.js
var require_Node = __commonJS({
  "node_modules/yaml/dist/nodes/Node.js"(exports) {
    "use strict";
    var applyReviver = require_applyReviver();
    var identity33 = require_identity();
    var toJS = require_toJS();
    var NodeBase = class {
      constructor(type) {
        Object.defineProperty(this, identity33.NODE_TYPE, { value: type });
      }
      /** Create a copy of this node.  */
      clone() {
        const copy3 = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (this.range)
          copy3.range = this.range.slice();
        return copy3;
      }
      /** A plain JavaScript representation of this node. */
      toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        if (!identity33.isDocument(doc))
          throw new TypeError("A document argument is required");
        const ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc,
          keep: true,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = toJS.toJS(this, "", ctx);
        if (typeof onAnchor === "function")
          for (const { count, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count);
        return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
      }
    };
    exports.NodeBase = NodeBase;
  }
});

// node_modules/yaml/dist/nodes/Alias.js
var require_Alias = __commonJS({
  "node_modules/yaml/dist/nodes/Alias.js"(exports) {
    "use strict";
    var anchors = require_anchors();
    var visit = require_visit();
    var identity33 = require_identity();
    var Node = require_Node();
    var toJS = require_toJS();
    var Alias = class extends Node.NodeBase {
      constructor(source2) {
        super(identity33.ALIAS);
        this.source = source2;
        Object.defineProperty(this, "tag", {
          set() {
            throw new Error("Alias nodes cannot have tags");
          }
        });
      }
      /**
       * Resolve the value of this alias within `doc`, finding the last
       * instance of the `source` anchor before this node.
       */
      resolve(doc) {
        let found = void 0;
        visit.visit(doc, {
          Node: (_key, node) => {
            if (node === this)
              return visit.visit.BREAK;
            if (node.anchor === this.source)
              found = node;
          }
        });
        return found;
      }
      toJSON(_arg, ctx) {
        if (!ctx)
          return { source: this.source };
        const { anchors: anchors2, doc, maxAliasCount } = ctx;
        const source2 = this.resolve(doc);
        if (!source2) {
          const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
          throw new ReferenceError(msg);
        }
        let data = anchors2.get(source2);
        if (!data) {
          toJS.toJS(source2, null, ctx);
          data = anchors2.get(source2);
        }
        if (!data || data.res === void 0) {
          const msg = "This should not happen: Alias anchor was not resolved?";
          throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
          data.count += 1;
          if (data.aliasCount === 0)
            data.aliasCount = getAliasCount(doc, source2, anchors2);
          if (data.count * data.aliasCount > maxAliasCount) {
            const msg = "Excessive alias count indicates a resource exhaustion attack";
            throw new ReferenceError(msg);
          }
        }
        return data.res;
      }
      toString(ctx, _onComment, _onChompKeep) {
        const src = `*${this.source}`;
        if (ctx) {
          anchors.anchorIsValid(this.source);
          if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
            throw new Error(msg);
          }
          if (ctx.implicitKey)
            return `${src} `;
        }
        return src;
      }
    };
    function getAliasCount(doc, node, anchors2) {
      if (identity33.isAlias(node)) {
        const source2 = node.resolve(doc);
        const anchor = anchors2 && source2 && anchors2.get(source2);
        return anchor ? anchor.count * anchor.aliasCount : 0;
      } else if (identity33.isCollection(node)) {
        let count = 0;
        for (const item of node.items) {
          const c = getAliasCount(doc, item, anchors2);
          if (c > count)
            count = c;
        }
        return count;
      } else if (identity33.isPair(node)) {
        const kc = getAliasCount(doc, node.key, anchors2);
        const vc = getAliasCount(doc, node.value, anchors2);
        return Math.max(kc, vc);
      }
      return 1;
    }
    exports.Alias = Alias;
  }
});

// node_modules/yaml/dist/nodes/Scalar.js
var require_Scalar = __commonJS({
  "node_modules/yaml/dist/nodes/Scalar.js"(exports) {
    "use strict";
    var identity33 = require_identity();
    var Node = require_Node();
    var toJS = require_toJS();
    var isScalarValue = (value4) => !value4 || typeof value4 !== "function" && typeof value4 !== "object";
    var Scalar = class extends Node.NodeBase {
      constructor(value4) {
        super(identity33.SCALAR);
        this.value = value4;
      }
      toJSON(arg, ctx) {
        return ctx?.keep ? this.value : toJS.toJS(this.value, arg, ctx);
      }
      toString() {
        return String(this.value);
      }
    };
    Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
    Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
    Scalar.PLAIN = "PLAIN";
    Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
    Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
    exports.Scalar = Scalar;
    exports.isScalarValue = isScalarValue;
  }
});

// node_modules/yaml/dist/doc/createNode.js
var require_createNode = __commonJS({
  "node_modules/yaml/dist/doc/createNode.js"(exports) {
    "use strict";
    var Alias = require_Alias();
    var identity33 = require_identity();
    var Scalar = require_Scalar();
    var defaultTagPrefix = "tag:yaml.org,2002:";
    function findTagObject(value4, tagName, tags) {
      if (tagName) {
        const match4 = tags.filter((t) => t.tag === tagName);
        const tagObj = match4.find((t) => !t.format) ?? match4[0];
        if (!tagObj)
          throw new Error(`Tag ${tagName} not found`);
        return tagObj;
      }
      return tags.find((t) => t.identify?.(value4) && !t.format);
    }
    function createNode(value4, tagName, ctx) {
      if (identity33.isDocument(value4))
        value4 = value4.contents;
      if (identity33.isNode(value4))
        return value4;
      if (identity33.isPair(value4)) {
        const map86 = ctx.schema[identity33.MAP].createNode?.(ctx.schema, null, ctx);
        map86.items.push(value4);
        return map86;
      }
      if (value4 instanceof String || value4 instanceof Number || value4 instanceof Boolean || typeof BigInt !== "undefined" && value4 instanceof BigInt) {
        value4 = value4.valueOf();
      }
      const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;
      let ref2 = void 0;
      if (aliasDuplicateObjects && value4 && typeof value4 === "object") {
        ref2 = sourceObjects.get(value4);
        if (ref2) {
          if (!ref2.anchor)
            ref2.anchor = onAnchor(value4);
          return new Alias.Alias(ref2.anchor);
        } else {
          ref2 = { anchor: null, node: null };
          sourceObjects.set(value4, ref2);
        }
      }
      if (tagName?.startsWith("!!"))
        tagName = defaultTagPrefix + tagName.slice(2);
      let tagObj = findTagObject(value4, tagName, schema.tags);
      if (!tagObj) {
        if (value4 && typeof value4.toJSON === "function") {
          value4 = value4.toJSON();
        }
        if (!value4 || typeof value4 !== "object") {
          const node2 = new Scalar.Scalar(value4);
          if (ref2)
            ref2.node = node2;
          return node2;
        }
        tagObj = value4 instanceof Map ? schema[identity33.MAP] : Symbol.iterator in Object(value4) ? schema[identity33.SEQ] : schema[identity33.MAP];
      }
      if (onTagObj) {
        onTagObj(tagObj);
        delete ctx.onTagObj;
      }
      const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value4, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value4, ctx) : new Scalar.Scalar(value4);
      if (tagName)
        node.tag = tagName;
      else if (!tagObj.default)
        node.tag = tagObj.tag;
      if (ref2)
        ref2.node = node;
      return node;
    }
    exports.createNode = createNode;
  }
});

// node_modules/yaml/dist/nodes/Collection.js
var require_Collection = __commonJS({
  "node_modules/yaml/dist/nodes/Collection.js"(exports) {
    "use strict";
    var createNode = require_createNode();
    var identity33 = require_identity();
    var Node = require_Node();
    function collectionFromPath(schema, path5, value4) {
      let v = value4;
      for (let i = path5.length - 1; i >= 0; --i) {
        const k = path5[i];
        if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
          const a = [];
          a[k] = v;
          v = a;
        } else {
          v = /* @__PURE__ */ new Map([[k, v]]);
        }
      }
      return createNode.createNode(v, void 0, {
        aliasDuplicateObjects: false,
        keepUndefined: false,
        onAnchor: () => {
          throw new Error("This should not happen, please report a bug.");
        },
        schema,
        sourceObjects: /* @__PURE__ */ new Map()
      });
    }
    var isEmptyPath = (path5) => path5 == null || typeof path5 === "object" && !!path5[Symbol.iterator]().next().done;
    var Collection = class extends Node.NodeBase {
      constructor(type, schema) {
        super(type);
        Object.defineProperty(this, "schema", {
          value: schema,
          configurable: true,
          enumerable: false,
          writable: true
        });
      }
      /**
       * Create a copy of this collection.
       *
       * @param schema - If defined, overwrites the original's schema
       */
      clone(schema) {
        const copy3 = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (schema)
          copy3.schema = schema;
        copy3.items = copy3.items.map((it) => identity33.isNode(it) || identity33.isPair(it) ? it.clone(schema) : it);
        if (this.range)
          copy3.range = this.range.slice();
        return copy3;
      }
      /**
       * Adds a value to the collection. For `!!map` and `!!omap` the value must
       * be a Pair instance or a `{ key, value }` object, which may not have a key
       * that already exists in the map.
       */
      addIn(path5, value4) {
        if (isEmptyPath(path5))
          this.add(value4);
        else {
          const [key, ...rest2] = path5;
          const node = this.get(key, true);
          if (identity33.isCollection(node))
            node.addIn(rest2, value4);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest2, value4));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest2}`);
        }
      }
      /**
       * Removes a value from the collection.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path5) {
        const [key, ...rest2] = path5;
        if (rest2.length === 0)
          return this.delete(key);
        const node = this.get(key, true);
        if (identity33.isCollection(node))
          return node.deleteIn(rest2);
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest2}`);
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path5, keepScalar) {
        const [key, ...rest2] = path5;
        const node = this.get(key, true);
        if (rest2.length === 0)
          return !keepScalar && identity33.isScalar(node) ? node.value : node;
        else
          return identity33.isCollection(node) ? node.getIn(rest2, keepScalar) : void 0;
      }
      hasAllNullValues(allowScalar) {
        return this.items.every((node) => {
          if (!identity33.isPair(node))
            return false;
          const n = node.value;
          return n == null || allowScalar && identity33.isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
        });
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       */
      hasIn(path5) {
        const [key, ...rest2] = path5;
        if (rest2.length === 0)
          return this.has(key);
        const node = this.get(key, true);
        return identity33.isCollection(node) ? node.hasIn(rest2) : false;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path5, value4) {
        const [key, ...rest2] = path5;
        if (rest2.length === 0) {
          this.set(key, value4);
        } else {
          const node = this.get(key, true);
          if (identity33.isCollection(node))
            node.setIn(rest2, value4);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest2, value4));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest2}`);
        }
      }
    };
    Collection.maxFlowStringSingleLineLength = 60;
    exports.Collection = Collection;
    exports.collectionFromPath = collectionFromPath;
    exports.isEmptyPath = isEmptyPath;
  }
});

// node_modules/yaml/dist/stringify/stringifyComment.js
var require_stringifyComment = __commonJS({
  "node_modules/yaml/dist/stringify/stringifyComment.js"(exports) {
    "use strict";
    var stringifyComment = (str2) => str2.replace(/^(?!$)(?: $)?/gm, "#");
    function indentComment(comment2, indent3) {
      if (/^\n+$/.test(comment2))
        return comment2.substring(1);
      return indent3 ? comment2.replace(/^(?! *$)/gm, indent3) : comment2;
    }
    var lineComment2 = (str2, indent3, comment2) => str2.endsWith("\n") ? indentComment(comment2, indent3) : comment2.includes("\n") ? "\n" + indentComment(comment2, indent3) : (str2.endsWith(" ") ? "" : " ") + comment2;
    exports.indentComment = indentComment;
    exports.lineComment = lineComment2;
    exports.stringifyComment = stringifyComment;
  }
});

// node_modules/yaml/dist/stringify/foldFlowLines.js
var require_foldFlowLines = __commonJS({
  "node_modules/yaml/dist/stringify/foldFlowLines.js"(exports) {
    "use strict";
    var FOLD_FLOW = "flow";
    var FOLD_BLOCK = "block";
    var FOLD_QUOTED = "quoted";
    function foldFlowLines(text3, indent3, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
      if (!lineWidth || lineWidth < 0)
        return text3;
      const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent3.length);
      if (text3.length <= endStep)
        return text3;
      const folds = [];
      const escapedFolds = {};
      let end4 = lineWidth - indent3.length;
      if (typeof indentAtStart === "number") {
        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
          folds.push(0);
        else
          end4 = lineWidth - indentAtStart;
      }
      let split3 = void 0;
      let prev = void 0;
      let overflow = false;
      let i = -1;
      let escStart = -1;
      let escEnd = -1;
      if (mode === FOLD_BLOCK) {
        i = consumeMoreIndentedLines(text3, i);
        if (i !== -1)
          end4 = i + endStep;
      }
      for (let ch; ch = text3[i += 1]; ) {
        if (mode === FOLD_QUOTED && ch === "\\") {
          escStart = i;
          switch (text3[i + 1]) {
            case "x":
              i += 3;
              break;
            case "u":
              i += 5;
              break;
            case "U":
              i += 9;
              break;
            default:
              i += 1;
          }
          escEnd = i;
        }
        if (ch === "\n") {
          if (mode === FOLD_BLOCK)
            i = consumeMoreIndentedLines(text3, i);
          end4 = i + endStep;
          split3 = void 0;
        } else {
          if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
            const next2 = text3[i + 1];
            if (next2 && next2 !== " " && next2 !== "\n" && next2 !== "	")
              split3 = i;
          }
          if (i >= end4) {
            if (split3) {
              folds.push(split3);
              end4 = split3 + endStep;
              split3 = void 0;
            } else if (mode === FOLD_QUOTED) {
              while (prev === " " || prev === "	") {
                prev = ch;
                ch = text3[i += 1];
                overflow = true;
              }
              const j = i > escEnd + 1 ? i - 2 : escStart - 1;
              if (escapedFolds[j])
                return text3;
              folds.push(j);
              escapedFolds[j] = true;
              end4 = j + endStep;
              split3 = void 0;
            } else {
              overflow = true;
            }
          }
        }
        prev = ch;
      }
      if (overflow && onOverflow)
        onOverflow();
      if (folds.length === 0)
        return text3;
      if (onFold)
        onFold();
      let res = text3.slice(0, folds[0]);
      for (let i2 = 0; i2 < folds.length; ++i2) {
        const fold23 = folds[i2];
        const end5 = folds[i2 + 1] || text3.length;
        if (fold23 === 0)
          res = `
${indent3}${text3.slice(0, end5)}`;
        else {
          if (mode === FOLD_QUOTED && escapedFolds[fold23])
            res += `${text3[fold23]}\\`;
          res += `
${indent3}${text3.slice(fold23 + 1, end5)}`;
        }
      }
      return res;
    }
    function consumeMoreIndentedLines(text3, i) {
      let ch = text3[i + 1];
      while (ch === " " || ch === "	") {
        do {
          ch = text3[i += 1];
        } while (ch && ch !== "\n");
        ch = text3[i + 1];
      }
      return i;
    }
    exports.FOLD_BLOCK = FOLD_BLOCK;
    exports.FOLD_FLOW = FOLD_FLOW;
    exports.FOLD_QUOTED = FOLD_QUOTED;
    exports.foldFlowLines = foldFlowLines;
  }
});

// node_modules/yaml/dist/stringify/stringifyString.js
var require_stringifyString = __commonJS({
  "node_modules/yaml/dist/stringify/stringifyString.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var foldFlowLines = require_foldFlowLines();
    var getFoldOptions = (ctx, isBlock) => ({
      indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
      lineWidth: ctx.options.lineWidth,
      minContentWidth: ctx.options.minContentWidth
    });
    var containsDocumentMarker = (str2) => /^(%|---|\.\.\.)/m.test(str2);
    function lineLengthOverLimit(str2, lineWidth, indentLength) {
      if (!lineWidth || lineWidth < 0)
        return false;
      const limit = lineWidth - indentLength;
      const strLen = str2.length;
      if (strLen <= limit)
        return false;
      for (let i = 0, start = 0; i < strLen; ++i) {
        if (str2[i] === "\n") {
          if (i - start > limit)
            return true;
          start = i + 1;
          if (strLen - start <= limit)
            return false;
        }
      }
      return true;
    }
    function doubleQuotedString(value4, ctx) {
      const json4 = JSON.stringify(value4);
      if (ctx.options.doubleQuotedAsJSON)
        return json4;
      const { implicitKey } = ctx;
      const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
      const indent3 = ctx.indent || (containsDocumentMarker(value4) ? "  " : "");
      let str2 = "";
      let start = 0;
      for (let i = 0, ch = json4[i]; ch; ch = json4[++i]) {
        if (ch === " " && json4[i + 1] === "\\" && json4[i + 2] === "n") {
          str2 += json4.slice(start, i) + "\\ ";
          i += 1;
          start = i;
          ch = "\\";
        }
        if (ch === "\\")
          switch (json4[i + 1]) {
            case "u":
              {
                str2 += json4.slice(start, i);
                const code = json4.substr(i + 2, 4);
                switch (code) {
                  case "0000":
                    str2 += "\\0";
                    break;
                  case "0007":
                    str2 += "\\a";
                    break;
                  case "000b":
                    str2 += "\\v";
                    break;
                  case "001b":
                    str2 += "\\e";
                    break;
                  case "0085":
                    str2 += "\\N";
                    break;
                  case "00a0":
                    str2 += "\\_";
                    break;
                  case "2028":
                    str2 += "\\L";
                    break;
                  case "2029":
                    str2 += "\\P";
                    break;
                  default:
                    if (code.substr(0, 2) === "00")
                      str2 += "\\x" + code.substr(2);
                    else
                      str2 += json4.substr(i, 6);
                }
                i += 5;
                start = i + 1;
              }
              break;
            case "n":
              if (implicitKey || json4[i + 2] === '"' || json4.length < minMultiLineLength) {
                i += 1;
              } else {
                str2 += json4.slice(start, i) + "\n\n";
                while (json4[i + 2] === "\\" && json4[i + 3] === "n" && json4[i + 4] !== '"') {
                  str2 += "\n";
                  i += 2;
                }
                str2 += indent3;
                if (json4[i + 2] === " ")
                  str2 += "\\";
                i += 1;
                start = i + 1;
              }
              break;
            default:
              i += 1;
          }
      }
      str2 = start ? str2 + json4.slice(start) : json4;
      return implicitKey ? str2 : foldFlowLines.foldFlowLines(str2, indent3, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, false));
    }
    function singleQuotedString(value4, ctx) {
      if (ctx.options.singleQuote === false || ctx.implicitKey && value4.includes("\n") || /[ \t]\n|\n[ \t]/.test(value4))
        return doubleQuotedString(value4, ctx);
      const indent3 = ctx.indent || (containsDocumentMarker(value4) ? "  " : "");
      const res = "'" + value4.replace(/'/g, "''").replace(/\n+/g, `$&
${indent3}`) + "'";
      return ctx.implicitKey ? res : foldFlowLines.foldFlowLines(res, indent3, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
    }
    function quotedString(value4, ctx) {
      const { singleQuote } = ctx.options;
      let qs;
      if (singleQuote === false)
        qs = doubleQuotedString;
      else {
        const hasDouble = value4.includes('"');
        const hasSingle = value4.includes("'");
        if (hasDouble && !hasSingle)
          qs = singleQuotedString;
        else if (hasSingle && !hasDouble)
          qs = doubleQuotedString;
        else
          qs = singleQuote ? singleQuotedString : doubleQuotedString;
      }
      return qs(value4, ctx);
    }
    var blockEndNewlines;
    try {
      blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
    } catch {
      blockEndNewlines = /\n+(?!\n|$)/g;
    }
    function blockString({ comment: comment2, type, value: value4 }, ctx, onComment, onChompKeep) {
      const { blockQuote, commentString, lineWidth } = ctx.options;
      if (!blockQuote || /\n[\t ]+$/.test(value4) || /^\s*$/.test(value4)) {
        return quotedString(value4, ctx);
      }
      const indent3 = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value4) ? "  " : "");
      const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.Scalar.BLOCK_FOLDED ? false : type === Scalar.Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value4, lineWidth, indent3.length);
      if (!value4)
        return literal ? "|\n" : ">\n";
      let chomp;
      let endStart;
      for (endStart = value4.length; endStart > 0; --endStart) {
        const ch = value4[endStart - 1];
        if (ch !== "\n" && ch !== "	" && ch !== " ")
          break;
      }
      let end4 = value4.substring(endStart);
      const endNlPos = end4.indexOf("\n");
      if (endNlPos === -1) {
        chomp = "-";
      } else if (value4 === end4 || endNlPos !== end4.length - 1) {
        chomp = "+";
        if (onChompKeep)
          onChompKeep();
      } else {
        chomp = "";
      }
      if (end4) {
        value4 = value4.slice(0, -end4.length);
        if (end4[end4.length - 1] === "\n")
          end4 = end4.slice(0, -1);
        end4 = end4.replace(blockEndNewlines, `$&${indent3}`);
      }
      let startWithSpace = false;
      let startEnd;
      let startNlPos = -1;
      for (startEnd = 0; startEnd < value4.length; ++startEnd) {
        const ch = value4[startEnd];
        if (ch === " ")
          startWithSpace = true;
        else if (ch === "\n")
          startNlPos = startEnd;
        else
          break;
      }
      let start = value4.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
      if (start) {
        value4 = value4.substring(start.length);
        start = start.replace(/\n+/g, `$&${indent3}`);
      }
      const indentSize = indent3 ? "2" : "1";
      let header = (literal ? "|" : ">") + (startWithSpace ? indentSize : "") + chomp;
      if (comment2) {
        header += " " + commentString(comment2.replace(/ ?[\r\n]+/g, " "));
        if (onComment)
          onComment();
      }
      if (literal) {
        value4 = value4.replace(/\n+/g, `$&${indent3}`);
        return `${header}
${indent3}${start}${value4}${end4}`;
      }
      value4 = value4.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent3}`);
      const body = foldFlowLines.foldFlowLines(`${start}${value4}${end4}`, indent3, foldFlowLines.FOLD_BLOCK, getFoldOptions(ctx, true));
      return `${header}
${indent3}${body}`;
    }
    function plainString(item, ctx, onComment, onChompKeep) {
      const { type, value: value4 } = item;
      const { actualString, implicitKey, indent: indent3, indentStep, inFlow } = ctx;
      if (implicitKey && /[\n[\]{},]/.test(value4) || inFlow && /[[\]{},]/.test(value4)) {
        return quotedString(value4, ctx);
      }
      if (!value4 || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value4)) {
        return implicitKey || inFlow || !value4.includes("\n") ? quotedString(value4, ctx) : blockString(item, ctx, onComment, onChompKeep);
      }
      if (!implicitKey && !inFlow && type !== Scalar.Scalar.PLAIN && value4.includes("\n")) {
        return blockString(item, ctx, onComment, onChompKeep);
      }
      if (containsDocumentMarker(value4)) {
        if (indent3 === "") {
          ctx.forceBlockIndent = true;
          return blockString(item, ctx, onComment, onChompKeep);
        } else if (implicitKey && indent3 === indentStep) {
          return quotedString(value4, ctx);
        }
      }
      const str2 = value4.replace(/\n+/g, `$&
${indent3}`);
      if (actualString) {
        const test2 = (tag) => tag.default && tag.tag !== "tag:yaml.org,2002:str" && tag.test?.test(str2);
        const { compat, tags } = ctx.doc.schema;
        if (tags.some(test2) || compat?.some(test2))
          return quotedString(value4, ctx);
      }
      return implicitKey ? str2 : foldFlowLines.foldFlowLines(str2, indent3, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
    }
    function stringifyString(item, ctx, onComment, onChompKeep) {
      const { implicitKey, inFlow } = ctx;
      const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
      let { type } = item;
      if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
        if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
          type = Scalar.Scalar.QUOTE_DOUBLE;
      }
      const _stringify = (_type) => {
        switch (_type) {
          case Scalar.Scalar.BLOCK_FOLDED:
          case Scalar.Scalar.BLOCK_LITERAL:
            return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
          case Scalar.Scalar.QUOTE_DOUBLE:
            return doubleQuotedString(ss.value, ctx);
          case Scalar.Scalar.QUOTE_SINGLE:
            return singleQuotedString(ss.value, ctx);
          case Scalar.Scalar.PLAIN:
            return plainString(ss, ctx, onComment, onChompKeep);
          default:
            return null;
        }
      };
      let res = _stringify(type);
      if (res === null) {
        const { defaultKeyType, defaultStringType } = ctx.options;
        const t = implicitKey && defaultKeyType || defaultStringType;
        res = _stringify(t);
        if (res === null)
          throw new Error(`Unsupported default string type ${t}`);
      }
      return res;
    }
    exports.stringifyString = stringifyString;
  }
});

// node_modules/yaml/dist/stringify/stringify.js
var require_stringify = __commonJS({
  "node_modules/yaml/dist/stringify/stringify.js"(exports) {
    "use strict";
    var anchors = require_anchors();
    var identity33 = require_identity();
    var stringifyComment = require_stringifyComment();
    var stringifyString = require_stringifyString();
    function createStringifyContext(doc, options) {
      const opt = Object.assign({
        blockQuote: true,
        commentString: stringifyComment.stringifyComment,
        defaultKeyType: null,
        defaultStringType: "PLAIN",
        directives: null,
        doubleQuotedAsJSON: false,
        doubleQuotedMinMultiLineLength: 40,
        falseStr: "false",
        flowCollectionPadding: true,
        indentSeq: true,
        lineWidth: 80,
        minContentWidth: 20,
        nullStr: "null",
        simpleKeys: false,
        singleQuote: null,
        trueStr: "true",
        verifyAliasOrder: true
      }, doc.schema.toStringOptions, options);
      let inFlow;
      switch (opt.collectionStyle) {
        case "block":
          inFlow = false;
          break;
        case "flow":
          inFlow = true;
          break;
        default:
          inFlow = null;
      }
      return {
        anchors: /* @__PURE__ */ new Set(),
        doc,
        flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
        indent: "",
        indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
        inFlow,
        options: opt
      };
    }
    function getTagObject(tags, item) {
      if (item.tag) {
        const match4 = tags.filter((t) => t.tag === item.tag);
        if (match4.length > 0)
          return match4.find((t) => t.format === item.format) ?? match4[0];
      }
      let tagObj = void 0;
      let obj;
      if (identity33.isScalar(item)) {
        obj = item.value;
        const match4 = tags.filter((t) => t.identify?.(obj));
        tagObj = match4.find((t) => t.format === item.format) ?? match4.find((t) => !t.format);
      } else {
        obj = item;
        tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
      }
      if (!tagObj) {
        const name4 = obj?.constructor?.name ?? typeof obj;
        throw new Error(`Tag not resolved for ${name4} value`);
      }
      return tagObj;
    }
    function stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {
      if (!doc.directives)
        return "";
      const props = [];
      const anchor = (identity33.isScalar(node) || identity33.isCollection(node)) && node.anchor;
      if (anchor && anchors.anchorIsValid(anchor)) {
        anchors$1.add(anchor);
        props.push(`&${anchor}`);
      }
      const tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;
      if (tag)
        props.push(doc.directives.tagString(tag));
      return props.join(" ");
    }
    function stringify3(item, ctx, onComment, onChompKeep) {
      if (identity33.isPair(item))
        return item.toString(ctx, onComment, onChompKeep);
      if (identity33.isAlias(item)) {
        if (ctx.doc.directives)
          return item.toString(ctx);
        if (ctx.resolvedAliases?.has(item)) {
          throw new TypeError(`Cannot stringify circular structure without alias nodes`);
        } else {
          if (ctx.resolvedAliases)
            ctx.resolvedAliases.add(item);
          else
            ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
          item = item.resolve(ctx.doc);
        }
      }
      let tagObj = void 0;
      const node = identity33.isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
      if (!tagObj)
        tagObj = getTagObject(ctx.doc.schema.tags, node);
      const props = stringifyProps(node, tagObj, ctx);
      if (props.length > 0)
        ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
      const str2 = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : identity33.isScalar(node) ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
      if (!props)
        return str2;
      return identity33.isScalar(node) || str2[0] === "{" || str2[0] === "[" ? `${props} ${str2}` : `${props}
${ctx.indent}${str2}`;
    }
    exports.createStringifyContext = createStringifyContext;
    exports.stringify = stringify3;
  }
});

// node_modules/yaml/dist/stringify/stringifyPair.js
var require_stringifyPair = __commonJS({
  "node_modules/yaml/dist/stringify/stringifyPair.js"(exports) {
    "use strict";
    var identity33 = require_identity();
    var Scalar = require_Scalar();
    var stringify3 = require_stringify();
    var stringifyComment = require_stringifyComment();
    function stringifyPair({ key, value: value4 }, ctx, onComment, onChompKeep) {
      const { allNullValues, doc, indent: indent3, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
      let keyComment = identity33.isNode(key) && key.comment || null;
      if (simpleKeys) {
        if (keyComment) {
          throw new Error("With simple keys, key nodes cannot have comments");
        }
        if (identity33.isCollection(key)) {
          const msg = "With simple keys, collection cannot be used as a key value";
          throw new Error(msg);
        }
      }
      let explicitKey = !simpleKeys && (!key || keyComment && value4 == null && !ctx.inFlow || identity33.isCollection(key) || (identity33.isScalar(key) ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL : typeof key === "object"));
      ctx = Object.assign({}, ctx, {
        allNullValues: false,
        implicitKey: !explicitKey && (simpleKeys || !allNullValues),
        indent: indent3 + indentStep
      });
      let keyCommentDone = false;
      let chompKeep = false;
      let str2 = stringify3.stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
      if (!explicitKey && !ctx.inFlow && str2.length > 1024) {
        if (simpleKeys)
          throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
        explicitKey = true;
      }
      if (ctx.inFlow) {
        if (allNullValues || value4 == null) {
          if (keyCommentDone && onComment)
            onComment();
          return str2 === "" ? "?" : explicitKey ? `? ${str2}` : str2;
        }
      } else if (allNullValues && !simpleKeys || value4 == null && explicitKey) {
        str2 = `? ${str2}`;
        if (keyComment && !keyCommentDone) {
          str2 += stringifyComment.lineComment(str2, ctx.indent, commentString(keyComment));
        } else if (chompKeep && onChompKeep)
          onChompKeep();
        return str2;
      }
      if (keyCommentDone)
        keyComment = null;
      if (explicitKey) {
        if (keyComment)
          str2 += stringifyComment.lineComment(str2, ctx.indent, commentString(keyComment));
        str2 = `? ${str2}
${indent3}:`;
      } else {
        str2 = `${str2}:`;
        if (keyComment)
          str2 += stringifyComment.lineComment(str2, ctx.indent, commentString(keyComment));
      }
      let vsb, vcb, valueComment;
      if (identity33.isNode(value4)) {
        vsb = !!value4.spaceBefore;
        vcb = value4.commentBefore;
        valueComment = value4.comment;
      } else {
        vsb = false;
        vcb = null;
        valueComment = null;
        if (value4 && typeof value4 === "object")
          value4 = doc.createNode(value4);
      }
      ctx.implicitKey = false;
      if (!explicitKey && !keyComment && identity33.isScalar(value4))
        ctx.indentAtStart = str2.length + 1;
      chompKeep = false;
      if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && identity33.isSeq(value4) && !value4.flow && !value4.tag && !value4.anchor) {
        ctx.indent = ctx.indent.substring(2);
      }
      let valueCommentDone = false;
      const valueStr = stringify3.stringify(value4, ctx, () => valueCommentDone = true, () => chompKeep = true);
      let ws = " ";
      if (keyComment || vsb || vcb) {
        ws = vsb ? "\n" : "";
        if (vcb) {
          const cs = commentString(vcb);
          ws += `
${stringifyComment.indentComment(cs, ctx.indent)}`;
        }
        if (valueStr === "" && !ctx.inFlow) {
          if (ws === "\n")
            ws = "\n\n";
        } else {
          ws += `
${ctx.indent}`;
        }
      } else if (!explicitKey && identity33.isCollection(value4)) {
        const vs0 = valueStr[0];
        const nl0 = valueStr.indexOf("\n");
        const hasNewline = nl0 !== -1;
        const flow = ctx.inFlow ?? value4.flow ?? value4.items.length === 0;
        if (hasNewline || !flow) {
          let hasPropsLine = false;
          if (hasNewline && (vs0 === "&" || vs0 === "!")) {
            let sp0 = valueStr.indexOf(" ");
            if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
              sp0 = valueStr.indexOf(" ", sp0 + 1);
            }
            if (sp0 === -1 || nl0 < sp0)
              hasPropsLine = true;
          }
          if (!hasPropsLine)
            ws = `
${ctx.indent}`;
        }
      } else if (valueStr === "" || valueStr[0] === "\n") {
        ws = "";
      }
      str2 += ws + valueStr;
      if (ctx.inFlow) {
        if (valueCommentDone && onComment)
          onComment();
      } else if (valueComment && !valueCommentDone) {
        str2 += stringifyComment.lineComment(str2, ctx.indent, commentString(valueComment));
      } else if (chompKeep && onChompKeep) {
        onChompKeep();
      }
      return str2;
    }
    exports.stringifyPair = stringifyPair;
  }
});

// node_modules/yaml/dist/log.js
var require_log = __commonJS({
  "node_modules/yaml/dist/log.js"(exports) {
    "use strict";
    function debug2(logLevel, ...messages) {
      if (logLevel === "debug")
        console.log(...messages);
    }
    function warn2(logLevel, warning) {
      if (logLevel === "debug" || logLevel === "warn") {
        if (typeof process !== "undefined" && process.emitWarning)
          process.emitWarning(warning);
        else
          console.warn(warning);
      }
    }
    exports.debug = debug2;
    exports.warn = warn2;
  }
});

// node_modules/yaml/dist/nodes/addPairToJSMap.js
var require_addPairToJSMap = __commonJS({
  "node_modules/yaml/dist/nodes/addPairToJSMap.js"(exports) {
    "use strict";
    var log5 = require_log();
    var stringify3 = require_stringify();
    var identity33 = require_identity();
    var Scalar = require_Scalar();
    var toJS = require_toJS();
    var MERGE_KEY = "<<";
    function addPairToJSMap(ctx, map86, { key, value: value4 }) {
      if (ctx?.doc.schema.merge && isMergeKey(key)) {
        value4 = identity33.isAlias(value4) ? value4.resolve(ctx.doc) : value4;
        if (identity33.isSeq(value4))
          for (const it of value4.items)
            mergeToJSMap(ctx, map86, it);
        else if (Array.isArray(value4))
          for (const it of value4)
            mergeToJSMap(ctx, map86, it);
        else
          mergeToJSMap(ctx, map86, value4);
      } else {
        const jsKey = toJS.toJS(key, "", ctx);
        if (map86 instanceof Map) {
          map86.set(jsKey, toJS.toJS(value4, jsKey, ctx));
        } else if (map86 instanceof Set) {
          map86.add(jsKey);
        } else {
          const stringKey = stringifyKey(key, jsKey, ctx);
          const jsValue = toJS.toJS(value4, stringKey, ctx);
          if (stringKey in map86)
            Object.defineProperty(map86, stringKey, {
              value: jsValue,
              writable: true,
              enumerable: true,
              configurable: true
            });
          else
            map86[stringKey] = jsValue;
        }
      }
      return map86;
    }
    var isMergeKey = (key) => key === MERGE_KEY || identity33.isScalar(key) && key.value === MERGE_KEY && (!key.type || key.type === Scalar.Scalar.PLAIN);
    function mergeToJSMap(ctx, map86, value4) {
      const source2 = ctx && identity33.isAlias(value4) ? value4.resolve(ctx.doc) : value4;
      if (!identity33.isMap(source2))
        throw new Error("Merge sources must be maps or map aliases");
      const srcMap = source2.toJSON(null, ctx, Map);
      for (const [key, value5] of srcMap) {
        if (map86 instanceof Map) {
          if (!map86.has(key))
            map86.set(key, value5);
        } else if (map86 instanceof Set) {
          map86.add(key);
        } else if (!Object.prototype.hasOwnProperty.call(map86, key)) {
          Object.defineProperty(map86, key, {
            value: value5,
            writable: true,
            enumerable: true,
            configurable: true
          });
        }
      }
      return map86;
    }
    function stringifyKey(key, jsKey, ctx) {
      if (jsKey === null)
        return "";
      if (typeof jsKey !== "object")
        return String(jsKey);
      if (identity33.isNode(key) && ctx && ctx.doc) {
        const strCtx = stringify3.createStringifyContext(ctx.doc, {});
        strCtx.anchors = /* @__PURE__ */ new Set();
        for (const node of ctx.anchors.keys())
          strCtx.anchors.add(node.anchor);
        strCtx.inFlow = true;
        strCtx.inStringifyKey = true;
        const strKey = key.toString(strCtx);
        if (!ctx.mapKeyWarned) {
          let jsonStr = JSON.stringify(strKey);
          if (jsonStr.length > 40)
            jsonStr = jsonStr.substring(0, 36) + '..."';
          log5.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
          ctx.mapKeyWarned = true;
        }
        return strKey;
      }
      return JSON.stringify(jsKey);
    }
    exports.addPairToJSMap = addPairToJSMap;
  }
});

// node_modules/yaml/dist/nodes/Pair.js
var require_Pair = __commonJS({
  "node_modules/yaml/dist/nodes/Pair.js"(exports) {
    "use strict";
    var createNode = require_createNode();
    var stringifyPair = require_stringifyPair();
    var addPairToJSMap = require_addPairToJSMap();
    var identity33 = require_identity();
    function createPair(key, value4, ctx) {
      const k = createNode.createNode(key, void 0, ctx);
      const v = createNode.createNode(value4, void 0, ctx);
      return new Pair(k, v);
    }
    var Pair = class _Pair {
      constructor(key, value4 = null) {
        Object.defineProperty(this, identity33.NODE_TYPE, { value: identity33.PAIR });
        this.key = key;
        this.value = value4;
      }
      clone(schema) {
        let { key, value: value4 } = this;
        if (identity33.isNode(key))
          key = key.clone(schema);
        if (identity33.isNode(value4))
          value4 = value4.clone(schema);
        return new _Pair(key, value4);
      }
      toJSON(_, ctx) {
        const pair = ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
        return addPairToJSMap.addPairToJSMap(ctx, pair, this);
      }
      toString(ctx, onComment, onChompKeep) {
        return ctx?.doc ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
      }
    };
    exports.Pair = Pair;
    exports.createPair = createPair;
  }
});

// node_modules/yaml/dist/stringify/stringifyCollection.js
var require_stringifyCollection = __commonJS({
  "node_modules/yaml/dist/stringify/stringifyCollection.js"(exports) {
    "use strict";
    var Collection = require_Collection();
    var identity33 = require_identity();
    var stringify3 = require_stringify();
    var stringifyComment = require_stringifyComment();
    function stringifyCollection(collection, ctx, options) {
      const flow = ctx.inFlow ?? collection.flow;
      const stringify4 = flow ? stringifyFlowCollection : stringifyBlockCollection;
      return stringify4(collection, ctx, options);
    }
    function stringifyBlockCollection({ comment: comment2, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
      const { indent: indent3, options: { commentString } } = ctx;
      const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
      let chompKeep = false;
      const lines6 = [];
      for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment3 = null;
        if (identity33.isNode(item)) {
          if (!chompKeep && item.spaceBefore)
            lines6.push("");
          addCommentBefore(ctx, lines6, item.commentBefore, chompKeep);
          if (item.comment)
            comment3 = item.comment;
        } else if (identity33.isPair(item)) {
          const ik = identity33.isNode(item.key) ? item.key : null;
          if (ik) {
            if (!chompKeep && ik.spaceBefore)
              lines6.push("");
            addCommentBefore(ctx, lines6, ik.commentBefore, chompKeep);
          }
        }
        chompKeep = false;
        let str3 = stringify3.stringify(item, itemCtx, () => comment3 = null, () => chompKeep = true);
        if (comment3)
          str3 += stringifyComment.lineComment(str3, itemIndent, commentString(comment3));
        if (chompKeep && comment3)
          chompKeep = false;
        lines6.push(blockItemPrefix + str3);
      }
      let str2;
      if (lines6.length === 0) {
        str2 = flowChars.start + flowChars.end;
      } else {
        str2 = lines6[0];
        for (let i = 1; i < lines6.length; ++i) {
          const line2 = lines6[i];
          str2 += line2 ? `
${indent3}${line2}` : "\n";
        }
      }
      if (comment2) {
        str2 += "\n" + stringifyComment.indentComment(commentString(comment2), indent3);
        if (onComment)
          onComment();
      } else if (chompKeep && onChompKeep)
        onChompKeep();
      return str2;
    }
    function stringifyFlowCollection({ comment: comment2, items }, ctx, { flowChars, itemIndent, onComment }) {
      const { indent: indent3, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
      itemIndent += indentStep;
      const itemCtx = Object.assign({}, ctx, {
        indent: itemIndent,
        inFlow: true,
        type: null
      });
      let reqNewline = false;
      let linesAtValue = 0;
      const lines6 = [];
      for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment3 = null;
        if (identity33.isNode(item)) {
          if (item.spaceBefore)
            lines6.push("");
          addCommentBefore(ctx, lines6, item.commentBefore, false);
          if (item.comment)
            comment3 = item.comment;
        } else if (identity33.isPair(item)) {
          const ik = identity33.isNode(item.key) ? item.key : null;
          if (ik) {
            if (ik.spaceBefore)
              lines6.push("");
            addCommentBefore(ctx, lines6, ik.commentBefore, false);
            if (ik.comment)
              reqNewline = true;
          }
          const iv = identity33.isNode(item.value) ? item.value : null;
          if (iv) {
            if (iv.comment)
              comment3 = iv.comment;
            if (iv.commentBefore)
              reqNewline = true;
          } else if (item.value == null && ik && ik.comment) {
            comment3 = ik.comment;
          }
        }
        if (comment3)
          reqNewline = true;
        let str3 = stringify3.stringify(item, itemCtx, () => comment3 = null);
        if (i < items.length - 1)
          str3 += ",";
        if (comment3)
          str3 += stringifyComment.lineComment(str3, itemIndent, commentString(comment3));
        if (!reqNewline && (lines6.length > linesAtValue || str3.includes("\n")))
          reqNewline = true;
        lines6.push(str3);
        linesAtValue = lines6.length;
      }
      let str2;
      const { start, end: end4 } = flowChars;
      if (lines6.length === 0) {
        str2 = start + end4;
      } else {
        if (!reqNewline) {
          const len = lines6.reduce((sum3, line2) => sum3 + line2.length + 2, 2);
          reqNewline = len > Collection.Collection.maxFlowStringSingleLineLength;
        }
        if (reqNewline) {
          str2 = start;
          for (const line2 of lines6)
            str2 += line2 ? `
${indentStep}${indent3}${line2}` : "\n";
          str2 += `
${indent3}${end4}`;
        } else {
          str2 = `${start}${fcPadding}${lines6.join(" ")}${fcPadding}${end4}`;
        }
      }
      if (comment2) {
        str2 += stringifyComment.lineComment(str2, indent3, commentString(comment2));
        if (onComment)
          onComment();
      }
      return str2;
    }
    function addCommentBefore({ indent: indent3, options: { commentString } }, lines6, comment2, chompKeep) {
      if (comment2 && chompKeep)
        comment2 = comment2.replace(/^\n+/, "");
      if (comment2) {
        const ic = stringifyComment.indentComment(commentString(comment2), indent3);
        lines6.push(ic.trimStart());
      }
    }
    exports.stringifyCollection = stringifyCollection;
  }
});

// node_modules/yaml/dist/nodes/YAMLMap.js
var require_YAMLMap = __commonJS({
  "node_modules/yaml/dist/nodes/YAMLMap.js"(exports) {
    "use strict";
    var stringifyCollection = require_stringifyCollection();
    var addPairToJSMap = require_addPairToJSMap();
    var Collection = require_Collection();
    var identity33 = require_identity();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    function findPair(items, key) {
      const k = identity33.isScalar(key) ? key.value : key;
      for (const it of items) {
        if (identity33.isPair(it)) {
          if (it.key === key || it.key === k)
            return it;
          if (identity33.isScalar(it.key) && it.key.value === k)
            return it;
        }
      }
      return void 0;
    }
    var YAMLMap = class extends Collection.Collection {
      static get tagName() {
        return "tag:yaml.org,2002:map";
      }
      constructor(schema) {
        super(identity33.MAP, schema);
        this.items = [];
      }
      /**
       * A generic collection parsing method that can be extended
       * to other node classes that inherit from YAMLMap
       */
      static from(schema, obj, ctx) {
        const { keepUndefined, replacer } = ctx;
        const map86 = new this(schema);
        const add3 = (key, value4) => {
          if (typeof replacer === "function")
            value4 = replacer.call(obj, key, value4);
          else if (Array.isArray(replacer) && !replacer.includes(key))
            return;
          if (value4 !== void 0 || keepUndefined)
            map86.items.push(Pair.createPair(key, value4, ctx));
        };
        if (obj instanceof Map) {
          for (const [key, value4] of obj)
            add3(key, value4);
        } else if (obj && typeof obj === "object") {
          for (const key of Object.keys(obj))
            add3(key, obj[key]);
        }
        if (typeof schema.sortMapEntries === "function") {
          map86.items.sort(schema.sortMapEntries);
        }
        return map86;
      }
      /**
       * Adds a value to the collection.
       *
       * @param overwrite - If not set `true`, using a key that is already in the
       *   collection will throw. Otherwise, overwrites the previous value.
       */
      add(pair, overwrite) {
        let _pair;
        if (identity33.isPair(pair))
          _pair = pair;
        else if (!pair || typeof pair !== "object" || !("key" in pair)) {
          _pair = new Pair.Pair(pair, pair?.value);
        } else
          _pair = new Pair.Pair(pair.key, pair.value);
        const prev = findPair(this.items, _pair.key);
        const sortEntries = this.schema?.sortMapEntries;
        if (prev) {
          if (!overwrite)
            throw new Error(`Key ${_pair.key} already set`);
          if (identity33.isScalar(prev.value) && Scalar.isScalarValue(_pair.value))
            prev.value.value = _pair.value;
          else
            prev.value = _pair.value;
        } else if (sortEntries) {
          const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
          if (i === -1)
            this.items.push(_pair);
          else
            this.items.splice(i, 0, _pair);
        } else {
          this.items.push(_pair);
        }
      }
      delete(key) {
        const it = findPair(this.items, key);
        if (!it)
          return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const it = findPair(this.items, key);
        const node = it?.value;
        return (!keepScalar && identity33.isScalar(node) ? node.value : node) ?? void 0;
      }
      has(key) {
        return !!findPair(this.items, key);
      }
      set(key, value4) {
        this.add(new Pair.Pair(key, value4), true);
      }
      /**
       * @param ctx - Conversion context, originally set in Document#toJS()
       * @param {Class} Type - If set, forces the returned collection type
       * @returns Instance of Type, Map, or Object
       */
      toJSON(_, ctx, Type) {
        const map86 = Type ? new Type() : ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
        if (ctx?.onCreate)
          ctx.onCreate(map86);
        for (const item of this.items)
          addPairToJSMap.addPairToJSMap(ctx, map86, item);
        return map86;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        for (const item of this.items) {
          if (!identity33.isPair(item))
            throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        if (!ctx.allNullValues && this.hasAllNullValues(false))
          ctx = Object.assign({}, ctx, { allNullValues: true });
        return stringifyCollection.stringifyCollection(this, ctx, {
          blockItemPrefix: "",
          flowChars: { start: "{", end: "}" },
          itemIndent: ctx.indent || "",
          onChompKeep,
          onComment
        });
      }
    };
    exports.YAMLMap = YAMLMap;
    exports.findPair = findPair;
  }
});

// node_modules/yaml/dist/schema/common/map.js
var require_map = __commonJS({
  "node_modules/yaml/dist/schema/common/map.js"(exports) {
    "use strict";
    var identity33 = require_identity();
    var YAMLMap = require_YAMLMap();
    var map86 = {
      collection: "map",
      default: true,
      nodeClass: YAMLMap.YAMLMap,
      tag: "tag:yaml.org,2002:map",
      resolve(map87, onError3) {
        if (!identity33.isMap(map87))
          onError3("Expected a mapping for this tag");
        return map87;
      },
      createNode: (schema, obj, ctx) => YAMLMap.YAMLMap.from(schema, obj, ctx)
    };
    exports.map = map86;
  }
});

// node_modules/yaml/dist/nodes/YAMLSeq.js
var require_YAMLSeq = __commonJS({
  "node_modules/yaml/dist/nodes/YAMLSeq.js"(exports) {
    "use strict";
    var createNode = require_createNode();
    var stringifyCollection = require_stringifyCollection();
    var Collection = require_Collection();
    var identity33 = require_identity();
    var Scalar = require_Scalar();
    var toJS = require_toJS();
    var YAMLSeq = class extends Collection.Collection {
      static get tagName() {
        return "tag:yaml.org,2002:seq";
      }
      constructor(schema) {
        super(identity33.SEQ, schema);
        this.items = [];
      }
      add(value4) {
        this.items.push(value4);
      }
      /**
       * Removes a value from the collection.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       *
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return void 0;
        const it = this.items[idx];
        return !keepScalar && identity33.isScalar(it) ? it.value : it;
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       */
      has(key) {
        const idx = asItemIndex(key);
        return typeof idx === "number" && idx < this.items.length;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       *
       * If `key` does not contain a representation of an integer, this will throw.
       * It may be wrapped in a `Scalar`.
       */
      set(key, value4) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          throw new Error(`Expected a valid index, not ${key}.`);
        const prev = this.items[idx];
        if (identity33.isScalar(prev) && Scalar.isScalarValue(value4))
          prev.value = value4;
        else
          this.items[idx] = value4;
      }
      toJSON(_, ctx) {
        const seq = [];
        if (ctx?.onCreate)
          ctx.onCreate(seq);
        let i = 0;
        for (const item of this.items)
          seq.push(toJS.toJS(item, String(i++), ctx));
        return seq;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        return stringifyCollection.stringifyCollection(this, ctx, {
          blockItemPrefix: "- ",
          flowChars: { start: "[", end: "]" },
          itemIndent: (ctx.indent || "") + "  ",
          onChompKeep,
          onComment
        });
      }
      static from(schema, obj, ctx) {
        const { replacer } = ctx;
        const seq = new this(schema);
        if (obj && Symbol.iterator in Object(obj)) {
          let i = 0;
          for (let it of obj) {
            if (typeof replacer === "function") {
              const key = obj instanceof Set ? it : String(i++);
              it = replacer.call(obj, key, it);
            }
            seq.items.push(createNode.createNode(it, void 0, ctx));
          }
        }
        return seq;
      }
    };
    function asItemIndex(key) {
      let idx = identity33.isScalar(key) ? key.value : key;
      if (idx && typeof idx === "string")
        idx = Number(idx);
      return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
    }
    exports.YAMLSeq = YAMLSeq;
  }
});

// node_modules/yaml/dist/schema/common/seq.js
var require_seq = __commonJS({
  "node_modules/yaml/dist/schema/common/seq.js"(exports) {
    "use strict";
    var identity33 = require_identity();
    var YAMLSeq = require_YAMLSeq();
    var seq = {
      collection: "seq",
      default: true,
      nodeClass: YAMLSeq.YAMLSeq,
      tag: "tag:yaml.org,2002:seq",
      resolve(seq2, onError3) {
        if (!identity33.isSeq(seq2))
          onError3("Expected a sequence for this tag");
        return seq2;
      },
      createNode: (schema, obj, ctx) => YAMLSeq.YAMLSeq.from(schema, obj, ctx)
    };
    exports.seq = seq;
  }
});

// node_modules/yaml/dist/schema/common/string.js
var require_string = __commonJS({
  "node_modules/yaml/dist/schema/common/string.js"(exports) {
    "use strict";
    var stringifyString = require_stringifyString();
    var string7 = {
      identify: (value4) => typeof value4 === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: (str2) => str2,
      stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({ actualString: true }, ctx);
        return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);
      }
    };
    exports.string = string7;
  }
});

// node_modules/yaml/dist/schema/common/null.js
var require_null = __commonJS({
  "node_modules/yaml/dist/schema/common/null.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var nullTag = {
      identify: (value4) => value4 == null,
      createNode: () => new Scalar.Scalar(null),
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => new Scalar.Scalar(null),
      stringify: ({ source: source2 }, ctx) => typeof source2 === "string" && nullTag.test.test(source2) ? source2 : ctx.options.nullStr
    };
    exports.nullTag = nullTag;
  }
});

// node_modules/yaml/dist/schema/core/bool.js
var require_bool = __commonJS({
  "node_modules/yaml/dist/schema/core/bool.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var boolTag = {
      identify: (value4) => typeof value4 === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
      resolve: (str2) => new Scalar.Scalar(str2[0] === "t" || str2[0] === "T"),
      stringify({ source: source2, value: value4 }, ctx) {
        if (source2 && boolTag.test.test(source2)) {
          const sv = source2[0] === "t" || source2[0] === "T";
          if (value4 === sv)
            return source2;
        }
        return value4 ? ctx.options.trueStr : ctx.options.falseStr;
      }
    };
    exports.boolTag = boolTag;
  }
});

// node_modules/yaml/dist/stringify/stringifyNumber.js
var require_stringifyNumber = __commonJS({
  "node_modules/yaml/dist/stringify/stringifyNumber.js"(exports) {
    "use strict";
    function stringifyNumber({ format: format2, minFractionDigits, tag, value: value4 }) {
      if (typeof value4 === "bigint")
        return String(value4);
      const num = typeof value4 === "number" ? value4 : Number(value4);
      if (!isFinite(num))
        return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
      let n = JSON.stringify(value4);
      if (!format2 && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
        let i = n.indexOf(".");
        if (i < 0) {
          i = n.length;
          n += ".";
        }
        let d = minFractionDigits - (n.length - i - 1);
        while (d-- > 0)
          n += "0";
      }
      return n;
    }
    exports.stringifyNumber = stringifyNumber;
  }
});

// node_modules/yaml/dist/schema/core/float.js
var require_float = __commonJS({
  "node_modules/yaml/dist/schema/core/float.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var stringifyNumber = require_stringifyNumber();
    var floatNaN = {
      identify: (value4) => typeof value4 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN))$/,
      resolve: (str2) => str2.slice(-3).toLowerCase() === "nan" ? NaN : str2[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber.stringifyNumber
    };
    var floatExp = {
      identify: (value4) => typeof value4 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
      resolve: (str2) => parseFloat(str2),
      stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
      }
    };
    var float = {
      identify: (value4) => typeof value4 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
      resolve(str2) {
        const node = new Scalar.Scalar(parseFloat(str2));
        const dot = str2.indexOf(".");
        if (dot !== -1 && str2[str2.length - 1] === "0")
          node.minFractionDigits = str2.length - dot - 1;
        return node;
      },
      stringify: stringifyNumber.stringifyNumber
    };
    exports.float = float;
    exports.floatExp = floatExp;
    exports.floatNaN = floatNaN;
  }
});

// node_modules/yaml/dist/schema/core/int.js
var require_int = __commonJS({
  "node_modules/yaml/dist/schema/core/int.js"(exports) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    var intIdentify = (value4) => typeof value4 === "bigint" || Number.isInteger(value4);
    var intResolve = (str2, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str2) : parseInt(str2.substring(offset), radix);
    function intStringify(node, radix, prefix4) {
      const { value: value4 } = node;
      if (intIdentify(value4) && value4 >= 0)
        return prefix4 + value4.toString(radix);
      return stringifyNumber.stringifyNumber(node);
    }
    var intOct = {
      identify: (value4) => intIdentify(value4) && value4 >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^0o[0-7]+$/,
      resolve: (str2, _onError, opt) => intResolve(str2, 2, 8, opt),
      stringify: (node) => intStringify(node, 8, "0o")
    };
    var int = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9]+$/,
      resolve: (str2, _onError, opt) => intResolve(str2, 0, 10, opt),
      stringify: stringifyNumber.stringifyNumber
    };
    var intHex = {
      identify: (value4) => intIdentify(value4) && value4 >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^0x[0-9a-fA-F]+$/,
      resolve: (str2, _onError, opt) => intResolve(str2, 2, 16, opt),
      stringify: (node) => intStringify(node, 16, "0x")
    };
    exports.int = int;
    exports.intHex = intHex;
    exports.intOct = intOct;
  }
});

// node_modules/yaml/dist/schema/core/schema.js
var require_schema = __commonJS({
  "node_modules/yaml/dist/schema/core/schema.js"(exports) {
    "use strict";
    var map86 = require_map();
    var _null = require_null();
    var seq = require_seq();
    var string7 = require_string();
    var bool = require_bool();
    var float = require_float();
    var int = require_int();
    var schema = [
      map86.map,
      seq.seq,
      string7.string,
      _null.nullTag,
      bool.boolTag,
      int.intOct,
      int.int,
      int.intHex,
      float.floatNaN,
      float.floatExp,
      float.float
    ];
    exports.schema = schema;
  }
});

// node_modules/yaml/dist/schema/json/schema.js
var require_schema2 = __commonJS({
  "node_modules/yaml/dist/schema/json/schema.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var map86 = require_map();
    var seq = require_seq();
    function intIdentify(value4) {
      return typeof value4 === "bigint" || Number.isInteger(value4);
    }
    var stringifyJSON = ({ value: value4 }) => JSON.stringify(value4);
    var jsonScalars = [
      {
        identify: (value4) => typeof value4 === "string",
        default: true,
        tag: "tag:yaml.org,2002:str",
        resolve: (str2) => str2,
        stringify: stringifyJSON
      },
      {
        identify: (value4) => value4 == null,
        createNode: () => new Scalar.Scalar(null),
        default: true,
        tag: "tag:yaml.org,2002:null",
        test: /^null$/,
        resolve: () => null,
        stringify: stringifyJSON
      },
      {
        identify: (value4) => typeof value4 === "boolean",
        default: true,
        tag: "tag:yaml.org,2002:bool",
        test: /^true|false$/,
        resolve: (str2) => str2 === "true",
        stringify: stringifyJSON
      },
      {
        identify: intIdentify,
        default: true,
        tag: "tag:yaml.org,2002:int",
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: (str2, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str2) : parseInt(str2, 10),
        stringify: ({ value: value4 }) => intIdentify(value4) ? value4.toString() : JSON.stringify(value4)
      },
      {
        identify: (value4) => typeof value4 === "number",
        default: true,
        tag: "tag:yaml.org,2002:float",
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: (str2) => parseFloat(str2),
        stringify: stringifyJSON
      }
    ];
    var jsonError = {
      default: true,
      tag: "",
      test: /^/,
      resolve(str2, onError3) {
        onError3(`Unresolved plain scalar ${JSON.stringify(str2)}`);
        return str2;
      }
    };
    var schema = [map86.map, seq.seq].concat(jsonScalars, jsonError);
    exports.schema = schema;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/binary.js
var require_binary = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/binary.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var stringifyString = require_stringifyString();
    var binary = {
      identify: (value4) => value4 instanceof Uint8Array,
      default: false,
      tag: "tag:yaml.org,2002:binary",
      /**
       * Returns a Buffer in node and an Uint8Array in browsers
       *
       * To use the resulting buffer as an image, you'll want to do something like:
       *
       *   const blob = new Blob([buffer], { type: 'image/jpeg' })
       *   document.querySelector('#photo').src = URL.createObjectURL(blob)
       */
      resolve(src, onError3) {
        if (typeof Buffer === "function") {
          return Buffer.from(src, "base64");
        } else if (typeof atob === "function") {
          const str2 = atob(src.replace(/[\n\r]/g, ""));
          const buffer = new Uint8Array(str2.length);
          for (let i = 0; i < str2.length; ++i)
            buffer[i] = str2.charCodeAt(i);
          return buffer;
        } else {
          onError3("This environment does not support reading binary tags; either Buffer or atob is required");
          return src;
        }
      },
      stringify({ comment: comment2, type, value: value4 }, ctx, onComment, onChompKeep) {
        const buf = value4;
        let str2;
        if (typeof Buffer === "function") {
          str2 = buf instanceof Buffer ? buf.toString("base64") : Buffer.from(buf.buffer).toString("base64");
        } else if (typeof btoa === "function") {
          let s = "";
          for (let i = 0; i < buf.length; ++i)
            s += String.fromCharCode(buf[i]);
          str2 = btoa(s);
        } else {
          throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
        }
        if (!type)
          type = Scalar.Scalar.BLOCK_LITERAL;
        if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
          const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
          const n = Math.ceil(str2.length / lineWidth);
          const lines6 = new Array(n);
          for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
            lines6[i] = str2.substr(o, lineWidth);
          }
          str2 = lines6.join(type === Scalar.Scalar.BLOCK_LITERAL ? "\n" : " ");
        }
        return stringifyString.stringifyString({ comment: comment2, type, value: str2 }, ctx, onComment, onChompKeep);
      }
    };
    exports.binary = binary;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/pairs.js
var require_pairs = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/pairs.js"(exports) {
    "use strict";
    var identity33 = require_identity();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    var YAMLSeq = require_YAMLSeq();
    function resolvePairs(seq, onError3) {
      if (identity33.isSeq(seq)) {
        for (let i = 0; i < seq.items.length; ++i) {
          let item = seq.items[i];
          if (identity33.isPair(item))
            continue;
          else if (identity33.isMap(item)) {
            if (item.items.length > 1)
              onError3("Each pair must have its own sequence indicator");
            const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
            if (item.commentBefore)
              pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
            if (item.comment) {
              const cn = pair.value ?? pair.key;
              cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
            }
            item = pair;
          }
          seq.items[i] = identity33.isPair(item) ? item : new Pair.Pair(item);
        }
      } else
        onError3("Expected a sequence for this tag");
      return seq;
    }
    function createPairs(schema, iterable, ctx) {
      const { replacer } = ctx;
      const pairs2 = new YAMLSeq.YAMLSeq(schema);
      pairs2.tag = "tag:yaml.org,2002:pairs";
      let i = 0;
      if (iterable && Symbol.iterator in Object(iterable))
        for (let it of iterable) {
          if (typeof replacer === "function")
            it = replacer.call(iterable, String(i++), it);
          let key, value4;
          if (Array.isArray(it)) {
            if (it.length === 2) {
              key = it[0];
              value4 = it[1];
            } else
              throw new TypeError(`Expected [key, value] tuple: ${it}`);
          } else if (it && it instanceof Object) {
            const keys4 = Object.keys(it);
            if (keys4.length === 1) {
              key = keys4[0];
              value4 = it[key];
            } else
              throw new TypeError(`Expected { key: value } tuple: ${it}`);
          } else {
            key = it;
          }
          pairs2.items.push(Pair.createPair(key, value4, ctx));
        }
      return pairs2;
    }
    var pairs = {
      collection: "seq",
      default: false,
      tag: "tag:yaml.org,2002:pairs",
      resolve: resolvePairs,
      createNode: createPairs
    };
    exports.createPairs = createPairs;
    exports.pairs = pairs;
    exports.resolvePairs = resolvePairs;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/omap.js
var require_omap = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/omap.js"(exports) {
    "use strict";
    var identity33 = require_identity();
    var toJS = require_toJS();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var pairs = require_pairs();
    var YAMLOMap = class _YAMLOMap extends YAMLSeq.YAMLSeq {
      constructor() {
        super();
        this.add = YAMLMap.YAMLMap.prototype.add.bind(this);
        this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);
        this.get = YAMLMap.YAMLMap.prototype.get.bind(this);
        this.has = YAMLMap.YAMLMap.prototype.has.bind(this);
        this.set = YAMLMap.YAMLMap.prototype.set.bind(this);
        this.tag = _YAMLOMap.tag;
      }
      /**
       * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
       * but TypeScript won't allow widening the signature of a child method.
       */
      toJSON(_, ctx) {
        if (!ctx)
          return super.toJSON(_);
        const map86 = /* @__PURE__ */ new Map();
        if (ctx?.onCreate)
          ctx.onCreate(map86);
        for (const pair of this.items) {
          let key, value4;
          if (identity33.isPair(pair)) {
            key = toJS.toJS(pair.key, "", ctx);
            value4 = toJS.toJS(pair.value, key, ctx);
          } else {
            key = toJS.toJS(pair, "", ctx);
          }
          if (map86.has(key))
            throw new Error("Ordered maps must not include duplicate keys");
          map86.set(key, value4);
        }
        return map86;
      }
      static from(schema, iterable, ctx) {
        const pairs$1 = pairs.createPairs(schema, iterable, ctx);
        const omap2 = new this();
        omap2.items = pairs$1.items;
        return omap2;
      }
    };
    YAMLOMap.tag = "tag:yaml.org,2002:omap";
    var omap = {
      collection: "seq",
      identify: (value4) => value4 instanceof Map,
      nodeClass: YAMLOMap,
      default: false,
      tag: "tag:yaml.org,2002:omap",
      resolve(seq, onError3) {
        const pairs$1 = pairs.resolvePairs(seq, onError3);
        const seenKeys = [];
        for (const { key } of pairs$1.items) {
          if (identity33.isScalar(key)) {
            if (seenKeys.includes(key.value)) {
              onError3(`Ordered maps must not include duplicate keys: ${key.value}`);
            } else {
              seenKeys.push(key.value);
            }
          }
        }
        return Object.assign(new YAMLOMap(), pairs$1);
      },
      createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)
    };
    exports.YAMLOMap = YAMLOMap;
    exports.omap = omap;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/bool.js
var require_bool2 = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/bool.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    function boolStringify({ value: value4, source: source2 }, ctx) {
      const boolObj = value4 ? trueTag : falseTag;
      if (source2 && boolObj.test.test(source2))
        return source2;
      return value4 ? ctx.options.trueStr : ctx.options.falseStr;
    }
    var trueTag = {
      identify: (value4) => value4 === true,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
      resolve: () => new Scalar.Scalar(true),
      stringify: boolStringify
    };
    var falseTag = {
      identify: (value4) => value4 === false,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
      resolve: () => new Scalar.Scalar(false),
      stringify: boolStringify
    };
    exports.falseTag = falseTag;
    exports.trueTag = trueTag;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/float.js
var require_float2 = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/float.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var stringifyNumber = require_stringifyNumber();
    var floatNaN = {
      identify: (value4) => typeof value4 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN)$/,
      resolve: (str2) => str2.slice(-3).toLowerCase() === "nan" ? NaN : str2[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber.stringifyNumber
    };
    var floatExp = {
      identify: (value4) => typeof value4 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
      resolve: (str2) => parseFloat(str2.replace(/_/g, "")),
      stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
      }
    };
    var float = {
      identify: (value4) => typeof value4 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
      resolve(str2) {
        const node = new Scalar.Scalar(parseFloat(str2.replace(/_/g, "")));
        const dot = str2.indexOf(".");
        if (dot !== -1) {
          const f = str2.substring(dot + 1).replace(/_/g, "");
          if (f[f.length - 1] === "0")
            node.minFractionDigits = f.length;
        }
        return node;
      },
      stringify: stringifyNumber.stringifyNumber
    };
    exports.float = float;
    exports.floatExp = floatExp;
    exports.floatNaN = floatNaN;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/int.js
var require_int2 = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/int.js"(exports) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    var intIdentify = (value4) => typeof value4 === "bigint" || Number.isInteger(value4);
    function intResolve(str2, offset, radix, { intAsBigInt }) {
      const sign2 = str2[0];
      if (sign2 === "-" || sign2 === "+")
        offset += 1;
      str2 = str2.substring(offset).replace(/_/g, "");
      if (intAsBigInt) {
        switch (radix) {
          case 2:
            str2 = `0b${str2}`;
            break;
          case 8:
            str2 = `0o${str2}`;
            break;
          case 16:
            str2 = `0x${str2}`;
            break;
        }
        const n2 = BigInt(str2);
        return sign2 === "-" ? BigInt(-1) * n2 : n2;
      }
      const n = parseInt(str2, radix);
      return sign2 === "-" ? -1 * n : n;
    }
    function intStringify(node, radix, prefix4) {
      const { value: value4 } = node;
      if (intIdentify(value4)) {
        const str2 = value4.toString(radix);
        return value4 < 0 ? "-" + prefix4 + str2.substr(1) : prefix4 + str2;
      }
      return stringifyNumber.stringifyNumber(node);
    }
    var intBin = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "BIN",
      test: /^[-+]?0b[0-1_]+$/,
      resolve: (str2, _onError, opt) => intResolve(str2, 2, 2, opt),
      stringify: (node) => intStringify(node, 2, "0b")
    };
    var intOct = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^[-+]?0[0-7_]+$/,
      resolve: (str2, _onError, opt) => intResolve(str2, 1, 8, opt),
      stringify: (node) => intStringify(node, 8, "0")
    };
    var int = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9][0-9_]*$/,
      resolve: (str2, _onError, opt) => intResolve(str2, 0, 10, opt),
      stringify: stringifyNumber.stringifyNumber
    };
    var intHex = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^[-+]?0x[0-9a-fA-F_]+$/,
      resolve: (str2, _onError, opt) => intResolve(str2, 2, 16, opt),
      stringify: (node) => intStringify(node, 16, "0x")
    };
    exports.int = int;
    exports.intBin = intBin;
    exports.intHex = intHex;
    exports.intOct = intOct;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/set.js
var require_set = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/set.js"(exports) {
    "use strict";
    var identity33 = require_identity();
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var YAMLSet = class _YAMLSet extends YAMLMap.YAMLMap {
      constructor(schema) {
        super(schema);
        this.tag = _YAMLSet.tag;
      }
      add(key) {
        let pair;
        if (identity33.isPair(key))
          pair = key;
        else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
          pair = new Pair.Pair(key.key, null);
        else
          pair = new Pair.Pair(key, null);
        const prev = YAMLMap.findPair(this.items, pair.key);
        if (!prev)
          this.items.push(pair);
      }
      /**
       * If `keepPair` is `true`, returns the Pair matching `key`.
       * Otherwise, returns the value of that Pair's key.
       */
      get(key, keepPair) {
        const pair = YAMLMap.findPair(this.items, key);
        return !keepPair && identity33.isPair(pair) ? identity33.isScalar(pair.key) ? pair.key.value : pair.key : pair;
      }
      set(key, value4) {
        if (typeof value4 !== "boolean")
          throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value4}`);
        const prev = YAMLMap.findPair(this.items, key);
        if (prev && !value4) {
          this.items.splice(this.items.indexOf(prev), 1);
        } else if (!prev && value4) {
          this.items.push(new Pair.Pair(key));
        }
      }
      toJSON(_, ctx) {
        return super.toJSON(_, ctx, Set);
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        if (this.hasAllNullValues(true))
          return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
        else
          throw new Error("Set items must all have null values");
      }
      static from(schema, iterable, ctx) {
        const { replacer } = ctx;
        const set3 = new this(schema);
        if (iterable && Symbol.iterator in Object(iterable))
          for (let value4 of iterable) {
            if (typeof replacer === "function")
              value4 = replacer.call(iterable, value4, value4);
            set3.items.push(Pair.createPair(value4, null, ctx));
          }
        return set3;
      }
    };
    YAMLSet.tag = "tag:yaml.org,2002:set";
    var set2 = {
      collection: "map",
      identify: (value4) => value4 instanceof Set,
      nodeClass: YAMLSet,
      default: false,
      tag: "tag:yaml.org,2002:set",
      createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),
      resolve(map86, onError3) {
        if (identity33.isMap(map86)) {
          if (map86.hasAllNullValues(true))
            return Object.assign(new YAMLSet(), map86);
          else
            onError3("Set items must all have null values");
        } else
          onError3("Expected a mapping for this tag");
        return map86;
      }
    };
    exports.YAMLSet = YAMLSet;
    exports.set = set2;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/timestamp.js"(exports) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    function parseSexagesimal(str2, asBigInt) {
      const sign2 = str2[0];
      const parts = sign2 === "-" || sign2 === "+" ? str2.substring(1) : str2;
      const num = (n) => asBigInt ? BigInt(n) : Number(n);
      const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
      return sign2 === "-" ? num(-1) * res : res;
    }
    function stringifySexagesimal(node) {
      let { value: value4 } = node;
      let num = (n) => n;
      if (typeof value4 === "bigint")
        num = (n) => BigInt(n);
      else if (isNaN(value4) || !isFinite(value4))
        return stringifyNumber.stringifyNumber(node);
      let sign2 = "";
      if (value4 < 0) {
        sign2 = "-";
        value4 *= num(-1);
      }
      const _60 = num(60);
      const parts = [value4 % _60];
      if (value4 < 60) {
        parts.unshift(0);
      } else {
        value4 = (value4 - parts[0]) / _60;
        parts.unshift(value4 % _60);
        if (value4 >= 60) {
          value4 = (value4 - parts[0]) / _60;
          parts.unshift(value4);
        }
      }
      return sign2 + parts.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
    }
    var intTime = {
      identify: (value4) => typeof value4 === "bigint" || Number.isInteger(value4),
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
      resolve: (str2, _onError, { intAsBigInt }) => parseSexagesimal(str2, intAsBigInt),
      stringify: stringifySexagesimal
    };
    var floatTime = {
      identify: (value4) => typeof value4 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
      resolve: (str2) => parseSexagesimal(str2, false),
      stringify: stringifySexagesimal
    };
    var timestamp = {
      identify: (value4) => value4 instanceof Date,
      default: true,
      tag: "tag:yaml.org,2002:timestamp",
      // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
      // may be omitted altogether, resulting in a date format. In such a case, the time part is
      // assumed to be 00:00:00Z (start of day, UTC).
      test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
      resolve(str2) {
        const match4 = str2.match(timestamp.test);
        if (!match4)
          throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
        const [, year2, month2, day2, hour2, minute2, second3] = match4.map(Number);
        const millisec = match4[7] ? Number((match4[7] + "00").substr(1, 3)) : 0;
        let date2 = Date.UTC(year2, month2 - 1, day2, hour2 || 0, minute2 || 0, second3 || 0, millisec);
        const tz = match4[8];
        if (tz && tz !== "Z") {
          let d = parseSexagesimal(tz, false);
          if (Math.abs(d) < 30)
            d *= 60;
          date2 -= 6e4 * d;
        }
        return new Date(date2);
      },
      stringify: ({ value: value4 }) => value4.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
    };
    exports.floatTime = floatTime;
    exports.intTime = intTime;
    exports.timestamp = timestamp;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/schema.js
var require_schema3 = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/schema.js"(exports) {
    "use strict";
    var map86 = require_map();
    var _null = require_null();
    var seq = require_seq();
    var string7 = require_string();
    var binary = require_binary();
    var bool = require_bool2();
    var float = require_float2();
    var int = require_int2();
    var omap = require_omap();
    var pairs = require_pairs();
    var set2 = require_set();
    var timestamp = require_timestamp();
    var schema = [
      map86.map,
      seq.seq,
      string7.string,
      _null.nullTag,
      bool.trueTag,
      bool.falseTag,
      int.intBin,
      int.intOct,
      int.int,
      int.intHex,
      float.floatNaN,
      float.floatExp,
      float.float,
      binary.binary,
      omap.omap,
      pairs.pairs,
      set2.set,
      timestamp.intTime,
      timestamp.floatTime,
      timestamp.timestamp
    ];
    exports.schema = schema;
  }
});

// node_modules/yaml/dist/schema/tags.js
var require_tags = __commonJS({
  "node_modules/yaml/dist/schema/tags.js"(exports) {
    "use strict";
    var map86 = require_map();
    var _null = require_null();
    var seq = require_seq();
    var string7 = require_string();
    var bool = require_bool();
    var float = require_float();
    var int = require_int();
    var schema = require_schema();
    var schema$1 = require_schema2();
    var binary = require_binary();
    var omap = require_omap();
    var pairs = require_pairs();
    var schema$2 = require_schema3();
    var set2 = require_set();
    var timestamp = require_timestamp();
    var schemas = /* @__PURE__ */ new Map([
      ["core", schema.schema],
      ["failsafe", [map86.map, seq.seq, string7.string]],
      ["json", schema$1.schema],
      ["yaml11", schema$2.schema],
      ["yaml-1.1", schema$2.schema]
    ]);
    var tagsByName = {
      binary: binary.binary,
      bool: bool.boolTag,
      float: float.float,
      floatExp: float.floatExp,
      floatNaN: float.floatNaN,
      floatTime: timestamp.floatTime,
      int: int.int,
      intHex: int.intHex,
      intOct: int.intOct,
      intTime: timestamp.intTime,
      map: map86.map,
      null: _null.nullTag,
      omap: omap.omap,
      pairs: pairs.pairs,
      seq: seq.seq,
      set: set2.set,
      timestamp: timestamp.timestamp
    };
    var coreKnownTags = {
      "tag:yaml.org,2002:binary": binary.binary,
      "tag:yaml.org,2002:omap": omap.omap,
      "tag:yaml.org,2002:pairs": pairs.pairs,
      "tag:yaml.org,2002:set": set2.set,
      "tag:yaml.org,2002:timestamp": timestamp.timestamp
    };
    function getTags(customTags, schemaName) {
      let tags = schemas.get(schemaName);
      if (!tags) {
        if (Array.isArray(customTags))
          tags = [];
        else {
          const keys4 = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
          throw new Error(`Unknown schema "${schemaName}"; use one of ${keys4} or define customTags array`);
        }
      }
      if (Array.isArray(customTags)) {
        for (const tag of customTags)
          tags = tags.concat(tag);
      } else if (typeof customTags === "function") {
        tags = customTags(tags.slice());
      }
      return tags.map((tag) => {
        if (typeof tag !== "string")
          return tag;
        const tagObj = tagsByName[tag];
        if (tagObj)
          return tagObj;
        const keys4 = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
        throw new Error(`Unknown custom tag "${tag}"; use one of ${keys4}`);
      });
    }
    exports.coreKnownTags = coreKnownTags;
    exports.getTags = getTags;
  }
});

// node_modules/yaml/dist/schema/Schema.js
var require_Schema = __commonJS({
  "node_modules/yaml/dist/schema/Schema.js"(exports) {
    "use strict";
    var identity33 = require_identity();
    var map86 = require_map();
    var seq = require_seq();
    var string7 = require_string();
    var tags = require_tags();
    var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
    var Schema = class _Schema {
      constructor({ compat, customTags, merge: merge4, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {
        this.compat = Array.isArray(compat) ? tags.getTags(compat, "compat") : compat ? tags.getTags(null, compat) : null;
        this.merge = !!merge4;
        this.name = typeof schema === "string" && schema || "core";
        this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};
        this.tags = tags.getTags(customTags, this.name);
        this.toStringOptions = toStringDefaults ?? null;
        Object.defineProperty(this, identity33.MAP, { value: map86.map });
        Object.defineProperty(this, identity33.SCALAR, { value: string7.string });
        Object.defineProperty(this, identity33.SEQ, { value: seq.seq });
        this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
      }
      clone() {
        const copy3 = Object.create(_Schema.prototype, Object.getOwnPropertyDescriptors(this));
        copy3.tags = this.tags.slice();
        return copy3;
      }
    };
    exports.Schema = Schema;
  }
});

// node_modules/yaml/dist/stringify/stringifyDocument.js
var require_stringifyDocument = __commonJS({
  "node_modules/yaml/dist/stringify/stringifyDocument.js"(exports) {
    "use strict";
    var identity33 = require_identity();
    var stringify3 = require_stringify();
    var stringifyComment = require_stringifyComment();
    function stringifyDocument(doc, options) {
      const lines6 = [];
      let hasDirectives = options.directives === true;
      if (options.directives !== false && doc.directives) {
        const dir = doc.directives.toString(doc);
        if (dir) {
          lines6.push(dir);
          hasDirectives = true;
        } else if (doc.directives.docStart)
          hasDirectives = true;
      }
      if (hasDirectives)
        lines6.push("---");
      const ctx = stringify3.createStringifyContext(doc, options);
      const { commentString } = ctx.options;
      if (doc.commentBefore) {
        if (lines6.length !== 1)
          lines6.unshift("");
        const cs = commentString(doc.commentBefore);
        lines6.unshift(stringifyComment.indentComment(cs, ""));
      }
      let chompKeep = false;
      let contentComment = null;
      if (doc.contents) {
        if (identity33.isNode(doc.contents)) {
          if (doc.contents.spaceBefore && hasDirectives)
            lines6.push("");
          if (doc.contents.commentBefore) {
            const cs = commentString(doc.contents.commentBefore);
            lines6.push(stringifyComment.indentComment(cs, ""));
          }
          ctx.forceBlockIndent = !!doc.comment;
          contentComment = doc.contents.comment;
        }
        const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
        let body = stringify3.stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
        if (contentComment)
          body += stringifyComment.lineComment(body, "", commentString(contentComment));
        if ((body[0] === "|" || body[0] === ">") && lines6[lines6.length - 1] === "---") {
          lines6[lines6.length - 1] = `--- ${body}`;
        } else
          lines6.push(body);
      } else {
        lines6.push(stringify3.stringify(doc.contents, ctx));
      }
      if (doc.directives?.docEnd) {
        if (doc.comment) {
          const cs = commentString(doc.comment);
          if (cs.includes("\n")) {
            lines6.push("...");
            lines6.push(stringifyComment.indentComment(cs, ""));
          } else {
            lines6.push(`... ${cs}`);
          }
        } else {
          lines6.push("...");
        }
      } else {
        let dc = doc.comment;
        if (dc && chompKeep)
          dc = dc.replace(/^\n+/, "");
        if (dc) {
          if ((!chompKeep || contentComment) && lines6[lines6.length - 1] !== "")
            lines6.push("");
          lines6.push(stringifyComment.indentComment(commentString(dc), ""));
        }
      }
      return lines6.join("\n") + "\n";
    }
    exports.stringifyDocument = stringifyDocument;
  }
});

// node_modules/yaml/dist/doc/Document.js
var require_Document = __commonJS({
  "node_modules/yaml/dist/doc/Document.js"(exports) {
    "use strict";
    var Alias = require_Alias();
    var Collection = require_Collection();
    var identity33 = require_identity();
    var Pair = require_Pair();
    var toJS = require_toJS();
    var Schema = require_Schema();
    var stringifyDocument = require_stringifyDocument();
    var anchors = require_anchors();
    var applyReviver = require_applyReviver();
    var createNode = require_createNode();
    var directives = require_directives();
    var Document3 = class _Document {
      constructor(value4, replacer, options) {
        this.commentBefore = null;
        this.comment = null;
        this.errors = [];
        this.warnings = [];
        Object.defineProperty(this, identity33.NODE_TYPE, { value: identity33.DOC });
        let _replacer = null;
        if (typeof replacer === "function" || Array.isArray(replacer)) {
          _replacer = replacer;
        } else if (options === void 0 && replacer) {
          options = replacer;
          replacer = void 0;
        }
        const opt = Object.assign({
          intAsBigInt: false,
          keepSourceTokens: false,
          logLevel: "warn",
          prettyErrors: true,
          strict: true,
          uniqueKeys: true,
          version: "1.2"
        }, options);
        this.options = opt;
        let { version } = opt;
        if (options?._directives) {
          this.directives = options._directives.atDocument();
          if (this.directives.yaml.explicit)
            version = this.directives.yaml.version;
        } else
          this.directives = new directives.Directives({ version });
        this.setSchema(version, options);
        this.contents = value4 === void 0 ? null : this.createNode(value4, _replacer, options);
      }
      /**
       * Create a deep copy of this Document and its contents.
       *
       * Custom Node values that inherit from `Object` still refer to their original instances.
       */
      clone() {
        const copy3 = Object.create(_Document.prototype, {
          [identity33.NODE_TYPE]: { value: identity33.DOC }
        });
        copy3.commentBefore = this.commentBefore;
        copy3.comment = this.comment;
        copy3.errors = this.errors.slice();
        copy3.warnings = this.warnings.slice();
        copy3.options = Object.assign({}, this.options);
        if (this.directives)
          copy3.directives = this.directives.clone();
        copy3.schema = this.schema.clone();
        copy3.contents = identity33.isNode(this.contents) ? this.contents.clone(copy3.schema) : this.contents;
        if (this.range)
          copy3.range = this.range.slice();
        return copy3;
      }
      /** Adds a value to the document. */
      add(value4) {
        if (assertCollection(this.contents))
          this.contents.add(value4);
      }
      /** Adds a value to the document. */
      addIn(path5, value4) {
        if (assertCollection(this.contents))
          this.contents.addIn(path5, value4);
      }
      /**
       * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
       *
       * If `node` already has an anchor, `name` is ignored.
       * Otherwise, the `node.anchor` value will be set to `name`,
       * or if an anchor with that name is already present in the document,
       * `name` will be used as a prefix for a new unique anchor.
       * If `name` is undefined, the generated anchor will use 'a' as a prefix.
       */
      createAlias(node, name4) {
        if (!node.anchor) {
          const prev = anchors.anchorNames(this);
          node.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          !name4 || prev.has(name4) ? anchors.findNewAnchor(name4 || "a", prev) : name4;
        }
        return new Alias.Alias(node.anchor);
      }
      createNode(value4, replacer, options) {
        let _replacer = void 0;
        if (typeof replacer === "function") {
          value4 = replacer.call({ "": value4 }, "", value4);
          _replacer = replacer;
        } else if (Array.isArray(replacer)) {
          const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
          const asStr = replacer.filter(keyToStr).map(String);
          if (asStr.length > 0)
            replacer = replacer.concat(asStr);
          _replacer = replacer;
        } else if (options === void 0 && replacer) {
          options = replacer;
          replacer = void 0;
        }
        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
        const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(
          this,
          // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          anchorPrefix || "a"
        );
        const ctx = {
          aliasDuplicateObjects: aliasDuplicateObjects ?? true,
          keepUndefined: keepUndefined ?? false,
          onAnchor,
          onTagObj,
          replacer: _replacer,
          schema: this.schema,
          sourceObjects
        };
        const node = createNode.createNode(value4, tag, ctx);
        if (flow && identity33.isCollection(node))
          node.flow = true;
        setAnchors();
        return node;
      }
      /**
       * Convert a key and a value into a `Pair` using the current schema,
       * recursively wrapping all values as `Scalar` or `Collection` nodes.
       */
      createPair(key, value4, options = {}) {
        const k = this.createNode(key, null, options);
        const v = this.createNode(value4, null, options);
        return new Pair.Pair(k, v);
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        return assertCollection(this.contents) ? this.contents.delete(key) : false;
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path5) {
        if (Collection.isEmptyPath(path5)) {
          if (this.contents == null)
            return false;
          this.contents = null;
          return true;
        }
        return assertCollection(this.contents) ? this.contents.deleteIn(path5) : false;
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      get(key, keepScalar) {
        return identity33.isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
      }
      /**
       * Returns item at `path`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path5, keepScalar) {
        if (Collection.isEmptyPath(path5))
          return !keepScalar && identity33.isScalar(this.contents) ? this.contents.value : this.contents;
        return identity33.isCollection(this.contents) ? this.contents.getIn(path5, keepScalar) : void 0;
      }
      /**
       * Checks if the document includes a value with the key `key`.
       */
      has(key) {
        return identity33.isCollection(this.contents) ? this.contents.has(key) : false;
      }
      /**
       * Checks if the document includes a value at `path`.
       */
      hasIn(path5) {
        if (Collection.isEmptyPath(path5))
          return this.contents !== void 0;
        return identity33.isCollection(this.contents) ? this.contents.hasIn(path5) : false;
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      set(key, value4) {
        if (this.contents == null) {
          this.contents = Collection.collectionFromPath(this.schema, [key], value4);
        } else if (assertCollection(this.contents)) {
          this.contents.set(key, value4);
        }
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path5, value4) {
        if (Collection.isEmptyPath(path5)) {
          this.contents = value4;
        } else if (this.contents == null) {
          this.contents = Collection.collectionFromPath(this.schema, Array.from(path5), value4);
        } else if (assertCollection(this.contents)) {
          this.contents.setIn(path5, value4);
        }
      }
      /**
       * Change the YAML version and schema used by the document.
       * A `null` version disables support for directives, explicit tags, anchors, and aliases.
       * It also requires the `schema` option to be given as a `Schema` instance value.
       *
       * Overrides all previously set schema options.
       */
      setSchema(version, options = {}) {
        if (typeof version === "number")
          version = String(version);
        let opt;
        switch (version) {
          case "1.1":
            if (this.directives)
              this.directives.yaml.version = "1.1";
            else
              this.directives = new directives.Directives({ version: "1.1" });
            opt = { merge: true, resolveKnownTags: false, schema: "yaml-1.1" };
            break;
          case "1.2":
          case "next":
            if (this.directives)
              this.directives.yaml.version = version;
            else
              this.directives = new directives.Directives({ version });
            opt = { merge: false, resolveKnownTags: true, schema: "core" };
            break;
          case null:
            if (this.directives)
              delete this.directives;
            opt = null;
            break;
          default: {
            const sv = JSON.stringify(version);
            throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
          }
        }
        if (options.schema instanceof Object)
          this.schema = options.schema;
        else if (opt)
          this.schema = new Schema.Schema(Object.assign(opt, options));
        else
          throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
      }
      // json & jsonArg are only used from toJSON()
      toJS({ json: json4, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        const ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc: this,
          keep: !json4,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = toJS.toJS(this.contents, jsonArg ?? "", ctx);
        if (typeof onAnchor === "function")
          for (const { count, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count);
        return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
      }
      /**
       * A JSON representation of the document `contents`.
       *
       * @param jsonArg Used by `JSON.stringify` to indicate the array index or
       *   property name.
       */
      toJSON(jsonArg, onAnchor) {
        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
      }
      /** A YAML representation of the document. */
      toString(options = {}) {
        if (this.errors.length > 0)
          throw new Error("Document with errors cannot be stringified");
        if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
          const s = JSON.stringify(options.indent);
          throw new Error(`"indent" option must be a positive integer, not ${s}`);
        }
        return stringifyDocument.stringifyDocument(this, options);
      }
    };
    function assertCollection(contents) {
      if (identity33.isCollection(contents))
        return true;
      throw new Error("Expected a YAML collection as document contents");
    }
    exports.Document = Document3;
  }
});

// node_modules/yaml/dist/errors.js
var require_errors = __commonJS({
  "node_modules/yaml/dist/errors.js"(exports) {
    "use strict";
    var YAMLError = class extends Error {
      constructor(name4, pos, code, message2) {
        super();
        this.name = name4;
        this.code = code;
        this.message = message2;
        this.pos = pos;
      }
    };
    var YAMLParseError = class extends YAMLError {
      constructor(pos, code, message2) {
        super("YAMLParseError", pos, code, message2);
      }
    };
    var YAMLWarning = class extends YAMLError {
      constructor(pos, code, message2) {
        super("YAMLWarning", pos, code, message2);
      }
    };
    var prettifyError = (src, lc) => (error4) => {
      if (error4.pos[0] === -1)
        return;
      error4.linePos = error4.pos.map((pos) => lc.linePos(pos));
      const { line: line2, col } = error4.linePos[0];
      error4.message += ` at line ${line2}, column ${col}`;
      let ci = col - 1;
      let lineStr = src.substring(lc.lineStarts[line2 - 1], lc.lineStarts[line2]).replace(/[\n\r]+$/, "");
      if (ci >= 60 && lineStr.length > 80) {
        const trimStart = Math.min(ci - 39, lineStr.length - 79);
        lineStr = "\u2026" + lineStr.substring(trimStart);
        ci -= trimStart - 1;
      }
      if (lineStr.length > 80)
        lineStr = lineStr.substring(0, 79) + "\u2026";
      if (line2 > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
        let prev = src.substring(lc.lineStarts[line2 - 2], lc.lineStarts[line2 - 1]);
        if (prev.length > 80)
          prev = prev.substring(0, 79) + "\u2026\n";
        lineStr = prev + lineStr;
      }
      if (/[^ ]/.test(lineStr)) {
        let count = 1;
        const end4 = error4.linePos[1];
        if (end4 && end4.line === line2 && end4.col > col) {
          count = Math.max(1, Math.min(end4.col - col, 80 - ci));
        }
        const pointer = " ".repeat(ci) + "^".repeat(count);
        error4.message += `:

${lineStr}
${pointer}
`;
      }
    };
    exports.YAMLError = YAMLError;
    exports.YAMLParseError = YAMLParseError;
    exports.YAMLWarning = YAMLWarning;
    exports.prettifyError = prettifyError;
  }
});

// node_modules/yaml/dist/compose/resolve-props.js
var require_resolve_props = __commonJS({
  "node_modules/yaml/dist/compose/resolve-props.js"(exports) {
    "use strict";
    function resolveProps(tokens, { flow, indicator, next: next2, offset, onError: onError3, startOnNewline }) {
      let spaceBefore = false;
      let atNewline = startOnNewline;
      let hasSpace = startOnNewline;
      let comment2 = "";
      let commentSep = "";
      let hasNewline = false;
      let hasNewlineAfterProp = false;
      let reqSpace = false;
      let anchor = null;
      let tag = null;
      let comma = null;
      let found = null;
      let start = null;
      for (const token2 of tokens) {
        if (reqSpace) {
          if (token2.type !== "space" && token2.type !== "newline" && token2.type !== "comma")
            onError3(token2.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
          reqSpace = false;
        }
        switch (token2.type) {
          case "space":
            if (!flow && atNewline && indicator !== "doc-start" && token2.source[0] === "	")
              onError3(token2, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
            hasSpace = true;
            break;
          case "comment": {
            if (!hasSpace)
              onError3(token2, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
            const cb = token2.source.substring(1) || " ";
            if (!comment2)
              comment2 = cb;
            else
              comment2 += commentSep + cb;
            commentSep = "";
            atNewline = false;
            break;
          }
          case "newline":
            if (atNewline) {
              if (comment2)
                comment2 += token2.source;
              else
                spaceBefore = true;
            } else
              commentSep += token2.source;
            atNewline = true;
            hasNewline = true;
            if (anchor || tag)
              hasNewlineAfterProp = true;
            hasSpace = true;
            break;
          case "anchor":
            if (anchor)
              onError3(token2, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
            if (token2.source.endsWith(":"))
              onError3(token2.offset + token2.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
            anchor = token2;
            if (start === null)
              start = token2.offset;
            atNewline = false;
            hasSpace = false;
            reqSpace = true;
            break;
          case "tag": {
            if (tag)
              onError3(token2, "MULTIPLE_TAGS", "A node can have at most one tag");
            tag = token2;
            if (start === null)
              start = token2.offset;
            atNewline = false;
            hasSpace = false;
            reqSpace = true;
            break;
          }
          case indicator:
            if (anchor || tag)
              onError3(token2, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token2.source} indicator`);
            if (found)
              onError3(token2, "UNEXPECTED_TOKEN", `Unexpected ${token2.source} in ${flow ?? "collection"}`);
            found = token2;
            atNewline = false;
            hasSpace = false;
            break;
          case "comma":
            if (flow) {
              if (comma)
                onError3(token2, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
              comma = token2;
              atNewline = false;
              hasSpace = false;
              break;
            }
          default:
            onError3(token2, "UNEXPECTED_TOKEN", `Unexpected ${token2.type} token`);
            atNewline = false;
            hasSpace = false;
        }
      }
      const last4 = tokens[tokens.length - 1];
      const end4 = last4 ? last4.offset + last4.source.length : offset;
      if (reqSpace && next2 && next2.type !== "space" && next2.type !== "newline" && next2.type !== "comma" && (next2.type !== "scalar" || next2.source !== ""))
        onError3(next2.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      return {
        comma,
        found,
        spaceBefore,
        comment: comment2,
        hasNewline,
        hasNewlineAfterProp,
        anchor,
        tag,
        end: end4,
        start: start ?? end4
      };
    }
    exports.resolveProps = resolveProps;
  }
});

// node_modules/yaml/dist/compose/util-contains-newline.js
var require_util_contains_newline = __commonJS({
  "node_modules/yaml/dist/compose/util-contains-newline.js"(exports) {
    "use strict";
    function containsNewline(key) {
      if (!key)
        return null;
      switch (key.type) {
        case "alias":
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
          if (key.source.includes("\n"))
            return true;
          if (key.end) {
            for (const st of key.end)
              if (st.type === "newline")
                return true;
          }
          return false;
        case "flow-collection":
          for (const it of key.items) {
            for (const st of it.start)
              if (st.type === "newline")
                return true;
            if (it.sep) {
              for (const st of it.sep)
                if (st.type === "newline")
                  return true;
            }
            if (containsNewline(it.key) || containsNewline(it.value))
              return true;
          }
          return false;
        default:
          return true;
      }
    }
    exports.containsNewline = containsNewline;
  }
});

// node_modules/yaml/dist/compose/util-flow-indent-check.js
var require_util_flow_indent_check = __commonJS({
  "node_modules/yaml/dist/compose/util-flow-indent-check.js"(exports) {
    "use strict";
    var utilContainsNewline = require_util_contains_newline();
    function flowIndentCheck(indent3, fc, onError3) {
      if (fc?.type === "flow-collection") {
        const end4 = fc.end[0];
        if (end4.indent === indent3 && (end4.source === "]" || end4.source === "}") && utilContainsNewline.containsNewline(fc)) {
          const msg = "Flow end indicator should be more indented than parent";
          onError3(end4, "BAD_INDENT", msg, true);
        }
      }
    }
    exports.flowIndentCheck = flowIndentCheck;
  }
});

// node_modules/yaml/dist/compose/util-map-includes.js
var require_util_map_includes = __commonJS({
  "node_modules/yaml/dist/compose/util-map-includes.js"(exports) {
    "use strict";
    var identity33 = require_identity();
    function mapIncludes(ctx, items, search2) {
      const { uniqueKeys } = ctx.options;
      if (uniqueKeys === false)
        return false;
      const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || identity33.isScalar(a) && identity33.isScalar(b) && a.value === b.value && !(a.value === "<<" && ctx.schema.merge);
      return items.some((pair) => isEqual(pair.key, search2));
    }
    exports.mapIncludes = mapIncludes;
  }
});

// node_modules/yaml/dist/compose/resolve-block-map.js
var require_resolve_block_map = __commonJS({
  "node_modules/yaml/dist/compose/resolve-block-map.js"(exports) {
    "use strict";
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var resolveProps = require_resolve_props();
    var utilContainsNewline = require_util_contains_newline();
    var utilFlowIndentCheck = require_util_flow_indent_check();
    var utilMapIncludes = require_util_map_includes();
    var startColMsg = "All mapping items must start at the same column";
    function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError3, tag) {
      const NodeClass = tag?.nodeClass ?? YAMLMap.YAMLMap;
      const map86 = new NodeClass(ctx.schema);
      if (ctx.atRoot)
        ctx.atRoot = false;
      let offset = bm.offset;
      let commentEnd = null;
      for (const collItem of bm.items) {
        const { start, key, sep: sep2, value: value4 } = collItem;
        const keyProps = resolveProps.resolveProps(start, {
          indicator: "explicit-key-ind",
          next: key ?? sep2?.[0],
          offset,
          onError: onError3,
          startOnNewline: true
        });
        const implicitKey = !keyProps.found;
        if (implicitKey) {
          if (key) {
            if (key.type === "block-seq")
              onError3(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
            else if ("indent" in key && key.indent !== bm.indent)
              onError3(offset, "BAD_INDENT", startColMsg);
          }
          if (!keyProps.anchor && !keyProps.tag && !sep2) {
            commentEnd = keyProps.end;
            if (keyProps.comment) {
              if (map86.comment)
                map86.comment += "\n" + keyProps.comment;
              else
                map86.comment = keyProps.comment;
            }
            continue;
          }
          if (keyProps.hasNewlineAfterProp || utilContainsNewline.containsNewline(key)) {
            onError3(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
          }
        } else if (keyProps.found?.indent !== bm.indent) {
          onError3(offset, "BAD_INDENT", startColMsg);
        }
        const keyStart = keyProps.end;
        const keyNode = key ? composeNode(ctx, key, keyProps, onError3) : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError3);
        if (ctx.schema.compat)
          utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError3);
        if (utilMapIncludes.mapIncludes(ctx, map86.items, keyNode))
          onError3(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        const valueProps = resolveProps.resolveProps(sep2 ?? [], {
          indicator: "map-value-ind",
          next: value4,
          offset: keyNode.range[2],
          onError: onError3,
          startOnNewline: !key || key.type === "block-scalar"
        });
        offset = valueProps.end;
        if (valueProps.found) {
          if (implicitKey) {
            if (value4?.type === "block-map" && !valueProps.hasNewline)
              onError3(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
            if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
              onError3(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
          }
          const valueNode = value4 ? composeNode(ctx, value4, valueProps, onError3) : composeEmptyNode(ctx, offset, sep2, null, valueProps, onError3);
          if (ctx.schema.compat)
            utilFlowIndentCheck.flowIndentCheck(bm.indent, value4, onError3);
          offset = valueNode.range[2];
          const pair = new Pair.Pair(keyNode, valueNode);
          if (ctx.options.keepSourceTokens)
            pair.srcToken = collItem;
          map86.items.push(pair);
        } else {
          if (implicitKey)
            onError3(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
          if (valueProps.comment) {
            if (keyNode.comment)
              keyNode.comment += "\n" + valueProps.comment;
            else
              keyNode.comment = valueProps.comment;
          }
          const pair = new Pair.Pair(keyNode);
          if (ctx.options.keepSourceTokens)
            pair.srcToken = collItem;
          map86.items.push(pair);
        }
      }
      if (commentEnd && commentEnd < offset)
        onError3(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
      map86.range = [bm.offset, offset, commentEnd ?? offset];
      return map86;
    }
    exports.resolveBlockMap = resolveBlockMap;
  }
});

// node_modules/yaml/dist/compose/resolve-block-seq.js
var require_resolve_block_seq = __commonJS({
  "node_modules/yaml/dist/compose/resolve-block-seq.js"(exports) {
    "use strict";
    var YAMLSeq = require_YAMLSeq();
    var resolveProps = require_resolve_props();
    var utilFlowIndentCheck = require_util_flow_indent_check();
    function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError3, tag) {
      const NodeClass = tag?.nodeClass ?? YAMLSeq.YAMLSeq;
      const seq = new NodeClass(ctx.schema);
      if (ctx.atRoot)
        ctx.atRoot = false;
      let offset = bs.offset;
      let commentEnd = null;
      for (const { start, value: value4 } of bs.items) {
        const props = resolveProps.resolveProps(start, {
          indicator: "seq-item-ind",
          next: value4,
          offset,
          onError: onError3,
          startOnNewline: true
        });
        if (!props.found) {
          if (props.anchor || props.tag || value4) {
            if (value4 && value4.type === "block-seq")
              onError3(props.end, "BAD_INDENT", "All sequence items must start at the same column");
            else
              onError3(offset, "MISSING_CHAR", "Sequence item without - indicator");
          } else {
            commentEnd = props.end;
            if (props.comment)
              seq.comment = props.comment;
            continue;
          }
        }
        const node = value4 ? composeNode(ctx, value4, props, onError3) : composeEmptyNode(ctx, props.end, start, null, props, onError3);
        if (ctx.schema.compat)
          utilFlowIndentCheck.flowIndentCheck(bs.indent, value4, onError3);
        offset = node.range[2];
        seq.items.push(node);
      }
      seq.range = [bs.offset, offset, commentEnd ?? offset];
      return seq;
    }
    exports.resolveBlockSeq = resolveBlockSeq;
  }
});

// node_modules/yaml/dist/compose/resolve-end.js
var require_resolve_end = __commonJS({
  "node_modules/yaml/dist/compose/resolve-end.js"(exports) {
    "use strict";
    function resolveEnd(end4, offset, reqSpace, onError3) {
      let comment2 = "";
      if (end4) {
        let hasSpace = false;
        let sep2 = "";
        for (const token2 of end4) {
          const { source: source2, type } = token2;
          switch (type) {
            case "space":
              hasSpace = true;
              break;
            case "comment": {
              if (reqSpace && !hasSpace)
                onError3(token2, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
              const cb = source2.substring(1) || " ";
              if (!comment2)
                comment2 = cb;
              else
                comment2 += sep2 + cb;
              sep2 = "";
              break;
            }
            case "newline":
              if (comment2)
                sep2 += source2;
              hasSpace = true;
              break;
            default:
              onError3(token2, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
          }
          offset += source2.length;
        }
      }
      return { comment: comment2, offset };
    }
    exports.resolveEnd = resolveEnd;
  }
});

// node_modules/yaml/dist/compose/resolve-flow-collection.js
var require_resolve_flow_collection = __commonJS({
  "node_modules/yaml/dist/compose/resolve-flow-collection.js"(exports) {
    "use strict";
    var identity33 = require_identity();
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var resolveEnd = require_resolve_end();
    var resolveProps = require_resolve_props();
    var utilContainsNewline = require_util_contains_newline();
    var utilMapIncludes = require_util_map_includes();
    var blockMsg = "Block collections are not allowed within flow collections";
    var isBlock = (token2) => token2 && (token2.type === "block-map" || token2.type === "block-seq");
    function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError3, tag) {
      const isMap = fc.start.source === "{";
      const fcName = isMap ? "flow map" : "flow sequence";
      const NodeClass = tag?.nodeClass ?? (isMap ? YAMLMap.YAMLMap : YAMLSeq.YAMLSeq);
      const coll = new NodeClass(ctx.schema);
      coll.flow = true;
      const atRoot = ctx.atRoot;
      if (atRoot)
        ctx.atRoot = false;
      let offset = fc.offset + fc.start.source.length;
      for (let i = 0; i < fc.items.length; ++i) {
        const collItem = fc.items[i];
        const { start, key, sep: sep2, value: value4 } = collItem;
        const props = resolveProps.resolveProps(start, {
          flow: fcName,
          indicator: "explicit-key-ind",
          next: key ?? sep2?.[0],
          offset,
          onError: onError3,
          startOnNewline: false
        });
        if (!props.found) {
          if (!props.anchor && !props.tag && !sep2 && !value4) {
            if (i === 0 && props.comma)
              onError3(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
            else if (i < fc.items.length - 1)
              onError3(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
            if (props.comment) {
              if (coll.comment)
                coll.comment += "\n" + props.comment;
              else
                coll.comment = props.comment;
            }
            offset = props.end;
            continue;
          }
          if (!isMap && ctx.options.strict && utilContainsNewline.containsNewline(key))
            onError3(
              key,
              // checked by containsNewline()
              "MULTILINE_IMPLICIT_KEY",
              "Implicit keys of flow sequence pairs need to be on a single line"
            );
        }
        if (i === 0) {
          if (props.comma)
            onError3(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        } else {
          if (!props.comma)
            onError3(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
          if (props.comment) {
            let prevItemComment = "";
            loop:
              for (const st of start) {
                switch (st.type) {
                  case "comma":
                  case "space":
                    break;
                  case "comment":
                    prevItemComment = st.source.substring(1);
                    break loop;
                  default:
                    break loop;
                }
              }
            if (prevItemComment) {
              let prev = coll.items[coll.items.length - 1];
              if (identity33.isPair(prev))
                prev = prev.value ?? prev.key;
              if (prev.comment)
                prev.comment += "\n" + prevItemComment;
              else
                prev.comment = prevItemComment;
              props.comment = props.comment.substring(prevItemComment.length + 1);
            }
          }
        }
        if (!isMap && !sep2 && !props.found) {
          const valueNode = value4 ? composeNode(ctx, value4, props, onError3) : composeEmptyNode(ctx, props.end, sep2, null, props, onError3);
          coll.items.push(valueNode);
          offset = valueNode.range[2];
          if (isBlock(value4))
            onError3(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
        } else {
          const keyStart = props.end;
          const keyNode = key ? composeNode(ctx, key, props, onError3) : composeEmptyNode(ctx, keyStart, start, null, props, onError3);
          if (isBlock(key))
            onError3(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
          const valueProps = resolveProps.resolveProps(sep2 ?? [], {
            flow: fcName,
            indicator: "map-value-ind",
            next: value4,
            offset: keyNode.range[2],
            onError: onError3,
            startOnNewline: false
          });
          if (valueProps.found) {
            if (!isMap && !props.found && ctx.options.strict) {
              if (sep2)
                for (const st of sep2) {
                  if (st === valueProps.found)
                    break;
                  if (st.type === "newline") {
                    onError3(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                    break;
                  }
                }
              if (props.start < valueProps.found.offset - 1024)
                onError3(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
            }
          } else if (value4) {
            if ("source" in value4 && value4.source && value4.source[0] === ":")
              onError3(value4, "MISSING_CHAR", `Missing space after : in ${fcName}`);
            else
              onError3(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
          }
          const valueNode = value4 ? composeNode(ctx, value4, valueProps, onError3) : valueProps.found ? composeEmptyNode(ctx, valueProps.end, sep2, null, valueProps, onError3) : null;
          if (valueNode) {
            if (isBlock(value4))
              onError3(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
          } else if (valueProps.comment) {
            if (keyNode.comment)
              keyNode.comment += "\n" + valueProps.comment;
            else
              keyNode.comment = valueProps.comment;
          }
          const pair = new Pair.Pair(keyNode, valueNode);
          if (ctx.options.keepSourceTokens)
            pair.srcToken = collItem;
          if (isMap) {
            const map86 = coll;
            if (utilMapIncludes.mapIncludes(ctx, map86.items, keyNode))
              onError3(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
            map86.items.push(pair);
          } else {
            const map86 = new YAMLMap.YAMLMap(ctx.schema);
            map86.flow = true;
            map86.items.push(pair);
            coll.items.push(map86);
          }
          offset = valueNode ? valueNode.range[2] : valueProps.end;
        }
      }
      const expectedEnd = isMap ? "}" : "]";
      const [ce, ...ee] = fc.end;
      let cePos = offset;
      if (ce && ce.source === expectedEnd)
        cePos = ce.offset + ce.source.length;
      else {
        const name4 = fcName[0].toUpperCase() + fcName.substring(1);
        const msg = atRoot ? `${name4} must end with a ${expectedEnd}` : `${name4} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
        onError3(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
        if (ce && ce.source.length !== 1)
          ee.unshift(ce);
      }
      if (ee.length > 0) {
        const end4 = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError3);
        if (end4.comment) {
          if (coll.comment)
            coll.comment += "\n" + end4.comment;
          else
            coll.comment = end4.comment;
        }
        coll.range = [fc.offset, cePos, end4.offset];
      } else {
        coll.range = [fc.offset, cePos, cePos];
      }
      return coll;
    }
    exports.resolveFlowCollection = resolveFlowCollection;
  }
});

// node_modules/yaml/dist/compose/compose-collection.js
var require_compose_collection = __commonJS({
  "node_modules/yaml/dist/compose/compose-collection.js"(exports) {
    "use strict";
    var identity33 = require_identity();
    var Scalar = require_Scalar();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var resolveBlockMap = require_resolve_block_map();
    var resolveBlockSeq = require_resolve_block_seq();
    var resolveFlowCollection = require_resolve_flow_collection();
    function resolveCollection(CN, ctx, token2, onError3, tagName, tag) {
      const coll = token2.type === "block-map" ? resolveBlockMap.resolveBlockMap(CN, ctx, token2, onError3, tag) : token2.type === "block-seq" ? resolveBlockSeq.resolveBlockSeq(CN, ctx, token2, onError3, tag) : resolveFlowCollection.resolveFlowCollection(CN, ctx, token2, onError3, tag);
      const Coll = coll.constructor;
      if (tagName === "!" || tagName === Coll.tagName) {
        coll.tag = Coll.tagName;
        return coll;
      }
      if (tagName)
        coll.tag = tagName;
      return coll;
    }
    function composeCollection(CN, ctx, token2, tagToken, onError3) {
      const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError3(tagToken, "TAG_RESOLVE_FAILED", msg));
      const expType = token2.type === "block-map" ? "map" : token2.type === "block-seq" ? "seq" : token2.start.source === "{" ? "map" : "seq";
      if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.YAMLSeq.tagName && expType === "seq" || !expType) {
        return resolveCollection(CN, ctx, token2, onError3, tagName);
      }
      let tag = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
      if (!tag) {
        const kt = ctx.schema.knownTags[tagName];
        if (kt && kt.collection === expType) {
          ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
          tag = kt;
        } else {
          if (kt?.collection) {
            onError3(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection}`, true);
          } else {
            onError3(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
          }
          return resolveCollection(CN, ctx, token2, onError3, tagName);
        }
      }
      const coll = resolveCollection(CN, ctx, token2, onError3, tagName, tag);
      const res = tag.resolve?.(coll, (msg) => onError3(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
      const node = identity33.isNode(res) ? res : new Scalar.Scalar(res);
      node.range = coll.range;
      node.tag = tagName;
      if (tag?.format)
        node.format = tag.format;
      return node;
    }
    exports.composeCollection = composeCollection;
  }
});

// node_modules/yaml/dist/compose/resolve-block-scalar.js
var require_resolve_block_scalar = __commonJS({
  "node_modules/yaml/dist/compose/resolve-block-scalar.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    function resolveBlockScalar(scalar, strict2, onError3) {
      const start = scalar.offset;
      const header = parseBlockScalarHeader(scalar, strict2, onError3);
      if (!header)
        return { value: "", type: null, comment: "", range: [start, start, start] };
      const type = header.mode === ">" ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;
      const lines6 = scalar.source ? splitLines(scalar.source) : [];
      let chompStart = lines6.length;
      for (let i = lines6.length - 1; i >= 0; --i) {
        const content = lines6[i][1];
        if (content === "" || content === "\r")
          chompStart = i;
        else
          break;
      }
      if (chompStart === 0) {
        const value5 = header.chomp === "+" && lines6.length > 0 ? "\n".repeat(Math.max(1, lines6.length - 1)) : "";
        let end5 = start + header.length;
        if (scalar.source)
          end5 += scalar.source.length;
        return { value: value5, type, comment: header.comment, range: [start, end5, end5] };
      }
      let trimIndent = scalar.indent + header.indent;
      let offset = scalar.offset + header.length;
      let contentStart = 0;
      for (let i = 0; i < chompStart; ++i) {
        const [indent3, content] = lines6[i];
        if (content === "" || content === "\r") {
          if (header.indent === 0 && indent3.length > trimIndent)
            trimIndent = indent3.length;
        } else {
          if (indent3.length < trimIndent) {
            const message2 = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
            onError3(offset + indent3.length, "MISSING_CHAR", message2);
          }
          if (header.indent === 0)
            trimIndent = indent3.length;
          contentStart = i;
          break;
        }
        offset += indent3.length + content.length + 1;
      }
      for (let i = lines6.length - 1; i >= chompStart; --i) {
        if (lines6[i][0].length > trimIndent)
          chompStart = i + 1;
      }
      let value4 = "";
      let sep2 = "";
      let prevMoreIndented = false;
      for (let i = 0; i < contentStart; ++i)
        value4 += lines6[i][0].slice(trimIndent) + "\n";
      for (let i = contentStart; i < chompStart; ++i) {
        let [indent3, content] = lines6[i];
        offset += indent3.length + content.length + 1;
        const crlf = content[content.length - 1] === "\r";
        if (crlf)
          content = content.slice(0, -1);
        if (content && indent3.length < trimIndent) {
          const src = header.indent ? "explicit indentation indicator" : "first line";
          const message2 = `Block scalar lines must not be less indented than their ${src}`;
          onError3(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message2);
          indent3 = "";
        }
        if (type === Scalar.Scalar.BLOCK_LITERAL) {
          value4 += sep2 + indent3.slice(trimIndent) + content;
          sep2 = "\n";
        } else if (indent3.length > trimIndent || content[0] === "	") {
          if (sep2 === " ")
            sep2 = "\n";
          else if (!prevMoreIndented && sep2 === "\n")
            sep2 = "\n\n";
          value4 += sep2 + indent3.slice(trimIndent) + content;
          sep2 = "\n";
          prevMoreIndented = true;
        } else if (content === "") {
          if (sep2 === "\n")
            value4 += "\n";
          else
            sep2 = "\n";
        } else {
          value4 += sep2 + content;
          sep2 = " ";
          prevMoreIndented = false;
        }
      }
      switch (header.chomp) {
        case "-":
          break;
        case "+":
          for (let i = chompStart; i < lines6.length; ++i)
            value4 += "\n" + lines6[i][0].slice(trimIndent);
          if (value4[value4.length - 1] !== "\n")
            value4 += "\n";
          break;
        default:
          value4 += "\n";
      }
      const end4 = start + header.length + scalar.source.length;
      return { value: value4, type, comment: header.comment, range: [start, end4, end4] };
    }
    function parseBlockScalarHeader({ offset, props }, strict2, onError3) {
      if (props[0].type !== "block-scalar-header") {
        onError3(props[0], "IMPOSSIBLE", "Block scalar header not found");
        return null;
      }
      const { source: source2 } = props[0];
      const mode = source2[0];
      let indent3 = 0;
      let chomp = "";
      let error4 = -1;
      for (let i = 1; i < source2.length; ++i) {
        const ch = source2[i];
        if (!chomp && (ch === "-" || ch === "+"))
          chomp = ch;
        else {
          const n = Number(ch);
          if (!indent3 && n)
            indent3 = n;
          else if (error4 === -1)
            error4 = offset + i;
        }
      }
      if (error4 !== -1)
        onError3(error4, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source2}`);
      let hasSpace = false;
      let comment2 = "";
      let length7 = source2.length;
      for (let i = 1; i < props.length; ++i) {
        const token2 = props[i];
        switch (token2.type) {
          case "space":
            hasSpace = true;
          case "newline":
            length7 += token2.source.length;
            break;
          case "comment":
            if (strict2 && !hasSpace) {
              const message2 = "Comments must be separated from other tokens by white space characters";
              onError3(token2, "MISSING_CHAR", message2);
            }
            length7 += token2.source.length;
            comment2 = token2.source.substring(1);
            break;
          case "error":
            onError3(token2, "UNEXPECTED_TOKEN", token2.message);
            length7 += token2.source.length;
            break;
          default: {
            const message2 = `Unexpected token in block scalar header: ${token2.type}`;
            onError3(token2, "UNEXPECTED_TOKEN", message2);
            const ts = token2.source;
            if (ts && typeof ts === "string")
              length7 += ts.length;
          }
        }
      }
      return { mode, indent: indent3, chomp, comment: comment2, length: length7 };
    }
    function splitLines(source2) {
      const split3 = source2.split(/\n( *)/);
      const first2 = split3[0];
      const m = first2.match(/^( *)/);
      const line0 = m?.[1] ? [m[1], first2.slice(m[1].length)] : ["", first2];
      const lines6 = [line0];
      for (let i = 1; i < split3.length; i += 2)
        lines6.push([split3[i], split3[i + 1]]);
      return lines6;
    }
    exports.resolveBlockScalar = resolveBlockScalar;
  }
});

// node_modules/yaml/dist/compose/resolve-flow-scalar.js
var require_resolve_flow_scalar = __commonJS({
  "node_modules/yaml/dist/compose/resolve-flow-scalar.js"(exports) {
    "use strict";
    var Scalar = require_Scalar();
    var resolveEnd = require_resolve_end();
    function resolveFlowScalar(scalar, strict2, onError3) {
      const { offset, type, source: source2, end: end4 } = scalar;
      let _type;
      let value4;
      const _onError = (rel, code, msg) => onError3(offset + rel, code, msg);
      switch (type) {
        case "scalar":
          _type = Scalar.Scalar.PLAIN;
          value4 = plainValue(source2, _onError);
          break;
        case "single-quoted-scalar":
          _type = Scalar.Scalar.QUOTE_SINGLE;
          value4 = singleQuotedValue(source2, _onError);
          break;
        case "double-quoted-scalar":
          _type = Scalar.Scalar.QUOTE_DOUBLE;
          value4 = doubleQuotedValue(source2, _onError);
          break;
        default:
          onError3(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
          return {
            value: "",
            type: null,
            comment: "",
            range: [offset, offset + source2.length, offset + source2.length]
          };
      }
      const valueEnd = offset + source2.length;
      const re = resolveEnd.resolveEnd(end4, valueEnd, strict2, onError3);
      return {
        value: value4,
        type: _type,
        comment: re.comment,
        range: [offset, valueEnd, re.offset]
      };
    }
    function plainValue(source2, onError3) {
      let badChar = "";
      switch (source2[0]) {
        case "	":
          badChar = "a tab character";
          break;
        case ",":
          badChar = "flow indicator character ,";
          break;
        case "%":
          badChar = "directive indicator character %";
          break;
        case "|":
        case ">": {
          badChar = `block scalar indicator ${source2[0]}`;
          break;
        }
        case "@":
        case "`": {
          badChar = `reserved character ${source2[0]}`;
          break;
        }
      }
      if (badChar)
        onError3(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
      return foldLines(source2);
    }
    function singleQuotedValue(source2, onError3) {
      if (source2[source2.length - 1] !== "'" || source2.length === 1)
        onError3(source2.length, "MISSING_CHAR", "Missing closing 'quote");
      return foldLines(source2.slice(1, -1)).replace(/''/g, "'");
    }
    function foldLines(source2) {
      let first2, line2;
      try {
        first2 = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
        line2 = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
      } catch (_) {
        first2 = /(.*?)[ \t]*\r?\n/sy;
        line2 = /[ \t]*(.*?)[ \t]*\r?\n/sy;
      }
      let match4 = first2.exec(source2);
      if (!match4)
        return source2;
      let res = match4[1];
      let sep2 = " ";
      let pos = first2.lastIndex;
      line2.lastIndex = pos;
      while (match4 = line2.exec(source2)) {
        if (match4[1] === "") {
          if (sep2 === "\n")
            res += sep2;
          else
            sep2 = "\n";
        } else {
          res += sep2 + match4[1];
          sep2 = " ";
        }
        pos = line2.lastIndex;
      }
      const last4 = /[ \t]*(.*)/sy;
      last4.lastIndex = pos;
      match4 = last4.exec(source2);
      return res + sep2 + (match4?.[1] ?? "");
    }
    function doubleQuotedValue(source2, onError3) {
      let res = "";
      for (let i = 1; i < source2.length - 1; ++i) {
        const ch = source2[i];
        if (ch === "\r" && source2[i + 1] === "\n")
          continue;
        if (ch === "\n") {
          const { fold: fold23, offset } = foldNewline(source2, i);
          res += fold23;
          i = offset;
        } else if (ch === "\\") {
          let next2 = source2[++i];
          const cc = escapeCodes[next2];
          if (cc)
            res += cc;
          else if (next2 === "\n") {
            next2 = source2[i + 1];
            while (next2 === " " || next2 === "	")
              next2 = source2[++i + 1];
          } else if (next2 === "\r" && source2[i + 1] === "\n") {
            next2 = source2[++i + 1];
            while (next2 === " " || next2 === "	")
              next2 = source2[++i + 1];
          } else if (next2 === "x" || next2 === "u" || next2 === "U") {
            const length7 = { x: 2, u: 4, U: 8 }[next2];
            res += parseCharCode(source2, i + 1, length7, onError3);
            i += length7;
          } else {
            const raw = source2.substr(i - 1, 2);
            onError3(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
            res += raw;
          }
        } else if (ch === " " || ch === "	") {
          const wsStart = i;
          let next2 = source2[i + 1];
          while (next2 === " " || next2 === "	")
            next2 = source2[++i + 1];
          if (next2 !== "\n" && !(next2 === "\r" && source2[i + 2] === "\n"))
            res += i > wsStart ? source2.slice(wsStart, i + 1) : ch;
        } else {
          res += ch;
        }
      }
      if (source2[source2.length - 1] !== '"' || source2.length === 1)
        onError3(source2.length, "MISSING_CHAR", 'Missing closing "quote');
      return res;
    }
    function foldNewline(source2, offset) {
      let fold23 = "";
      let ch = source2[offset + 1];
      while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
        if (ch === "\r" && source2[offset + 2] !== "\n")
          break;
        if (ch === "\n")
          fold23 += "\n";
        offset += 1;
        ch = source2[offset + 1];
      }
      if (!fold23)
        fold23 = " ";
      return { fold: fold23, offset };
    }
    var escapeCodes = {
      "0": "\0",
      a: "\x07",
      b: "\b",
      e: "\x1B",
      f: "\f",
      n: "\n",
      r: "\r",
      t: "	",
      v: "\v",
      N: "\x85",
      _: "\xA0",
      L: "\u2028",
      P: "\u2029",
      " ": " ",
      '"': '"',
      "/": "/",
      "\\": "\\",
      "	": "	"
    };
    function parseCharCode(source2, offset, length7, onError3) {
      const cc = source2.substr(offset, length7);
      const ok = cc.length === length7 && /^[0-9a-fA-F]+$/.test(cc);
      const code = ok ? parseInt(cc, 16) : NaN;
      if (isNaN(code)) {
        const raw = source2.substr(offset - 2, length7 + 2);
        onError3(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        return raw;
      }
      return String.fromCodePoint(code);
    }
    exports.resolveFlowScalar = resolveFlowScalar;
  }
});

// node_modules/yaml/dist/compose/compose-scalar.js
var require_compose_scalar = __commonJS({
  "node_modules/yaml/dist/compose/compose-scalar.js"(exports) {
    "use strict";
    var identity33 = require_identity();
    var Scalar = require_Scalar();
    var resolveBlockScalar = require_resolve_block_scalar();
    var resolveFlowScalar = require_resolve_flow_scalar();
    function composeScalar(ctx, token2, tagToken, onError3) {
      const { value: value4, type, comment: comment2, range: range3 } = token2.type === "block-scalar" ? resolveBlockScalar.resolveBlockScalar(token2, ctx.options.strict, onError3) : resolveFlowScalar.resolveFlowScalar(token2, ctx.options.strict, onError3);
      const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError3(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
      const tag = tagToken && tagName ? findScalarTagByName(ctx.schema, value4, tagName, tagToken, onError3) : token2.type === "scalar" ? findScalarTagByTest(ctx, value4, token2, onError3) : ctx.schema[identity33.SCALAR];
      let scalar;
      try {
        const res = tag.resolve(value4, (msg) => onError3(tagToken ?? token2, "TAG_RESOLVE_FAILED", msg), ctx.options);
        scalar = identity33.isScalar(res) ? res : new Scalar.Scalar(res);
      } catch (error4) {
        const msg = error4 instanceof Error ? error4.message : String(error4);
        onError3(tagToken ?? token2, "TAG_RESOLVE_FAILED", msg);
        scalar = new Scalar.Scalar(value4);
      }
      scalar.range = range3;
      scalar.source = value4;
      if (type)
        scalar.type = type;
      if (tagName)
        scalar.tag = tagName;
      if (tag.format)
        scalar.format = tag.format;
      if (comment2)
        scalar.comment = comment2;
      return scalar;
    }
    function findScalarTagByName(schema, value4, tagName, tagToken, onError3) {
      if (tagName === "!")
        return schema[identity33.SCALAR];
      const matchWithTest = [];
      for (const tag of schema.tags) {
        if (!tag.collection && tag.tag === tagName) {
          if (tag.default && tag.test)
            matchWithTest.push(tag);
          else
            return tag;
        }
      }
      for (const tag of matchWithTest)
        if (tag.test?.test(value4))
          return tag;
      const kt = schema.knownTags[tagName];
      if (kt && !kt.collection) {
        schema.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
        return kt;
      }
      onError3(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
      return schema[identity33.SCALAR];
    }
    function findScalarTagByTest({ directives, schema }, value4, token2, onError3) {
      const tag = schema.tags.find((tag2) => tag2.default && tag2.test?.test(value4)) || schema[identity33.SCALAR];
      if (schema.compat) {
        const compat = schema.compat.find((tag2) => tag2.default && tag2.test?.test(value4)) ?? schema[identity33.SCALAR];
        if (tag.tag !== compat.tag) {
          const ts = directives.tagString(tag.tag);
          const cs = directives.tagString(compat.tag);
          const msg = `Value may be parsed as either ${ts} or ${cs}`;
          onError3(token2, "TAG_RESOLVE_FAILED", msg, true);
        }
      }
      return tag;
    }
    exports.composeScalar = composeScalar;
  }
});

// node_modules/yaml/dist/compose/util-empty-scalar-position.js
var require_util_empty_scalar_position = __commonJS({
  "node_modules/yaml/dist/compose/util-empty-scalar-position.js"(exports) {
    "use strict";
    function emptyScalarPosition(offset, before, pos) {
      if (before) {
        if (pos === null)
          pos = before.length;
        for (let i = pos - 1; i >= 0; --i) {
          let st = before[i];
          switch (st.type) {
            case "space":
            case "comment":
            case "newline":
              offset -= st.source.length;
              continue;
          }
          st = before[++i];
          while (st?.type === "space") {
            offset += st.source.length;
            st = before[++i];
          }
          break;
        }
      }
      return offset;
    }
    exports.emptyScalarPosition = emptyScalarPosition;
  }
});

// node_modules/yaml/dist/compose/compose-node.js
var require_compose_node = __commonJS({
  "node_modules/yaml/dist/compose/compose-node.js"(exports) {
    "use strict";
    var Alias = require_Alias();
    var composeCollection = require_compose_collection();
    var composeScalar = require_compose_scalar();
    var resolveEnd = require_resolve_end();
    var utilEmptyScalarPosition = require_util_empty_scalar_position();
    var CN = { composeNode, composeEmptyNode };
    function composeNode(ctx, token2, props, onError3) {
      const { spaceBefore, comment: comment2, anchor, tag } = props;
      let node;
      let isSrcToken = true;
      switch (token2.type) {
        case "alias":
          node = composeAlias(ctx, token2, onError3);
          if (anchor || tag)
            onError3(token2, "ALIAS_PROPS", "An alias node must not specify any properties");
          break;
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "block-scalar":
          node = composeScalar.composeScalar(ctx, token2, tag, onError3);
          if (anchor)
            node.anchor = anchor.source.substring(1);
          break;
        case "block-map":
        case "block-seq":
        case "flow-collection":
          node = composeCollection.composeCollection(CN, ctx, token2, tag, onError3);
          if (anchor)
            node.anchor = anchor.source.substring(1);
          break;
        default: {
          const message2 = token2.type === "error" ? token2.message : `Unsupported token (type: ${token2.type})`;
          onError3(token2, "UNEXPECTED_TOKEN", message2);
          node = composeEmptyNode(ctx, token2.offset, void 0, null, props, onError3);
          isSrcToken = false;
        }
      }
      if (anchor && node.anchor === "")
        onError3(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
      if (spaceBefore)
        node.spaceBefore = true;
      if (comment2) {
        if (token2.type === "scalar" && token2.source === "")
          node.comment = comment2;
        else
          node.commentBefore = comment2;
      }
      if (ctx.options.keepSourceTokens && isSrcToken)
        node.srcToken = token2;
      return node;
    }
    function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment: comment2, anchor, tag, end: end4 }, onError3) {
      const token2 = {
        type: "scalar",
        offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
        indent: -1,
        source: ""
      };
      const node = composeScalar.composeScalar(ctx, token2, tag, onError3);
      if (anchor) {
        node.anchor = anchor.source.substring(1);
        if (node.anchor === "")
          onError3(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
      }
      if (spaceBefore)
        node.spaceBefore = true;
      if (comment2) {
        node.comment = comment2;
        node.range[2] = end4;
      }
      return node;
    }
    function composeAlias({ options }, { offset, source: source2, end: end4 }, onError3) {
      const alias = new Alias.Alias(source2.substring(1));
      if (alias.source === "")
        onError3(offset, "BAD_ALIAS", "Alias cannot be an empty string");
      if (alias.source.endsWith(":"))
        onError3(offset + source2.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
      const valueEnd = offset + source2.length;
      const re = resolveEnd.resolveEnd(end4, valueEnd, options.strict, onError3);
      alias.range = [offset, valueEnd, re.offset];
      if (re.comment)
        alias.comment = re.comment;
      return alias;
    }
    exports.composeEmptyNode = composeEmptyNode;
    exports.composeNode = composeNode;
  }
});

// node_modules/yaml/dist/compose/compose-doc.js
var require_compose_doc = __commonJS({
  "node_modules/yaml/dist/compose/compose-doc.js"(exports) {
    "use strict";
    var Document3 = require_Document();
    var composeNode = require_compose_node();
    var resolveEnd = require_resolve_end();
    var resolveProps = require_resolve_props();
    function composeDoc(options, directives, { offset, start, value: value4, end: end4 }, onError3) {
      const opts = Object.assign({ _directives: directives }, options);
      const doc = new Document3.Document(void 0, opts);
      const ctx = {
        atRoot: true,
        directives: doc.directives,
        options: doc.options,
        schema: doc.schema
      };
      const props = resolveProps.resolveProps(start, {
        indicator: "doc-start",
        next: value4 ?? end4?.[0],
        offset,
        onError: onError3,
        startOnNewline: true
      });
      if (props.found) {
        doc.directives.docStart = true;
        if (value4 && (value4.type === "block-map" || value4.type === "block-seq") && !props.hasNewline)
          onError3(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
      }
      doc.contents = value4 ? composeNode.composeNode(ctx, value4, props, onError3) : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError3);
      const contentEnd = doc.contents.range[2];
      const re = resolveEnd.resolveEnd(end4, contentEnd, false, onError3);
      if (re.comment)
        doc.comment = re.comment;
      doc.range = [offset, contentEnd, re.offset];
      return doc;
    }
    exports.composeDoc = composeDoc;
  }
});

// node_modules/yaml/dist/compose/composer.js
var require_composer = __commonJS({
  "node_modules/yaml/dist/compose/composer.js"(exports) {
    "use strict";
    var directives = require_directives();
    var Document3 = require_Document();
    var errors = require_errors();
    var identity33 = require_identity();
    var composeDoc = require_compose_doc();
    var resolveEnd = require_resolve_end();
    function getErrorPos(src) {
      if (typeof src === "number")
        return [src, src + 1];
      if (Array.isArray(src))
        return src.length === 2 ? src : [src[0], src[1]];
      const { offset, source: source2 } = src;
      return [offset, offset + (typeof source2 === "string" ? source2.length : 1)];
    }
    function parsePrelude(prelude) {
      let comment2 = "";
      let atComment = false;
      let afterEmptyLine = false;
      for (let i = 0; i < prelude.length; ++i) {
        const source2 = prelude[i];
        switch (source2[0]) {
          case "#":
            comment2 += (comment2 === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source2.substring(1) || " ");
            atComment = true;
            afterEmptyLine = false;
            break;
          case "%":
            if (prelude[i + 1]?.[0] !== "#")
              i += 1;
            atComment = false;
            break;
          default:
            if (!atComment)
              afterEmptyLine = true;
            atComment = false;
        }
      }
      return { comment: comment2, afterEmptyLine };
    }
    var Composer = class {
      constructor(options = {}) {
        this.doc = null;
        this.atDirectives = false;
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
        this.onError = (source2, code, message2, warning) => {
          const pos = getErrorPos(source2);
          if (warning)
            this.warnings.push(new errors.YAMLWarning(pos, code, message2));
          else
            this.errors.push(new errors.YAMLParseError(pos, code, message2));
        };
        this.directives = new directives.Directives({ version: options.version || "1.2" });
        this.options = options;
      }
      decorate(doc, afterDoc) {
        const { comment: comment2, afterEmptyLine } = parsePrelude(this.prelude);
        if (comment2) {
          const dc = doc.contents;
          if (afterDoc) {
            doc.comment = doc.comment ? `${doc.comment}
${comment2}` : comment2;
          } else if (afterEmptyLine || doc.directives.docStart || !dc) {
            doc.commentBefore = comment2;
          } else if (identity33.isCollection(dc) && !dc.flow && dc.items.length > 0) {
            let it = dc.items[0];
            if (identity33.isPair(it))
              it = it.key;
            const cb = it.commentBefore;
            it.commentBefore = cb ? `${comment2}
${cb}` : comment2;
          } else {
            const cb = dc.commentBefore;
            dc.commentBefore = cb ? `${comment2}
${cb}` : comment2;
          }
        }
        if (afterDoc) {
          Array.prototype.push.apply(doc.errors, this.errors);
          Array.prototype.push.apply(doc.warnings, this.warnings);
        } else {
          doc.errors = this.errors;
          doc.warnings = this.warnings;
        }
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
      }
      /**
       * Current stream status information.
       *
       * Mostly useful at the end of input for an empty stream.
       */
      streamInfo() {
        return {
          comment: parsePrelude(this.prelude).comment,
          directives: this.directives,
          errors: this.errors,
          warnings: this.warnings
        };
      }
      /**
       * Compose tokens into documents.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *compose(tokens, forceDoc = false, endOffset = -1) {
        for (const token2 of tokens)
          yield* this.next(token2);
        yield* this.end(forceDoc, endOffset);
      }
      /** Advance the composer by one CST token. */
      *next(token2) {
        if (process.env.LOG_STREAM)
          console.dir(token2, { depth: null });
        switch (token2.type) {
          case "directive":
            this.directives.add(token2.source, (offset, message2, warning) => {
              const pos = getErrorPos(token2);
              pos[0] += offset;
              this.onError(pos, "BAD_DIRECTIVE", message2, warning);
            });
            this.prelude.push(token2.source);
            this.atDirectives = true;
            break;
          case "document": {
            const doc = composeDoc.composeDoc(this.options, this.directives, token2, this.onError);
            if (this.atDirectives && !doc.directives.docStart)
              this.onError(token2, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
            this.decorate(doc, false);
            if (this.doc)
              yield this.doc;
            this.doc = doc;
            this.atDirectives = false;
            break;
          }
          case "byte-order-mark":
          case "space":
            break;
          case "comment":
          case "newline":
            this.prelude.push(token2.source);
            break;
          case "error": {
            const msg = token2.source ? `${token2.message}: ${JSON.stringify(token2.source)}` : token2.message;
            const error4 = new errors.YAMLParseError(getErrorPos(token2), "UNEXPECTED_TOKEN", msg);
            if (this.atDirectives || !this.doc)
              this.errors.push(error4);
            else
              this.doc.errors.push(error4);
            break;
          }
          case "doc-end": {
            if (!this.doc) {
              const msg = "Unexpected doc-end without preceding document";
              this.errors.push(new errors.YAMLParseError(getErrorPos(token2), "UNEXPECTED_TOKEN", msg));
              break;
            }
            this.doc.directives.docEnd = true;
            const end4 = resolveEnd.resolveEnd(token2.end, token2.offset + token2.source.length, this.doc.options.strict, this.onError);
            this.decorate(this.doc, true);
            if (end4.comment) {
              const dc = this.doc.comment;
              this.doc.comment = dc ? `${dc}
${end4.comment}` : end4.comment;
            }
            this.doc.range[2] = end4.offset;
            break;
          }
          default:
            this.errors.push(new errors.YAMLParseError(getErrorPos(token2), "UNEXPECTED_TOKEN", `Unsupported token ${token2.type}`));
        }
      }
      /**
       * Call at end of input to yield any remaining document.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *end(forceDoc = false, endOffset = -1) {
        if (this.doc) {
          this.decorate(this.doc, true);
          yield this.doc;
          this.doc = null;
        } else if (forceDoc) {
          const opts = Object.assign({ _directives: this.directives }, this.options);
          const doc = new Document3.Document(void 0, opts);
          if (this.atDirectives)
            this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
          doc.range = [0, endOffset, endOffset];
          this.decorate(doc, false);
          yield doc;
        }
      }
    };
    exports.Composer = Composer;
  }
});

// node_modules/yaml/dist/parse/cst-scalar.js
var require_cst_scalar = __commonJS({
  "node_modules/yaml/dist/parse/cst-scalar.js"(exports) {
    "use strict";
    var resolveBlockScalar = require_resolve_block_scalar();
    var resolveFlowScalar = require_resolve_flow_scalar();
    var errors = require_errors();
    var stringifyString = require_stringifyString();
    function resolveAsScalar(token2, strict2 = true, onError3) {
      if (token2) {
        const _onError = (pos, code, message2) => {
          const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
          if (onError3)
            onError3(offset, code, message2);
          else
            throw new errors.YAMLParseError([offset, offset + 1], code, message2);
        };
        switch (token2.type) {
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return resolveFlowScalar.resolveFlowScalar(token2, strict2, _onError);
          case "block-scalar":
            return resolveBlockScalar.resolveBlockScalar(token2, strict2, _onError);
        }
      }
      return null;
    }
    function createScalarToken(value4, context) {
      const { implicitKey = false, indent: indent3, inFlow = false, offset = -1, type = "PLAIN" } = context;
      const source2 = stringifyString.stringifyString({ type, value: value4 }, {
        implicitKey,
        indent: indent3 > 0 ? " ".repeat(indent3) : "",
        inFlow,
        options: { blockQuote: true, lineWidth: -1 }
      });
      const end4 = context.end ?? [
        { type: "newline", offset: -1, indent: indent3, source: "\n" }
      ];
      switch (source2[0]) {
        case "|":
        case ">": {
          const he = source2.indexOf("\n");
          const head6 = source2.substring(0, he);
          const body = source2.substring(he + 1) + "\n";
          const props = [
            { type: "block-scalar-header", offset, indent: indent3, source: head6 }
          ];
          if (!addEndtoBlockProps(props, end4))
            props.push({ type: "newline", offset: -1, indent: indent3, source: "\n" });
          return { type: "block-scalar", offset, indent: indent3, props, source: body };
        }
        case '"':
          return { type: "double-quoted-scalar", offset, indent: indent3, source: source2, end: end4 };
        case "'":
          return { type: "single-quoted-scalar", offset, indent: indent3, source: source2, end: end4 };
        default:
          return { type: "scalar", offset, indent: indent3, source: source2, end: end4 };
      }
    }
    function setScalarValue(token2, value4, context = {}) {
      let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
      let indent3 = "indent" in token2 ? token2.indent : null;
      if (afterKey && typeof indent3 === "number")
        indent3 += 2;
      if (!type)
        switch (token2.type) {
          case "single-quoted-scalar":
            type = "QUOTE_SINGLE";
            break;
          case "double-quoted-scalar":
            type = "QUOTE_DOUBLE";
            break;
          case "block-scalar": {
            const header = token2.props[0];
            if (header.type !== "block-scalar-header")
              throw new Error("Invalid block scalar header");
            type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
            break;
          }
          default:
            type = "PLAIN";
        }
      const source2 = stringifyString.stringifyString({ type, value: value4 }, {
        implicitKey: implicitKey || indent3 === null,
        indent: indent3 !== null && indent3 > 0 ? " ".repeat(indent3) : "",
        inFlow,
        options: { blockQuote: true, lineWidth: -1 }
      });
      switch (source2[0]) {
        case "|":
        case ">":
          setBlockScalarValue(token2, source2);
          break;
        case '"':
          setFlowScalarValue(token2, source2, "double-quoted-scalar");
          break;
        case "'":
          setFlowScalarValue(token2, source2, "single-quoted-scalar");
          break;
        default:
          setFlowScalarValue(token2, source2, "scalar");
      }
    }
    function setBlockScalarValue(token2, source2) {
      const he = source2.indexOf("\n");
      const head6 = source2.substring(0, he);
      const body = source2.substring(he + 1) + "\n";
      if (token2.type === "block-scalar") {
        const header = token2.props[0];
        if (header.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        header.source = head6;
        token2.source = body;
      } else {
        const { offset } = token2;
        const indent3 = "indent" in token2 ? token2.indent : -1;
        const props = [
          { type: "block-scalar-header", offset, indent: indent3, source: head6 }
        ];
        if (!addEndtoBlockProps(props, "end" in token2 ? token2.end : void 0))
          props.push({ type: "newline", offset: -1, indent: indent3, source: "\n" });
        for (const key of Object.keys(token2))
          if (key !== "type" && key !== "offset")
            delete token2[key];
        Object.assign(token2, { type: "block-scalar", indent: indent3, props, source: body });
      }
    }
    function addEndtoBlockProps(props, end4) {
      if (end4)
        for (const st of end4)
          switch (st.type) {
            case "space":
            case "comment":
              props.push(st);
              break;
            case "newline":
              props.push(st);
              return true;
          }
      return false;
    }
    function setFlowScalarValue(token2, source2, type) {
      switch (token2.type) {
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
          token2.type = type;
          token2.source = source2;
          break;
        case "block-scalar": {
          const end4 = token2.props.slice(1);
          let oa = source2.length;
          if (token2.props[0].type === "block-scalar-header")
            oa -= token2.props[0].source.length;
          for (const tok of end4)
            tok.offset += oa;
          delete token2.props;
          Object.assign(token2, { type, source: source2, end: end4 });
          break;
        }
        case "block-map":
        case "block-seq": {
          const offset = token2.offset + source2.length;
          const nl = { type: "newline", offset, indent: token2.indent, source: "\n" };
          delete token2.items;
          Object.assign(token2, { type, source: source2, end: [nl] });
          break;
        }
        default: {
          const indent3 = "indent" in token2 ? token2.indent : -1;
          const end4 = "end" in token2 && Array.isArray(token2.end) ? token2.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
          for (const key of Object.keys(token2))
            if (key !== "type" && key !== "offset")
              delete token2[key];
          Object.assign(token2, { type, indent: indent3, source: source2, end: end4 });
        }
      }
    }
    exports.createScalarToken = createScalarToken;
    exports.resolveAsScalar = resolveAsScalar;
    exports.setScalarValue = setScalarValue;
  }
});

// node_modules/yaml/dist/parse/cst-stringify.js
var require_cst_stringify = __commonJS({
  "node_modules/yaml/dist/parse/cst-stringify.js"(exports) {
    "use strict";
    var stringify3 = (cst) => "type" in cst ? stringifyToken(cst) : stringifyItem(cst);
    function stringifyToken(token2) {
      switch (token2.type) {
        case "block-scalar": {
          let res = "";
          for (const tok of token2.props)
            res += stringifyToken(tok);
          return res + token2.source;
        }
        case "block-map":
        case "block-seq": {
          let res = "";
          for (const item of token2.items)
            res += stringifyItem(item);
          return res;
        }
        case "flow-collection": {
          let res = token2.start.source;
          for (const item of token2.items)
            res += stringifyItem(item);
          for (const st of token2.end)
            res += st.source;
          return res;
        }
        case "document": {
          let res = stringifyItem(token2);
          if (token2.end)
            for (const st of token2.end)
              res += st.source;
          return res;
        }
        default: {
          let res = token2.source;
          if ("end" in token2 && token2.end)
            for (const st of token2.end)
              res += st.source;
          return res;
        }
      }
    }
    function stringifyItem({ start, key, sep: sep2, value: value4 }) {
      let res = "";
      for (const st of start)
        res += st.source;
      if (key)
        res += stringifyToken(key);
      if (sep2)
        for (const st of sep2)
          res += st.source;
      if (value4)
        res += stringifyToken(value4);
      return res;
    }
    exports.stringify = stringify3;
  }
});

// node_modules/yaml/dist/parse/cst-visit.js
var require_cst_visit = __commonJS({
  "node_modules/yaml/dist/parse/cst-visit.js"(exports) {
    "use strict";
    var BREAK = Symbol("break visit");
    var SKIP = Symbol("skip children");
    var REMOVE = Symbol("remove item");
    function visit(cst, visitor) {
      if ("type" in cst && cst.type === "document")
        cst = { start: cst.start, value: cst.value };
      _visit(Object.freeze([]), cst, visitor);
    }
    visit.BREAK = BREAK;
    visit.SKIP = SKIP;
    visit.REMOVE = REMOVE;
    visit.itemAtPath = (cst, path5) => {
      let item = cst;
      for (const [field, index4] of path5) {
        const tok = item?.[field];
        if (tok && "items" in tok) {
          item = tok.items[index4];
        } else
          return void 0;
      }
      return item;
    };
    visit.parentCollection = (cst, path5) => {
      const parent = visit.itemAtPath(cst, path5.slice(0, -1));
      const field = path5[path5.length - 1][0];
      const coll = parent?.[field];
      if (coll && "items" in coll)
        return coll;
      throw new Error("Parent collection not found");
    };
    function _visit(path5, item, visitor) {
      let ctrl = visitor(item, path5);
      if (typeof ctrl === "symbol")
        return ctrl;
      for (const field of ["key", "value"]) {
        const token2 = item[field];
        if (token2 && "items" in token2) {
          for (let i = 0; i < token2.items.length; ++i) {
            const ci = _visit(Object.freeze(path5.concat([[field, i]])), token2.items[i], visitor);
            if (typeof ci === "number")
              i = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              token2.items.splice(i, 1);
              i -= 1;
            }
          }
          if (typeof ctrl === "function" && field === "key")
            ctrl = ctrl(item, path5);
        }
      }
      return typeof ctrl === "function" ? ctrl(item, path5) : ctrl;
    }
    exports.visit = visit;
  }
});

// node_modules/yaml/dist/parse/cst.js
var require_cst = __commonJS({
  "node_modules/yaml/dist/parse/cst.js"(exports) {
    "use strict";
    var cstScalar = require_cst_scalar();
    var cstStringify = require_cst_stringify();
    var cstVisit = require_cst_visit();
    var BOM = "\uFEFF";
    var DOCUMENT = "";
    var FLOW_END = "";
    var SCALAR = "";
    var isCollection = (token2) => !!token2 && "items" in token2;
    var isScalar = (token2) => !!token2 && (token2.type === "scalar" || token2.type === "single-quoted-scalar" || token2.type === "double-quoted-scalar" || token2.type === "block-scalar");
    function prettyToken(token2) {
      switch (token2) {
        case BOM:
          return "<BOM>";
        case DOCUMENT:
          return "<DOC>";
        case FLOW_END:
          return "<FLOW_END>";
        case SCALAR:
          return "<SCALAR>";
        default:
          return JSON.stringify(token2);
      }
    }
    function tokenType(source2) {
      switch (source2) {
        case BOM:
          return "byte-order-mark";
        case DOCUMENT:
          return "doc-mode";
        case FLOW_END:
          return "flow-error-end";
        case SCALAR:
          return "scalar";
        case "---":
          return "doc-start";
        case "...":
          return "doc-end";
        case "":
        case "\n":
        case "\r\n":
          return "newline";
        case "-":
          return "seq-item-ind";
        case "?":
          return "explicit-key-ind";
        case ":":
          return "map-value-ind";
        case "{":
          return "flow-map-start";
        case "}":
          return "flow-map-end";
        case "[":
          return "flow-seq-start";
        case "]":
          return "flow-seq-end";
        case ",":
          return "comma";
      }
      switch (source2[0]) {
        case " ":
        case "	":
          return "space";
        case "#":
          return "comment";
        case "%":
          return "directive-line";
        case "*":
          return "alias";
        case "&":
          return "anchor";
        case "!":
          return "tag";
        case "'":
          return "single-quoted-scalar";
        case '"':
          return "double-quoted-scalar";
        case "|":
        case ">":
          return "block-scalar-header";
      }
      return null;
    }
    exports.createScalarToken = cstScalar.createScalarToken;
    exports.resolveAsScalar = cstScalar.resolveAsScalar;
    exports.setScalarValue = cstScalar.setScalarValue;
    exports.stringify = cstStringify.stringify;
    exports.visit = cstVisit.visit;
    exports.BOM = BOM;
    exports.DOCUMENT = DOCUMENT;
    exports.FLOW_END = FLOW_END;
    exports.SCALAR = SCALAR;
    exports.isCollection = isCollection;
    exports.isScalar = isScalar;
    exports.prettyToken = prettyToken;
    exports.tokenType = tokenType;
  }
});

// node_modules/yaml/dist/parse/lexer.js
var require_lexer = __commonJS({
  "node_modules/yaml/dist/parse/lexer.js"(exports) {
    "use strict";
    var cst = require_cst();
    function isEmpty7(ch) {
      switch (ch) {
        case void 0:
        case " ":
        case "\n":
        case "\r":
        case "	":
          return true;
        default:
          return false;
      }
    }
    var hexDigits = "0123456789ABCDEFabcdef".split("");
    var tagChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split("");
    var invalidFlowScalarChars = ",[]{}".split("");
    var invalidAnchorChars = " ,[]{}\n\r	".split("");
    var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.includes(ch);
    var Lexer = class {
      constructor() {
        this.atEnd = false;
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        this.buffer = "";
        this.flowKey = false;
        this.flowLevel = 0;
        this.indentNext = 0;
        this.indentValue = 0;
        this.lineEndPos = null;
        this.next = null;
        this.pos = 0;
      }
      /**
       * Generate YAML tokens from the `source` string. If `incomplete`,
       * a part of the last line may be left as a buffer for the next call.
       *
       * @returns A generator of lexical tokens
       */
      *lex(source2, incomplete = false) {
        if (source2) {
          this.buffer = this.buffer ? this.buffer + source2 : source2;
          this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next2 = this.next ?? "stream";
        while (next2 && (incomplete || this.hasChars(1)))
          next2 = yield* this.parseNext(next2);
      }
      atLineEnd() {
        let i = this.pos;
        let ch = this.buffer[i];
        while (ch === " " || ch === "	")
          ch = this.buffer[++i];
        if (!ch || ch === "#" || ch === "\n")
          return true;
        if (ch === "\r")
          return this.buffer[i + 1] === "\n";
        return false;
      }
      charAt(n) {
        return this.buffer[this.pos + n];
      }
      continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
          let indent3 = 0;
          while (ch === " ")
            ch = this.buffer[++indent3 + offset];
          if (ch === "\r") {
            const next2 = this.buffer[indent3 + offset + 1];
            if (next2 === "\n" || !next2 && !this.atEnd)
              return offset + indent3 + 1;
          }
          return ch === "\n" || indent3 >= this.indentNext || !ch && !this.atEnd ? offset + indent3 : -1;
        }
        if (ch === "-" || ch === ".") {
          const dt = this.buffer.substr(offset, 3);
          if ((dt === "---" || dt === "...") && isEmpty7(this.buffer[offset + 3]))
            return -1;
        }
        return offset;
      }
      getLine() {
        let end4 = this.lineEndPos;
        if (typeof end4 !== "number" || end4 !== -1 && end4 < this.pos) {
          end4 = this.buffer.indexOf("\n", this.pos);
          this.lineEndPos = end4;
        }
        if (end4 === -1)
          return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end4 - 1] === "\r")
          end4 -= 1;
        return this.buffer.substring(this.pos, end4);
      }
      hasChars(n) {
        return this.pos + n <= this.buffer.length;
      }
      setNext(state2) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state2;
        return null;
      }
      peek(n) {
        return this.buffer.substr(this.pos, n);
      }
      *parseNext(next2) {
        switch (next2) {
          case "stream":
            return yield* this.parseStream();
          case "line-start":
            return yield* this.parseLineStart();
          case "block-start":
            return yield* this.parseBlockStart();
          case "doc":
            return yield* this.parseDocument();
          case "flow":
            return yield* this.parseFlowCollection();
          case "quoted-scalar":
            return yield* this.parseQuotedScalar();
          case "block-scalar":
            return yield* this.parseBlockScalar();
          case "plain-scalar":
            return yield* this.parsePlainScalar();
        }
      }
      *parseStream() {
        let line2 = this.getLine();
        if (line2 === null)
          return this.setNext("stream");
        if (line2[0] === cst.BOM) {
          yield* this.pushCount(1);
          line2 = line2.substring(1);
        }
        if (line2[0] === "%") {
          let dirEnd = line2.length;
          const cs = line2.indexOf("#");
          if (cs !== -1) {
            const ch = line2[cs - 1];
            if (ch === " " || ch === "	")
              dirEnd = cs - 1;
          }
          while (true) {
            const ch = line2[dirEnd - 1];
            if (ch === " " || ch === "	")
              dirEnd -= 1;
            else
              break;
          }
          const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
          yield* this.pushCount(line2.length - n);
          this.pushNewline();
          return "stream";
        }
        if (this.atLineEnd()) {
          const sp = yield* this.pushSpaces(true);
          yield* this.pushCount(line2.length - sp);
          yield* this.pushNewline();
          return "stream";
        }
        yield cst.DOCUMENT;
        return yield* this.parseLineStart();
      }
      *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd)
          return this.setNext("line-start");
        if (ch === "-" || ch === ".") {
          if (!this.atEnd && !this.hasChars(4))
            return this.setNext("line-start");
          const s = this.peek(3);
          if (s === "---" && isEmpty7(this.charAt(3))) {
            yield* this.pushCount(3);
            this.indentValue = 0;
            this.indentNext = 0;
            return "doc";
          } else if (s === "..." && isEmpty7(this.charAt(3))) {
            yield* this.pushCount(3);
            return "stream";
          }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !isEmpty7(this.charAt(1)))
          this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
      }
      *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd)
          return this.setNext("block-start");
        if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty7(ch1)) {
          const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
          this.indentNext = this.indentValue + 1;
          this.indentValue += n;
          return yield* this.parseBlockStart();
        }
        return "doc";
      }
      *parseDocument() {
        yield* this.pushSpaces(true);
        const line2 = this.getLine();
        if (line2 === null)
          return this.setNext("doc");
        let n = yield* this.pushIndicators();
        switch (line2[n]) {
          case "#":
            yield* this.pushCount(line2.length - n);
          case void 0:
            yield* this.pushNewline();
            return yield* this.parseLineStart();
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel = 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            return "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "doc";
          case '"':
          case "'":
            return yield* this.parseQuotedScalar();
          case "|":
          case ">":
            n += yield* this.parseBlockScalarHeader();
            n += yield* this.pushSpaces(true);
            yield* this.pushCount(line2.length - n);
            yield* this.pushNewline();
            return yield* this.parseBlockScalar();
          default:
            return yield* this.parsePlainScalar();
        }
      }
      *parseFlowCollection() {
        let nl, sp;
        let indent3 = -1;
        do {
          nl = yield* this.pushNewline();
          if (nl > 0) {
            sp = yield* this.pushSpaces(false);
            this.indentValue = indent3 = sp;
          } else {
            sp = 0;
          }
          sp += yield* this.pushSpaces(true);
        } while (nl + sp > 0);
        const line2 = this.getLine();
        if (line2 === null)
          return this.setNext("flow");
        if (indent3 !== -1 && indent3 < this.indentNext && line2[0] !== "#" || indent3 === 0 && (line2.startsWith("---") || line2.startsWith("...")) && isEmpty7(line2[3])) {
          const atFlowEndMarker = indent3 === this.indentNext - 1 && this.flowLevel === 1 && (line2[0] === "]" || line2[0] === "}");
          if (!atFlowEndMarker) {
            this.flowLevel = 0;
            yield cst.FLOW_END;
            return yield* this.parseLineStart();
          }
        }
        let n = 0;
        while (line2[n] === ",") {
          n += yield* this.pushCount(1);
          n += yield* this.pushSpaces(true);
          this.flowKey = false;
        }
        n += yield* this.pushIndicators();
        switch (line2[n]) {
          case void 0:
            return "flow";
          case "#":
            yield* this.pushCount(line2.length - n);
            return "flow";
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel += 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            this.flowKey = true;
            this.flowLevel -= 1;
            return this.flowLevel ? "flow" : "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "flow";
          case '"':
          case "'":
            this.flowKey = true;
            return yield* this.parseQuotedScalar();
          case ":": {
            const next2 = this.charAt(1);
            if (this.flowKey || isEmpty7(next2) || next2 === ",") {
              this.flowKey = false;
              yield* this.pushCount(1);
              yield* this.pushSpaces(true);
              return "flow";
            }
          }
          default:
            this.flowKey = false;
            return yield* this.parsePlainScalar();
        }
      }
      *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end4 = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") {
          while (end4 !== -1 && this.buffer[end4 + 1] === "'")
            end4 = this.buffer.indexOf("'", end4 + 2);
        } else {
          while (end4 !== -1) {
            let n = 0;
            while (this.buffer[end4 - 1 - n] === "\\")
              n += 1;
            if (n % 2 === 0)
              break;
            end4 = this.buffer.indexOf('"', end4 + 1);
          }
        }
        const qb = this.buffer.substring(0, end4);
        let nl = qb.indexOf("\n", this.pos);
        if (nl !== -1) {
          while (nl !== -1) {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = qb.indexOf("\n", cs);
          }
          if (nl !== -1) {
            end4 = nl - (qb[nl - 1] === "\r" ? 2 : 1);
          }
        }
        if (end4 === -1) {
          if (!this.atEnd)
            return this.setNext("quoted-scalar");
          end4 = this.buffer.length;
        }
        yield* this.pushToIndex(end4 + 1, false);
        return this.flowLevel ? "flow" : "doc";
      }
      *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i = this.pos;
        while (true) {
          const ch = this.buffer[++i];
          if (ch === "+")
            this.blockScalarKeep = true;
          else if (ch > "0" && ch <= "9")
            this.blockScalarIndent = Number(ch) - 1;
          else if (ch !== "-")
            break;
        }
        return yield* this.pushUntil((ch) => isEmpty7(ch) || ch === "#");
      }
      *parseBlockScalar() {
        let nl = this.pos - 1;
        let indent3 = 0;
        let ch;
        loop:
          for (let i = this.pos; ch = this.buffer[i]; ++i) {
            switch (ch) {
              case " ":
                indent3 += 1;
                break;
              case "\n":
                nl = i;
                indent3 = 0;
                break;
              case "\r": {
                const next2 = this.buffer[i + 1];
                if (!next2 && !this.atEnd)
                  return this.setNext("block-scalar");
                if (next2 === "\n")
                  break;
              }
              default:
                break loop;
            }
          }
        if (!ch && !this.atEnd)
          return this.setNext("block-scalar");
        if (indent3 >= this.indentNext) {
          if (this.blockScalarIndent === -1)
            this.indentNext = indent3;
          else
            this.indentNext += this.blockScalarIndent;
          do {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = this.buffer.indexOf("\n", cs);
          } while (nl !== -1);
          if (nl === -1) {
            if (!this.atEnd)
              return this.setNext("block-scalar");
            nl = this.buffer.length;
          }
        }
        if (!this.blockScalarKeep) {
          do {
            let i = nl - 1;
            let ch2 = this.buffer[i];
            if (ch2 === "\r")
              ch2 = this.buffer[--i];
            const lastChar = i;
            while (ch2 === " " || ch2 === "	")
              ch2 = this.buffer[--i];
            if (ch2 === "\n" && i >= this.pos && i + 1 + indent3 > lastChar)
              nl = i;
            else
              break;
          } while (true);
        }
        yield cst.SCALAR;
        yield* this.pushToIndex(nl + 1, true);
        return yield* this.parseLineStart();
      }
      *parsePlainScalar() {
        const inFlow = this.flowLevel > 0;
        let end4 = this.pos - 1;
        let i = this.pos - 1;
        let ch;
        while (ch = this.buffer[++i]) {
          if (ch === ":") {
            const next2 = this.buffer[i + 1];
            if (isEmpty7(next2) || inFlow && next2 === ",")
              break;
            end4 = i;
          } else if (isEmpty7(ch)) {
            let next2 = this.buffer[i + 1];
            if (ch === "\r") {
              if (next2 === "\n") {
                i += 1;
                ch = "\n";
                next2 = this.buffer[i + 1];
              } else
                end4 = i;
            }
            if (next2 === "#" || inFlow && invalidFlowScalarChars.includes(next2))
              break;
            if (ch === "\n") {
              const cs = this.continueScalar(i + 1);
              if (cs === -1)
                break;
              i = Math.max(i, cs - 2);
            }
          } else {
            if (inFlow && invalidFlowScalarChars.includes(ch))
              break;
            end4 = i;
          }
        }
        if (!ch && !this.atEnd)
          return this.setNext("plain-scalar");
        yield cst.SCALAR;
        yield* this.pushToIndex(end4 + 1, true);
        return inFlow ? "flow" : "doc";
      }
      *pushCount(n) {
        if (n > 0) {
          yield this.buffer.substr(this.pos, n);
          this.pos += n;
          return n;
        }
        return 0;
      }
      *pushToIndex(i, allowEmpty) {
        const s = this.buffer.slice(this.pos, i);
        if (s) {
          yield s;
          this.pos += s.length;
          return s.length;
        } else if (allowEmpty)
          yield "";
        return 0;
      }
      *pushIndicators() {
        switch (this.charAt(0)) {
          case "!":
            return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "&":
            return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "-":
          case "?":
          case ":": {
            const inFlow = this.flowLevel > 0;
            const ch1 = this.charAt(1);
            if (isEmpty7(ch1) || inFlow && invalidFlowScalarChars.includes(ch1)) {
              if (!inFlow)
                this.indentNext = this.indentValue + 1;
              else if (this.flowKey)
                this.flowKey = false;
              return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
            }
          }
        }
        return 0;
      }
      *pushTag() {
        if (this.charAt(1) === "<") {
          let i = this.pos + 2;
          let ch = this.buffer[i];
          while (!isEmpty7(ch) && ch !== ">")
            ch = this.buffer[++i];
          return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
        } else {
          let i = this.pos + 1;
          let ch = this.buffer[i];
          while (ch) {
            if (tagChars.includes(ch))
              ch = this.buffer[++i];
            else if (ch === "%" && hexDigits.includes(this.buffer[i + 1]) && hexDigits.includes(this.buffer[i + 2])) {
              ch = this.buffer[i += 3];
            } else
              break;
          }
          return yield* this.pushToIndex(i, false);
        }
      }
      *pushNewline() {
        const ch = this.buffer[this.pos];
        if (ch === "\n")
          return yield* this.pushCount(1);
        else if (ch === "\r" && this.charAt(1) === "\n")
          return yield* this.pushCount(2);
        else
          return 0;
      }
      *pushSpaces(allowTabs) {
        let i = this.pos - 1;
        let ch;
        do {
          ch = this.buffer[++i];
        } while (ch === " " || allowTabs && ch === "	");
        const n = i - this.pos;
        if (n > 0) {
          yield this.buffer.substr(this.pos, n);
          this.pos = i;
        }
        return n;
      }
      *pushUntil(test2) {
        let i = this.pos;
        let ch = this.buffer[i];
        while (!test2(ch))
          ch = this.buffer[++i];
        return yield* this.pushToIndex(i, false);
      }
    };
    exports.Lexer = Lexer;
  }
});

// node_modules/yaml/dist/parse/line-counter.js
var require_line_counter = __commonJS({
  "node_modules/yaml/dist/parse/line-counter.js"(exports) {
    "use strict";
    var LineCounter = class {
      constructor() {
        this.lineStarts = [];
        this.addNewLine = (offset) => this.lineStarts.push(offset);
        this.linePos = (offset) => {
          let low = 0;
          let high = this.lineStarts.length;
          while (low < high) {
            const mid = low + high >> 1;
            if (this.lineStarts[mid] < offset)
              low = mid + 1;
            else
              high = mid;
          }
          if (this.lineStarts[low] === offset)
            return { line: low + 1, col: 1 };
          if (low === 0)
            return { line: 0, col: offset };
          const start = this.lineStarts[low - 1];
          return { line: low, col: offset - start + 1 };
        };
      }
    };
    exports.LineCounter = LineCounter;
  }
});

// node_modules/yaml/dist/parse/parser.js
var require_parser = __commonJS({
  "node_modules/yaml/dist/parse/parser.js"(exports) {
    "use strict";
    var cst = require_cst();
    var lexer = require_lexer();
    function includesToken(list2, type) {
      for (let i = 0; i < list2.length; ++i)
        if (list2[i].type === type)
          return true;
      return false;
    }
    function findNonEmptyIndex(list2) {
      for (let i = 0; i < list2.length; ++i) {
        switch (list2[i].type) {
          case "space":
          case "comment":
          case "newline":
            break;
          default:
            return i;
        }
      }
      return -1;
    }
    function isFlowToken(token2) {
      switch (token2?.type) {
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "flow-collection":
          return true;
        default:
          return false;
      }
    }
    function getPrevProps(parent) {
      switch (parent.type) {
        case "document":
          return parent.start;
        case "block-map": {
          const it = parent.items[parent.items.length - 1];
          return it.sep ?? it.start;
        }
        case "block-seq":
          return parent.items[parent.items.length - 1].start;
        default:
          return [];
      }
    }
    function getFirstKeyStartProps(prev) {
      if (prev.length === 0)
        return [];
      let i = prev.length;
      loop:
        while (--i >= 0) {
          switch (prev[i].type) {
            case "doc-start":
            case "explicit-key-ind":
            case "map-value-ind":
            case "seq-item-ind":
            case "newline":
              break loop;
          }
        }
      while (prev[++i]?.type === "space") {
      }
      return prev.splice(i, prev.length);
    }
    function fixFlowSeqItems(fc) {
      if (fc.start.type === "flow-seq-start") {
        for (const it of fc.items) {
          if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
            if (it.key)
              it.value = it.key;
            delete it.key;
            if (isFlowToken(it.value)) {
              if (it.value.end)
                Array.prototype.push.apply(it.value.end, it.sep);
              else
                it.value.end = it.sep;
            } else
              Array.prototype.push.apply(it.start, it.sep);
            delete it.sep;
          }
        }
      }
    }
    var Parser = class {
      /**
       * @param onNewLine - If defined, called separately with the start position of
       *   each new line (in `parse()`, including the start of input).
       */
      constructor(onNewLine) {
        this.atNewLine = true;
        this.atScalar = false;
        this.indent = 0;
        this.offset = 0;
        this.onKeyLine = false;
        this.stack = [];
        this.source = "";
        this.type = "";
        this.lexer = new lexer.Lexer();
        this.onNewLine = onNewLine;
      }
      /**
       * Parse `source` as a YAML stream.
       * If `incomplete`, a part of the last line may be left as a buffer for the next call.
       *
       * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
       *
       * @returns A generator of tokens representing each directive, document, and other structure.
       */
      *parse(source2, incomplete = false) {
        if (this.onNewLine && this.offset === 0)
          this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source2, incomplete))
          yield* this.next(lexeme);
        if (!incomplete)
          yield* this.end();
      }
      /**
       * Advance the parser by the `source` of one lexical token.
       */
      *next(source2) {
        this.source = source2;
        if (process.env.LOG_TOKENS)
          console.log("|", cst.prettyToken(source2));
        if (this.atScalar) {
          this.atScalar = false;
          yield* this.step();
          this.offset += source2.length;
          return;
        }
        const type = cst.tokenType(source2);
        if (!type) {
          const message2 = `Not a YAML token: ${source2}`;
          yield* this.pop({ type: "error", offset: this.offset, message: message2, source: source2 });
          this.offset += source2.length;
        } else if (type === "scalar") {
          this.atNewLine = false;
          this.atScalar = true;
          this.type = "scalar";
        } else {
          this.type = type;
          yield* this.step();
          switch (type) {
            case "newline":
              this.atNewLine = true;
              this.indent = 0;
              if (this.onNewLine)
                this.onNewLine(this.offset + source2.length);
              break;
            case "space":
              if (this.atNewLine && source2[0] === " ")
                this.indent += source2.length;
              break;
            case "explicit-key-ind":
            case "map-value-ind":
            case "seq-item-ind":
              if (this.atNewLine)
                this.indent += source2.length;
              break;
            case "doc-mode":
            case "flow-error-end":
              return;
            default:
              this.atNewLine = false;
          }
          this.offset += source2.length;
        }
      }
      /** Call at end of input to push out any remaining constructions */
      *end() {
        while (this.stack.length > 0)
          yield* this.pop();
      }
      get sourceToken() {
        const st = {
          type: this.type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
        return st;
      }
      *step() {
        const top3 = this.peek(1);
        if (this.type === "doc-end" && (!top3 || top3.type !== "doc-end")) {
          while (this.stack.length > 0)
            yield* this.pop();
          this.stack.push({
            type: "doc-end",
            offset: this.offset,
            source: this.source
          });
          return;
        }
        if (!top3)
          return yield* this.stream();
        switch (top3.type) {
          case "document":
            return yield* this.document(top3);
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return yield* this.scalar(top3);
          case "block-scalar":
            return yield* this.blockScalar(top3);
          case "block-map":
            return yield* this.blockMap(top3);
          case "block-seq":
            return yield* this.blockSequence(top3);
          case "flow-collection":
            return yield* this.flowCollection(top3);
          case "doc-end":
            return yield* this.documentEnd(top3);
        }
        yield* this.pop();
      }
      peek(n) {
        return this.stack[this.stack.length - n];
      }
      *pop(error4) {
        const token2 = error4 ?? this.stack.pop();
        if (!token2) {
          const message2 = "Tried to pop an empty stack";
          yield { type: "error", offset: this.offset, source: "", message: message2 };
        } else if (this.stack.length === 0) {
          yield token2;
        } else {
          const top3 = this.peek(1);
          if (token2.type === "block-scalar") {
            token2.indent = "indent" in top3 ? top3.indent : 0;
          } else if (token2.type === "flow-collection" && top3.type === "document") {
            token2.indent = 0;
          }
          if (token2.type === "flow-collection")
            fixFlowSeqItems(token2);
          switch (top3.type) {
            case "document":
              top3.value = token2;
              break;
            case "block-scalar":
              top3.props.push(token2);
              break;
            case "block-map": {
              const it = top3.items[top3.items.length - 1];
              if (it.value) {
                top3.items.push({ start: [], key: token2, sep: [] });
                this.onKeyLine = true;
                return;
              } else if (it.sep) {
                it.value = token2;
              } else {
                Object.assign(it, { key: token2, sep: [] });
                this.onKeyLine = !includesToken(it.start, "explicit-key-ind");
                return;
              }
              break;
            }
            case "block-seq": {
              const it = top3.items[top3.items.length - 1];
              if (it.value)
                top3.items.push({ start: [], value: token2 });
              else
                it.value = token2;
              break;
            }
            case "flow-collection": {
              const it = top3.items[top3.items.length - 1];
              if (!it || it.value)
                top3.items.push({ start: [], key: token2, sep: [] });
              else if (it.sep)
                it.value = token2;
              else
                Object.assign(it, { key: token2, sep: [] });
              return;
            }
            default:
              yield* this.pop();
              yield* this.pop(token2);
          }
          if ((top3.type === "document" || top3.type === "block-map" || top3.type === "block-seq") && (token2.type === "block-map" || token2.type === "block-seq")) {
            const last4 = token2.items[token2.items.length - 1];
            if (last4 && !last4.sep && !last4.value && last4.start.length > 0 && findNonEmptyIndex(last4.start) === -1 && (token2.indent === 0 || last4.start.every((st) => st.type !== "comment" || st.indent < token2.indent))) {
              if (top3.type === "document")
                top3.end = last4.start;
              else
                top3.items.push({ start: last4.start });
              token2.items.splice(-1, 1);
            }
          }
        }
      }
      *stream() {
        switch (this.type) {
          case "directive-line":
            yield { type: "directive", offset: this.offset, source: this.source };
            return;
          case "byte-order-mark":
          case "space":
          case "comment":
          case "newline":
            yield this.sourceToken;
            return;
          case "doc-mode":
          case "doc-start": {
            const doc = {
              type: "document",
              offset: this.offset,
              start: []
            };
            if (this.type === "doc-start")
              doc.start.push(this.sourceToken);
            this.stack.push(doc);
            return;
          }
        }
        yield {
          type: "error",
          offset: this.offset,
          message: `Unexpected ${this.type} token in YAML stream`,
          source: this.source
        };
      }
      *document(doc) {
        if (doc.value)
          return yield* this.lineEnd(doc);
        switch (this.type) {
          case "doc-start": {
            if (findNonEmptyIndex(doc.start) !== -1) {
              yield* this.pop();
              yield* this.step();
            } else
              doc.start.push(this.sourceToken);
            return;
          }
          case "anchor":
          case "tag":
          case "space":
          case "comment":
          case "newline":
            doc.start.push(this.sourceToken);
            return;
        }
        const bv = this.startBlockValue(doc);
        if (bv)
          this.stack.push(bv);
        else {
          yield {
            type: "error",
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML document`,
            source: this.source
          };
        }
      }
      *scalar(scalar) {
        if (this.type === "map-value-ind") {
          const prev = getPrevProps(this.peek(2));
          const start = getFirstKeyStartProps(prev);
          let sep2;
          if (scalar.end) {
            sep2 = scalar.end;
            sep2.push(this.sourceToken);
            delete scalar.end;
          } else
            sep2 = [this.sourceToken];
          const map86 = {
            type: "block-map",
            offset: scalar.offset,
            indent: scalar.indent,
            items: [{ start, key: scalar, sep: sep2 }]
          };
          this.onKeyLine = true;
          this.stack[this.stack.length - 1] = map86;
        } else
          yield* this.lineEnd(scalar);
      }
      *blockScalar(scalar) {
        switch (this.type) {
          case "space":
          case "comment":
          case "newline":
            scalar.props.push(this.sourceToken);
            return;
          case "scalar":
            scalar.source = this.source;
            this.atNewLine = true;
            this.indent = 0;
            if (this.onNewLine) {
              let nl = this.source.indexOf("\n") + 1;
              while (nl !== 0) {
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf("\n", nl) + 1;
              }
            }
            yield* this.pop();
            break;
          default:
            yield* this.pop();
            yield* this.step();
        }
      }
      *blockMap(map86) {
        const it = map86.items[map86.items.length - 1];
        switch (this.type) {
          case "newline":
            this.onKeyLine = false;
            if (it.value) {
              const end4 = "end" in it.value ? it.value.end : void 0;
              const last4 = Array.isArray(end4) ? end4[end4.length - 1] : void 0;
              if (last4?.type === "comment")
                end4?.push(this.sourceToken);
              else
                map86.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              it.start.push(this.sourceToken);
            }
            return;
          case "space":
          case "comment":
            if (it.value) {
              map86.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              if (this.atIndentedComment(it.start, map86.indent)) {
                const prev = map86.items[map86.items.length - 2];
                const end4 = prev?.value?.end;
                if (Array.isArray(end4)) {
                  Array.prototype.push.apply(end4, it.start);
                  end4.push(this.sourceToken);
                  map86.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
        }
        if (this.indent >= map86.indent) {
          const atNextItem = !this.onKeyLine && this.indent === map86.indent && it.sep;
          let start = [];
          if (atNextItem && it.sep && !it.value) {
            const nl = [];
            for (let i = 0; i < it.sep.length; ++i) {
              const st = it.sep[i];
              switch (st.type) {
                case "newline":
                  nl.push(i);
                  break;
                case "space":
                  break;
                case "comment":
                  if (st.indent > map86.indent)
                    nl.length = 0;
                  break;
                default:
                  nl.length = 0;
              }
            }
            if (nl.length >= 2)
              start = it.sep.splice(nl[1]);
          }
          switch (this.type) {
            case "anchor":
            case "tag":
              if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map86.items.push({ start });
                this.onKeyLine = true;
              } else if (it.sep) {
                it.sep.push(this.sourceToken);
              } else {
                it.start.push(this.sourceToken);
              }
              return;
            case "explicit-key-ind":
              if (!it.sep && !includesToken(it.start, "explicit-key-ind")) {
                it.start.push(this.sourceToken);
              } else if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map86.items.push({ start });
              } else {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: [this.sourceToken] }]
                });
              }
              this.onKeyLine = true;
              return;
            case "map-value-ind":
              if (includesToken(it.start, "explicit-key-ind")) {
                if (!it.sep) {
                  if (includesToken(it.start, "newline")) {
                    Object.assign(it, { key: null, sep: [this.sourceToken] });
                  } else {
                    const start2 = getFirstKeyStartProps(it.start);
                    this.stack.push({
                      type: "block-map",
                      offset: this.offset,
                      indent: this.indent,
                      items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                    });
                  }
                } else if (it.value) {
                  map86.items.push({ start: [], key: null, sep: [this.sourceToken] });
                } else if (includesToken(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, key: null, sep: [this.sourceToken] }]
                  });
                } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
                  const start2 = getFirstKeyStartProps(it.start);
                  const key = it.key;
                  const sep2 = it.sep;
                  sep2.push(this.sourceToken);
                  delete it.key, delete it.sep;
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: start2, key, sep: sep2 }]
                  });
                } else if (start.length > 0) {
                  it.sep = it.sep.concat(start, this.sourceToken);
                } else {
                  it.sep.push(this.sourceToken);
                }
              } else {
                if (!it.sep) {
                  Object.assign(it, { key: null, sep: [this.sourceToken] });
                } else if (it.value || atNextItem) {
                  map86.items.push({ start, key: null, sep: [this.sourceToken] });
                } else if (includesToken(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: [], key: null, sep: [this.sourceToken] }]
                  });
                } else {
                  it.sep.push(this.sourceToken);
                }
              }
              this.onKeyLine = true;
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs2 = this.flowScalar(this.type);
              if (atNextItem || it.value) {
                map86.items.push({ start, key: fs2, sep: [] });
                this.onKeyLine = true;
              } else if (it.sep) {
                this.stack.push(fs2);
              } else {
                Object.assign(it, { key: fs2, sep: [] });
                this.onKeyLine = true;
              }
              return;
            }
            default: {
              const bv = this.startBlockValue(map86);
              if (bv) {
                if (atNextItem && bv.type !== "block-seq" && includesToken(it.start, "explicit-key-ind")) {
                  map86.items.push({ start });
                }
                this.stack.push(bv);
                return;
              }
            }
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *blockSequence(seq) {
        const it = seq.items[seq.items.length - 1];
        switch (this.type) {
          case "newline":
            if (it.value) {
              const end4 = "end" in it.value ? it.value.end : void 0;
              const last4 = Array.isArray(end4) ? end4[end4.length - 1] : void 0;
              if (last4?.type === "comment")
                end4?.push(this.sourceToken);
              else
                seq.items.push({ start: [this.sourceToken] });
            } else
              it.start.push(this.sourceToken);
            return;
          case "space":
          case "comment":
            if (it.value)
              seq.items.push({ start: [this.sourceToken] });
            else {
              if (this.atIndentedComment(it.start, seq.indent)) {
                const prev = seq.items[seq.items.length - 2];
                const end4 = prev?.value?.end;
                if (Array.isArray(end4)) {
                  Array.prototype.push.apply(end4, it.start);
                  end4.push(this.sourceToken);
                  seq.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
          case "anchor":
          case "tag":
            if (it.value || this.indent <= seq.indent)
              break;
            it.start.push(this.sourceToken);
            return;
          case "seq-item-ind":
            if (this.indent !== seq.indent)
              break;
            if (it.value || includesToken(it.start, "seq-item-ind"))
              seq.items.push({ start: [this.sourceToken] });
            else
              it.start.push(this.sourceToken);
            return;
        }
        if (this.indent > seq.indent) {
          const bv = this.startBlockValue(seq);
          if (bv) {
            this.stack.push(bv);
            return;
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *flowCollection(fc) {
        const it = fc.items[fc.items.length - 1];
        if (this.type === "flow-error-end") {
          let top3;
          do {
            yield* this.pop();
            top3 = this.peek(1);
          } while (top3 && top3.type === "flow-collection");
        } else if (fc.end.length === 0) {
          switch (this.type) {
            case "comma":
            case "explicit-key-ind":
              if (!it || it.sep)
                fc.items.push({ start: [this.sourceToken] });
              else
                it.start.push(this.sourceToken);
              return;
            case "map-value-ind":
              if (!it || it.value)
                fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              return;
            case "space":
            case "comment":
            case "newline":
            case "anchor":
            case "tag":
              if (!it || it.value)
                fc.items.push({ start: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                it.start.push(this.sourceToken);
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs2 = this.flowScalar(this.type);
              if (!it || it.value)
                fc.items.push({ start: [], key: fs2, sep: [] });
              else if (it.sep)
                this.stack.push(fs2);
              else
                Object.assign(it, { key: fs2, sep: [] });
              return;
            }
            case "flow-map-end":
            case "flow-seq-end":
              fc.end.push(this.sourceToken);
              return;
          }
          const bv = this.startBlockValue(fc);
          if (bv)
            this.stack.push(bv);
          else {
            yield* this.pop();
            yield* this.step();
          }
        } else {
          const parent = this.peek(2);
          if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
            yield* this.pop();
            yield* this.step();
          } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            fixFlowSeqItems(fc);
            const sep2 = fc.end.splice(1, fc.end.length);
            sep2.push(this.sourceToken);
            const map86 = {
              type: "block-map",
              offset: fc.offset,
              indent: fc.indent,
              items: [{ start, key: fc, sep: sep2 }]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map86;
          } else {
            yield* this.lineEnd(fc);
          }
        }
      }
      flowScalar(type) {
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        return {
          type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
      }
      startBlockValue(parent) {
        switch (this.type) {
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return this.flowScalar(this.type);
          case "block-scalar-header":
            return {
              type: "block-scalar",
              offset: this.offset,
              indent: this.indent,
              props: [this.sourceToken],
              source: ""
            };
          case "flow-map-start":
          case "flow-seq-start":
            return {
              type: "flow-collection",
              offset: this.offset,
              indent: this.indent,
              start: this.sourceToken,
              items: [],
              end: []
            };
          case "seq-item-ind":
            return {
              type: "block-seq",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken] }]
            };
          case "explicit-key-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            start.push(this.sourceToken);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start }]
            };
          }
          case "map-value-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start, key: null, sep: [this.sourceToken] }]
            };
          }
        }
        return null;
      }
      atIndentedComment(start, indent3) {
        if (this.type !== "comment")
          return false;
        if (this.indent <= indent3)
          return false;
        return start.every((st) => st.type === "newline" || st.type === "space");
      }
      *documentEnd(docEnd) {
        if (this.type !== "doc-mode") {
          if (docEnd.end)
            docEnd.end.push(this.sourceToken);
          else
            docEnd.end = [this.sourceToken];
          if (this.type === "newline")
            yield* this.pop();
        }
      }
      *lineEnd(token2) {
        switch (this.type) {
          case "comma":
          case "doc-start":
          case "doc-end":
          case "flow-seq-end":
          case "flow-map-end":
          case "map-value-ind":
            yield* this.pop();
            yield* this.step();
            break;
          case "newline":
            this.onKeyLine = false;
          case "space":
          case "comment":
          default:
            if (token2.end)
              token2.end.push(this.sourceToken);
            else
              token2.end = [this.sourceToken];
            if (this.type === "newline")
              yield* this.pop();
        }
      }
    };
    exports.Parser = Parser;
  }
});

// node_modules/yaml/dist/public-api.js
var require_public_api = __commonJS({
  "node_modules/yaml/dist/public-api.js"(exports) {
    "use strict";
    var composer = require_composer();
    var Document3 = require_Document();
    var errors = require_errors();
    var log5 = require_log();
    var lineCounter = require_line_counter();
    var parser5 = require_parser();
    function parseOptions(options) {
      const prettyErrors = options.prettyErrors !== false;
      const lineCounter$1 = options.lineCounter || prettyErrors && new lineCounter.LineCounter() || null;
      return { lineCounter: lineCounter$1, prettyErrors };
    }
    function parseAllDocuments(source2, options = {}) {
      const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
      const parser$1 = new parser5.Parser(lineCounter2?.addNewLine);
      const composer$1 = new composer.Composer(options);
      const docs = Array.from(composer$1.compose(parser$1.parse(source2)));
      if (prettyErrors && lineCounter2)
        for (const doc of docs) {
          doc.errors.forEach(errors.prettifyError(source2, lineCounter2));
          doc.warnings.forEach(errors.prettifyError(source2, lineCounter2));
        }
      if (docs.length > 0)
        return docs;
      return Object.assign([], { empty: true }, composer$1.streamInfo());
    }
    function parseDocument(source2, options = {}) {
      const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
      const parser$1 = new parser5.Parser(lineCounter2?.addNewLine);
      const composer$1 = new composer.Composer(options);
      let doc = null;
      for (const _doc of composer$1.compose(parser$1.parse(source2), true, source2.length)) {
        if (!doc)
          doc = _doc;
        else if (doc.options.logLevel !== "silent") {
          doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
          break;
        }
      }
      if (prettyErrors && lineCounter2) {
        doc.errors.forEach(errors.prettifyError(source2, lineCounter2));
        doc.warnings.forEach(errors.prettifyError(source2, lineCounter2));
      }
      return doc;
    }
    function parse10(src, reviver, options) {
      let _reviver = void 0;
      if (typeof reviver === "function") {
        _reviver = reviver;
      } else if (options === void 0 && reviver && typeof reviver === "object") {
        options = reviver;
      }
      const doc = parseDocument(src, options);
      if (!doc)
        return null;
      doc.warnings.forEach((warning) => log5.warn(doc.options.logLevel, warning));
      if (doc.errors.length > 0) {
        if (doc.options.logLevel !== "silent")
          throw doc.errors[0];
        else
          doc.errors = [];
      }
      return doc.toJS(Object.assign({ reviver: _reviver }, options));
    }
    function stringify3(value4, replacer, options) {
      let _replacer = null;
      if (typeof replacer === "function" || Array.isArray(replacer)) {
        _replacer = replacer;
      } else if (options === void 0 && replacer) {
        options = replacer;
      }
      if (typeof options === "string")
        options = options.length;
      if (typeof options === "number") {
        const indent3 = Math.round(options);
        options = indent3 < 1 ? void 0 : indent3 > 8 ? { indent: 8 } : { indent: indent3 };
      }
      if (value4 === void 0) {
        const { keepUndefined } = options ?? replacer ?? {};
        if (!keepUndefined)
          return void 0;
      }
      return new Document3.Document(value4, _replacer, options).toString(options);
    }
    exports.parse = parse10;
    exports.parseAllDocuments = parseAllDocuments;
    exports.parseDocument = parseDocument;
    exports.stringify = stringify3;
  }
});

// node_modules/yaml/dist/index.js
var require_dist = __commonJS({
  "node_modules/yaml/dist/index.js"(exports) {
    "use strict";
    var composer = require_composer();
    var Document3 = require_Document();
    var Schema = require_Schema();
    var errors = require_errors();
    var Alias = require_Alias();
    var identity33 = require_identity();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var cst = require_cst();
    var lexer = require_lexer();
    var lineCounter = require_line_counter();
    var parser5 = require_parser();
    var publicApi = require_public_api();
    var visit = require_visit();
    exports.Composer = composer.Composer;
    exports.Document = Document3.Document;
    exports.Schema = Schema.Schema;
    exports.YAMLError = errors.YAMLError;
    exports.YAMLParseError = errors.YAMLParseError;
    exports.YAMLWarning = errors.YAMLWarning;
    exports.Alias = Alias.Alias;
    exports.isAlias = identity33.isAlias;
    exports.isCollection = identity33.isCollection;
    exports.isDocument = identity33.isDocument;
    exports.isMap = identity33.isMap;
    exports.isNode = identity33.isNode;
    exports.isPair = identity33.isPair;
    exports.isScalar = identity33.isScalar;
    exports.isSeq = identity33.isSeq;
    exports.Pair = Pair.Pair;
    exports.Scalar = Scalar.Scalar;
    exports.YAMLMap = YAMLMap.YAMLMap;
    exports.YAMLSeq = YAMLSeq.YAMLSeq;
    exports.CST = cst;
    exports.Lexer = lexer.Lexer;
    exports.LineCounter = lineCounter.LineCounter;
    exports.Parser = parser5.Parser;
    exports.parse = publicApi.parse;
    exports.parseAllDocuments = publicApi.parseAllDocuments;
    exports.parseDocument = publicApi.parseDocument;
    exports.stringify = publicApi.stringify;
    exports.visit = visit.visit;
    exports.visitAsync = visit.visitAsync;
  }
});

// node_modules/universalify/index.js
var require_universalify = __commonJS({
  "node_modules/universalify/index.js"(exports) {
    "use strict";
    exports.fromCallback = function(fn) {
      return Object.defineProperty(function(...args) {
        if (typeof args[args.length - 1] === "function")
          fn.apply(this, args);
        else {
          return new Promise((resolve2, reject) => {
            fn.call(
              this,
              ...args,
              (err, res) => err != null ? reject(err) : resolve2(res)
            );
          });
        }
      }, "name", { value: fn.name });
    };
    exports.fromPromise = function(fn) {
      return Object.defineProperty(function(...args) {
        const cb = args[args.length - 1];
        if (typeof cb !== "function")
          return fn.apply(this, args);
        else
          fn.apply(this, args.slice(0, -1)).then((r) => cb(null, r), cb);
      }, "name", { value: fn.name });
    };
  }
});

// node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS({
  "node_modules/graceful-fs/polyfills.js"(exports, module) {
    var constants4 = __require("constants");
    var origCwd = process.cwd;
    var cwd3 = null;
    var platform3 = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      if (!cwd3)
        cwd3 = origCwd.call(process);
      return cwd3;
    };
    try {
      process.cwd();
    } catch (er) {
    }
    if (typeof process.chdir === "function") {
      chdir2 = process.chdir;
      process.chdir = function(d) {
        cwd3 = null;
        chdir2.call(process, d);
      };
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(process.chdir, chdir2);
    }
    var chdir2;
    module.exports = patch3;
    function patch3(fs2) {
      if (constants4.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs2);
      }
      if (!fs2.lutimes) {
        patchLutimes(fs2);
      }
      fs2.chown = chownFix(fs2.chown);
      fs2.fchown = chownFix(fs2.fchown);
      fs2.lchown = chownFix(fs2.lchown);
      fs2.chmod = chmodFix(fs2.chmod);
      fs2.fchmod = chmodFix(fs2.fchmod);
      fs2.lchmod = chmodFix(fs2.lchmod);
      fs2.chownSync = chownFixSync(fs2.chownSync);
      fs2.fchownSync = chownFixSync(fs2.fchownSync);
      fs2.lchownSync = chownFixSync(fs2.lchownSync);
      fs2.chmodSync = chmodFixSync(fs2.chmodSync);
      fs2.fchmodSync = chmodFixSync(fs2.fchmodSync);
      fs2.lchmodSync = chmodFixSync(fs2.lchmodSync);
      fs2.stat = statFix(fs2.stat);
      fs2.fstat = statFix(fs2.fstat);
      fs2.lstat = statFix(fs2.lstat);
      fs2.statSync = statFixSync(fs2.statSync);
      fs2.fstatSync = statFixSync(fs2.fstatSync);
      fs2.lstatSync = statFixSync(fs2.lstatSync);
      if (fs2.chmod && !fs2.lchmod) {
        fs2.lchmod = function(path5, mode, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs2.lchmodSync = function() {
        };
      }
      if (fs2.chown && !fs2.lchown) {
        fs2.lchown = function(path5, uid, gid, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs2.lchownSync = function() {
        };
      }
      if (platform3 === "win32") {
        fs2.rename = typeof fs2.rename !== "function" ? fs2.rename : function(fs$rename) {
          function rename3(from3, to2, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from3, to2, function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
                setTimeout(function() {
                  fs2.stat(to2, function(stater, st) {
                    if (stater && stater.code === "ENOENT")
                      fs$rename(from3, to2, CB);
                    else
                      cb(er);
                  });
                }, backoff);
                if (backoff < 100)
                  backoff += 10;
                return;
              }
              if (cb)
                cb(er);
            });
          }
          if (Object.setPrototypeOf)
            Object.setPrototypeOf(rename3, fs$rename);
          return rename3;
        }(fs2.rename);
      }
      fs2.read = typeof fs2.read !== "function" ? fs2.read : function(fs$read) {
        function read7(fd, buffer, offset, length7, position2, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = function(er, _, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs2, fd, buffer, offset, length7, position2, callback);
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs2, fd, buffer, offset, length7, position2, callback);
        }
        if (Object.setPrototypeOf)
          Object.setPrototypeOf(read7, fs$read);
        return read7;
      }(fs2.read);
      fs2.readSync = typeof fs2.readSync !== "function" ? fs2.readSync : function(fs$readSync) {
        return function(fd, buffer, offset, length7, position2) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs2, fd, buffer, offset, length7, position2);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      }(fs2.readSync);
      function patchLchmod(fs3) {
        fs3.lchmod = function(path5, mode, callback) {
          fs3.open(
            path5,
            constants4.O_WRONLY | constants4.O_SYMLINK,
            mode,
            function(err, fd) {
              if (err) {
                if (callback)
                  callback(err);
                return;
              }
              fs3.fchmod(fd, mode, function(err2) {
                fs3.close(fd, function(err22) {
                  if (callback)
                    callback(err2 || err22);
                });
              });
            }
          );
        };
        fs3.lchmodSync = function(path5, mode) {
          var fd = fs3.openSync(path5, constants4.O_WRONLY | constants4.O_SYMLINK, mode);
          var threw = true;
          var ret;
          try {
            ret = fs3.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs3.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs3.closeSync(fd);
            }
          }
          return ret;
        };
      }
      function patchLutimes(fs3) {
        if (constants4.hasOwnProperty("O_SYMLINK") && fs3.futimes) {
          fs3.lutimes = function(path5, at, mt, cb) {
            fs3.open(path5, constants4.O_SYMLINK, function(er, fd) {
              if (er) {
                if (cb)
                  cb(er);
                return;
              }
              fs3.futimes(fd, at, mt, function(er2) {
                fs3.close(fd, function(er22) {
                  if (cb)
                    cb(er2 || er22);
                });
              });
            });
          };
          fs3.lutimesSync = function(path5, at, mt) {
            var fd = fs3.openSync(path5, constants4.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs3.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs3.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs3.closeSync(fd);
              }
            }
            return ret;
          };
        } else if (fs3.futimes) {
          fs3.lutimes = function(_a, _b, _c, cb) {
            if (cb)
              process.nextTick(cb);
          };
          fs3.lutimesSync = function() {
          };
        }
      }
      function chmodFix(orig) {
        if (!orig)
          return orig;
        return function(target, mode, cb) {
          return orig.call(fs2, target, mode, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, mode) {
          try {
            return orig.call(fs2, target, mode);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function chownFix(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid, cb) {
          return orig.call(fs2, target, uid, gid, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid) {
          try {
            return orig.call(fs2, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function statFix(orig) {
        if (!orig)
          return orig;
        return function(target, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0)
                stats.uid += 4294967296;
              if (stats.gid < 0)
                stats.gid += 4294967296;
            }
            if (cb)
              cb.apply(this, arguments);
          }
          return options ? orig.call(fs2, target, options, callback) : orig.call(fs2, target, callback);
        };
      }
      function statFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, options) {
          var stats = options ? orig.call(fs2, target, options) : orig.call(fs2, target);
          if (stats) {
            if (stats.uid < 0)
              stats.uid += 4294967296;
            if (stats.gid < 0)
              stats.gid += 4294967296;
          }
          return stats;
        };
      }
      function chownErOk(er) {
        if (!er)
          return true;
        if (er.code === "ENOSYS")
          return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true;
        }
        return false;
      }
    }
  }
});

// node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS({
  "node_modules/graceful-fs/legacy-streams.js"(exports, module) {
    var Stream = __require("stream").Stream;
    module.exports = legacy;
    function legacy(fs2) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path5, options) {
        if (!(this instanceof ReadStream))
          return new ReadStream(path5, options);
        Stream.call(this);
        var self2 = this;
        this.path = path5;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options = options || {};
        var keys4 = Object.keys(options);
        for (var index4 = 0, length7 = keys4.length; index4 < length7; index4++) {
          var key = keys4[index4];
          this[key] = options[key];
        }
        if (this.encoding)
          this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if ("number" !== typeof this.end) {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self2._read();
          });
          return;
        }
        fs2.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self2.emit("error", err);
            self2.readable = false;
            return;
          }
          self2.fd = fd;
          self2.emit("open", fd);
          self2._read();
        });
      }
      function WriteStream(path5, options) {
        if (!(this instanceof WriteStream))
          return new WriteStream(path5, options);
        Stream.call(this);
        this.path = path5;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options = options || {};
        var keys4 = Object.keys(options);
        for (var index4 = 0, length7 = keys4.length; index4 < length7; index4++) {
          var key = keys4[index4];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs2.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  }
});

// node_modules/graceful-fs/clone.js
var require_clone = __commonJS({
  "node_modules/graceful-fs/clone.js"(exports, module) {
    "use strict";
    module.exports = clone;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone(obj) {
      if (obj === null || typeof obj !== "object")
        return obj;
      if (obj instanceof Object)
        var copy3 = { __proto__: getPrototypeOf(obj) };
      else
        var copy3 = /* @__PURE__ */ Object.create(null);
      Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy3, key, Object.getOwnPropertyDescriptor(obj, key));
      });
      return copy3;
    }
  }
});

// node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS({
  "node_modules/graceful-fs/graceful-fs.js"(exports, module) {
    var fs2 = __require("fs");
    var polyfills = require_polyfills();
    var legacy = require_legacy_streams();
    var clone = require_clone();
    var util = __require("util");
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }
    function noop() {
    }
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue2;
        }
      });
    }
    var debug2 = noop;
    if (util.debuglog)
      debug2 = util.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug2 = function() {
        var m = util.format.apply(util, arguments);
        m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
        console.error(m);
      };
    if (!fs2[gracefulQueue]) {
      queue = global[gracefulQueue] || [];
      publishQueue(fs2, queue);
      fs2.close = function(fs$close) {
        function close2(fd, cb) {
          return fs$close.call(fs2, fd, function(err) {
            if (!err) {
              resetQueue();
            }
            if (typeof cb === "function")
              cb.apply(this, arguments);
          });
        }
        Object.defineProperty(close2, previousSymbol, {
          value: fs$close
        });
        return close2;
      }(fs2.close);
      fs2.closeSync = function(fs$closeSync) {
        function closeSync2(fd) {
          fs$closeSync.apply(fs2, arguments);
          resetQueue();
        }
        Object.defineProperty(closeSync2, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync2;
      }(fs2.closeSync);
      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function() {
          debug2(fs2[gracefulQueue]);
          __require("assert").equal(fs2[gracefulQueue].length, 0);
        });
      }
    }
    var queue;
    if (!global[gracefulQueue]) {
      publishQueue(global, fs2[gracefulQueue]);
    }
    module.exports = patch3(clone(fs2));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs2.__patched) {
      module.exports = patch3(fs2);
      fs2.__patched = true;
    }
    function patch3(fs3) {
      polyfills(fs3);
      fs3.gracefulify = patch3;
      fs3.createReadStream = createReadStream;
      fs3.createWriteStream = createWriteStream;
      var fs$readFile = fs3.readFile;
      fs3.readFile = readFile4;
      function readFile4(path5, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$readFile(path5, options, cb);
        function go$readFile(path6, options2, cb2, startTime) {
          return fs$readFile(path6, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readFile, [path6, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$writeFile = fs3.writeFile;
      fs3.writeFile = writeFile6;
      function writeFile6(path5, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$writeFile(path5, data, options, cb);
        function go$writeFile(path6, data2, options2, cb2, startTime) {
          return fs$writeFile(path6, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$writeFile, [path6, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$appendFile = fs3.appendFile;
      if (fs$appendFile)
        fs3.appendFile = appendFile3;
      function appendFile3(path5, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$appendFile(path5, data, options, cb);
        function go$appendFile(path6, data2, options2, cb2, startTime) {
          return fs$appendFile(path6, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$appendFile, [path6, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$copyFile = fs3.copyFile;
      if (fs$copyFile)
        fs3.copyFile = copyFile3;
      function copyFile3(src, dest, flags, cb) {
        if (typeof flags === "function") {
          cb = flags;
          flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        function go$copyFile(src2, dest2, flags2, cb2, startTime) {
          return fs$copyFile(src2, dest2, flags2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$readdir = fs3.readdir;
      fs3.readdir = readdir4;
      var noReaddirOptionVersions = /^v[0-5]\./;
      function readdir4(path5, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path6, options2, cb2, startTime) {
          return fs$readdir(path6, fs$readdirCallback(
            path6,
            options2,
            cb2,
            startTime
          ));
        } : function go$readdir2(path6, options2, cb2, startTime) {
          return fs$readdir(path6, options2, fs$readdirCallback(
            path6,
            options2,
            cb2,
            startTime
          ));
        };
        return go$readdir(path5, options, cb);
        function fs$readdirCallback(path6, options2, cb2, startTime) {
          return function(err, files) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([
                go$readdir,
                [path6, options2, cb2],
                err,
                startTime || Date.now(),
                Date.now()
              ]);
            else {
              if (files && files.sort)
                files.sort();
              if (typeof cb2 === "function")
                cb2.call(this, err, files);
            }
          };
        }
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs3);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs3.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs3.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs3, "ReadStream", {
        get: function() {
          return ReadStream;
        },
        set: function(val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs3, "WriteStream", {
        get: function() {
          return WriteStream;
        },
        set: function(val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs3, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs3, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      function ReadStream(path5, options) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open2(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      function WriteStream(path5, options) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open2(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      function createReadStream(path5, options) {
        return new fs3.ReadStream(path5, options);
      }
      function createWriteStream(path5, options) {
        return new fs3.WriteStream(path5, options);
      }
      var fs$open = fs3.open;
      fs3.open = open2;
      function open2(path5, flags, mode, cb) {
        if (typeof mode === "function")
          cb = mode, mode = null;
        return go$open(path5, flags, mode, cb);
        function go$open(path6, flags2, mode2, cb2, startTime) {
          return fs$open(path6, flags2, mode2, function(err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$open, [path6, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      return fs3;
    }
    function enqueue(elem6) {
      debug2("ENQUEUE", elem6[0].name, elem6[1]);
      fs2[gracefulQueue].push(elem6);
      retry();
    }
    var retryTimer;
    function resetQueue() {
      var now3 = Date.now();
      for (var i = 0; i < fs2[gracefulQueue].length; ++i) {
        if (fs2[gracefulQueue][i].length > 2) {
          fs2[gracefulQueue][i][3] = now3;
          fs2[gracefulQueue][i][4] = now3;
        }
      }
      retry();
    }
    function retry() {
      clearTimeout(retryTimer);
      retryTimer = void 0;
      if (fs2[gracefulQueue].length === 0)
        return;
      var elem6 = fs2[gracefulQueue].shift();
      var fn = elem6[0];
      var args = elem6[1];
      var err = elem6[2];
      var startTime = elem6[3];
      var lastTime = elem6[4];
      if (startTime === void 0) {
        debug2("RETRY", fn.name, args);
        fn.apply(null, args);
      } else if (Date.now() - startTime >= 6e4) {
        debug2("TIMEOUT", fn.name, args);
        var cb = args.pop();
        if (typeof cb === "function")
          cb.call(null, err);
      } else {
        var sinceAttempt = Date.now() - lastTime;
        var sinceStart = Math.max(lastTime - startTime, 1);
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        if (sinceAttempt >= desiredDelay) {
          debug2("RETRY", fn.name, args);
          fn.apply(null, args.concat([startTime]));
        } else {
          fs2[gracefulQueue].push(elem6);
        }
      }
      if (retryTimer === void 0) {
        retryTimer = setTimeout(retry, 0);
      }
    }
  }
});

// node_modules/fs-extra/lib/fs/index.js
var require_fs = __commonJS({
  "node_modules/fs-extra/lib/fs/index.js"(exports) {
    "use strict";
    var u = require_universalify().fromCallback;
    var fs2 = require_graceful_fs();
    var api = [
      "access",
      "appendFile",
      "chmod",
      "chown",
      "close",
      "copyFile",
      "fchmod",
      "fchown",
      "fdatasync",
      "fstat",
      "fsync",
      "ftruncate",
      "futimes",
      "lchmod",
      "lchown",
      "link",
      "lstat",
      "mkdir",
      "mkdtemp",
      "open",
      "opendir",
      "readdir",
      "readFile",
      "readlink",
      "realpath",
      "rename",
      "rm",
      "rmdir",
      "stat",
      "symlink",
      "truncate",
      "unlink",
      "utimes",
      "writeFile"
    ].filter((key) => {
      return typeof fs2[key] === "function";
    });
    Object.assign(exports, fs2);
    api.forEach((method) => {
      exports[method] = u(fs2[method]);
    });
    exports.exists = function(filename, callback) {
      if (typeof callback === "function") {
        return fs2.exists(filename, callback);
      }
      return new Promise((resolve2) => {
        return fs2.exists(filename, resolve2);
      });
    };
    exports.read = function(fd, buffer, offset, length7, position2, callback) {
      if (typeof callback === "function") {
        return fs2.read(fd, buffer, offset, length7, position2, callback);
      }
      return new Promise((resolve2, reject) => {
        fs2.read(fd, buffer, offset, length7, position2, (err, bytesRead, buffer2) => {
          if (err)
            return reject(err);
          resolve2({ bytesRead, buffer: buffer2 });
        });
      });
    };
    exports.write = function(fd, buffer, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs2.write(fd, buffer, ...args);
      }
      return new Promise((resolve2, reject) => {
        fs2.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
          if (err)
            return reject(err);
          resolve2({ bytesWritten, buffer: buffer2 });
        });
      });
    };
    if (typeof fs2.writev === "function") {
      exports.writev = function(fd, buffers, ...args) {
        if (typeof args[args.length - 1] === "function") {
          return fs2.writev(fd, buffers, ...args);
        }
        return new Promise((resolve2, reject) => {
          fs2.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
            if (err)
              return reject(err);
            resolve2({ bytesWritten, buffers: buffers2 });
          });
        });
      };
    }
    if (typeof fs2.realpath.native === "function") {
      exports.realpath.native = u(fs2.realpath.native);
    } else {
      process.emitWarning(
        "fs.realpath.native is not a function. Is fs being monkey-patched?",
        "Warning",
        "fs-extra-WARN0003"
      );
    }
  }
});

// node_modules/fs-extra/lib/mkdirs/utils.js
var require_utils = __commonJS({
  "node_modules/fs-extra/lib/mkdirs/utils.js"(exports, module) {
    "use strict";
    var path5 = __require("path");
    module.exports.checkPath = function checkPath(pth) {
      if (process.platform === "win32") {
        const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path5.parse(pth).root, ""));
        if (pathHasInvalidWinCharacters) {
          const error4 = new Error(`Path contains invalid characters: ${pth}`);
          error4.code = "EINVAL";
          throw error4;
        }
      }
    };
  }
});

// node_modules/fs-extra/lib/mkdirs/make-dir.js
var require_make_dir = __commonJS({
  "node_modules/fs-extra/lib/mkdirs/make-dir.js"(exports, module) {
    "use strict";
    var fs2 = require_fs();
    var { checkPath } = require_utils();
    var getMode = (options) => {
      const defaults2 = { mode: 511 };
      if (typeof options === "number")
        return options;
      return { ...defaults2, ...options }.mode;
    };
    module.exports.makeDir = async (dir, options) => {
      checkPath(dir);
      return fs2.mkdir(dir, {
        mode: getMode(options),
        recursive: true
      });
    };
    module.exports.makeDirSync = (dir, options) => {
      checkPath(dir);
      return fs2.mkdirSync(dir, {
        mode: getMode(options),
        recursive: true
      });
    };
  }
});

// node_modules/fs-extra/lib/mkdirs/index.js
var require_mkdirs = __commonJS({
  "node_modules/fs-extra/lib/mkdirs/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    var { makeDir: _makeDir, makeDirSync } = require_make_dir();
    var makeDir = u(_makeDir);
    module.exports = {
      mkdirs: makeDir,
      mkdirsSync: makeDirSync,
      // alias
      mkdirp: makeDir,
      mkdirpSync: makeDirSync,
      ensureDir: makeDir,
      ensureDirSync: makeDirSync
    };
  }
});

// node_modules/fs-extra/lib/path-exists/index.js
var require_path_exists = __commonJS({
  "node_modules/fs-extra/lib/path-exists/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    var fs2 = require_fs();
    function pathExists(path5) {
      return fs2.access(path5).then(() => true).catch(() => false);
    }
    module.exports = {
      pathExists: u(pathExists),
      pathExistsSync: fs2.existsSync
    };
  }
});

// node_modules/fs-extra/lib/util/utimes.js
var require_utimes = __commonJS({
  "node_modules/fs-extra/lib/util/utimes.js"(exports, module) {
    "use strict";
    var fs2 = require_graceful_fs();
    function utimesMillis(path5, atime, mtime, callback) {
      fs2.open(path5, "r+", (err, fd) => {
        if (err)
          return callback(err);
        fs2.futimes(fd, atime, mtime, (futimesErr) => {
          fs2.close(fd, (closeErr) => {
            if (callback)
              callback(futimesErr || closeErr);
          });
        });
      });
    }
    function utimesMillisSync(path5, atime, mtime) {
      const fd = fs2.openSync(path5, "r+");
      fs2.futimesSync(fd, atime, mtime);
      return fs2.closeSync(fd);
    }
    module.exports = {
      utimesMillis,
      utimesMillisSync
    };
  }
});

// node_modules/fs-extra/lib/util/stat.js
var require_stat = __commonJS({
  "node_modules/fs-extra/lib/util/stat.js"(exports, module) {
    "use strict";
    var fs2 = require_fs();
    var path5 = __require("path");
    var util = __require("util");
    function getStats(src, dest, opts) {
      const statFunc = opts.dereference ? (file) => fs2.stat(file, { bigint: true }) : (file) => fs2.lstat(file, { bigint: true });
      return Promise.all([
        statFunc(src),
        statFunc(dest).catch((err) => {
          if (err.code === "ENOENT")
            return null;
          throw err;
        })
      ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
    }
    function getStatsSync(src, dest, opts) {
      let destStat;
      const statFunc = opts.dereference ? (file) => fs2.statSync(file, { bigint: true }) : (file) => fs2.lstatSync(file, { bigint: true });
      const srcStat = statFunc(src);
      try {
        destStat = statFunc(dest);
      } catch (err) {
        if (err.code === "ENOENT")
          return { srcStat, destStat: null };
        throw err;
      }
      return { srcStat, destStat };
    }
    function checkPaths(src, dest, funcName, opts, cb) {
      util.callbackify(getStats)(src, dest, opts, (err, stats) => {
        if (err)
          return cb(err);
        const { srcStat, destStat } = stats;
        if (destStat) {
          if (areIdentical(srcStat, destStat)) {
            const srcBaseName = path5.basename(src);
            const destBaseName = path5.basename(dest);
            if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
              return cb(null, { srcStat, destStat, isChangingCase: true });
            }
            return cb(new Error("Source and destination must not be the same."));
          }
          if (srcStat.isDirectory() && !destStat.isDirectory()) {
            return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));
          }
          if (!srcStat.isDirectory() && destStat.isDirectory()) {
            return cb(new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`));
          }
        }
        if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
          return cb(new Error(errMsg(src, dest, funcName)));
        }
        return cb(null, { srcStat, destStat });
      });
    }
    function checkPathsSync(src, dest, funcName, opts) {
      const { srcStat, destStat } = getStatsSync(src, dest, opts);
      if (destStat) {
        if (areIdentical(srcStat, destStat)) {
          const srcBaseName = path5.basename(src);
          const destBaseName = path5.basename(dest);
          if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
            return { srcStat, destStat, isChangingCase: true };
          }
          throw new Error("Source and destination must not be the same.");
        }
        if (srcStat.isDirectory() && !destStat.isDirectory()) {
          throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
        }
        if (!srcStat.isDirectory() && destStat.isDirectory()) {
          throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
        }
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return { srcStat, destStat };
    }
    function checkParentPaths(src, srcStat, dest, funcName, cb) {
      const srcParent = path5.resolve(path5.dirname(src));
      const destParent = path5.resolve(path5.dirname(dest));
      if (destParent === srcParent || destParent === path5.parse(destParent).root)
        return cb();
      fs2.stat(destParent, { bigint: true }, (err, destStat) => {
        if (err) {
          if (err.code === "ENOENT")
            return cb();
          return cb(err);
        }
        if (areIdentical(srcStat, destStat)) {
          return cb(new Error(errMsg(src, dest, funcName)));
        }
        return checkParentPaths(src, srcStat, destParent, funcName, cb);
      });
    }
    function checkParentPathsSync(src, srcStat, dest, funcName) {
      const srcParent = path5.resolve(path5.dirname(src));
      const destParent = path5.resolve(path5.dirname(dest));
      if (destParent === srcParent || destParent === path5.parse(destParent).root)
        return;
      let destStat;
      try {
        destStat = fs2.statSync(destParent, { bigint: true });
      } catch (err) {
        if (err.code === "ENOENT")
          return;
        throw err;
      }
      if (areIdentical(srcStat, destStat)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return checkParentPathsSync(src, srcStat, destParent, funcName);
    }
    function areIdentical(srcStat, destStat) {
      return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
    }
    function isSrcSubdir(src, dest) {
      const srcArr = path5.resolve(src).split(path5.sep).filter((i) => i);
      const destArr = path5.resolve(dest).split(path5.sep).filter((i) => i);
      return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true);
    }
    function errMsg(src, dest, funcName) {
      return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
    }
    module.exports = {
      checkPaths,
      checkPathsSync,
      checkParentPaths,
      checkParentPathsSync,
      isSrcSubdir,
      areIdentical
    };
  }
});

// node_modules/fs-extra/lib/copy/copy.js
var require_copy = __commonJS({
  "node_modules/fs-extra/lib/copy/copy.js"(exports, module) {
    "use strict";
    var fs2 = require_graceful_fs();
    var path5 = __require("path");
    var mkdirs = require_mkdirs().mkdirs;
    var pathExists = require_path_exists().pathExists;
    var utimesMillis = require_utimes().utimesMillis;
    var stat6 = require_stat();
    function copy3(src, dest, opts, cb) {
      if (typeof opts === "function" && !cb) {
        cb = opts;
        opts = {};
      } else if (typeof opts === "function") {
        opts = { filter: opts };
      }
      cb = cb || function() {
      };
      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        process.emitWarning(
          "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
          "Warning",
          "fs-extra-WARN0001"
        );
      }
      stat6.checkPaths(src, dest, "copy", opts, (err, stats) => {
        if (err)
          return cb(err);
        const { srcStat, destStat } = stats;
        stat6.checkParentPaths(src, srcStat, dest, "copy", (err2) => {
          if (err2)
            return cb(err2);
          if (opts.filter)
            return handleFilter(checkParentDir, destStat, src, dest, opts, cb);
          return checkParentDir(destStat, src, dest, opts, cb);
        });
      });
    }
    function checkParentDir(destStat, src, dest, opts, cb) {
      const destParent = path5.dirname(dest);
      pathExists(destParent, (err, dirExists) => {
        if (err)
          return cb(err);
        if (dirExists)
          return getStats(destStat, src, dest, opts, cb);
        mkdirs(destParent, (err2) => {
          if (err2)
            return cb(err2);
          return getStats(destStat, src, dest, opts, cb);
        });
      });
    }
    function handleFilter(onInclude, destStat, src, dest, opts, cb) {
      Promise.resolve(opts.filter(src, dest)).then((include) => {
        if (include)
          return onInclude(destStat, src, dest, opts, cb);
        return cb();
      }, (error4) => cb(error4));
    }
    function startCopy(destStat, src, dest, opts, cb) {
      if (opts.filter)
        return handleFilter(getStats, destStat, src, dest, opts, cb);
      return getStats(destStat, src, dest, opts, cb);
    }
    function getStats(destStat, src, dest, opts, cb) {
      const stat7 = opts.dereference ? fs2.stat : fs2.lstat;
      stat7(src, (err, srcStat) => {
        if (err)
          return cb(err);
        if (srcStat.isDirectory())
          return onDir(srcStat, destStat, src, dest, opts, cb);
        else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
          return onFile(srcStat, destStat, src, dest, opts, cb);
        else if (srcStat.isSymbolicLink())
          return onLink(destStat, src, dest, opts, cb);
        else if (srcStat.isSocket())
          return cb(new Error(`Cannot copy a socket file: ${src}`));
        else if (srcStat.isFIFO())
          return cb(new Error(`Cannot copy a FIFO pipe: ${src}`));
        return cb(new Error(`Unknown file: ${src}`));
      });
    }
    function onFile(srcStat, destStat, src, dest, opts, cb) {
      if (!destStat)
        return copyFile3(srcStat, src, dest, opts, cb);
      return mayCopyFile(srcStat, src, dest, opts, cb);
    }
    function mayCopyFile(srcStat, src, dest, opts, cb) {
      if (opts.overwrite) {
        fs2.unlink(dest, (err) => {
          if (err)
            return cb(err);
          return copyFile3(srcStat, src, dest, opts, cb);
        });
      } else if (opts.errorOnExist) {
        return cb(new Error(`'${dest}' already exists`));
      } else
        return cb();
    }
    function copyFile3(srcStat, src, dest, opts, cb) {
      fs2.copyFile(src, dest, (err) => {
        if (err)
          return cb(err);
        if (opts.preserveTimestamps)
          return handleTimestampsAndMode(srcStat.mode, src, dest, cb);
        return setDestMode(dest, srcStat.mode, cb);
      });
    }
    function handleTimestampsAndMode(srcMode, src, dest, cb) {
      if (fileIsNotWritable(srcMode)) {
        return makeFileWritable(dest, srcMode, (err) => {
          if (err)
            return cb(err);
          return setDestTimestampsAndMode(srcMode, src, dest, cb);
        });
      }
      return setDestTimestampsAndMode(srcMode, src, dest, cb);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode, cb) {
      return setDestMode(dest, srcMode | 128, cb);
    }
    function setDestTimestampsAndMode(srcMode, src, dest, cb) {
      setDestTimestamps(src, dest, (err) => {
        if (err)
          return cb(err);
        return setDestMode(dest, srcMode, cb);
      });
    }
    function setDestMode(dest, srcMode, cb) {
      return fs2.chmod(dest, srcMode, cb);
    }
    function setDestTimestamps(src, dest, cb) {
      fs2.stat(src, (err, updatedSrcStat) => {
        if (err)
          return cb(err);
        return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb);
      });
    }
    function onDir(srcStat, destStat, src, dest, opts, cb) {
      if (!destStat)
        return mkDirAndCopy(srcStat.mode, src, dest, opts, cb);
      return copyDir(src, dest, opts, cb);
    }
    function mkDirAndCopy(srcMode, src, dest, opts, cb) {
      fs2.mkdir(dest, (err) => {
        if (err)
          return cb(err);
        copyDir(src, dest, opts, (err2) => {
          if (err2)
            return cb(err2);
          return setDestMode(dest, srcMode, cb);
        });
      });
    }
    function copyDir(src, dest, opts, cb) {
      fs2.readdir(src, (err, items) => {
        if (err)
          return cb(err);
        return copyDirItems(items, src, dest, opts, cb);
      });
    }
    function copyDirItems(items, src, dest, opts, cb) {
      const item = items.pop();
      if (!item)
        return cb();
      return copyDirItem(items, item, src, dest, opts, cb);
    }
    function copyDirItem(items, item, src, dest, opts, cb) {
      const srcItem = path5.join(src, item);
      const destItem = path5.join(dest, item);
      stat6.checkPaths(srcItem, destItem, "copy", opts, (err, stats) => {
        if (err)
          return cb(err);
        const { destStat } = stats;
        startCopy(destStat, srcItem, destItem, opts, (err2) => {
          if (err2)
            return cb(err2);
          return copyDirItems(items, src, dest, opts, cb);
        });
      });
    }
    function onLink(destStat, src, dest, opts, cb) {
      fs2.readlink(src, (err, resolvedSrc) => {
        if (err)
          return cb(err);
        if (opts.dereference) {
          resolvedSrc = path5.resolve(process.cwd(), resolvedSrc);
        }
        if (!destStat) {
          return fs2.symlink(resolvedSrc, dest, cb);
        } else {
          fs2.readlink(dest, (err2, resolvedDest) => {
            if (err2) {
              if (err2.code === "EINVAL" || err2.code === "UNKNOWN")
                return fs2.symlink(resolvedSrc, dest, cb);
              return cb(err2);
            }
            if (opts.dereference) {
              resolvedDest = path5.resolve(process.cwd(), resolvedDest);
            }
            if (stat6.isSrcSubdir(resolvedSrc, resolvedDest)) {
              return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));
            }
            if (destStat.isDirectory() && stat6.isSrcSubdir(resolvedDest, resolvedSrc)) {
              return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));
            }
            return copyLink(resolvedSrc, dest, cb);
          });
        }
      });
    }
    function copyLink(resolvedSrc, dest, cb) {
      fs2.unlink(dest, (err) => {
        if (err)
          return cb(err);
        return fs2.symlink(resolvedSrc, dest, cb);
      });
    }
    module.exports = copy3;
  }
});

// node_modules/fs-extra/lib/copy/copy-sync.js
var require_copy_sync = __commonJS({
  "node_modules/fs-extra/lib/copy/copy-sync.js"(exports, module) {
    "use strict";
    var fs2 = require_graceful_fs();
    var path5 = __require("path");
    var mkdirsSync = require_mkdirs().mkdirsSync;
    var utimesMillisSync = require_utimes().utimesMillisSync;
    var stat6 = require_stat();
    function copySync(src, dest, opts) {
      if (typeof opts === "function") {
        opts = { filter: opts };
      }
      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        process.emitWarning(
          "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
          "Warning",
          "fs-extra-WARN0002"
        );
      }
      const { srcStat, destStat } = stat6.checkPathsSync(src, dest, "copy", opts);
      stat6.checkParentPathsSync(src, srcStat, dest, "copy");
      return handleFilterAndCopy(destStat, src, dest, opts);
    }
    function handleFilterAndCopy(destStat, src, dest, opts) {
      if (opts.filter && !opts.filter(src, dest))
        return;
      const destParent = path5.dirname(dest);
      if (!fs2.existsSync(destParent))
        mkdirsSync(destParent);
      return getStats(destStat, src, dest, opts);
    }
    function startCopy(destStat, src, dest, opts) {
      if (opts.filter && !opts.filter(src, dest))
        return;
      return getStats(destStat, src, dest, opts);
    }
    function getStats(destStat, src, dest, opts) {
      const statSync2 = opts.dereference ? fs2.statSync : fs2.lstatSync;
      const srcStat = statSync2(src);
      if (srcStat.isDirectory())
        return onDir(srcStat, destStat, src, dest, opts);
      else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
        return onFile(srcStat, destStat, src, dest, opts);
      else if (srcStat.isSymbolicLink())
        return onLink(destStat, src, dest, opts);
      else if (srcStat.isSocket())
        throw new Error(`Cannot copy a socket file: ${src}`);
      else if (srcStat.isFIFO())
        throw new Error(`Cannot copy a FIFO pipe: ${src}`);
      throw new Error(`Unknown file: ${src}`);
    }
    function onFile(srcStat, destStat, src, dest, opts) {
      if (!destStat)
        return copyFile3(srcStat, src, dest, opts);
      return mayCopyFile(srcStat, src, dest, opts);
    }
    function mayCopyFile(srcStat, src, dest, opts) {
      if (opts.overwrite) {
        fs2.unlinkSync(dest);
        return copyFile3(srcStat, src, dest, opts);
      } else if (opts.errorOnExist) {
        throw new Error(`'${dest}' already exists`);
      }
    }
    function copyFile3(srcStat, src, dest, opts) {
      fs2.copyFileSync(src, dest);
      if (opts.preserveTimestamps)
        handleTimestamps(srcStat.mode, src, dest);
      return setDestMode(dest, srcStat.mode);
    }
    function handleTimestamps(srcMode, src, dest) {
      if (fileIsNotWritable(srcMode))
        makeFileWritable(dest, srcMode);
      return setDestTimestamps(src, dest);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode) {
      return setDestMode(dest, srcMode | 128);
    }
    function setDestMode(dest, srcMode) {
      return fs2.chmodSync(dest, srcMode);
    }
    function setDestTimestamps(src, dest) {
      const updatedSrcStat = fs2.statSync(src);
      return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
    }
    function onDir(srcStat, destStat, src, dest, opts) {
      if (!destStat)
        return mkDirAndCopy(srcStat.mode, src, dest, opts);
      return copyDir(src, dest, opts);
    }
    function mkDirAndCopy(srcMode, src, dest, opts) {
      fs2.mkdirSync(dest);
      copyDir(src, dest, opts);
      return setDestMode(dest, srcMode);
    }
    function copyDir(src, dest, opts) {
      fs2.readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts));
    }
    function copyDirItem(item, src, dest, opts) {
      const srcItem = path5.join(src, item);
      const destItem = path5.join(dest, item);
      const { destStat } = stat6.checkPathsSync(srcItem, destItem, "copy", opts);
      return startCopy(destStat, srcItem, destItem, opts);
    }
    function onLink(destStat, src, dest, opts) {
      let resolvedSrc = fs2.readlinkSync(src);
      if (opts.dereference) {
        resolvedSrc = path5.resolve(process.cwd(), resolvedSrc);
      }
      if (!destStat) {
        return fs2.symlinkSync(resolvedSrc, dest);
      } else {
        let resolvedDest;
        try {
          resolvedDest = fs2.readlinkSync(dest);
        } catch (err) {
          if (err.code === "EINVAL" || err.code === "UNKNOWN")
            return fs2.symlinkSync(resolvedSrc, dest);
          throw err;
        }
        if (opts.dereference) {
          resolvedDest = path5.resolve(process.cwd(), resolvedDest);
        }
        if (stat6.isSrcSubdir(resolvedSrc, resolvedDest)) {
          throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
        }
        if (fs2.statSync(dest).isDirectory() && stat6.isSrcSubdir(resolvedDest, resolvedSrc)) {
          throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
        }
        return copyLink(resolvedSrc, dest);
      }
    }
    function copyLink(resolvedSrc, dest) {
      fs2.unlinkSync(dest);
      return fs2.symlinkSync(resolvedSrc, dest);
    }
    module.exports = copySync;
  }
});

// node_modules/fs-extra/lib/copy/index.js
var require_copy2 = __commonJS({
  "node_modules/fs-extra/lib/copy/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromCallback;
    module.exports = {
      copy: u(require_copy()),
      copySync: require_copy_sync()
    };
  }
});

// node_modules/fs-extra/lib/remove/rimraf.js
var require_rimraf = __commonJS({
  "node_modules/fs-extra/lib/remove/rimraf.js"(exports, module) {
    "use strict";
    var fs2 = require_graceful_fs();
    var path5 = __require("path");
    var assert = __require("assert");
    var isWindows3 = process.platform === "win32";
    function defaults2(options) {
      const methods = [
        "unlink",
        "chmod",
        "stat",
        "lstat",
        "rmdir",
        "readdir"
      ];
      methods.forEach((m) => {
        options[m] = options[m] || fs2[m];
        m = m + "Sync";
        options[m] = options[m] || fs2[m];
      });
      options.maxBusyTries = options.maxBusyTries || 3;
    }
    function rimraf(p, options, cb) {
      let busyTries = 0;
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      assert(p, "rimraf: missing path");
      assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
      assert.strictEqual(typeof cb, "function", "rimraf: callback function required");
      assert(options, "rimraf: invalid options argument provided");
      assert.strictEqual(typeof options, "object", "rimraf: options should be object");
      defaults2(options);
      rimraf_(p, options, function CB(er) {
        if (er) {
          if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") && busyTries < options.maxBusyTries) {
            busyTries++;
            const time3 = busyTries * 100;
            return setTimeout(() => rimraf_(p, options, CB), time3);
          }
          if (er.code === "ENOENT")
            er = null;
        }
        cb(er);
      });
    }
    function rimraf_(p, options, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.lstat(p, (er, st) => {
        if (er && er.code === "ENOENT") {
          return cb(null);
        }
        if (er && er.code === "EPERM" && isWindows3) {
          return fixWinEPERM(p, options, er, cb);
        }
        if (st && st.isDirectory()) {
          return rmdir3(p, options, er, cb);
        }
        options.unlink(p, (er2) => {
          if (er2) {
            if (er2.code === "ENOENT") {
              return cb(null);
            }
            if (er2.code === "EPERM") {
              return isWindows3 ? fixWinEPERM(p, options, er2, cb) : rmdir3(p, options, er2, cb);
            }
            if (er2.code === "EISDIR") {
              return rmdir3(p, options, er2, cb);
            }
          }
          return cb(er2);
        });
      });
    }
    function fixWinEPERM(p, options, er, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.chmod(p, 438, (er2) => {
        if (er2) {
          cb(er2.code === "ENOENT" ? null : er);
        } else {
          options.stat(p, (er3, stats) => {
            if (er3) {
              cb(er3.code === "ENOENT" ? null : er);
            } else if (stats.isDirectory()) {
              rmdir3(p, options, er, cb);
            } else {
              options.unlink(p, cb);
            }
          });
        }
      });
    }
    function fixWinEPERMSync(p, options, er) {
      let stats;
      assert(p);
      assert(options);
      try {
        options.chmodSync(p, 438);
      } catch (er2) {
        if (er2.code === "ENOENT") {
          return;
        } else {
          throw er;
        }
      }
      try {
        stats = options.statSync(p);
      } catch (er3) {
        if (er3.code === "ENOENT") {
          return;
        } else {
          throw er;
        }
      }
      if (stats.isDirectory()) {
        rmdirSync2(p, options, er);
      } else {
        options.unlinkSync(p);
      }
    }
    function rmdir3(p, options, originalEr, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.rmdir(p, (er) => {
        if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")) {
          rmkids(p, options, cb);
        } else if (er && er.code === "ENOTDIR") {
          cb(originalEr);
        } else {
          cb(er);
        }
      });
    }
    function rmkids(p, options, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.readdir(p, (er, files) => {
        if (er)
          return cb(er);
        let n = files.length;
        let errState;
        if (n === 0)
          return options.rmdir(p, cb);
        files.forEach((f) => {
          rimraf(path5.join(p, f), options, (er2) => {
            if (errState) {
              return;
            }
            if (er2)
              return cb(errState = er2);
            if (--n === 0) {
              options.rmdir(p, cb);
            }
          });
        });
      });
    }
    function rimrafSync(p, options) {
      let st;
      options = options || {};
      defaults2(options);
      assert(p, "rimraf: missing path");
      assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
      assert(options, "rimraf: missing options");
      assert.strictEqual(typeof options, "object", "rimraf: options should be object");
      try {
        st = options.lstatSync(p);
      } catch (er) {
        if (er.code === "ENOENT") {
          return;
        }
        if (er.code === "EPERM" && isWindows3) {
          fixWinEPERMSync(p, options, er);
        }
      }
      try {
        if (st && st.isDirectory()) {
          rmdirSync2(p, options, null);
        } else {
          options.unlinkSync(p);
        }
      } catch (er) {
        if (er.code === "ENOENT") {
          return;
        } else if (er.code === "EPERM") {
          return isWindows3 ? fixWinEPERMSync(p, options, er) : rmdirSync2(p, options, er);
        } else if (er.code !== "EISDIR") {
          throw er;
        }
        rmdirSync2(p, options, er);
      }
    }
    function rmdirSync2(p, options, originalEr) {
      assert(p);
      assert(options);
      try {
        options.rmdirSync(p);
      } catch (er) {
        if (er.code === "ENOTDIR") {
          throw originalEr;
        } else if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM") {
          rmkidsSync(p, options);
        } else if (er.code !== "ENOENT") {
          throw er;
        }
      }
    }
    function rmkidsSync(p, options) {
      assert(p);
      assert(options);
      options.readdirSync(p).forEach((f) => rimrafSync(path5.join(p, f), options));
      if (isWindows3) {
        const startTime = Date.now();
        do {
          try {
            const ret = options.rmdirSync(p, options);
            return ret;
          } catch {
          }
        } while (Date.now() - startTime < 500);
      } else {
        const ret = options.rmdirSync(p, options);
        return ret;
      }
    }
    module.exports = rimraf;
    rimraf.sync = rimrafSync;
  }
});

// node_modules/fs-extra/lib/remove/index.js
var require_remove = __commonJS({
  "node_modules/fs-extra/lib/remove/index.js"(exports, module) {
    "use strict";
    var fs2 = require_graceful_fs();
    var u = require_universalify().fromCallback;
    var rimraf = require_rimraf();
    function remove(path5, callback) {
      if (fs2.rm)
        return fs2.rm(path5, { recursive: true, force: true }, callback);
      rimraf(path5, callback);
    }
    function removeSync(path5) {
      if (fs2.rmSync)
        return fs2.rmSync(path5, { recursive: true, force: true });
      rimraf.sync(path5);
    }
    module.exports = {
      remove: u(remove),
      removeSync
    };
  }
});

// node_modules/fs-extra/lib/empty/index.js
var require_empty = __commonJS({
  "node_modules/fs-extra/lib/empty/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    var fs2 = require_fs();
    var path5 = __require("path");
    var mkdir3 = require_mkdirs();
    var remove = require_remove();
    var emptyDir = u(async function emptyDir2(dir) {
      let items;
      try {
        items = await fs2.readdir(dir);
      } catch {
        return mkdir3.mkdirs(dir);
      }
      return Promise.all(items.map((item) => remove.remove(path5.join(dir, item))));
    });
    function emptyDirSync(dir) {
      let items;
      try {
        items = fs2.readdirSync(dir);
      } catch {
        return mkdir3.mkdirsSync(dir);
      }
      items.forEach((item) => {
        item = path5.join(dir, item);
        remove.removeSync(item);
      });
    }
    module.exports = {
      emptyDirSync,
      emptydirSync: emptyDirSync,
      emptyDir,
      emptydir: emptyDir
    };
  }
});

// node_modules/fs-extra/lib/ensure/file.js
var require_file = __commonJS({
  "node_modules/fs-extra/lib/ensure/file.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromCallback;
    var path5 = __require("path");
    var fs2 = require_graceful_fs();
    var mkdir3 = require_mkdirs();
    function createFile(file, callback) {
      function makeFile() {
        fs2.writeFile(file, "", (err) => {
          if (err)
            return callback(err);
          callback();
        });
      }
      fs2.stat(file, (err, stats) => {
        if (!err && stats.isFile())
          return callback();
        const dir = path5.dirname(file);
        fs2.stat(dir, (err2, stats2) => {
          if (err2) {
            if (err2.code === "ENOENT") {
              return mkdir3.mkdirs(dir, (err3) => {
                if (err3)
                  return callback(err3);
                makeFile();
              });
            }
            return callback(err2);
          }
          if (stats2.isDirectory())
            makeFile();
          else {
            fs2.readdir(dir, (err3) => {
              if (err3)
                return callback(err3);
            });
          }
        });
      });
    }
    function createFileSync(file) {
      let stats;
      try {
        stats = fs2.statSync(file);
      } catch {
      }
      if (stats && stats.isFile())
        return;
      const dir = path5.dirname(file);
      try {
        if (!fs2.statSync(dir).isDirectory()) {
          fs2.readdirSync(dir);
        }
      } catch (err) {
        if (err && err.code === "ENOENT")
          mkdir3.mkdirsSync(dir);
        else
          throw err;
      }
      fs2.writeFileSync(file, "");
    }
    module.exports = {
      createFile: u(createFile),
      createFileSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/link.js
var require_link = __commonJS({
  "node_modules/fs-extra/lib/ensure/link.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromCallback;
    var path5 = __require("path");
    var fs2 = require_graceful_fs();
    var mkdir3 = require_mkdirs();
    var pathExists = require_path_exists().pathExists;
    var { areIdentical } = require_stat();
    function createLink(srcpath, dstpath, callback) {
      function makeLink(srcpath2, dstpath2) {
        fs2.link(srcpath2, dstpath2, (err) => {
          if (err)
            return callback(err);
          callback(null);
        });
      }
      fs2.lstat(dstpath, (_, dstStat) => {
        fs2.lstat(srcpath, (err, srcStat) => {
          if (err) {
            err.message = err.message.replace("lstat", "ensureLink");
            return callback(err);
          }
          if (dstStat && areIdentical(srcStat, dstStat))
            return callback(null);
          const dir = path5.dirname(dstpath);
          pathExists(dir, (err2, dirExists) => {
            if (err2)
              return callback(err2);
            if (dirExists)
              return makeLink(srcpath, dstpath);
            mkdir3.mkdirs(dir, (err3) => {
              if (err3)
                return callback(err3);
              makeLink(srcpath, dstpath);
            });
          });
        });
      });
    }
    function createLinkSync(srcpath, dstpath) {
      let dstStat;
      try {
        dstStat = fs2.lstatSync(dstpath);
      } catch {
      }
      try {
        const srcStat = fs2.lstatSync(srcpath);
        if (dstStat && areIdentical(srcStat, dstStat))
          return;
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        throw err;
      }
      const dir = path5.dirname(dstpath);
      const dirExists = fs2.existsSync(dir);
      if (dirExists)
        return fs2.linkSync(srcpath, dstpath);
      mkdir3.mkdirsSync(dir);
      return fs2.linkSync(srcpath, dstpath);
    }
    module.exports = {
      createLink: u(createLink),
      createLinkSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/symlink-paths.js
var require_symlink_paths = __commonJS({
  "node_modules/fs-extra/lib/ensure/symlink-paths.js"(exports, module) {
    "use strict";
    var path5 = __require("path");
    var fs2 = require_graceful_fs();
    var pathExists = require_path_exists().pathExists;
    function symlinkPaths(srcpath, dstpath, callback) {
      if (path5.isAbsolute(srcpath)) {
        return fs2.lstat(srcpath, (err) => {
          if (err) {
            err.message = err.message.replace("lstat", "ensureSymlink");
            return callback(err);
          }
          return callback(null, {
            toCwd: srcpath,
            toDst: srcpath
          });
        });
      } else {
        const dstdir = path5.dirname(dstpath);
        const relativeToDst = path5.join(dstdir, srcpath);
        return pathExists(relativeToDst, (err, exists10) => {
          if (err)
            return callback(err);
          if (exists10) {
            return callback(null, {
              toCwd: relativeToDst,
              toDst: srcpath
            });
          } else {
            return fs2.lstat(srcpath, (err2) => {
              if (err2) {
                err2.message = err2.message.replace("lstat", "ensureSymlink");
                return callback(err2);
              }
              return callback(null, {
                toCwd: srcpath,
                toDst: path5.relative(dstdir, srcpath)
              });
            });
          }
        });
      }
    }
    function symlinkPathsSync(srcpath, dstpath) {
      let exists10;
      if (path5.isAbsolute(srcpath)) {
        exists10 = fs2.existsSync(srcpath);
        if (!exists10)
          throw new Error("absolute srcpath does not exist");
        return {
          toCwd: srcpath,
          toDst: srcpath
        };
      } else {
        const dstdir = path5.dirname(dstpath);
        const relativeToDst = path5.join(dstdir, srcpath);
        exists10 = fs2.existsSync(relativeToDst);
        if (exists10) {
          return {
            toCwd: relativeToDst,
            toDst: srcpath
          };
        } else {
          exists10 = fs2.existsSync(srcpath);
          if (!exists10)
            throw new Error("relative srcpath does not exist");
          return {
            toCwd: srcpath,
            toDst: path5.relative(dstdir, srcpath)
          };
        }
      }
    }
    module.exports = {
      symlinkPaths,
      symlinkPathsSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/symlink-type.js
var require_symlink_type = __commonJS({
  "node_modules/fs-extra/lib/ensure/symlink-type.js"(exports, module) {
    "use strict";
    var fs2 = require_graceful_fs();
    function symlinkType(srcpath, type, callback) {
      callback = typeof type === "function" ? type : callback;
      type = typeof type === "function" ? false : type;
      if (type)
        return callback(null, type);
      fs2.lstat(srcpath, (err, stats) => {
        if (err)
          return callback(null, "file");
        type = stats && stats.isDirectory() ? "dir" : "file";
        callback(null, type);
      });
    }
    function symlinkTypeSync(srcpath, type) {
      let stats;
      if (type)
        return type;
      try {
        stats = fs2.lstatSync(srcpath);
      } catch {
        return "file";
      }
      return stats && stats.isDirectory() ? "dir" : "file";
    }
    module.exports = {
      symlinkType,
      symlinkTypeSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/symlink.js
var require_symlink = __commonJS({
  "node_modules/fs-extra/lib/ensure/symlink.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromCallback;
    var path5 = __require("path");
    var fs2 = require_fs();
    var _mkdirs = require_mkdirs();
    var mkdirs = _mkdirs.mkdirs;
    var mkdirsSync = _mkdirs.mkdirsSync;
    var _symlinkPaths = require_symlink_paths();
    var symlinkPaths = _symlinkPaths.symlinkPaths;
    var symlinkPathsSync = _symlinkPaths.symlinkPathsSync;
    var _symlinkType = require_symlink_type();
    var symlinkType = _symlinkType.symlinkType;
    var symlinkTypeSync = _symlinkType.symlinkTypeSync;
    var pathExists = require_path_exists().pathExists;
    var { areIdentical } = require_stat();
    function createSymlink(srcpath, dstpath, type, callback) {
      callback = typeof type === "function" ? type : callback;
      type = typeof type === "function" ? false : type;
      fs2.lstat(dstpath, (err, stats) => {
        if (!err && stats.isSymbolicLink()) {
          Promise.all([
            fs2.stat(srcpath),
            fs2.stat(dstpath)
          ]).then(([srcStat, dstStat]) => {
            if (areIdentical(srcStat, dstStat))
              return callback(null);
            _createSymlink(srcpath, dstpath, type, callback);
          });
        } else
          _createSymlink(srcpath, dstpath, type, callback);
      });
    }
    function _createSymlink(srcpath, dstpath, type, callback) {
      symlinkPaths(srcpath, dstpath, (err, relative2) => {
        if (err)
          return callback(err);
        srcpath = relative2.toDst;
        symlinkType(relative2.toCwd, type, (err2, type2) => {
          if (err2)
            return callback(err2);
          const dir = path5.dirname(dstpath);
          pathExists(dir, (err3, dirExists) => {
            if (err3)
              return callback(err3);
            if (dirExists)
              return fs2.symlink(srcpath, dstpath, type2, callback);
            mkdirs(dir, (err4) => {
              if (err4)
                return callback(err4);
              fs2.symlink(srcpath, dstpath, type2, callback);
            });
          });
        });
      });
    }
    function createSymlinkSync(srcpath, dstpath, type) {
      let stats;
      try {
        stats = fs2.lstatSync(dstpath);
      } catch {
      }
      if (stats && stats.isSymbolicLink()) {
        const srcStat = fs2.statSync(srcpath);
        const dstStat = fs2.statSync(dstpath);
        if (areIdentical(srcStat, dstStat))
          return;
      }
      const relative2 = symlinkPathsSync(srcpath, dstpath);
      srcpath = relative2.toDst;
      type = symlinkTypeSync(relative2.toCwd, type);
      const dir = path5.dirname(dstpath);
      const exists10 = fs2.existsSync(dir);
      if (exists10)
        return fs2.symlinkSync(srcpath, dstpath, type);
      mkdirsSync(dir);
      return fs2.symlinkSync(srcpath, dstpath, type);
    }
    module.exports = {
      createSymlink: u(createSymlink),
      createSymlinkSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/index.js
var require_ensure = __commonJS({
  "node_modules/fs-extra/lib/ensure/index.js"(exports, module) {
    "use strict";
    var { createFile, createFileSync } = require_file();
    var { createLink, createLinkSync } = require_link();
    var { createSymlink, createSymlinkSync } = require_symlink();
    module.exports = {
      // file
      createFile,
      createFileSync,
      ensureFile: createFile,
      ensureFileSync: createFileSync,
      // link
      createLink,
      createLinkSync,
      ensureLink: createLink,
      ensureLinkSync: createLinkSync,
      // symlink
      createSymlink,
      createSymlinkSync,
      ensureSymlink: createSymlink,
      ensureSymlinkSync: createSymlinkSync
    };
  }
});

// node_modules/jsonfile/utils.js
var require_utils2 = __commonJS({
  "node_modules/jsonfile/utils.js"(exports, module) {
    function stringify3(obj, { EOL = "\n", finalEOL = true, replacer = null, spaces: spaces2 } = {}) {
      const EOF = finalEOL ? EOL : "";
      const str2 = JSON.stringify(obj, replacer, spaces2);
      return str2.replace(/\n/g, EOL) + EOF;
    }
    function stripBom(content) {
      if (Buffer.isBuffer(content))
        content = content.toString("utf8");
      return content.replace(/^\uFEFF/, "");
    }
    module.exports = { stringify: stringify3, stripBom };
  }
});

// node_modules/jsonfile/index.js
var require_jsonfile = __commonJS({
  "node_modules/jsonfile/index.js"(exports, module) {
    var _fs;
    try {
      _fs = require_graceful_fs();
    } catch (_) {
      _fs = __require("fs");
    }
    var universalify = require_universalify();
    var { stringify: stringify3, stripBom } = require_utils2();
    async function _readFile(file, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      const fs2 = options.fs || _fs;
      const shouldThrow = "throws" in options ? options.throws : true;
      let data = await universalify.fromCallback(fs2.readFile)(file, options);
      data = stripBom(data);
      let obj;
      try {
        obj = JSON.parse(data, options ? options.reviver : null);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }
      return obj;
    }
    var readFile4 = universalify.fromPromise(_readFile);
    function readFileSync2(file, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      const fs2 = options.fs || _fs;
      const shouldThrow = "throws" in options ? options.throws : true;
      try {
        let content = fs2.readFileSync(file, options);
        content = stripBom(content);
        return JSON.parse(content, options.reviver);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }
    }
    async function _writeFile(file, obj, options = {}) {
      const fs2 = options.fs || _fs;
      const str2 = stringify3(obj, options);
      await universalify.fromCallback(fs2.writeFile)(file, str2, options);
    }
    var writeFile6 = universalify.fromPromise(_writeFile);
    function writeFileSync2(file, obj, options = {}) {
      const fs2 = options.fs || _fs;
      const str2 = stringify3(obj, options);
      return fs2.writeFileSync(file, str2, options);
    }
    var jsonfile = {
      readFile: readFile4,
      readFileSync: readFileSync2,
      writeFile: writeFile6,
      writeFileSync: writeFileSync2
    };
    module.exports = jsonfile;
  }
});

// node_modules/fs-extra/lib/json/jsonfile.js
var require_jsonfile2 = __commonJS({
  "node_modules/fs-extra/lib/json/jsonfile.js"(exports, module) {
    "use strict";
    var jsonFile = require_jsonfile();
    module.exports = {
      // jsonfile exports
      readJson: jsonFile.readFile,
      readJsonSync: jsonFile.readFileSync,
      writeJson: jsonFile.writeFile,
      writeJsonSync: jsonFile.writeFileSync
    };
  }
});

// node_modules/fs-extra/lib/output-file/index.js
var require_output_file = __commonJS({
  "node_modules/fs-extra/lib/output-file/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromCallback;
    var fs2 = require_graceful_fs();
    var path5 = __require("path");
    var mkdir3 = require_mkdirs();
    var pathExists = require_path_exists().pathExists;
    function outputFile(file, data, encoding, callback) {
      if (typeof encoding === "function") {
        callback = encoding;
        encoding = "utf8";
      }
      const dir = path5.dirname(file);
      pathExists(dir, (err, itDoes) => {
        if (err)
          return callback(err);
        if (itDoes)
          return fs2.writeFile(file, data, encoding, callback);
        mkdir3.mkdirs(dir, (err2) => {
          if (err2)
            return callback(err2);
          fs2.writeFile(file, data, encoding, callback);
        });
      });
    }
    function outputFileSync(file, ...args) {
      const dir = path5.dirname(file);
      if (fs2.existsSync(dir)) {
        return fs2.writeFileSync(file, ...args);
      }
      mkdir3.mkdirsSync(dir);
      fs2.writeFileSync(file, ...args);
    }
    module.exports = {
      outputFile: u(outputFile),
      outputFileSync
    };
  }
});

// node_modules/fs-extra/lib/json/output-json.js
var require_output_json = __commonJS({
  "node_modules/fs-extra/lib/json/output-json.js"(exports, module) {
    "use strict";
    var { stringify: stringify3 } = require_utils2();
    var { outputFile } = require_output_file();
    async function outputJson(file, data, options = {}) {
      const str2 = stringify3(data, options);
      await outputFile(file, str2, options);
    }
    module.exports = outputJson;
  }
});

// node_modules/fs-extra/lib/json/output-json-sync.js
var require_output_json_sync = __commonJS({
  "node_modules/fs-extra/lib/json/output-json-sync.js"(exports, module) {
    "use strict";
    var { stringify: stringify3 } = require_utils2();
    var { outputFileSync } = require_output_file();
    function outputJsonSync(file, data, options) {
      const str2 = stringify3(data, options);
      outputFileSync(file, str2, options);
    }
    module.exports = outputJsonSync;
  }
});

// node_modules/fs-extra/lib/json/index.js
var require_json = __commonJS({
  "node_modules/fs-extra/lib/json/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    var jsonFile = require_jsonfile2();
    jsonFile.outputJson = u(require_output_json());
    jsonFile.outputJsonSync = require_output_json_sync();
    jsonFile.outputJSON = jsonFile.outputJson;
    jsonFile.outputJSONSync = jsonFile.outputJsonSync;
    jsonFile.writeJSON = jsonFile.writeJson;
    jsonFile.writeJSONSync = jsonFile.writeJsonSync;
    jsonFile.readJSON = jsonFile.readJson;
    jsonFile.readJSONSync = jsonFile.readJsonSync;
    module.exports = jsonFile;
  }
});

// node_modules/fs-extra/lib/move/move.js
var require_move = __commonJS({
  "node_modules/fs-extra/lib/move/move.js"(exports, module) {
    "use strict";
    var fs2 = require_graceful_fs();
    var path5 = __require("path");
    var copy3 = require_copy2().copy;
    var remove = require_remove().remove;
    var mkdirp7 = require_mkdirs().mkdirp;
    var pathExists = require_path_exists().pathExists;
    var stat6 = require_stat();
    function move(src, dest, opts, cb) {
      if (typeof opts === "function") {
        cb = opts;
        opts = {};
      }
      opts = opts || {};
      const overwrite = opts.overwrite || opts.clobber || false;
      stat6.checkPaths(src, dest, "move", opts, (err, stats) => {
        if (err)
          return cb(err);
        const { srcStat, isChangingCase = false } = stats;
        stat6.checkParentPaths(src, srcStat, dest, "move", (err2) => {
          if (err2)
            return cb(err2);
          if (isParentRoot(dest))
            return doRename(src, dest, overwrite, isChangingCase, cb);
          mkdirp7(path5.dirname(dest), (err3) => {
            if (err3)
              return cb(err3);
            return doRename(src, dest, overwrite, isChangingCase, cb);
          });
        });
      });
    }
    function isParentRoot(dest) {
      const parent = path5.dirname(dest);
      const parsedPath = path5.parse(parent);
      return parsedPath.root === parent;
    }
    function doRename(src, dest, overwrite, isChangingCase, cb) {
      if (isChangingCase)
        return rename3(src, dest, overwrite, cb);
      if (overwrite) {
        return remove(dest, (err) => {
          if (err)
            return cb(err);
          return rename3(src, dest, overwrite, cb);
        });
      }
      pathExists(dest, (err, destExists) => {
        if (err)
          return cb(err);
        if (destExists)
          return cb(new Error("dest already exists."));
        return rename3(src, dest, overwrite, cb);
      });
    }
    function rename3(src, dest, overwrite, cb) {
      fs2.rename(src, dest, (err) => {
        if (!err)
          return cb();
        if (err.code !== "EXDEV")
          return cb(err);
        return moveAcrossDevice(src, dest, overwrite, cb);
      });
    }
    function moveAcrossDevice(src, dest, overwrite, cb) {
      const opts = {
        overwrite,
        errorOnExist: true
      };
      copy3(src, dest, opts, (err) => {
        if (err)
          return cb(err);
        return remove(src, cb);
      });
    }
    module.exports = move;
  }
});

// node_modules/fs-extra/lib/move/move-sync.js
var require_move_sync = __commonJS({
  "node_modules/fs-extra/lib/move/move-sync.js"(exports, module) {
    "use strict";
    var fs2 = require_graceful_fs();
    var path5 = __require("path");
    var copySync = require_copy2().copySync;
    var removeSync = require_remove().removeSync;
    var mkdirpSync = require_mkdirs().mkdirpSync;
    var stat6 = require_stat();
    function moveSync4(src, dest, opts) {
      opts = opts || {};
      const overwrite = opts.overwrite || opts.clobber || false;
      const { srcStat, isChangingCase = false } = stat6.checkPathsSync(src, dest, "move", opts);
      stat6.checkParentPathsSync(src, srcStat, dest, "move");
      if (!isParentRoot(dest))
        mkdirpSync(path5.dirname(dest));
      return doRename(src, dest, overwrite, isChangingCase);
    }
    function isParentRoot(dest) {
      const parent = path5.dirname(dest);
      const parsedPath = path5.parse(parent);
      return parsedPath.root === parent;
    }
    function doRename(src, dest, overwrite, isChangingCase) {
      if (isChangingCase)
        return rename3(src, dest, overwrite);
      if (overwrite) {
        removeSync(dest);
        return rename3(src, dest, overwrite);
      }
      if (fs2.existsSync(dest))
        throw new Error("dest already exists.");
      return rename3(src, dest, overwrite);
    }
    function rename3(src, dest, overwrite) {
      try {
        fs2.renameSync(src, dest);
      } catch (err) {
        if (err.code !== "EXDEV")
          throw err;
        return moveAcrossDevice(src, dest, overwrite);
      }
    }
    function moveAcrossDevice(src, dest, overwrite) {
      const opts = {
        overwrite,
        errorOnExist: true
      };
      copySync(src, dest, opts);
      return removeSync(src);
    }
    module.exports = moveSync4;
  }
});

// node_modules/fs-extra/lib/move/index.js
var require_move2 = __commonJS({
  "node_modules/fs-extra/lib/move/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromCallback;
    module.exports = {
      move: u(require_move()),
      moveSync: require_move_sync()
    };
  }
});

// node_modules/fs-extra/lib/index.js
var require_lib = __commonJS({
  "node_modules/fs-extra/lib/index.js"(exports, module) {
    "use strict";
    module.exports = {
      // Export promiseified graceful-fs:
      ...require_fs(),
      // Export extra methods:
      ...require_copy2(),
      ...require_empty(),
      ...require_ensure(),
      ...require_json(),
      ...require_mkdirs(),
      ...require_move2(),
      ...require_output_file(),
      ...require_path_exists(),
      ...require_remove()
    };
  }
});

// node_modules/xhr2/lib/xhr2.js
var require_xhr2 = __commonJS({
  "node_modules/xhr2/lib/xhr2.js"(exports, module) {
    (function() {
      var InvalidStateError, NetworkError, ProgressEvent, SecurityError, SyntaxError2, XMLHttpRequest2, XMLHttpRequestEventTarget, XMLHttpRequestUpload, http, https, os3, url2;
      XMLHttpRequestEventTarget = function() {
        class XMLHttpRequestEventTarget2 {
          // @private
          // This is an abstract class and should not be instantiated directly.
          constructor() {
            this.onloadstart = null;
            this.onprogress = null;
            this.onabort = null;
            this.onerror = null;
            this.onload = null;
            this.ontimeout = null;
            this.onloadend = null;
            this._listeners = {};
          }
          // Adds a new-style listener for one of the XHR events.
          // @see http://www.w3.org/TR/XMLHttpRequest/#events
          // @param {String} eventType an XHR event type, such as 'readystatechange'
          // @param {function(ProgressEvent)} listener function that will be called when
          //   the event fires
          // @return {undefined} undefined
          addEventListener(eventType, listener) {
            var base;
            eventType = eventType.toLowerCase();
            (base = this._listeners)[eventType] || (base[eventType] = []);
            this._listeners[eventType].push(listener);
            return void 0;
          }
          // Removes an event listener added by calling addEventListener.
          // @param {String} eventType an XHR event type, such as 'readystatechange'
          // @param {function(ProgressEvent)} listener the value passed in a previous
          //   call to addEventListener.
          // @return {undefined} undefined
          removeEventListener(eventType, listener) {
            var index4;
            eventType = eventType.toLowerCase();
            if (this._listeners[eventType]) {
              index4 = this._listeners[eventType].indexOf(listener);
              if (index4 !== -1) {
                this._listeners[eventType].splice(index4, 1);
              }
            }
            return void 0;
          }
          // Calls all the listeners for an event.
          // @param {ProgressEvent} event the event to be dispatched
          // @return {undefined} undefined
          dispatchEvent(event) {
            var eventType, j, len, listener, listeners;
            event.currentTarget = event.target = this;
            eventType = event.type;
            if (listeners = this._listeners[eventType]) {
              for (j = 0, len = listeners.length; j < len; j++) {
                listener = listeners[j];
                listener.call(this, event);
              }
            }
            if (listener = this[`on${eventType}`]) {
              listener.call(this, event);
            }
            return void 0;
          }
        }
        ;
        XMLHttpRequestEventTarget2.prototype.onloadstart = null;
        XMLHttpRequestEventTarget2.prototype.onprogress = null;
        XMLHttpRequestEventTarget2.prototype.onabort = null;
        XMLHttpRequestEventTarget2.prototype.onerror = null;
        XMLHttpRequestEventTarget2.prototype.onload = null;
        XMLHttpRequestEventTarget2.prototype.ontimeout = null;
        XMLHttpRequestEventTarget2.prototype.onloadend = null;
        return XMLHttpRequestEventTarget2;
      }.call(this);
      http = __require("http");
      https = __require("https");
      os3 = __require("os");
      url2 = __require("url");
      XMLHttpRequest2 = function() {
        class XMLHttpRequest3 extends XMLHttpRequestEventTarget {
          // Creates a new request.
          // @param {Object} options one or more of the options below
          // @option options {Boolean} anon if true, the request's anonymous flag
          //   will be set
          // @see http://www.w3.org/TR/XMLHttpRequest/#constructors
          // @see http://www.w3.org/TR/XMLHttpRequest/#anonymous-flag
          constructor(options) {
            super();
            this.onreadystatechange = null;
            this._anonymous = options && options.anon;
            this.readyState = XMLHttpRequest3.UNSENT;
            this.response = null;
            this.responseText = "";
            this.responseType = "";
            this.responseURL = "";
            this.status = 0;
            this.statusText = "";
            this.timeout = 0;
            this.upload = new XMLHttpRequestUpload(this);
            this._method = null;
            this._url = null;
            this._sync = false;
            this._headers = null;
            this._loweredHeaders = null;
            this._mimeOverride = null;
            this._request = null;
            this._response = null;
            this._responseParts = null;
            this._responseHeaders = null;
            this._aborting = null;
            this._error = null;
            this._loadedBytes = 0;
            this._totalBytes = 0;
            this._lengthComputable = false;
          }
          // Sets the XHR's method, URL, synchronous flag, and authentication params.
          // @param {String} method the HTTP method to be used
          // @param {String} url the URL that the request will be made to
          // @param {?Boolean} async if false, the XHR should be processed
          //   synchronously; true by default
          // @param {?String} user the user credential to be used in HTTP basic
          //   authentication
          // @param {?String} password the password credential to be used in HTTP basic
          //   authentication
          // @return {undefined} undefined
          // @throw {SecurityError} method is not one of the allowed methods
          // @throw {SyntaxError} urlString is not a valid URL
          // @throw {Error} the URL contains an unsupported protocol; the supported
          //   protocols are file, http and https
          // @see http://www.w3.org/TR/XMLHttpRequest/#the-open()-method
          open(method, url3, async, user, password) {
            var xhrUrl;
            method = method.toUpperCase();
            if (method in this._restrictedMethods) {
              throw new SecurityError(`HTTP method ${method} is not allowed in XHR`);
            }
            xhrUrl = this._parseUrl(url3);
            if (async === void 0) {
              async = true;
            }
            switch (this.readyState) {
              case XMLHttpRequest3.UNSENT:
              case XMLHttpRequest3.OPENED:
              case XMLHttpRequest3.DONE:
                null;
                break;
              case XMLHttpRequest3.HEADERS_RECEIVED:
              case XMLHttpRequest3.LOADING:
                null;
            }
            this._method = method;
            this._url = xhrUrl;
            this._sync = !async;
            this._headers = {};
            this._loweredHeaders = {};
            this._mimeOverride = null;
            this._setReadyState(XMLHttpRequest3.OPENED);
            this._request = null;
            this._response = null;
            this.status = 0;
            this.statusText = "";
            this._responseParts = [];
            this._responseHeaders = null;
            this._loadedBytes = 0;
            this._totalBytes = 0;
            this._lengthComputable = false;
            return void 0;
          }
          // Appends a header to the list of author request headers.
          // @param {String} name the HTTP header name
          // @param {String} value the HTTP header value
          // @return {undefined} undefined
          // @throw {InvalidStateError} readyState is not OPENED
          // @throw {SyntaxError} name is not a valid HTTP header name or value is not
          //   a valid HTTP header value
          // @see http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader()-method
          setRequestHeader(name4, value4) {
            var loweredName;
            if (this.readyState !== XMLHttpRequest3.OPENED) {
              throw new InvalidStateError("XHR readyState must be OPENED");
            }
            loweredName = name4.toLowerCase();
            if (this._restrictedHeaders[loweredName] || /^sec\-/.test(loweredName) || /^proxy-/.test(loweredName)) {
              console.warn(`Refused to set unsafe header "${name4}"`);
              return void 0;
            }
            value4 = value4.toString();
            if (loweredName in this._loweredHeaders) {
              name4 = this._loweredHeaders[loweredName];
              this._headers[name4] = this._headers[name4] + ", " + value4;
            } else {
              this._loweredHeaders[loweredName] = name4;
              this._headers[name4] = value4;
            }
            return void 0;
          }
          // Initiates the request.
          // @param {?String, ?ArrayBufferView} data the data to be sent; ignored for
          //   GET and HEAD requests
          // @return {undefined} undefined
          // @throw {InvalidStateError} readyState is not OPENED
          // @see http://www.w3.org/TR/XMLHttpRequest/#the-send()-method
          send(data) {
            if (this.readyState !== XMLHttpRequest3.OPENED) {
              throw new InvalidStateError("XHR readyState must be OPENED");
            }
            if (this._request) {
              throw new InvalidStateError("send() already called");
            }
            switch (this._url.protocol) {
              case "file:":
                this._sendFile(data);
                break;
              case "http:":
              case "https:":
                this._sendHttp(data);
                break;
              default:
                throw new NetworkError(`Unsupported protocol ${this._url.protocol}`);
            }
            return void 0;
          }
          // Cancels the network activity performed by this request.
          // @return {undefined} undefined
          // @see http://www.w3.org/TR/XMLHttpRequest/#the-abort()-method
          abort() {
            if (!this._request) {
              return;
            }
            this._request.abort();
            this._setError();
            this._dispatchProgress("abort");
            this._dispatchProgress("loadend");
            return void 0;
          }
          // Returns a header value in the HTTP response for this XHR.
          // @param {String} name case-insensitive HTTP header name
          // @return {?String} value the value of the header whose name matches the
          //   given name, or null if there is no such header
          // @see http://www.w3.org/TR/XMLHttpRequest/#the-getresponseheader()-method
          getResponseHeader(name4) {
            var loweredName;
            if (!this._responseHeaders) {
              return null;
            }
            loweredName = name4.toLowerCase();
            if (loweredName in this._responseHeaders) {
              return this._responseHeaders[loweredName];
            } else {
              return null;
            }
          }
          // Returns all the HTTP headers in this XHR's response.
          // @return {String} header lines separated by CR LF, where each header line
          //   has the name and value separated by a ": " (colon, space); the empty
          //   string is returned if the headers are not available
          // @see http://www.w3.org/TR/XMLHttpRequest/#the-getallresponseheaders()-method
          getAllResponseHeaders() {
            var lines6, name4, value4;
            if (!this._responseHeaders) {
              return "";
            }
            lines6 = function() {
              var ref2, results;
              ref2 = this._responseHeaders;
              results = [];
              for (name4 in ref2) {
                value4 = ref2[name4];
                results.push(`${name4}: ${value4}`);
              }
              return results;
            }.call(this);
            return lines6.join("\r\n");
          }
          // Overrides the Content-Type
          // @return {undefined} undefined
          // @see http://www.w3.org/TR/XMLHttpRequest/#the-overridemimetype()-method
          overrideMimeType(newMimeType) {
            if (this.readyState === XMLHttpRequest3.LOADING || this.readyState === XMLHttpRequest3.DONE) {
              throw new InvalidStateError("overrideMimeType() not allowed in LOADING or DONE");
            }
            this._mimeOverride = newMimeType.toLowerCase();
            return void 0;
          }
          // Network configuration not exposed in the XHR API.
          // Although the XMLHttpRequest specification calls itself "ECMAScript HTTP",
          // it assumes that requests are always performed in the context of a browser
          // application, where some network parameters are set by the browser user and
          // should not be modified by Web applications. This API provides access to
          // these network parameters.
          // NOTE: this is not in the XMLHttpRequest API, and will not work in
          // browsers.  It is a stable node-xhr2 API.
          // @param {Object} options one or more of the options below
          // @option options {?http.Agent} httpAgent the value for the nodejsHttpAgent
          //   property (the agent used for HTTP requests)
          // @option options {?https.Agent} httpsAgent the value for the
          //   nodejsHttpsAgent property (the agent used for HTTPS requests)
          // @return {undefined} undefined
          nodejsSet(options) {
            var baseUrl, parsedUrl;
            if ("httpAgent" in options) {
              this.nodejsHttpAgent = options.httpAgent;
            }
            if ("httpsAgent" in options) {
              this.nodejsHttpsAgent = options.httpsAgent;
            }
            if ("baseUrl" in options) {
              baseUrl = options.baseUrl;
              if (baseUrl !== null) {
                parsedUrl = url2.parse(baseUrl, false, true);
                if (!parsedUrl.protocol) {
                  throw new SyntaxError2("baseUrl must be an absolute URL");
                }
              }
              this.nodejsBaseUrl = baseUrl;
            }
            return void 0;
          }
          // Default settings for the network configuration not exposed in the XHR API.
          // NOTE: this is not in the XMLHttpRequest API, and will not work in
          // browsers.  It is a stable node-xhr2 API.
          // @param {Object} options one or more of the options below
          // @option options {?http.Agent} httpAgent the default value for the
          //   nodejsHttpAgent property (the agent used for HTTP requests)
          // @option options {https.Agent} httpsAgent the default value for the
          //   nodejsHttpsAgent property (the agent used for HTTPS requests)
          // @return {undefined} undefined
          // @see XMLHttpRequest.nodejsSet
          static nodejsSet(options) {
            XMLHttpRequest3.prototype.nodejsSet(options);
            return void 0;
          }
          // Sets the readyState property and fires the readystatechange event.
          // @private
          // @param {Number} newReadyState the new value of readyState
          // @return {undefined} undefined
          _setReadyState(newReadyState) {
            var event;
            this.readyState = newReadyState;
            event = new ProgressEvent("readystatechange");
            this.dispatchEvent(event);
            return void 0;
          }
          // XMLHttpRequest#send() implementation for the file: protocol.
          // @private
          _sendFile() {
            if (this._url.method !== "GET") {
              throw new NetworkError("The file protocol only supports GET");
            }
            throw new Error("Protocol file: not implemented");
          }
          // XMLHttpRequest#send() implementation for the http: and https: protocols.
          // @private
          // This method sets the instance variables and calls _sendHxxpRequest(), which
          // is responsible for building a node.js request and firing it off. The code
          // in _sendHxxpRequest() is separated off so it can be reused when handling
          // redirects.
          // @see http://www.w3.org/TR/XMLHttpRequest/#infrastructure-for-the-send()-method
          _sendHttp(data) {
            if (this._sync) {
              throw new Error("Synchronous XHR processing not implemented");
            }
            if (data != null && (this._method === "GET" || this._method === "HEAD")) {
              console.warn(`Discarding entity body for ${this._method} requests`);
              data = null;
            } else {
              data || (data = "");
            }
            this.upload._setData(data);
            this._finalizeHeaders();
            this._sendHxxpRequest();
            return void 0;
          }
          // Sets up and fires off a HTTP/HTTPS request using the node.js API.
          // @private
          // This method contains the bulk of the XMLHttpRequest#send() implementation,
          // and is also used to issue new HTTP requests when handling HTTP redirects.
          // @see http://www.w3.org/TR/XMLHttpRequest/#infrastructure-for-the-send()-method
          _sendHxxpRequest() {
            var agent, hxxp, request3;
            if (this._url.protocol === "http:") {
              hxxp = http;
              agent = this.nodejsHttpAgent;
            } else {
              hxxp = https;
              agent = this.nodejsHttpsAgent;
            }
            request3 = hxxp.request({
              hostname: this._url.hostname,
              port: this._url.port,
              path: this._url.path,
              auth: this._url.auth,
              method: this._method,
              headers: this._headers,
              agent
            });
            this._request = request3;
            if (this.timeout) {
              request3.setTimeout(this.timeout, () => {
                return this._onHttpTimeout(request3);
              });
            }
            request3.on("response", (response) => {
              return this._onHttpResponse(request3, response);
            });
            request3.on("error", (error4) => {
              return this._onHttpRequestError(request3, error4);
            });
            this.upload._startUpload(request3);
            if (this._request === request3) {
              this._dispatchProgress("loadstart");
            }
            return void 0;
          }
          // Fills in the restricted HTTP headers with default values.
          // This is called right before the HTTP request is sent off.
          // @private
          // @return {undefined} undefined
          _finalizeHeaders() {
            var base;
            this._headers["Connection"] = "keep-alive";
            this._headers["Host"] = this._url.host;
            if (this._anonymous) {
              this._headers["Referer"] = "about:blank";
            }
            (base = this._headers)["User-Agent"] || (base["User-Agent"] = this._userAgent);
            this.upload._finalizeHeaders(this._headers, this._loweredHeaders);
            return void 0;
          }
          // Called when the headers of an HTTP response have been received.
          // @private
          // @param {http.ClientRequest} request the node.js ClientRequest instance that
          //   produced this response
          // @param {http.ClientResponse} response the node.js ClientResponse instance
          //   passed to
          _onHttpResponse(request3, response) {
            var lengthString;
            if (this._request !== request3) {
              return;
            }
            switch (response.statusCode) {
              case 301:
              case 302:
              case 303:
              case 307:
              case 308:
                this._url = this._parseUrl(response.headers["location"]);
                this._method = "GET";
                if ("content-type" in this._loweredHeaders) {
                  delete this._headers[this._loweredHeaders["content-type"]];
                  delete this._loweredHeaders["content-type"];
                }
                if ("Content-Type" in this._headers) {
                  delete this._headers["Content-Type"];
                }
                delete this._headers["Content-Length"];
                this.upload._reset();
                this._finalizeHeaders();
                this._sendHxxpRequest();
                return;
            }
            this._response = response;
            this._response.on("data", (data) => {
              return this._onHttpResponseData(response, data);
            });
            this._response.on("end", () => {
              return this._onHttpResponseEnd(response);
            });
            this._response.on("close", () => {
              return this._onHttpResponseClose(response);
            });
            this.responseURL = this._url.href.split("#")[0];
            this.status = this._response.statusCode;
            this.statusText = http.STATUS_CODES[this.status];
            this._parseResponseHeaders(response);
            if (lengthString = this._responseHeaders["content-length"]) {
              this._totalBytes = parseInt(lengthString);
              this._lengthComputable = true;
            } else {
              this._lengthComputable = false;
            }
            return this._setReadyState(XMLHttpRequest3.HEADERS_RECEIVED);
          }
          // Called when some data has been received on a HTTP connection.
          // @private
          // @param {http.ClientResponse} response the node.js ClientResponse instance
          //   that fired this event
          // @param {String, Buffer} data the data that has been received
          _onHttpResponseData(response, data) {
            if (this._response !== response) {
              return;
            }
            this._responseParts.push(data);
            this._loadedBytes += data.length;
            if (this.readyState !== XMLHttpRequest3.LOADING) {
              this._setReadyState(XMLHttpRequest3.LOADING);
            }
            return this._dispatchProgress("progress");
          }
          // Called when the HTTP request finished processing.
          // @private
          // @param {http.ClientResponse} response the node.js ClientResponse instance
          //   that fired this event
          _onHttpResponseEnd(response) {
            if (this._response !== response) {
              return;
            }
            this._parseResponse();
            this._request = null;
            this._response = null;
            this._setReadyState(XMLHttpRequest3.DONE);
            this._dispatchProgress("load");
            return this._dispatchProgress("loadend");
          }
          // Called when the underlying HTTP connection was closed prematurely.
          // If this method is called, it will be called after or instead of
          // onHttpResponseEnd.
          // @private
          // @param {http.ClientResponse} response the node.js ClientResponse instance
          //   that fired this event
          _onHttpResponseClose(response) {
            var request3;
            if (this._response !== response) {
              return;
            }
            request3 = this._request;
            this._setError();
            request3.abort();
            this._setReadyState(XMLHttpRequest3.DONE);
            this._dispatchProgress("error");
            return this._dispatchProgress("loadend");
          }
          // Called when the timeout set on the HTTP socket expires.
          // @private
          // @param {http.ClientRequest} request the node.js ClientRequest instance that
          //   fired this event
          _onHttpTimeout(request3) {
            if (this._request !== request3) {
              return;
            }
            this._setError();
            request3.abort();
            this._setReadyState(XMLHttpRequest3.DONE);
            this._dispatchProgress("timeout");
            return this._dispatchProgress("loadend");
          }
          // Called when something wrong happens on the HTTP socket
          // @private
          // @param {http.ClientRequest} request the node.js ClientRequest instance that
          //   fired this event
          // @param {Error} error emitted exception
          _onHttpRequestError(request3, error4) {
            if (this._request !== request3) {
              return;
            }
            this._setError();
            request3.abort();
            this._setReadyState(XMLHttpRequest3.DONE);
            this._dispatchProgress("error");
            return this._dispatchProgress("loadend");
          }
          // Fires an XHR progress event.
          // @private
          // @param {String} eventType one of the XHR progress event types, such as
          //   'load' and 'progress'
          _dispatchProgress(eventType) {
            var event;
            event = new ProgressEvent(eventType);
            event.lengthComputable = this._lengthComputable;
            event.loaded = this._loadedBytes;
            event.total = this._totalBytes;
            this.dispatchEvent(event);
            return void 0;
          }
          // Sets up the XHR to reflect the fact that an error has occurred.
          // The possible errors are a network error, a timeout, or an abort.
          // @private
          _setError() {
            this._request = null;
            this._response = null;
            this._responseHeaders = null;
            this._responseParts = null;
            return void 0;
          }
          // Parses a request URL string.
          // @private
          // This method is a thin wrapper around url.parse() that normalizes HTTP
          // user/password credentials. It is used to parse the URL string passed to
          // XMLHttpRequest#open() and the URLs in the Location headers of HTTP redirect
          // responses.
          // @param {String} urlString the URL to be parsed
          // @return {Object} parsed URL
          _parseUrl(urlString) {
            var absoluteUrlString, index4, password, user, xhrUrl;
            if (this.nodejsBaseUrl === null) {
              absoluteUrlString = urlString;
            } else {
              absoluteUrlString = url2.resolve(this.nodejsBaseUrl, urlString);
            }
            xhrUrl = url2.parse(absoluteUrlString, false, true);
            xhrUrl.hash = null;
            if (xhrUrl.auth && (typeof user !== "undefined" && user !== null || typeof password !== "undefined" && password !== null)) {
              index4 = xhrUrl.auth.indexOf(":");
              if (index4 === -1) {
                if (!user) {
                  user = xhrUrl.auth;
                }
              } else {
                if (!user) {
                  user = xhrUrl.substring(0, index4);
                }
                if (!password) {
                  password = xhrUrl.substring(index4 + 1);
                }
              }
            }
            if (user || password) {
              xhrUrl.auth = `${user}:${password}`;
            }
            return xhrUrl;
          }
          // Reads the headers from a node.js ClientResponse instance.
          // @private
          // @param {http.ClientResponse} response the response whose headers will be
          //   imported into this XMLHttpRequest's state
          // @return {undefined} undefined
          // @see http://www.w3.org/TR/XMLHttpRequest/#the-getresponseheader()-method
          // @see http://www.w3.org/TR/XMLHttpRequest/#the-getallresponseheaders()-method
          _parseResponseHeaders(response) {
            var loweredName, name4, ref2, value4;
            this._responseHeaders = {};
            ref2 = response.headers;
            for (name4 in ref2) {
              value4 = ref2[name4];
              loweredName = name4.toLowerCase();
              if (this._privateHeaders[loweredName]) {
                continue;
              }
              if (this._mimeOverride !== null && loweredName === "content-type") {
                value4 = this._mimeOverride;
              }
              this._responseHeaders[loweredName] = value4;
            }
            if (this._mimeOverride !== null && !("content-type" in this._responseHeaders)) {
              this._responseHeaders["content-type"] = this._mimeOverride;
            }
            return void 0;
          }
          // Sets the response and responseText properties when an XHR completes.
          // @private
          // @return {undefined} undefined
          _parseResponse() {
            var arrayBuffer2, buffer, i, j, jsonError, ref2, view;
            if (Buffer.concat) {
              buffer = Buffer.concat(this._responseParts);
            } else {
              buffer = this._concatBuffers(this._responseParts);
            }
            this._responseParts = null;
            switch (this.responseType) {
              case "text":
                this._parseTextResponse(buffer);
                break;
              case "json":
                this.responseText = null;
                try {
                  this.response = JSON.parse(buffer.toString("utf-8"));
                } catch (error1) {
                  jsonError = error1;
                  this.response = null;
                }
                break;
              case "buffer":
                this.responseText = null;
                this.response = buffer;
                break;
              case "arraybuffer":
                this.responseText = null;
                arrayBuffer2 = new ArrayBuffer(buffer.length);
                view = new Uint8Array(arrayBuffer2);
                for (i = j = 0, ref2 = buffer.length; 0 <= ref2 ? j < ref2 : j > ref2; i = 0 <= ref2 ? ++j : --j) {
                  view[i] = buffer[i];
                }
                this.response = arrayBuffer2;
                break;
              default:
                this._parseTextResponse(buffer);
            }
            return void 0;
          }
          // Sets response and responseText for a 'text' response type.
          // @private
          // @param {Buffer} buffer the node.js Buffer containing the binary response
          // @return {undefined} undefined
          _parseTextResponse(buffer) {
            var e;
            try {
              this.responseText = buffer.toString(this._parseResponseEncoding());
            } catch (error1) {
              e = error1;
              this.responseText = buffer.toString("binary");
            }
            this.response = this.responseText;
            return void 0;
          }
          // Figures out the string encoding of the XHR's response.
          // This is called to determine the encoding when responseText is set.
          // @private
          // @return {String} a string encoding, e.g. 'utf-8'
          _parseResponseEncoding() {
            var contentType, encoding, match4;
            encoding = null;
            if (contentType = this._responseHeaders["content-type"]) {
              if (match4 = /\;\s*charset\=(.*)$/.exec(contentType)) {
                return match4[1];
              }
            }
            return "utf-8";
          }
          // Buffer.concat implementation for node 0.6.
          // @private
          // @param {Array<Buffer>} buffers the buffers whose contents will be merged
          // @return {Buffer} same as Buffer.concat(buffers) in node 0.8 and above
          _concatBuffers(buffers) {
            var buffer, j, k, len, len1, length7, target;
            if (buffers.length === 0) {
              return Buffer.alloc(0);
            }
            if (buffers.length === 1) {
              return buffers[0];
            }
            length7 = 0;
            for (j = 0, len = buffers.length; j < len; j++) {
              buffer = buffers[j];
              length7 += buffer.length;
            }
            target = Buffer.alloc(length7);
            length7 = 0;
            for (k = 0, len1 = buffers.length; k < len1; k++) {
              buffer = buffers[k];
              buffer.copy(target, length7);
              length7 += buffer.length;
            }
            return target;
          }
        }
        ;
        XMLHttpRequest3.prototype.onreadystatechange = null;
        XMLHttpRequest3.prototype.readyState = null;
        XMLHttpRequest3.prototype.response = null;
        XMLHttpRequest3.prototype.responseText = null;
        XMLHttpRequest3.prototype.responseType = null;
        XMLHttpRequest3.prototype.status = null;
        XMLHttpRequest3.prototype.timeout = null;
        XMLHttpRequest3.prototype.upload = null;
        XMLHttpRequest3.prototype.UNSENT = 0;
        XMLHttpRequest3.UNSENT = 0;
        XMLHttpRequest3.prototype.OPENED = 1;
        XMLHttpRequest3.OPENED = 1;
        XMLHttpRequest3.prototype.HEADERS_RECEIVED = 2;
        XMLHttpRequest3.HEADERS_RECEIVED = 2;
        XMLHttpRequest3.prototype.LOADING = 3;
        XMLHttpRequest3.LOADING = 3;
        XMLHttpRequest3.prototype.DONE = 4;
        XMLHttpRequest3.DONE = 4;
        XMLHttpRequest3.prototype.nodejsHttpAgent = http.globalAgent;
        XMLHttpRequest3.prototype.nodejsHttpsAgent = https.globalAgent;
        XMLHttpRequest3.prototype.nodejsBaseUrl = null;
        XMLHttpRequest3.prototype._restrictedMethods = {
          CONNECT: true,
          TRACE: true,
          TRACK: true
        };
        XMLHttpRequest3.prototype._restrictedHeaders = {
          "accept-charset": true,
          "accept-encoding": true,
          "access-control-request-headers": true,
          "access-control-request-method": true,
          connection: true,
          "content-length": true,
          cookie: true,
          cookie2: true,
          date: true,
          dnt: true,
          expect: true,
          host: true,
          "keep-alive": true,
          origin: true,
          referer: true,
          te: true,
          trailer: true,
          "transfer-encoding": true,
          upgrade: true,
          via: true
        };
        XMLHttpRequest3.prototype._privateHeaders = {
          "set-cookie": true,
          "set-cookie2": true
        };
        XMLHttpRequest3.prototype._userAgent = `Mozilla/5.0 (${os3.type()} ${os3.arch()}) node.js/${process.versions.node} v8/${process.versions.v8}`;
        return XMLHttpRequest3;
      }.call(this);
      module.exports = XMLHttpRequest2;
      XMLHttpRequest2.XMLHttpRequest = XMLHttpRequest2;
      SecurityError = class SecurityError extends Error {
        // @private
        constructor() {
          super();
        }
      };
      XMLHttpRequest2.SecurityError = SecurityError;
      InvalidStateError = class InvalidStateError extends Error {
        // @private
        constructor() {
          super();
        }
      };
      InvalidStateError = class InvalidStateError extends Error {
      };
      XMLHttpRequest2.InvalidStateError = InvalidStateError;
      NetworkError = class NetworkError extends Error {
        // @private
        constructor() {
          super();
        }
      };
      XMLHttpRequest2.SyntaxError = SyntaxError2;
      SyntaxError2 = class SyntaxError extends Error {
        // @private:
        constructor() {
          super();
        }
      };
      ProgressEvent = function() {
        class ProgressEvent2 {
          // Creates a new event.
          // @param {String} type the event type, e.g. 'readystatechange'; must be
          //   lowercased
          constructor(type) {
            this.type = type;
            this.target = null;
            this.currentTarget = null;
            this.lengthComputable = false;
            this.loaded = 0;
            this.total = 0;
          }
        }
        ;
        ProgressEvent2.prototype.bubbles = false;
        ProgressEvent2.prototype.cancelable = false;
        ProgressEvent2.prototype.target = null;
        ProgressEvent2.prototype.loaded = null;
        ProgressEvent2.prototype.lengthComputable = null;
        ProgressEvent2.prototype.total = null;
        return ProgressEvent2;
      }.call(this);
      XMLHttpRequest2.ProgressEvent = ProgressEvent;
      XMLHttpRequestUpload = class XMLHttpRequestUpload extends XMLHttpRequestEventTarget {
        // @private
        // @param {XMLHttpRequest} the XMLHttpRequest that this upload object is
        //   associated with
        constructor(request3) {
          super();
          this._request = request3;
          this._reset();
        }
        // Sets up this Upload to handle a new request.
        // @private
        // @return {undefined} undefined
        _reset() {
          this._contentType = null;
          this._body = null;
          return void 0;
        }
        // Implements the upload-related part of the send() XHR specification.
        // @private
        // @param {?String, ?Buffer, ?ArrayBufferView} data the argument passed to
        //   XMLHttpRequest#send()
        // @return {undefined} undefined
        // @see step 4 of http://www.w3.org/TR/XMLHttpRequest/#the-send()-method
        _setData(data) {
          var body, i, j, k, offset, ref2, ref1, view;
          if (typeof data === "undefined" || data === null) {
            return;
          }
          if (typeof data === "string") {
            if (data.length !== 0) {
              this._contentType = "text/plain;charset=UTF-8";
            }
            this._body = Buffer.from(data, "utf8");
          } else if (Buffer.isBuffer(data)) {
            this._body = data;
          } else if (data instanceof ArrayBuffer) {
            body = Buffer.alloc(data.byteLength);
            view = new Uint8Array(data);
            for (i = j = 0, ref2 = data.byteLength; 0 <= ref2 ? j < ref2 : j > ref2; i = 0 <= ref2 ? ++j : --j) {
              body[i] = view[i];
            }
            this._body = body;
          } else if (data.buffer && data.buffer instanceof ArrayBuffer) {
            body = Buffer.alloc(data.byteLength);
            offset = data.byteOffset;
            view = new Uint8Array(data.buffer);
            for (i = k = 0, ref1 = data.byteLength; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {
              body[i] = view[i + offset];
            }
            this._body = body;
          } else {
            throw new Error(`Unsupported send() data ${data}`);
          }
          return void 0;
        }
        // Updates the HTTP headers right before the request is sent.
        // This is used to set data-dependent headers such as Content-Length and
        // Content-Type.
        // @private
        // @param {Object<String, String>} headers the HTTP headers to be sent
        // @param {Object<String, String>} loweredHeaders maps lowercased HTTP header
        //   names (e.g., 'content-type') to the actual names used in the headers
        //   parameter (e.g., 'Content-Type')
        // @return {undefined} undefined
        _finalizeHeaders(headers, loweredHeaders) {
          if (this._contentType) {
            if (!("content-type" in loweredHeaders)) {
              headers["Content-Type"] = this._contentType;
            }
          }
          if (this._body) {
            headers["Content-Length"] = this._body.length.toString();
          }
          return void 0;
        }
        // Starts sending the HTTP request data.
        // @private
        // @param {http.ClientRequest} request the HTTP request
        // @return {undefined} undefined
        _startUpload(request3) {
          if (this._body) {
            request3.write(this._body);
          }
          request3.end();
          return void 0;
        }
      };
      XMLHttpRequest2.XMLHttpRequestUpload = XMLHttpRequestUpload;
    }).call(exports);
  }
});

// node_modules/fast-glob/out/utils/array.js
var require_array = __commonJS({
  "node_modules/fast-glob/out/utils/array.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.splitWhen = exports.flatten = void 0;
    function flatten2(items) {
      return items.reduce((collection, item) => [].concat(collection, item), []);
    }
    exports.flatten = flatten2;
    function splitWhen(items, predicate) {
      const result = [[]];
      let groupIndex = 0;
      for (const item of items) {
        if (predicate(item)) {
          groupIndex++;
          result[groupIndex] = [];
        } else {
          result[groupIndex].push(item);
        }
      }
      return result;
    }
    exports.splitWhen = splitWhen;
  }
});

// node_modules/fast-glob/out/utils/errno.js
var require_errno = __commonJS({
  "node_modules/fast-glob/out/utils/errno.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isEnoentCodeError = void 0;
    function isEnoentCodeError(error4) {
      return error4.code === "ENOENT";
    }
    exports.isEnoentCodeError = isEnoentCodeError;
  }
});

// node_modules/fast-glob/out/utils/fs.js
var require_fs2 = __commonJS({
  "node_modules/fast-glob/out/utils/fs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDirentFromStats = void 0;
    var DirentFromStats = class {
      constructor(name4, stats) {
        this.name = name4;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name4, stats) {
      return new DirentFromStats(name4, stats);
    }
    exports.createDirentFromStats = createDirentFromStats;
  }
});

// node_modules/fast-glob/out/utils/path.js
var require_path = __commonJS({
  "node_modules/fast-glob/out/utils/path.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertPosixPathToPattern = exports.convertWindowsPathToPattern = exports.convertPathToPattern = exports.escapePosixPath = exports.escapeWindowsPath = exports.escape = exports.removeLeadingDotSegment = exports.makeAbsolute = exports.unixify = void 0;
    var os3 = __require("os");
    var path5 = __require("path");
    var IS_WINDOWS_PLATFORM = os3.platform() === "win32";
    var LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2;
    var POSIX_UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\()|\\(?![!()*+?@[\]{|}]))/g;
    var WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([(){}]|^!|[!+@](?=\())/g;
    var DOS_DEVICE_PATH_RE = /^\\\\([.?])/;
    var WINDOWS_BACKSLASHES_RE = /\\(?![!()+@{}])/g;
    function unixify(filepath) {
      return filepath.replace(/\\/g, "/");
    }
    exports.unixify = unixify;
    function makeAbsolute(cwd3, filepath) {
      return path5.resolve(cwd3, filepath);
    }
    exports.makeAbsolute = makeAbsolute;
    function removeLeadingDotSegment(entry) {
      if (entry.charAt(0) === ".") {
        const secondCharactery = entry.charAt(1);
        if (secondCharactery === "/" || secondCharactery === "\\") {
          return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
        }
      }
      return entry;
    }
    exports.removeLeadingDotSegment = removeLeadingDotSegment;
    exports.escape = IS_WINDOWS_PLATFORM ? escapeWindowsPath : escapePosixPath;
    function escapeWindowsPath(pattern) {
      return pattern.replace(WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
    }
    exports.escapeWindowsPath = escapeWindowsPath;
    function escapePosixPath(pattern) {
      return pattern.replace(POSIX_UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
    }
    exports.escapePosixPath = escapePosixPath;
    exports.convertPathToPattern = IS_WINDOWS_PLATFORM ? convertWindowsPathToPattern : convertPosixPathToPattern;
    function convertWindowsPathToPattern(filepath) {
      return escapeWindowsPath(filepath).replace(DOS_DEVICE_PATH_RE, "//$1").replace(WINDOWS_BACKSLASHES_RE, "/");
    }
    exports.convertWindowsPathToPattern = convertWindowsPathToPattern;
    function convertPosixPathToPattern(filepath) {
      return escapePosixPath(filepath);
    }
    exports.convertPosixPathToPattern = convertPosixPathToPattern;
  }
});

// node_modules/is-extglob/index.js
var require_is_extglob = __commonJS({
  "node_modules/is-extglob/index.js"(exports, module) {
    module.exports = function isExtglob(str2) {
      if (typeof str2 !== "string" || str2 === "") {
        return false;
      }
      var match4;
      while (match4 = /(\\).|([@?!+*]\(.*\))/g.exec(str2)) {
        if (match4[2])
          return true;
        str2 = str2.slice(match4.index + match4[0].length);
      }
      return false;
    };
  }
});

// node_modules/is-glob/index.js
var require_is_glob = __commonJS({
  "node_modules/is-glob/index.js"(exports, module) {
    var isExtglob = require_is_extglob();
    var chars2 = { "{": "}", "(": ")", "[": "]" };
    var strictCheck = function(str2) {
      if (str2[0] === "!") {
        return true;
      }
      var index4 = 0;
      var pipeIndex = -2;
      var closeSquareIndex = -2;
      var closeCurlyIndex = -2;
      var closeParenIndex = -2;
      var backSlashIndex = -2;
      while (index4 < str2.length) {
        if (str2[index4] === "*") {
          return true;
        }
        if (str2[index4 + 1] === "?" && /[\].+)]/.test(str2[index4])) {
          return true;
        }
        if (closeSquareIndex !== -1 && str2[index4] === "[" && str2[index4 + 1] !== "]") {
          if (closeSquareIndex < index4) {
            closeSquareIndex = str2.indexOf("]", index4);
          }
          if (closeSquareIndex > index4) {
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
            backSlashIndex = str2.indexOf("\\", index4);
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
          }
        }
        if (closeCurlyIndex !== -1 && str2[index4] === "{" && str2[index4 + 1] !== "}") {
          closeCurlyIndex = str2.indexOf("}", index4);
          if (closeCurlyIndex > index4) {
            backSlashIndex = str2.indexOf("\\", index4);
            if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
              return true;
            }
          }
        }
        if (closeParenIndex !== -1 && str2[index4] === "(" && str2[index4 + 1] === "?" && /[:!=]/.test(str2[index4 + 2]) && str2[index4 + 3] !== ")") {
          closeParenIndex = str2.indexOf(")", index4);
          if (closeParenIndex > index4) {
            backSlashIndex = str2.indexOf("\\", index4);
            if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
              return true;
            }
          }
        }
        if (pipeIndex !== -1 && str2[index4] === "(" && str2[index4 + 1] !== "|") {
          if (pipeIndex < index4) {
            pipeIndex = str2.indexOf("|", index4);
          }
          if (pipeIndex !== -1 && str2[pipeIndex + 1] !== ")") {
            closeParenIndex = str2.indexOf(")", pipeIndex);
            if (closeParenIndex > pipeIndex) {
              backSlashIndex = str2.indexOf("\\", pipeIndex);
              if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
                return true;
              }
            }
          }
        }
        if (str2[index4] === "\\") {
          var open2 = str2[index4 + 1];
          index4 += 2;
          var close2 = chars2[open2];
          if (close2) {
            var n = str2.indexOf(close2, index4);
            if (n !== -1) {
              index4 = n + 1;
            }
          }
          if (str2[index4] === "!") {
            return true;
          }
        } else {
          index4++;
        }
      }
      return false;
    };
    var relaxedCheck = function(str2) {
      if (str2[0] === "!") {
        return true;
      }
      var index4 = 0;
      while (index4 < str2.length) {
        if (/[*?{}()[\]]/.test(str2[index4])) {
          return true;
        }
        if (str2[index4] === "\\") {
          var open2 = str2[index4 + 1];
          index4 += 2;
          var close2 = chars2[open2];
          if (close2) {
            var n = str2.indexOf(close2, index4);
            if (n !== -1) {
              index4 = n + 1;
            }
          }
          if (str2[index4] === "!") {
            return true;
          }
        } else {
          index4++;
        }
      }
      return false;
    };
    module.exports = function isGlob(str2, options) {
      if (typeof str2 !== "string" || str2 === "") {
        return false;
      }
      if (isExtglob(str2)) {
        return true;
      }
      var check = strictCheck;
      if (options && options.strict === false) {
        check = relaxedCheck;
      }
      return check(str2);
    };
  }
});

// node_modules/glob-parent/index.js
var require_glob_parent = __commonJS({
  "node_modules/glob-parent/index.js"(exports, module) {
    "use strict";
    var isGlob = require_is_glob();
    var pathPosixDirname = __require("path").posix.dirname;
    var isWin32 = __require("os").platform() === "win32";
    var slash = "/";
    var backslash = /\\/g;
    var enclosure = /[\{\[].*[\}\]]$/;
    var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
    var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
    module.exports = function globParent(str2, opts) {
      var options = Object.assign({ flipBackslashes: true }, opts);
      if (options.flipBackslashes && isWin32 && str2.indexOf(slash) < 0) {
        str2 = str2.replace(backslash, slash);
      }
      if (enclosure.test(str2)) {
        str2 += slash;
      }
      str2 += "a";
      do {
        str2 = pathPosixDirname(str2);
      } while (isGlob(str2) || globby.test(str2));
      return str2.replace(escaped, "$1");
    };
  }
});

// node_modules/braces/lib/utils.js
var require_utils3 = __commonJS({
  "node_modules/braces/lib/utils.js"(exports) {
    "use strict";
    exports.isInteger = (num) => {
      if (typeof num === "number") {
        return Number.isInteger(num);
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isInteger(Number(num));
      }
      return false;
    };
    exports.find = (node, type) => node.nodes.find((node2) => node2.type === type);
    exports.exceedsLimit = (min8, max8, step3 = 1, limit) => {
      if (limit === false)
        return false;
      if (!exports.isInteger(min8) || !exports.isInteger(max8))
        return false;
      return (Number(max8) - Number(min8)) / Number(step3) >= limit;
    };
    exports.escapeNode = (block, n = 0, type) => {
      let node = block.nodes[n];
      if (!node)
        return;
      if (type && node.type === type || node.type === "open" || node.type === "close") {
        if (node.escaped !== true) {
          node.value = "\\" + node.value;
          node.escaped = true;
        }
      }
    };
    exports.encloseBrace = (node) => {
      if (node.type !== "brace")
        return false;
      if (node.commas >> 0 + node.ranges >> 0 === 0) {
        node.invalid = true;
        return true;
      }
      return false;
    };
    exports.isInvalidBrace = (block) => {
      if (block.type !== "brace")
        return false;
      if (block.invalid === true || block.dollar)
        return true;
      if (block.commas >> 0 + block.ranges >> 0 === 0) {
        block.invalid = true;
        return true;
      }
      if (block.open !== true || block.close !== true) {
        block.invalid = true;
        return true;
      }
      return false;
    };
    exports.isOpenOrClose = (node) => {
      if (node.type === "open" || node.type === "close") {
        return true;
      }
      return node.open === true || node.close === true;
    };
    exports.reduce = (nodes) => nodes.reduce((acc, node) => {
      if (node.type === "text")
        acc.push(node.value);
      if (node.type === "range")
        node.type = "text";
      return acc;
    }, []);
    exports.flatten = (...args) => {
      const result = [];
      const flat = (arr) => {
        for (let i = 0; i < arr.length; i++) {
          let ele = arr[i];
          Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
        }
        return result;
      };
      flat(args);
      return result;
    };
  }
});

// node_modules/braces/lib/stringify.js
var require_stringify2 = __commonJS({
  "node_modules/braces/lib/stringify.js"(exports, module) {
    "use strict";
    var utils = require_utils3();
    module.exports = (ast, options = {}) => {
      let stringify3 = (node, parent = {}) => {
        let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options.escapeInvalid === true;
        let output5 = "";
        if (node.value) {
          if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
            return "\\" + node.value;
          }
          return node.value;
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output5 += stringify3(child);
          }
        }
        return output5;
      };
      return stringify3(ast);
    };
  }
});

// node_modules/is-number/index.js
var require_is_number = __commonJS({
  "node_modules/is-number/index.js"(exports, module) {
    "use strict";
    module.exports = function(num) {
      if (typeof num === "number") {
        return num - num === 0;
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
      }
      return false;
    };
  }
});

// node_modules/to-regex-range/index.js
var require_to_regex_range = __commonJS({
  "node_modules/to-regex-range/index.js"(exports, module) {
    "use strict";
    var isNumber = require_is_number();
    var toRegexRange = (min8, max8, options) => {
      if (isNumber(min8) === false) {
        throw new TypeError("toRegexRange: expected the first argument to be a number");
      }
      if (max8 === void 0 || min8 === max8) {
        return String(min8);
      }
      if (isNumber(max8) === false) {
        throw new TypeError("toRegexRange: expected the second argument to be a number.");
      }
      let opts = { relaxZeros: true, ...options };
      if (typeof opts.strictZeros === "boolean") {
        opts.relaxZeros = opts.strictZeros === false;
      }
      let relax = String(opts.relaxZeros);
      let shorthand = String(opts.shorthand);
      let capture = String(opts.capture);
      let wrap5 = String(opts.wrap);
      let cacheKey = min8 + ":" + max8 + "=" + relax + shorthand + capture + wrap5;
      if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
        return toRegexRange.cache[cacheKey].result;
      }
      let a = Math.min(min8, max8);
      let b = Math.max(min8, max8);
      if (Math.abs(a - b) === 1) {
        let result = min8 + "|" + max8;
        if (opts.capture) {
          return `(${result})`;
        }
        if (opts.wrap === false) {
          return result;
        }
        return `(?:${result})`;
      }
      let isPadded = hasPadding(min8) || hasPadding(max8);
      let state2 = { min: min8, max: max8, a, b };
      let positives = [];
      let negatives = [];
      if (isPadded) {
        state2.isPadded = isPadded;
        state2.maxLen = String(state2.max).length;
      }
      if (a < 0) {
        let newMin = b < 0 ? Math.abs(b) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a), state2, opts);
        a = state2.a = 0;
      }
      if (b >= 0) {
        positives = splitToPatterns(a, b, state2, opts);
      }
      state2.negatives = negatives;
      state2.positives = positives;
      state2.result = collatePatterns(negatives, positives, opts);
      if (opts.capture === true) {
        state2.result = `(${state2.result})`;
      } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
        state2.result = `(?:${state2.result})`;
      }
      toRegexRange.cache[cacheKey] = state2;
      return state2.result;
    };
    function collatePatterns(neg, pos, options) {
      let onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];
      let onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
      let intersected = filterPatterns(neg, pos, "-?", true, options) || [];
      let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
      return subpatterns.join("|");
    }
    function splitToRanges(min8, max8) {
      let nines = 1;
      let zeros = 1;
      let stop = countNines(min8, nines);
      let stops = /* @__PURE__ */ new Set([max8]);
      while (min8 <= stop && stop <= max8) {
        stops.add(stop);
        nines += 1;
        stop = countNines(min8, nines);
      }
      stop = countZeros(max8 + 1, zeros) - 1;
      while (min8 < stop && stop <= max8) {
        stops.add(stop);
        zeros += 1;
        stop = countZeros(max8 + 1, zeros) - 1;
      }
      stops = [...stops];
      stops.sort(compare10);
      return stops;
    }
    function rangeToPattern(start, stop, options) {
      if (start === stop) {
        return { pattern: start, count: [], digits: 0 };
      }
      let zipped = zip2(start, stop);
      let digits = zipped.length;
      let pattern = "";
      let count = 0;
      for (let i = 0; i < digits; i++) {
        let [startDigit, stopDigit] = zipped[i];
        if (startDigit === stopDigit) {
          pattern += startDigit;
        } else if (startDigit !== "0" || stopDigit !== "9") {
          pattern += toCharacterClass(startDigit, stopDigit, options);
        } else {
          count++;
        }
      }
      if (count) {
        pattern += options.shorthand === true ? "\\d" : "[0-9]";
      }
      return { pattern, count: [count], digits };
    }
    function splitToPatterns(min8, max8, tok, options) {
      let ranges = splitToRanges(min8, max8);
      let tokens = [];
      let start = min8;
      let prev;
      for (let i = 0; i < ranges.length; i++) {
        let max9 = ranges[i];
        let obj = rangeToPattern(String(start), String(max9), options);
        let zeros = "";
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
          if (prev.count.length > 1) {
            prev.count.pop();
          }
          prev.count.push(obj.count[0]);
          prev.string = prev.pattern + toQuantifier(prev.count);
          start = max9 + 1;
          continue;
        }
        if (tok.isPadded) {
          zeros = padZeros(max9, tok, options);
        }
        obj.string = zeros + obj.pattern + toQuantifier(obj.count);
        tokens.push(obj);
        start = max9 + 1;
        prev = obj;
      }
      return tokens;
    }
    function filterPatterns(arr, comparison, prefix4, intersection3, options) {
      let result = [];
      for (let ele of arr) {
        let { string: string7 } = ele;
        if (!intersection3 && !contains2(comparison, "string", string7)) {
          result.push(prefix4 + string7);
        }
        if (intersection3 && contains2(comparison, "string", string7)) {
          result.push(prefix4 + string7);
        }
      }
      return result;
    }
    function zip2(a, b) {
      let arr = [];
      for (let i = 0; i < a.length; i++)
        arr.push([a[i], b[i]]);
      return arr;
    }
    function compare10(a, b) {
      return a > b ? 1 : b > a ? -1 : 0;
    }
    function contains2(arr, key, val) {
      return arr.some((ele) => ele[key] === val);
    }
    function countNines(min8, len) {
      return Number(String(min8).slice(0, -len) + "9".repeat(len));
    }
    function countZeros(integer, zeros) {
      return integer - integer % Math.pow(10, zeros);
    }
    function toQuantifier(digits) {
      let [start = 0, stop = ""] = digits;
      if (stop || start > 1) {
        return `{${start + (stop ? "," + stop : "")}}`;
      }
      return "";
    }
    function toCharacterClass(a, b, options) {
      return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
    }
    function hasPadding(str2) {
      return /^-?(0+)\d/.test(str2);
    }
    function padZeros(value4, tok, options) {
      if (!tok.isPadded) {
        return value4;
      }
      let diff2 = Math.abs(tok.maxLen - String(value4).length);
      let relax = options.relaxZeros !== false;
      switch (diff2) {
        case 0:
          return "";
        case 1:
          return relax ? "0?" : "0";
        case 2:
          return relax ? "0{0,2}" : "00";
        default: {
          return relax ? `0{0,${diff2}}` : `0{${diff2}}`;
        }
      }
    }
    toRegexRange.cache = {};
    toRegexRange.clearCache = () => toRegexRange.cache = {};
    module.exports = toRegexRange;
  }
});

// node_modules/fill-range/index.js
var require_fill_range = __commonJS({
  "node_modules/fill-range/index.js"(exports, module) {
    "use strict";
    var util = __require("util");
    var toRegexRange = require_to_regex_range();
    var isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    var transform = (toNumber3) => {
      return (value4) => toNumber3 === true ? Number(value4) : String(value4);
    };
    var isValidValue = (value4) => {
      return typeof value4 === "number" || typeof value4 === "string" && value4 !== "";
    };
    var isNumber = (num) => Number.isInteger(+num);
    var zeros = (input) => {
      let value4 = `${input}`;
      let index4 = -1;
      if (value4[0] === "-")
        value4 = value4.slice(1);
      if (value4 === "0")
        return false;
      while (value4[++index4] === "0")
        ;
      return index4 > 0;
    };
    var stringify3 = (start, end4, options) => {
      if (typeof start === "string" || typeof end4 === "string") {
        return true;
      }
      return options.stringify === true;
    };
    var pad = (input, maxLength, toNumber3) => {
      if (maxLength > 0) {
        let dash = input[0] === "-" ? "-" : "";
        if (dash)
          input = input.slice(1);
        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
      }
      if (toNumber3 === false) {
        return String(input);
      }
      return input;
    };
    var toMaxLen = (input, maxLength) => {
      let negative = input[0] === "-" ? "-" : "";
      if (negative) {
        input = input.slice(1);
        maxLength--;
      }
      while (input.length < maxLength)
        input = "0" + input;
      return negative ? "-" + input : input;
    };
    var toSequence = (parts, options) => {
      parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      let prefix4 = options.capture ? "" : "?:";
      let positives = "";
      let negatives = "";
      let result;
      if (parts.positives.length) {
        positives = parts.positives.join("|");
      }
      if (parts.negatives.length) {
        negatives = `-(${prefix4}${parts.negatives.join("|")})`;
      }
      if (positives && negatives) {
        result = `${positives}|${negatives}`;
      } else {
        result = positives || negatives;
      }
      if (options.wrap) {
        return `(${prefix4}${result})`;
      }
      return result;
    };
    var toRange = (a, b, isNumbers, options) => {
      if (isNumbers) {
        return toRegexRange(a, b, { wrap: false, ...options });
      }
      let start = String.fromCharCode(a);
      if (a === b)
        return start;
      let stop = String.fromCharCode(b);
      return `[${start}-${stop}]`;
    };
    var toRegex = (start, end4, options) => {
      if (Array.isArray(start)) {
        let wrap5 = options.wrap === true;
        let prefix4 = options.capture ? "" : "?:";
        return wrap5 ? `(${prefix4}${start.join("|")})` : start.join("|");
      }
      return toRegexRange(start, end4, options);
    };
    var rangeError = (...args) => {
      return new RangeError("Invalid range arguments: " + util.inspect(...args));
    };
    var invalidRange = (start, end4, options) => {
      if (options.strictRanges === true)
        throw rangeError([start, end4]);
      return [];
    };
    var invalidStep = (step3, options) => {
      if (options.strictRanges === true) {
        throw new TypeError(`Expected step "${step3}" to be a number`);
      }
      return [];
    };
    var fillNumbers = (start, end4, step3 = 1, options = {}) => {
      let a = Number(start);
      let b = Number(end4);
      if (!Number.isInteger(a) || !Number.isInteger(b)) {
        if (options.strictRanges === true)
          throw rangeError([start, end4]);
        return [];
      }
      if (a === 0)
        a = 0;
      if (b === 0)
        b = 0;
      let descending = a > b;
      let startString = String(start);
      let endString = String(end4);
      let stepString = String(step3);
      step3 = Math.max(Math.abs(step3), 1);
      let padded = zeros(startString) || zeros(endString) || zeros(stepString);
      let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
      let toNumber3 = padded === false && stringify3(start, end4, options) === false;
      let format2 = options.transform || transform(toNumber3);
      if (options.toRegex && step3 === 1) {
        return toRange(toMaxLen(start, maxLen), toMaxLen(end4, maxLen), true, options);
      }
      let parts = { negatives: [], positives: [] };
      let push2 = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
      let range3 = [];
      let index4 = 0;
      while (descending ? a >= b : a <= b) {
        if (options.toRegex === true && step3 > 1) {
          push2(a);
        } else {
          range3.push(pad(format2(a, index4), maxLen, toNumber3));
        }
        a = descending ? a - step3 : a + step3;
        index4++;
      }
      if (options.toRegex === true) {
        return step3 > 1 ? toSequence(parts, options) : toRegex(range3, null, { wrap: false, ...options });
      }
      return range3;
    };
    var fillLetters = (start, end4, step3 = 1, options = {}) => {
      if (!isNumber(start) && start.length > 1 || !isNumber(end4) && end4.length > 1) {
        return invalidRange(start, end4, options);
      }
      let format2 = options.transform || ((val) => String.fromCharCode(val));
      let a = `${start}`.charCodeAt(0);
      let b = `${end4}`.charCodeAt(0);
      let descending = a > b;
      let min8 = Math.min(a, b);
      let max8 = Math.max(a, b);
      if (options.toRegex && step3 === 1) {
        return toRange(min8, max8, false, options);
      }
      let range3 = [];
      let index4 = 0;
      while (descending ? a >= b : a <= b) {
        range3.push(format2(a, index4));
        a = descending ? a - step3 : a + step3;
        index4++;
      }
      if (options.toRegex === true) {
        return toRegex(range3, null, { wrap: false, options });
      }
      return range3;
    };
    var fill4 = (start, end4, step3, options = {}) => {
      if (end4 == null && isValidValue(start)) {
        return [start];
      }
      if (!isValidValue(start) || !isValidValue(end4)) {
        return invalidRange(start, end4, options);
      }
      if (typeof step3 === "function") {
        return fill4(start, end4, 1, { transform: step3 });
      }
      if (isObject(step3)) {
        return fill4(start, end4, 0, step3);
      }
      let opts = { ...options };
      if (opts.capture === true)
        opts.wrap = true;
      step3 = step3 || opts.step || 1;
      if (!isNumber(step3)) {
        if (step3 != null && !isObject(step3))
          return invalidStep(step3, opts);
        return fill4(start, end4, 1, step3);
      }
      if (isNumber(start) && isNumber(end4)) {
        return fillNumbers(start, end4, step3, opts);
      }
      return fillLetters(start, end4, Math.max(Math.abs(step3), 1), opts);
    };
    module.exports = fill4;
  }
});

// node_modules/braces/lib/compile.js
var require_compile = __commonJS({
  "node_modules/braces/lib/compile.js"(exports, module) {
    "use strict";
    var fill4 = require_fill_range();
    var utils = require_utils3();
    var compile2 = (ast, options = {}) => {
      let walk = (node, parent = {}) => {
        let invalidBlock = utils.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options.escapeInvalid === true;
        let invalid = invalidBlock === true || invalidNode === true;
        let prefix4 = options.escapeInvalid === true ? "\\" : "";
        let output5 = "";
        if (node.isOpen === true) {
          return prefix4 + node.value;
        }
        if (node.isClose === true) {
          return prefix4 + node.value;
        }
        if (node.type === "open") {
          return invalid ? prefix4 + node.value : "(";
        }
        if (node.type === "close") {
          return invalid ? prefix4 + node.value : ")";
        }
        if (node.type === "comma") {
          return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          let range3 = fill4(...args, { ...options, wrap: false, toRegex: true });
          if (range3.length !== 0) {
            return args.length > 1 && range3.length > 1 ? `(${range3})` : range3;
          }
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output5 += walk(child, node);
          }
        }
        return output5;
      };
      return walk(ast);
    };
    module.exports = compile2;
  }
});

// node_modules/braces/lib/expand.js
var require_expand = __commonJS({
  "node_modules/braces/lib/expand.js"(exports, module) {
    "use strict";
    var fill4 = require_fill_range();
    var stringify3 = require_stringify2();
    var utils = require_utils3();
    var append40 = (queue = "", stash = "", enclose2 = false) => {
      let result = [];
      queue = [].concat(queue);
      stash = [].concat(stash);
      if (!stash.length)
        return queue;
      if (!queue.length) {
        return enclose2 ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
      }
      for (let item of queue) {
        if (Array.isArray(item)) {
          for (let value4 of item) {
            result.push(append40(value4, stash, enclose2));
          }
        } else {
          for (let ele of stash) {
            if (enclose2 === true && typeof ele === "string")
              ele = `{${ele}}`;
            result.push(Array.isArray(ele) ? append40(item, ele, enclose2) : item + ele);
          }
        }
      }
      return utils.flatten(result);
    };
    var expand = (ast, options = {}) => {
      let rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit;
      let walk = (node, parent = {}) => {
        node.queue = [];
        let p = parent;
        let q = parent.queue;
        while (p.type !== "brace" && p.type !== "root" && p.parent) {
          p = p.parent;
          q = p.queue;
        }
        if (node.invalid || node.dollar) {
          q.push(append40(q.pop(), stringify3(node, options)));
          return;
        }
        if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
          q.push(append40(q.pop(), ["{}"]));
          return;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
          }
          let range3 = fill4(...args, options);
          if (range3.length === 0) {
            range3 = stringify3(node, options);
          }
          q.push(append40(q.pop(), range3));
          node.nodes = [];
          return;
        }
        let enclose2 = utils.encloseBrace(node);
        let queue = node.queue;
        let block = node;
        while (block.type !== "brace" && block.type !== "root" && block.parent) {
          block = block.parent;
          queue = block.queue;
        }
        for (let i = 0; i < node.nodes.length; i++) {
          let child = node.nodes[i];
          if (child.type === "comma" && node.type === "brace") {
            if (i === 1)
              queue.push("");
            queue.push("");
            continue;
          }
          if (child.type === "close") {
            q.push(append40(q.pop(), queue, enclose2));
            continue;
          }
          if (child.value && child.type !== "open") {
            queue.push(append40(queue.pop(), child.value));
            continue;
          }
          if (child.nodes) {
            walk(child, node);
          }
        }
        return queue;
      };
      return utils.flatten(walk(ast));
    };
    module.exports = expand;
  }
});

// node_modules/braces/lib/constants.js
var require_constants = __commonJS({
  "node_modules/braces/lib/constants.js"(exports, module) {
    "use strict";
    module.exports = {
      MAX_LENGTH: 1024 * 64,
      // Digits
      CHAR_0: "0",
      /* 0 */
      CHAR_9: "9",
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: "A",
      /* A */
      CHAR_LOWERCASE_A: "a",
      /* a */
      CHAR_UPPERCASE_Z: "Z",
      /* Z */
      CHAR_LOWERCASE_Z: "z",
      /* z */
      CHAR_LEFT_PARENTHESES: "(",
      /* ( */
      CHAR_RIGHT_PARENTHESES: ")",
      /* ) */
      CHAR_ASTERISK: "*",
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: "&",
      /* & */
      CHAR_AT: "@",
      /* @ */
      CHAR_BACKSLASH: "\\",
      /* \ */
      CHAR_BACKTICK: "`",
      /* ` */
      CHAR_CARRIAGE_RETURN: "\r",
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: "^",
      /* ^ */
      CHAR_COLON: ":",
      /* : */
      CHAR_COMMA: ",",
      /* , */
      CHAR_DOLLAR: "$",
      /* . */
      CHAR_DOT: ".",
      /* . */
      CHAR_DOUBLE_QUOTE: '"',
      /* " */
      CHAR_EQUAL: "=",
      /* = */
      CHAR_EXCLAMATION_MARK: "!",
      /* ! */
      CHAR_FORM_FEED: "\f",
      /* \f */
      CHAR_FORWARD_SLASH: "/",
      /* / */
      CHAR_HASH: "#",
      /* # */
      CHAR_HYPHEN_MINUS: "-",
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: "<",
      /* < */
      CHAR_LEFT_CURLY_BRACE: "{",
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: "[",
      /* [ */
      CHAR_LINE_FEED: "\n",
      /* \n */
      CHAR_NO_BREAK_SPACE: "\xA0",
      /* \u00A0 */
      CHAR_PERCENT: "%",
      /* % */
      CHAR_PLUS: "+",
      /* + */
      CHAR_QUESTION_MARK: "?",
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: ">",
      /* > */
      CHAR_RIGHT_CURLY_BRACE: "}",
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: "]",
      /* ] */
      CHAR_SEMICOLON: ";",
      /* ; */
      CHAR_SINGLE_QUOTE: "'",
      /* ' */
      CHAR_SPACE: " ",
      /*   */
      CHAR_TAB: "	",
      /* \t */
      CHAR_UNDERSCORE: "_",
      /* _ */
      CHAR_VERTICAL_LINE: "|",
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
      /* \uFEFF */
    };
  }
});

// node_modules/braces/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/braces/lib/parse.js"(exports, module) {
    "use strict";
    var stringify3 = require_stringify2();
    var {
      MAX_LENGTH,
      CHAR_BACKSLASH,
      /* \ */
      CHAR_BACKTICK,
      /* ` */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_RIGHT_SQUARE_BRACKET,
      /* ] */
      CHAR_DOUBLE_QUOTE,
      /* " */
      CHAR_SINGLE_QUOTE,
      /* ' */
      CHAR_NO_BREAK_SPACE,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE
    } = require_constants();
    var parse10 = (input, options = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      let opts = options || {};
      let max8 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      if (input.length > max8) {
        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max8})`);
      }
      let ast = { type: "root", input, nodes: [] };
      let stack = [ast];
      let block = ast;
      let prev = ast;
      let brackets2 = 0;
      let length7 = input.length;
      let index4 = 0;
      let depth = 0;
      let value4;
      let memo = {};
      const advance = () => input[index4++];
      const push2 = (node) => {
        if (node.type === "text" && prev.type === "dot") {
          prev.type = "text";
        }
        if (prev && prev.type === "text" && node.type === "text") {
          prev.value += node.value;
          return;
        }
        block.nodes.push(node);
        node.parent = block;
        node.prev = prev;
        prev = node;
        return node;
      };
      push2({ type: "bos" });
      while (index4 < length7) {
        block = stack[stack.length - 1];
        value4 = advance();
        if (value4 === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value4 === CHAR_NO_BREAK_SPACE) {
          continue;
        }
        if (value4 === CHAR_BACKSLASH) {
          push2({ type: "text", value: (options.keepEscaping ? value4 : "") + advance() });
          continue;
        }
        if (value4 === CHAR_RIGHT_SQUARE_BRACKET) {
          push2({ type: "text", value: "\\" + value4 });
          continue;
        }
        if (value4 === CHAR_LEFT_SQUARE_BRACKET) {
          brackets2++;
          let closed = true;
          let next2;
          while (index4 < length7 && (next2 = advance())) {
            value4 += next2;
            if (next2 === CHAR_LEFT_SQUARE_BRACKET) {
              brackets2++;
              continue;
            }
            if (next2 === CHAR_BACKSLASH) {
              value4 += advance();
              continue;
            }
            if (next2 === CHAR_RIGHT_SQUARE_BRACKET) {
              brackets2--;
              if (brackets2 === 0) {
                break;
              }
            }
          }
          push2({ type: "text", value: value4 });
          continue;
        }
        if (value4 === CHAR_LEFT_PARENTHESES) {
          block = push2({ type: "paren", nodes: [] });
          stack.push(block);
          push2({ type: "text", value: value4 });
          continue;
        }
        if (value4 === CHAR_RIGHT_PARENTHESES) {
          if (block.type !== "paren") {
            push2({ type: "text", value: value4 });
            continue;
          }
          block = stack.pop();
          push2({ type: "text", value: value4 });
          block = stack[stack.length - 1];
          continue;
        }
        if (value4 === CHAR_DOUBLE_QUOTE || value4 === CHAR_SINGLE_QUOTE || value4 === CHAR_BACKTICK) {
          let open2 = value4;
          let next2;
          if (options.keepQuotes !== true) {
            value4 = "";
          }
          while (index4 < length7 && (next2 = advance())) {
            if (next2 === CHAR_BACKSLASH) {
              value4 += next2 + advance();
              continue;
            }
            if (next2 === open2) {
              if (options.keepQuotes === true)
                value4 += next2;
              break;
            }
            value4 += next2;
          }
          push2({ type: "text", value: value4 });
          continue;
        }
        if (value4 === CHAR_LEFT_CURLY_BRACE) {
          depth++;
          let dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
          let brace = {
            type: "brace",
            open: true,
            close: false,
            dollar,
            depth,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          block = push2(brace);
          stack.push(block);
          push2({ type: "open", value: value4 });
          continue;
        }
        if (value4 === CHAR_RIGHT_CURLY_BRACE) {
          if (block.type !== "brace") {
            push2({ type: "text", value: value4 });
            continue;
          }
          let type = "close";
          block = stack.pop();
          block.close = true;
          push2({ type, value: value4 });
          depth--;
          block = stack[stack.length - 1];
          continue;
        }
        if (value4 === CHAR_COMMA && depth > 0) {
          if (block.ranges > 0) {
            block.ranges = 0;
            let open2 = block.nodes.shift();
            block.nodes = [open2, { type: "text", value: stringify3(block) }];
          }
          push2({ type: "comma", value: value4 });
          block.commas++;
          continue;
        }
        if (value4 === CHAR_DOT && depth > 0 && block.commas === 0) {
          let siblings = block.nodes;
          if (depth === 0 || siblings.length === 0) {
            push2({ type: "text", value: value4 });
            continue;
          }
          if (prev.type === "dot") {
            block.range = [];
            prev.value += value4;
            prev.type = "range";
            if (block.nodes.length !== 3 && block.nodes.length !== 5) {
              block.invalid = true;
              block.ranges = 0;
              prev.type = "text";
              continue;
            }
            block.ranges++;
            block.args = [];
            continue;
          }
          if (prev.type === "range") {
            siblings.pop();
            let before = siblings[siblings.length - 1];
            before.value += prev.value + value4;
            prev = before;
            block.ranges--;
            continue;
          }
          push2({ type: "dot", value: value4 });
          continue;
        }
        push2({ type: "text", value: value4 });
      }
      do {
        block = stack.pop();
        if (block.type !== "root") {
          block.nodes.forEach((node) => {
            if (!node.nodes) {
              if (node.type === "open")
                node.isOpen = true;
              if (node.type === "close")
                node.isClose = true;
              if (!node.nodes)
                node.type = "text";
              node.invalid = true;
            }
          });
          let parent = stack[stack.length - 1];
          let index5 = parent.nodes.indexOf(block);
          parent.nodes.splice(index5, 1, ...block.nodes);
        }
      } while (stack.length > 0);
      push2({ type: "eos" });
      return ast;
    };
    module.exports = parse10;
  }
});

// node_modules/braces/index.js
var require_braces = __commonJS({
  "node_modules/braces/index.js"(exports, module) {
    "use strict";
    var stringify3 = require_stringify2();
    var compile2 = require_compile();
    var expand = require_expand();
    var parse10 = require_parse2();
    var braces2 = (input, options = {}) => {
      let output5 = [];
      if (Array.isArray(input)) {
        for (let pattern of input) {
          let result = braces2.create(pattern, options);
          if (Array.isArray(result)) {
            output5.push(...result);
          } else {
            output5.push(result);
          }
        }
      } else {
        output5 = [].concat(braces2.create(input, options));
      }
      if (options && options.expand === true && options.nodupes === true) {
        output5 = [...new Set(output5)];
      }
      return output5;
    };
    braces2.parse = (input, options = {}) => parse10(input, options);
    braces2.stringify = (input, options = {}) => {
      if (typeof input === "string") {
        return stringify3(braces2.parse(input, options), options);
      }
      return stringify3(input, options);
    };
    braces2.compile = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces2.parse(input, options);
      }
      return compile2(input, options);
    };
    braces2.expand = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces2.parse(input, options);
      }
      let result = expand(input, options);
      if (options.noempty === true) {
        result = result.filter(Boolean);
      }
      if (options.nodupes === true) {
        result = [...new Set(result)];
      }
      return result;
    };
    braces2.create = (input, options = {}) => {
      if (input === "" || input.length < 3) {
        return [input];
      }
      return options.expand !== true ? braces2.compile(input, options) : braces2.expand(input, options);
    };
    module.exports = braces2;
  }
});

// node_modules/picomatch/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/picomatch/lib/constants.js"(exports, module) {
    "use strict";
    var path5 = __require("path");
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    };
    var WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    };
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      // regular expressions
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      // Replace globs with equivalent patterns to reduce parsing time.
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      // Digits
      CHAR_0: 48,
      /* 0 */
      CHAR_9: 57,
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: 65,
      /* A */
      CHAR_LOWERCASE_A: 97,
      /* a */
      CHAR_UPPERCASE_Z: 90,
      /* Z */
      CHAR_LOWERCASE_Z: 122,
      /* z */
      CHAR_LEFT_PARENTHESES: 40,
      /* ( */
      CHAR_RIGHT_PARENTHESES: 41,
      /* ) */
      CHAR_ASTERISK: 42,
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: 38,
      /* & */
      CHAR_AT: 64,
      /* @ */
      CHAR_BACKWARD_SLASH: 92,
      /* \ */
      CHAR_CARRIAGE_RETURN: 13,
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: 94,
      /* ^ */
      CHAR_COLON: 58,
      /* : */
      CHAR_COMMA: 44,
      /* , */
      CHAR_DOT: 46,
      /* . */
      CHAR_DOUBLE_QUOTE: 34,
      /* " */
      CHAR_EQUAL: 61,
      /* = */
      CHAR_EXCLAMATION_MARK: 33,
      /* ! */
      CHAR_FORM_FEED: 12,
      /* \f */
      CHAR_FORWARD_SLASH: 47,
      /* / */
      CHAR_GRAVE_ACCENT: 96,
      /* ` */
      CHAR_HASH: 35,
      /* # */
      CHAR_HYPHEN_MINUS: 45,
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: 60,
      /* < */
      CHAR_LEFT_CURLY_BRACE: 123,
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: 91,
      /* [ */
      CHAR_LINE_FEED: 10,
      /* \n */
      CHAR_NO_BREAK_SPACE: 160,
      /* \u00A0 */
      CHAR_PERCENT: 37,
      /* % */
      CHAR_PLUS: 43,
      /* + */
      CHAR_QUESTION_MARK: 63,
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      /* > */
      CHAR_RIGHT_CURLY_BRACE: 125,
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      /* ] */
      CHAR_SEMICOLON: 59,
      /* ; */
      CHAR_SINGLE_QUOTE: 39,
      /* ' */
      CHAR_SPACE: 32,
      /*   */
      CHAR_TAB: 9,
      /* \t */
      CHAR_UNDERSCORE: 95,
      /* _ */
      CHAR_VERTICAL_LINE: 124,
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      /* \uFEFF */
      SEP: path5.sep,
      /**
       * Create EXTGLOB_CHARS
       */
      extglobChars(chars2) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars2.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      /**
       * Create GLOB_CHARS
       */
      globChars(win32) {
        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});

// node_modules/picomatch/lib/utils.js
var require_utils4 = __commonJS({
  "node_modules/picomatch/lib/utils.js"(exports) {
    "use strict";
    var path5 = __require("path");
    var win32 = process.platform === "win32";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants2();
    exports.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports.hasRegexChars = (str2) => REGEX_SPECIAL_CHARS.test(str2);
    exports.isRegexChar = (str2) => str2.length === 1 && exports.hasRegexChars(str2);
    exports.escapeRegex = (str2) => str2.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports.toPosixSlashes = (str2) => str2.replace(REGEX_BACKSLASH, "/");
    exports.removeBackslashes = (str2) => {
      return str2.replace(REGEX_REMOVE_BACKSLASH, (match4) => {
        return match4 === "\\" ? "" : match4;
      });
    };
    exports.supportsLookbehinds = () => {
      const segs = process.version.slice(1).split(".").map(Number);
      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
        return true;
      }
      return false;
    };
    exports.isWindows = (options) => {
      if (options && typeof options.windows === "boolean") {
        return options.windows;
      }
      return win32 === true || path5.sep === "\\";
    };
    exports.escapeLast = (input, char2, lastIdx) => {
      const idx = input.lastIndexOf(char2, lastIdx);
      if (idx === -1)
        return input;
      if (input[idx - 1] === "\\")
        return exports.escapeLast(input, char2, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports.removePrefix = (input, state2 = {}) => {
      let output5 = input;
      if (output5.startsWith("./")) {
        output5 = output5.slice(2);
        state2.prefix = "./";
      }
      return output5;
    };
    exports.wrapOutput = (input, state2 = {}, options = {}) => {
      const prepend = options.contains ? "" : "^";
      const append40 = options.contains ? "" : "$";
      let output5 = `${prepend}(?:${input})${append40}`;
      if (state2.negated === true) {
        output5 = `(?:^(?!${output5}).*$)`;
      }
      return output5;
    };
  }
});

// node_modules/picomatch/lib/scan.js
var require_scan2 = __commonJS({
  "node_modules/picomatch/lib/scan.js"(exports, module) {
    "use strict";
    var utils = require_utils4();
    var {
      CHAR_ASTERISK,
      /* * */
      CHAR_AT,
      /* @ */
      CHAR_BACKWARD_SLASH,
      /* \ */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_EXCLAMATION_MARK,
      /* ! */
      CHAR_FORWARD_SLASH,
      /* / */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_PLUS,
      /* + */
      CHAR_QUESTION_MARK,
      /* ? */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_RIGHT_SQUARE_BRACKET
      /* ] */
    } = require_constants2();
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token2) => {
      if (token2.isPrefix !== true) {
        token2.depth = token2.isGlobstar ? Infinity : 1;
      }
    };
    var scan = (input, options) => {
      const opts = options || {};
      const length7 = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str2 = input;
      let index4 = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces2 = 0;
      let prev;
      let code;
      let token2 = { value: "", depth: 0, isGlob: false };
      const eos = () => index4 >= length7;
      const peek2 = () => str2.charCodeAt(index4 + 1);
      const advance = () => {
        prev = code;
        return str2.charCodeAt(++index4);
      };
      while (index4 < length7) {
        code = advance();
        let next2;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token2.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces2++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token2.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces2++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              isBrace = token2.isBrace = true;
              isGlob = token2.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token2.isBrace = true;
              isGlob = token2.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces2--;
              if (braces2 === 0) {
                braceEscaped = false;
                isBrace = token2.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index4);
          tokens.push(token2);
          token2 = { value: "", depth: 0, isGlob: false };
          if (finished === true)
            continue;
          if (prev === CHAR_DOT && index4 === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index4 + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek2() === CHAR_LEFT_PARENTHESES) {
            isGlob = token2.isGlob = true;
            isExtglob = token2.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index4 === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token2.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token2.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK)
            isGlobstar = token2.isGlobstar = true;
          isGlob = token2.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob = token2.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next2 = advance())) {
            if (next2 === CHAR_BACKWARD_SLASH) {
              backslashes = token2.backslashes = true;
              advance();
              continue;
            }
            if (next2 === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token2.isBracket = true;
              isGlob = token2.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index4 === start) {
          negated = token2.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob = token2.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token2.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base = str2;
      let prefix4 = "";
      let glob = "";
      if (start > 0) {
        prefix4 = str2.slice(0, start);
        str2 = str2.slice(start);
        lastIndex -= start;
      }
      if (base && isGlob === true && lastIndex > 0) {
        base = str2.slice(0, lastIndex);
        glob = str2.slice(lastIndex);
      } else if (isGlob === true) {
        base = "";
        glob = str2;
      } else {
        base = str2;
      }
      if (base && base !== "" && base !== "/" && base !== str2) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob)
          glob = utils.removeBackslashes(glob);
        if (base && backslashes === true) {
          base = utils.removeBackslashes(base);
        }
      }
      const state2 = {
        prefix: prefix4,
        input,
        start,
        base,
        glob,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state2.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token2);
        }
        state2.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n = prevIndex ? prevIndex + 1 : start;
          const i = slashes[idx];
          const value4 = input.slice(n, i);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix4;
            } else {
              tokens[idx].value = value4;
            }
            depth(tokens[idx]);
            state2.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value4 !== "") {
            parts.push(value4);
          }
          prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value4 = input.slice(prevIndex + 1);
          parts.push(value4);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value4;
            depth(tokens[tokens.length - 1]);
            state2.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state2.slashes = slashes;
        state2.parts = parts;
      }
      return state2;
    };
    module.exports = scan;
  }
});

// node_modules/picomatch/lib/parse.js
var require_parse3 = __commonJS({
  "node_modules/picomatch/lib/parse.js"(exports, module) {
    "use strict";
    var constants4 = require_constants2();
    var utils = require_utils4();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants4;
    var expandRange = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value4 = `[${args.join("-")}]`;
      try {
        new RegExp(value4);
      } catch (ex) {
        return args.map((v) => utils.escapeRegex(v)).join("..");
      }
      return value4;
    };
    var syntaxError = (type, char2) => {
      return `Missing ${type}: "${char2}" - use "\\\\${char2}" to match literal characters`;
    };
    var parse10 = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = { ...options };
      const max8 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max8) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max8}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win32 = utils.isWindows(options);
      const PLATFORM_CHARS = constants4.globChars(win32);
      const EXTGLOB_CHARS = constants4.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state2 = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils.removePrefix(input, state2);
      len = input.length;
      const extglobs = [];
      const braces2 = [];
      const stack = [];
      let prev = bos;
      let value4;
      const eos = () => state2.index === len - 1;
      const peek2 = state2.peek = (n = 1) => input[state2.index + n];
      const advance = state2.advance = () => input[++state2.index] || "";
      const remaining = () => input.slice(state2.index + 1);
      const consume = (value5 = "", num = 0) => {
        state2.consumed += value5;
        state2.index += num;
      };
      const append40 = (token2) => {
        state2.output += token2.output != null ? token2.output : token2.value;
        consume(token2.value);
      };
      const negate3 = () => {
        let count = 1;
        while (peek2() === "!" && (peek2(2) !== "(" || peek2(3) === "?")) {
          advance();
          state2.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state2.negated = true;
        state2.start++;
        return true;
      };
      const increment = (type) => {
        state2[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state2[type]--;
        stack.pop();
      };
      const push2 = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state2.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state2.output = state2.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star;
            state2.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output)
          append40(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value5) => {
        const token2 = { ...EXTGLOB_CHARS[value5], conditions: 1, inner: "" };
        token2.prev = prev;
        token2.parens = state2.parens;
        token2.output = state2.output;
        const output5 = (opts.capture ? "(" : "") + token2.open;
        increment("parens");
        push2({ type, value: value5, output: state2.output ? "" : ONE_CHAR });
        push2({ type: "paren", extglob: true, value: advance(), output: output5 });
        extglobs.push(token2);
      };
      const extglobClose = (token2) => {
        let output5 = token2.close + (opts.capture ? ")" : "");
        let rest2;
        if (token2.type === "negate") {
          let extglobStar = star;
          if (token2.inner && token2.inner.length > 1 && token2.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
            output5 = token2.close = `)$))${extglobStar}`;
          }
          if (token2.inner.includes("*") && (rest2 = remaining()) && /^\.[^\\/.]+$/.test(rest2)) {
            const expression = parse10(rest2, { ...options, fastpaths: false }).output;
            output5 = token2.close = `)${expression})${extglobStar})`;
          }
          if (token2.prev.type === "bos") {
            state2.negatedExtglob = true;
          }
        }
        push2({ type: "paren", extglob: true, value: value4, output: output5 });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output5 = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars2, first2, rest2, index4) => {
          if (first2 === "\\") {
            backslashes = true;
            return m;
          }
          if (first2 === "?") {
            if (esc) {
              return esc + first2 + (rest2 ? QMARK.repeat(rest2.length) : "");
            }
            if (index4 === 0) {
              return qmarkNoDot + (rest2 ? QMARK.repeat(rest2.length) : "");
            }
            return QMARK.repeat(chars2.length);
          }
          if (first2 === ".") {
            return DOT_LITERAL.repeat(chars2.length);
          }
          if (first2 === "*") {
            if (esc) {
              return esc + first2 + (rest2 ? star : "");
            }
            return star;
          }
          return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output5 = output5.replace(/\\/g, "");
          } else {
            output5 = output5.replace(/\\+/g, (m) => {
              return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
            });
          }
        }
        if (output5 === input && opts.contains === true) {
          state2.output = input;
          return state2;
        }
        state2.output = utils.wrapOutput(output5, state2, options);
        return state2;
      }
      while (!eos()) {
        value4 = advance();
        if (value4 === "\0") {
          continue;
        }
        if (value4 === "\\") {
          const next2 = peek2();
          if (next2 === "/" && opts.bash !== true) {
            continue;
          }
          if (next2 === "." || next2 === ";") {
            continue;
          }
          if (!next2) {
            value4 += "\\";
            push2({ type: "text", value: value4 });
            continue;
          }
          const match4 = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match4 && match4[0].length > 2) {
            slashes = match4[0].length;
            state2.index += slashes;
            if (slashes % 2 !== 0) {
              value4 += "\\";
            }
          }
          if (opts.unescape === true) {
            value4 = advance();
          } else {
            value4 += advance();
          }
          if (state2.brackets === 0) {
            push2({ type: "text", value: value4 });
            continue;
          }
        }
        if (state2.brackets > 0 && (value4 !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value4 === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest3 = prev.value.slice(idx + 2);
                const posix = POSIX_REGEX_SOURCE[rest3];
                if (posix) {
                  prev.value = pre + posix;
                  state2.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value4 === "[" && peek2() !== ":" || value4 === "-" && peek2() === "]") {
            value4 = `\\${value4}`;
          }
          if (value4 === "]" && (prev.value === "[" || prev.value === "[^")) {
            value4 = `\\${value4}`;
          }
          if (opts.posix === true && value4 === "!" && prev.value === "[") {
            value4 = "^";
          }
          prev.value += value4;
          append40({ value: value4 });
          continue;
        }
        if (state2.quotes === 1 && value4 !== '"') {
          value4 = utils.escapeRegex(value4);
          prev.value += value4;
          append40({ value: value4 });
          continue;
        }
        if (value4 === '"') {
          state2.quotes = state2.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push2({ type: "text", value: value4 });
          }
          continue;
        }
        if (value4 === "(") {
          increment("parens");
          push2({ type: "paren", value: value4 });
          continue;
        }
        if (value4 === ")") {
          if (state2.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state2.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push2({ type: "paren", value: value4, output: state2.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value4 === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value4 = `\\${value4}`;
          } else {
            increment("brackets");
          }
          push2({ type: "bracket", value: value4 });
          continue;
        }
        if (value4 === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push2({ type: "text", value: value4, output: `\\${value4}` });
            continue;
          }
          if (state2.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push2({ type: "text", value: value4, output: `\\${value4}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value4 = `/${value4}`;
          }
          prev.value += value4;
          append40({ value: value4 });
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state2.output = state2.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state2.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state2.output += prev.value;
          continue;
        }
        if (value4 === "{" && opts.nobrace !== true) {
          increment("braces");
          const open2 = {
            type: "brace",
            value: value4,
            output: "(",
            outputIndex: state2.output.length,
            tokensIndex: state2.tokens.length
          };
          braces2.push(open2);
          push2(open2);
          continue;
        }
        if (value4 === "}") {
          const brace = braces2[braces2.length - 1];
          if (opts.nobrace === true || !brace) {
            push2({ type: "text", value: value4, output: value4 });
            continue;
          }
          let output5 = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range3 = [];
            for (let i = arr.length - 1; i >= 0; i--) {
              tokens.pop();
              if (arr[i].type === "brace") {
                break;
              }
              if (arr[i].type !== "dots") {
                range3.unshift(arr[i].value);
              }
            }
            output5 = expandRange(range3, opts);
            state2.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state2.output.slice(0, brace.outputIndex);
            const toks = state2.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value4 = output5 = "\\}";
            state2.output = out;
            for (const t of toks) {
              state2.output += t.output || t.value;
            }
          }
          push2({ type: "brace", value: value4, output: output5 });
          decrement("braces");
          braces2.pop();
          continue;
        }
        if (value4 === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push2({ type: "text", value: value4 });
          continue;
        }
        if (value4 === ",") {
          let output5 = value4;
          const brace = braces2[braces2.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output5 = "|";
          }
          push2({ type: "comma", value: value4, output: output5 });
          continue;
        }
        if (value4 === "/") {
          if (prev.type === "dot" && state2.index === state2.start + 1) {
            state2.start = state2.index + 1;
            state2.consumed = "";
            state2.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push2({ type: "slash", value: value4, output: SLASH_LITERAL });
          continue;
        }
        if (value4 === ".") {
          if (state2.braces > 0 && prev.type === "dot") {
            if (prev.value === ".")
              prev.output = DOT_LITERAL;
            const brace = braces2[braces2.length - 1];
            prev.type = "dots";
            prev.output += value4;
            prev.value += value4;
            brace.dots = true;
            continue;
          }
          if (state2.braces + state2.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push2({ type: "text", value: value4, output: DOT_LITERAL });
            continue;
          }
          push2({ type: "dot", value: value4, output: DOT_LITERAL });
          continue;
        }
        if (value4 === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek2() === "(" && peek2(2) !== "?") {
            extglobOpen("qmark", value4);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next2 = peek2();
            let output5 = value4;
            if (next2 === "<" && !utils.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next2) || next2 === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output5 = `\\${value4}`;
            }
            push2({ type: "text", value: value4, output: output5 });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push2({ type: "qmark", value: value4, output: QMARK_NO_DOT });
            continue;
          }
          push2({ type: "qmark", value: value4, output: QMARK });
          continue;
        }
        if (value4 === "!") {
          if (opts.noextglob !== true && peek2() === "(") {
            if (peek2(2) !== "?" || !/[!=<:]/.test(peek2(3))) {
              extglobOpen("negate", value4);
              continue;
            }
          }
          if (opts.nonegate !== true && state2.index === 0) {
            negate3();
            continue;
          }
        }
        if (value4 === "+") {
          if (opts.noextglob !== true && peek2() === "(" && peek2(2) !== "?") {
            extglobOpen("plus", value4);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push2({ type: "plus", value: value4, output: PLUS_LITERAL });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state2.parens > 0) {
            push2({ type: "plus", value: value4 });
            continue;
          }
          push2({ type: "plus", value: PLUS_LITERAL });
          continue;
        }
        if (value4 === "@") {
          if (opts.noextglob !== true && peek2() === "(" && peek2(2) !== "?") {
            push2({ type: "at", extglob: true, value: value4, output: "" });
            continue;
          }
          push2({ type: "text", value: value4 });
          continue;
        }
        if (value4 !== "*") {
          if (value4 === "$" || value4 === "^") {
            value4 = `\\${value4}`;
          }
          const match4 = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match4) {
            value4 += match4[0];
            state2.index += match4[0].length;
          }
          push2({ type: "text", value: value4 });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value4;
          prev.output = star;
          state2.backtrack = true;
          state2.globstar = true;
          consume(value4);
          continue;
        }
        let rest2 = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest2)) {
          extglobOpen("star", value4);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value4);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest2[0] && rest2[0] !== "/")) {
            push2({ type: "star", value: value4, output: "" });
            continue;
          }
          const isBrace = state2.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push2({ type: "star", value: value4, output: "" });
            continue;
          }
          while (rest2.slice(0, 3) === "/**") {
            const after = input[state2.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest2 = rest2.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value4;
            prev.output = globstar(opts);
            state2.output = prev.output;
            state2.globstar = true;
            consume(value4);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state2.output = state2.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value4;
            state2.globstar = true;
            state2.output += prior.output + prev.output;
            consume(value4);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest2[0] === "/") {
            const end4 = rest2[1] !== void 0 ? "|$" : "";
            state2.output = state2.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end4})`;
            prev.value += value4;
            state2.output += prior.output + prev.output;
            state2.globstar = true;
            consume(value4 + advance());
            push2({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest2[0] === "/") {
            prev.type = "globstar";
            prev.value += value4;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state2.output = prev.output;
            state2.globstar = true;
            consume(value4 + advance());
            push2({ type: "slash", value: "/", output: "" });
            continue;
          }
          state2.output = state2.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value4;
          state2.output += prev.output;
          state2.globstar = true;
          consume(value4);
          continue;
        }
        const token2 = { type: "star", value: value4, output: star };
        if (opts.bash === true) {
          token2.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token2.output = nodot + token2.output;
          }
          push2(token2);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token2.output = value4;
          push2(token2);
          continue;
        }
        if (state2.index === state2.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state2.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state2.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state2.output += nodot;
            prev.output += nodot;
          }
          if (peek2() !== "*") {
            state2.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push2(token2);
      }
      while (state2.brackets > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "]"));
        state2.output = utils.escapeLast(state2.output, "[");
        decrement("brackets");
      }
      while (state2.parens > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", ")"));
        state2.output = utils.escapeLast(state2.output, "(");
        decrement("parens");
      }
      while (state2.braces > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "}"));
        state2.output = utils.escapeLast(state2.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push2({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
      }
      if (state2.backtrack === true) {
        state2.output = "";
        for (const token2 of state2.tokens) {
          state2.output += token2.output != null ? token2.output : token2.value;
          if (token2.suffix) {
            state2.output += token2.suffix;
          }
        }
      }
      return state2;
    };
    parse10.fastpaths = (input, options) => {
      const opts = { ...options };
      const max8 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max8) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max8}`);
      }
      input = REPLACEMENTS[input] || input;
      const win32 = utils.isWindows(options);
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants4.globChars(win32);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state2 = { negated: false, prefix: "" };
      let star = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true)
          return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create5 = (str2) => {
        switch (str2) {
          case "*":
            return `${nodot}${ONE_CHAR}${star}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
          default: {
            const match4 = /^(.*?)\.(\w+)$/.exec(str2);
            if (!match4)
              return;
            const source3 = create5(match4[1]);
            if (!source3)
              return;
            return source3 + DOT_LITERAL + match4[2];
          }
        }
      };
      const output5 = utils.removePrefix(input, state2);
      let source2 = create5(output5);
      if (source2 && opts.strictSlashes !== true) {
        source2 += `${SLASH_LITERAL}?`;
      }
      return source2;
    };
    module.exports = parse10;
  }
});

// node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS({
  "node_modules/picomatch/lib/picomatch.js"(exports, module) {
    "use strict";
    var path5 = __require("path");
    var scan = require_scan2();
    var parse10 = require_parse3();
    var utils = require_utils4();
    var constants4 = require_constants2();
    var isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch = (glob, options, returnState = false) => {
      if (Array.isArray(glob)) {
        const fns = glob.map((input) => picomatch(input, options, returnState));
        const arrayMatcher = (str2) => {
          for (const isMatch of fns) {
            const state3 = isMatch(str2);
            if (state3)
              return state3;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix = utils.isWindows(options);
      const regex4 = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
      const state2 = regex4.state;
      delete regex4.state;
      let isIgnored2 = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
        isIgnored2 = picomatch(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const { isMatch, match: match4, output: output5 } = picomatch.test(input, regex4, options, { glob, posix });
        const result = { glob, state: state2, regex: regex4, posix, input, output: output5, match: match4, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored2(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state2;
      }
      return matcher;
    };
    picomatch.test = (input, regex4, options, { glob, posix } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options || {};
      const format2 = opts.format || (posix ? utils.toPosixSlashes : null);
      let match4 = input === glob;
      let output5 = match4 && format2 ? format2(input) : input;
      if (match4 === false) {
        output5 = format2 ? format2(input) : input;
        match4 = output5 === glob;
      }
      if (match4 === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match4 = picomatch.matchBase(input, regex4, options, posix);
        } else {
          match4 = regex4.exec(output5);
        }
      }
      return { isMatch: Boolean(match4), match: match4, output: output5 };
    };
    picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
      const regex4 = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
      return regex4.test(path5.basename(input));
    };
    picomatch.isMatch = (str2, patterns, options) => picomatch(patterns, options)(str2);
    picomatch.parse = (pattern, options) => {
      if (Array.isArray(pattern))
        return pattern.map((p) => picomatch.parse(p, options));
      return parse10(pattern, { ...options, fastpaths: false });
    };
    picomatch.scan = (input, options) => scan(input, options);
    picomatch.compileRe = (state2, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state2.output;
      }
      const opts = options || {};
      const prepend = opts.contains ? "" : "^";
      const append40 = opts.contains ? "" : "$";
      let source2 = `${prepend}(?:${state2.output})${append40}`;
      if (state2 && state2.negated === true) {
        source2 = `^(?!${source2}).*$`;
      }
      const regex4 = picomatch.toRegex(source2, options);
      if (returnState === true) {
        regex4.state = state2;
      }
      return regex4;
    };
    picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse10.fastpaths(input, options);
      }
      if (!parsed.output) {
        parsed = parse10(input, options);
      }
      return picomatch.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch.toRegex = (source2, options) => {
      try {
        const opts = options || {};
        return new RegExp(source2, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true)
          throw err;
        return /$^/;
      }
    };
    picomatch.constants = constants4;
    module.exports = picomatch;
  }
});

// node_modules/picomatch/index.js
var require_picomatch2 = __commonJS({
  "node_modules/picomatch/index.js"(exports, module) {
    "use strict";
    module.exports = require_picomatch();
  }
});

// node_modules/micromatch/index.js
var require_micromatch = __commonJS({
  "node_modules/micromatch/index.js"(exports, module) {
    "use strict";
    var util = __require("util");
    var braces2 = require_braces();
    var picomatch = require_picomatch2();
    var utils = require_utils4();
    var isEmptyString = (val) => val === "" || val === "./";
    var micromatch = (list2, patterns, options) => {
      patterns = [].concat(patterns);
      list2 = [].concat(list2);
      let omit = /* @__PURE__ */ new Set();
      let keep = /* @__PURE__ */ new Set();
      let items = /* @__PURE__ */ new Set();
      let negatives = 0;
      let onResult = (state2) => {
        items.add(state2.output);
        if (options && options.onResult) {
          options.onResult(state2);
        }
      };
      for (let i = 0; i < patterns.length; i++) {
        let isMatch = picomatch(String(patterns[i]), { ...options, onResult }, true);
        let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
        if (negated)
          negatives++;
        for (let item of list2) {
          let matched = isMatch(item, true);
          let match4 = negated ? !matched.isMatch : matched.isMatch;
          if (!match4)
            continue;
          if (negated) {
            omit.add(matched.output);
          } else {
            omit.delete(matched.output);
            keep.add(matched.output);
          }
        }
      }
      let result = negatives === patterns.length ? [...items] : [...keep];
      let matches = result.filter((item) => !omit.has(item));
      if (options && matches.length === 0) {
        if (options.failglob === true) {
          throw new Error(`No matches found for "${patterns.join(", ")}"`);
        }
        if (options.nonull === true || options.nullglob === true) {
          return options.unescape ? patterns.map((p) => p.replace(/\\/g, "")) : patterns;
        }
      }
      return matches;
    };
    micromatch.match = micromatch;
    micromatch.matcher = (pattern, options) => picomatch(pattern, options);
    micromatch.isMatch = (str2, patterns, options) => picomatch(patterns, options)(str2);
    micromatch.any = micromatch.isMatch;
    micromatch.not = (list2, patterns, options = {}) => {
      patterns = [].concat(patterns).map(String);
      let result = /* @__PURE__ */ new Set();
      let items = [];
      let onResult = (state2) => {
        if (options.onResult)
          options.onResult(state2);
        items.push(state2.output);
      };
      let matches = new Set(micromatch(list2, patterns, { ...options, onResult }));
      for (let item of items) {
        if (!matches.has(item)) {
          result.add(item);
        }
      }
      return [...result];
    };
    micromatch.contains = (str2, pattern, options) => {
      if (typeof str2 !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str2)}"`);
      }
      if (Array.isArray(pattern)) {
        return pattern.some((p) => micromatch.contains(str2, p, options));
      }
      if (typeof pattern === "string") {
        if (isEmptyString(str2) || isEmptyString(pattern)) {
          return false;
        }
        if (str2.includes(pattern) || str2.startsWith("./") && str2.slice(2).includes(pattern)) {
          return true;
        }
      }
      return micromatch.isMatch(str2, pattern, { ...options, contains: true });
    };
    micromatch.matchKeys = (obj, patterns, options) => {
      if (!utils.isObject(obj)) {
        throw new TypeError("Expected the first argument to be an object");
      }
      let keys4 = micromatch(Object.keys(obj), patterns, options);
      let res = {};
      for (let key of keys4)
        res[key] = obj[key];
      return res;
    };
    micromatch.some = (list2, patterns, options) => {
      let items = [].concat(list2);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (items.some((item) => isMatch(item))) {
          return true;
        }
      }
      return false;
    };
    micromatch.every = (list2, patterns, options) => {
      let items = [].concat(list2);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (!items.every((item) => isMatch(item))) {
          return false;
        }
      }
      return true;
    };
    micromatch.all = (str2, patterns, options) => {
      if (typeof str2 !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str2)}"`);
      }
      return [].concat(patterns).every((p) => picomatch(p, options)(str2));
    };
    micromatch.capture = (glob, input, options) => {
      let posix = utils.isWindows(options);
      let regex4 = picomatch.makeRe(String(glob), { ...options, capture: true });
      let match4 = regex4.exec(posix ? utils.toPosixSlashes(input) : input);
      if (match4) {
        return match4.slice(1).map((v) => v === void 0 ? "" : v);
      }
    };
    micromatch.makeRe = (...args) => picomatch.makeRe(...args);
    micromatch.scan = (...args) => picomatch.scan(...args);
    micromatch.parse = (patterns, options) => {
      let res = [];
      for (let pattern of [].concat(patterns || [])) {
        for (let str2 of braces2(String(pattern), options)) {
          res.push(picomatch.parse(str2, options));
        }
      }
      return res;
    };
    micromatch.braces = (pattern, options) => {
      if (typeof pattern !== "string")
        throw new TypeError("Expected a string");
      if (options && options.nobrace === true || !/\{.*\}/.test(pattern)) {
        return [pattern];
      }
      return braces2(pattern, options);
    };
    micromatch.braceExpand = (pattern, options) => {
      if (typeof pattern !== "string")
        throw new TypeError("Expected a string");
      return micromatch.braces(pattern, { ...options, expand: true });
    };
    module.exports = micromatch;
  }
});

// node_modules/fast-glob/out/utils/pattern.js
var require_pattern = __commonJS({
  "node_modules/fast-glob/out/utils/pattern.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.removeDuplicateSlashes = exports.matchAny = exports.convertPatternsToRe = exports.makeRe = exports.getPatternParts = exports.expandBraceExpansion = exports.expandPatternsWithBraceExpansion = exports.isAffectDepthOfReadingPattern = exports.endsWithSlashGlobStar = exports.hasGlobStar = exports.getBaseDirectory = exports.isPatternRelatedToParentDirectory = exports.getPatternsOutsideCurrentDirectory = exports.getPatternsInsideCurrentDirectory = exports.getPositivePatterns = exports.getNegativePatterns = exports.isPositivePattern = exports.isNegativePattern = exports.convertToNegativePattern = exports.convertToPositivePattern = exports.isDynamicPattern = exports.isStaticPattern = void 0;
    var path5 = __require("path");
    var globParent = require_glob_parent();
    var micromatch = require_micromatch();
    var GLOBSTAR = "**";
    var ESCAPE_SYMBOL = "\\";
    var COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
    var REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[[^[]*]/;
    var REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/;
    var GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\([^(]*\)/;
    var BRACE_EXPANSION_SEPARATORS_RE = /,|\.\./;
    var DOUBLE_SLASH_RE = /(?!^)\/{2,}/g;
    function isStaticPattern(pattern, options = {}) {
      return !isDynamicPattern(pattern, options);
    }
    exports.isStaticPattern = isStaticPattern;
    function isDynamicPattern(pattern, options = {}) {
      if (pattern === "") {
        return false;
      }
      if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {
        return true;
      }
      if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {
        return true;
      }
      if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {
        return true;
      }
      if (options.braceExpansion !== false && hasBraceExpansion(pattern)) {
        return true;
      }
      return false;
    }
    exports.isDynamicPattern = isDynamicPattern;
    function hasBraceExpansion(pattern) {
      const openingBraceIndex = pattern.indexOf("{");
      if (openingBraceIndex === -1) {
        return false;
      }
      const closingBraceIndex = pattern.indexOf("}", openingBraceIndex + 1);
      if (closingBraceIndex === -1) {
        return false;
      }
      const braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);
      return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);
    }
    function convertToPositivePattern(pattern) {
      return isNegativePattern(pattern) ? pattern.slice(1) : pattern;
    }
    exports.convertToPositivePattern = convertToPositivePattern;
    function convertToNegativePattern(pattern) {
      return "!" + pattern;
    }
    exports.convertToNegativePattern = convertToNegativePattern;
    function isNegativePattern(pattern) {
      return pattern.startsWith("!") && pattern[1] !== "(";
    }
    exports.isNegativePattern = isNegativePattern;
    function isPositivePattern(pattern) {
      return !isNegativePattern(pattern);
    }
    exports.isPositivePattern = isPositivePattern;
    function getNegativePatterns(patterns) {
      return patterns.filter(isNegativePattern);
    }
    exports.getNegativePatterns = getNegativePatterns;
    function getPositivePatterns(patterns) {
      return patterns.filter(isPositivePattern);
    }
    exports.getPositivePatterns = getPositivePatterns;
    function getPatternsInsideCurrentDirectory(patterns) {
      return patterns.filter((pattern) => !isPatternRelatedToParentDirectory(pattern));
    }
    exports.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;
    function getPatternsOutsideCurrentDirectory(patterns) {
      return patterns.filter(isPatternRelatedToParentDirectory);
    }
    exports.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;
    function isPatternRelatedToParentDirectory(pattern) {
      return pattern.startsWith("..") || pattern.startsWith("./..");
    }
    exports.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;
    function getBaseDirectory(pattern) {
      return globParent(pattern, { flipBackslashes: false });
    }
    exports.getBaseDirectory = getBaseDirectory;
    function hasGlobStar(pattern) {
      return pattern.includes(GLOBSTAR);
    }
    exports.hasGlobStar = hasGlobStar;
    function endsWithSlashGlobStar(pattern) {
      return pattern.endsWith("/" + GLOBSTAR);
    }
    exports.endsWithSlashGlobStar = endsWithSlashGlobStar;
    function isAffectDepthOfReadingPattern(pattern) {
      const basename2 = path5.basename(pattern);
      return endsWithSlashGlobStar(pattern) || isStaticPattern(basename2);
    }
    exports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
    function expandPatternsWithBraceExpansion(patterns) {
      return patterns.reduce((collection, pattern) => {
        return collection.concat(expandBraceExpansion(pattern));
      }, []);
    }
    exports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
    function expandBraceExpansion(pattern) {
      const patterns = micromatch.braces(pattern, { expand: true, nodupes: true });
      patterns.sort((a, b) => a.length - b.length);
      return patterns.filter((pattern2) => pattern2 !== "");
    }
    exports.expandBraceExpansion = expandBraceExpansion;
    function getPatternParts(pattern, options) {
      let { parts } = micromatch.scan(pattern, Object.assign(Object.assign({}, options), { parts: true }));
      if (parts.length === 0) {
        parts = [pattern];
      }
      if (parts[0].startsWith("/")) {
        parts[0] = parts[0].slice(1);
        parts.unshift("");
      }
      return parts;
    }
    exports.getPatternParts = getPatternParts;
    function makeRe(pattern, options) {
      return micromatch.makeRe(pattern, options);
    }
    exports.makeRe = makeRe;
    function convertPatternsToRe(patterns, options) {
      return patterns.map((pattern) => makeRe(pattern, options));
    }
    exports.convertPatternsToRe = convertPatternsToRe;
    function matchAny(entry, patternsRe) {
      return patternsRe.some((patternRe) => patternRe.test(entry));
    }
    exports.matchAny = matchAny;
    function removeDuplicateSlashes(pattern) {
      return pattern.replace(DOUBLE_SLASH_RE, "/");
    }
    exports.removeDuplicateSlashes = removeDuplicateSlashes;
  }
});

// node_modules/merge2/index.js
var require_merge2 = __commonJS({
  "node_modules/merge2/index.js"(exports, module) {
    "use strict";
    var Stream = __require("stream");
    var PassThrough = Stream.PassThrough;
    var slice6 = Array.prototype.slice;
    module.exports = merge22;
    function merge22() {
      const streamsQueue = [];
      const args = slice6.call(arguments);
      let merging = false;
      let options = args[args.length - 1];
      if (options && !Array.isArray(options) && options.pipe == null) {
        args.pop();
      } else {
        options = {};
      }
      const doEnd = options.end !== false;
      const doPipeError = options.pipeError === true;
      if (options.objectMode == null) {
        options.objectMode = true;
      }
      if (options.highWaterMark == null) {
        options.highWaterMark = 64 * 1024;
      }
      const mergedStream = PassThrough(options);
      function addStream() {
        for (let i = 0, len = arguments.length; i < len; i++) {
          streamsQueue.push(pauseStreams(arguments[i], options));
        }
        mergeStream();
        return this;
      }
      function mergeStream() {
        if (merging) {
          return;
        }
        merging = true;
        let streams = streamsQueue.shift();
        if (!streams) {
          process.nextTick(endStream);
          return;
        }
        if (!Array.isArray(streams)) {
          streams = [streams];
        }
        let pipesCount = streams.length + 1;
        function next2() {
          if (--pipesCount > 0) {
            return;
          }
          merging = false;
          mergeStream();
        }
        function pipe2(stream3) {
          function onend() {
            stream3.removeListener("merge2UnpipeEnd", onend);
            stream3.removeListener("end", onend);
            if (doPipeError) {
              stream3.removeListener("error", onerror);
            }
            next2();
          }
          function onerror(err) {
            mergedStream.emit("error", err);
          }
          if (stream3._readableState.endEmitted) {
            return next2();
          }
          stream3.on("merge2UnpipeEnd", onend);
          stream3.on("end", onend);
          if (doPipeError) {
            stream3.on("error", onerror);
          }
          stream3.pipe(mergedStream, { end: false });
          stream3.resume();
        }
        for (let i = 0; i < streams.length; i++) {
          pipe2(streams[i]);
        }
        next2();
      }
      function endStream() {
        merging = false;
        mergedStream.emit("queueDrain");
        if (doEnd) {
          mergedStream.end();
        }
      }
      mergedStream.setMaxListeners(0);
      mergedStream.add = addStream;
      mergedStream.on("unpipe", function(stream3) {
        stream3.emit("merge2UnpipeEnd");
      });
      if (args.length) {
        addStream.apply(null, args);
      }
      return mergedStream;
    }
    function pauseStreams(streams, options) {
      if (!Array.isArray(streams)) {
        if (!streams._readableState && streams.pipe) {
          streams = streams.pipe(PassThrough(options));
        }
        if (!streams._readableState || !streams.pause || !streams.pipe) {
          throw new Error("Only readable stream can be merged.");
        }
        streams.pause();
      } else {
        for (let i = 0, len = streams.length; i < len; i++) {
          streams[i] = pauseStreams(streams[i], options);
        }
      }
      return streams;
    }
  }
});

// node_modules/fast-glob/out/utils/stream.js
var require_stream = __commonJS({
  "node_modules/fast-glob/out/utils/stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.merge = void 0;
    var merge22 = require_merge2();
    function merge4(streams) {
      const mergedStream = merge22(streams);
      streams.forEach((stream3) => {
        stream3.once("error", (error4) => mergedStream.emit("error", error4));
      });
      mergedStream.once("close", () => propagateCloseEventToSources(streams));
      mergedStream.once("end", () => propagateCloseEventToSources(streams));
      return mergedStream;
    }
    exports.merge = merge4;
    function propagateCloseEventToSources(streams) {
      streams.forEach((stream3) => stream3.emit("close"));
    }
  }
});

// node_modules/fast-glob/out/utils/string.js
var require_string2 = __commonJS({
  "node_modules/fast-glob/out/utils/string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isEmpty = exports.isString = void 0;
    function isString(input) {
      return typeof input === "string";
    }
    exports.isString = isString;
    function isEmpty7(input) {
      return input === "";
    }
    exports.isEmpty = isEmpty7;
  }
});

// node_modules/fast-glob/out/utils/index.js
var require_utils5 = __commonJS({
  "node_modules/fast-glob/out/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.string = exports.stream = exports.pattern = exports.path = exports.fs = exports.errno = exports.array = void 0;
    var array2 = require_array();
    exports.array = array2;
    var errno = require_errno();
    exports.errno = errno;
    var fs2 = require_fs2();
    exports.fs = fs2;
    var path5 = require_path();
    exports.path = path5;
    var pattern = require_pattern();
    exports.pattern = pattern;
    var stream3 = require_stream();
    exports.stream = stream3;
    var string7 = require_string2();
    exports.string = string7;
  }
});

// node_modules/fast-glob/out/managers/tasks.js
var require_tasks = __commonJS({
  "node_modules/fast-glob/out/managers/tasks.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertPatternGroupToTask = exports.convertPatternGroupsToTasks = exports.groupPatternsByBaseDirectory = exports.getNegativePatternsAsPositive = exports.getPositivePatterns = exports.convertPatternsToTasks = exports.generate = void 0;
    var utils = require_utils5();
    function generate(input, settings) {
      const patterns = processPatterns(input, settings);
      const ignore2 = processPatterns(settings.ignore, settings);
      const positivePatterns = getPositivePatterns(patterns);
      const negativePatterns = getNegativePatternsAsPositive(patterns, ignore2);
      const staticPatterns = positivePatterns.filter((pattern) => utils.pattern.isStaticPattern(pattern, settings));
      const dynamicPatterns = positivePatterns.filter((pattern) => utils.pattern.isDynamicPattern(pattern, settings));
      const staticTasks = convertPatternsToTasks(
        staticPatterns,
        negativePatterns,
        /* dynamic */
        false
      );
      const dynamicTasks = convertPatternsToTasks(
        dynamicPatterns,
        negativePatterns,
        /* dynamic */
        true
      );
      return staticTasks.concat(dynamicTasks);
    }
    exports.generate = generate;
    function processPatterns(input, settings) {
      let patterns = input;
      if (settings.braceExpansion) {
        patterns = utils.pattern.expandPatternsWithBraceExpansion(patterns);
      }
      if (settings.baseNameMatch) {
        patterns = patterns.map((pattern) => pattern.includes("/") ? pattern : `**/${pattern}`);
      }
      return patterns.map((pattern) => utils.pattern.removeDuplicateSlashes(pattern));
    }
    function convertPatternsToTasks(positive, negative, dynamic) {
      const tasks = [];
      const patternsOutsideCurrentDirectory = utils.pattern.getPatternsOutsideCurrentDirectory(positive);
      const patternsInsideCurrentDirectory = utils.pattern.getPatternsInsideCurrentDirectory(positive);
      const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);
      const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);
      tasks.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));
      if ("." in insideCurrentDirectoryGroup) {
        tasks.push(convertPatternGroupToTask(".", patternsInsideCurrentDirectory, negative, dynamic));
      } else {
        tasks.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));
      }
      return tasks;
    }
    exports.convertPatternsToTasks = convertPatternsToTasks;
    function getPositivePatterns(patterns) {
      return utils.pattern.getPositivePatterns(patterns);
    }
    exports.getPositivePatterns = getPositivePatterns;
    function getNegativePatternsAsPositive(patterns, ignore2) {
      const negative = utils.pattern.getNegativePatterns(patterns).concat(ignore2);
      const positive = negative.map(utils.pattern.convertToPositivePattern);
      return positive;
    }
    exports.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
    function groupPatternsByBaseDirectory(patterns) {
      const group4 = {};
      return patterns.reduce((collection, pattern) => {
        const base = utils.pattern.getBaseDirectory(pattern);
        if (base in collection) {
          collection[base].push(pattern);
        } else {
          collection[base] = [pattern];
        }
        return collection;
      }, group4);
    }
    exports.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
    function convertPatternGroupsToTasks(positive, negative, dynamic) {
      return Object.keys(positive).map((base) => {
        return convertPatternGroupToTask(base, positive[base], negative, dynamic);
      });
    }
    exports.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
    function convertPatternGroupToTask(base, positive, negative, dynamic) {
      return {
        dynamic,
        positive,
        negative,
        base,
        patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))
      };
    }
    exports.convertPatternGroupToTask = convertPatternGroupToTask;
  }
});

// node_modules/@nodelib/fs.stat/out/providers/async.js
var require_async = __commonJS({
  "node_modules/@nodelib/fs.stat/out/providers/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.read = void 0;
    function read7(path5, settings, callback) {
      settings.fs.lstat(path5, (lstatError, lstat3) => {
        if (lstatError !== null) {
          callFailureCallback(callback, lstatError);
          return;
        }
        if (!lstat3.isSymbolicLink() || !settings.followSymbolicLink) {
          callSuccessCallback(callback, lstat3);
          return;
        }
        settings.fs.stat(path5, (statError, stat6) => {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              callFailureCallback(callback, statError);
              return;
            }
            callSuccessCallback(callback, lstat3);
            return;
          }
          if (settings.markSymbolicLink) {
            stat6.isSymbolicLink = () => true;
          }
          callSuccessCallback(callback, stat6);
        });
      });
    }
    exports.read = read7;
    function callFailureCallback(callback, error4) {
      callback(error4);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  }
});

// node_modules/@nodelib/fs.stat/out/providers/sync.js
var require_sync = __commonJS({
  "node_modules/@nodelib/fs.stat/out/providers/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.read = void 0;
    function read7(path5, settings) {
      const lstat3 = settings.fs.lstatSync(path5);
      if (!lstat3.isSymbolicLink() || !settings.followSymbolicLink) {
        return lstat3;
      }
      try {
        const stat6 = settings.fs.statSync(path5);
        if (settings.markSymbolicLink) {
          stat6.isSymbolicLink = () => true;
        }
        return stat6;
      } catch (error4) {
        if (!settings.throwErrorOnBrokenSymbolicLink) {
          return lstat3;
        }
        throw error4;
      }
    }
    exports.read = read7;
  }
});

// node_modules/@nodelib/fs.stat/out/adapters/fs.js
var require_fs3 = __commonJS({
  "node_modules/@nodelib/fs.stat/out/adapters/fs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;
    var fs2 = __require("fs");
    exports.FILE_SYSTEM_ADAPTER = {
      lstat: fs2.lstat,
      stat: fs2.stat,
      lstatSync: fs2.lstatSync,
      statSync: fs2.statSync
    };
    function createFileSystemAdapter(fsMethods) {
      if (fsMethods === void 0) {
        return exports.FILE_SYSTEM_ADAPTER;
      }
      return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports.createFileSystemAdapter = createFileSystemAdapter;
  }
});

// node_modules/@nodelib/fs.stat/out/settings.js
var require_settings = __commonJS({
  "node_modules/@nodelib/fs.stat/out/settings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var fs2 = require_fs3();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
        this.fs = fs2.createFileSystemAdapter(this._options.fs);
        this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
      }
      _getValue(option3, value4) {
        return option3 !== null && option3 !== void 0 ? option3 : value4;
      }
    };
    exports.default = Settings;
  }
});

// node_modules/@nodelib/fs.stat/out/index.js
var require_out = __commonJS({
  "node_modules/@nodelib/fs.stat/out/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.statSync = exports.stat = exports.Settings = void 0;
    var async = require_async();
    var sync = require_sync();
    var settings_1 = require_settings();
    exports.Settings = settings_1.default;
    function stat6(path5, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        async.read(path5, getSettings(), optionsOrSettingsOrCallback);
        return;
      }
      async.read(path5, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports.stat = stat6;
    function statSync2(path5, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      return sync.read(path5, settings);
    }
    exports.statSync = statSync2;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// node_modules/queue-microtask/index.js
var require_queue_microtask = __commonJS({
  "node_modules/queue-microtask/index.js"(exports, module) {
    var promise2;
    module.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : global) : (cb) => (promise2 || (promise2 = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
      throw err;
    }, 0));
  }
});

// node_modules/run-parallel/index.js
var require_run_parallel = __commonJS({
  "node_modules/run-parallel/index.js"(exports, module) {
    module.exports = runParallel;
    var queueMicrotask2 = require_queue_microtask();
    function runParallel(tasks, cb) {
      let results, pending, keys4;
      let isSync = true;
      if (Array.isArray(tasks)) {
        results = [];
        pending = tasks.length;
      } else {
        keys4 = Object.keys(tasks);
        results = {};
        pending = keys4.length;
      }
      function done(err) {
        function end4() {
          if (cb)
            cb(err, results);
          cb = null;
        }
        if (isSync)
          queueMicrotask2(end4);
        else
          end4();
      }
      function each(i, err, result) {
        results[i] = result;
        if (--pending === 0 || err) {
          done(err);
        }
      }
      if (!pending) {
        done(null);
      } else if (keys4) {
        keys4.forEach(function(key) {
          tasks[key](function(err, result) {
            each(key, err, result);
          });
        });
      } else {
        tasks.forEach(function(task, i) {
          task(function(err, result) {
            each(i, err, result);
          });
        });
      }
      isSync = false;
    }
  }
});

// node_modules/@nodelib/fs.scandir/out/constants.js
var require_constants3 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
    var NODE_PROCESS_VERSION_PARTS = process.versions.node.split(".");
    if (NODE_PROCESS_VERSION_PARTS[0] === void 0 || NODE_PROCESS_VERSION_PARTS[1] === void 0) {
      throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);
    }
    var MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
    var MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
    var SUPPORTED_MAJOR_VERSION = 10;
    var SUPPORTED_MINOR_VERSION = 10;
    var IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
    var IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
    exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;
  }
});

// node_modules/@nodelib/fs.scandir/out/utils/fs.js
var require_fs4 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/utils/fs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDirentFromStats = void 0;
    var DirentFromStats = class {
      constructor(name4, stats) {
        this.name = name4;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name4, stats) {
      return new DirentFromStats(name4, stats);
    }
    exports.createDirentFromStats = createDirentFromStats;
  }
});

// node_modules/@nodelib/fs.scandir/out/utils/index.js
var require_utils6 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fs = void 0;
    var fs2 = require_fs4();
    exports.fs = fs2;
  }
});

// node_modules/@nodelib/fs.scandir/out/providers/common.js
var require_common = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/providers/common.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.joinPathSegments = void 0;
    function joinPathSegments(a, b, separator) {
      if (a.endsWith(separator)) {
        return a + b;
      }
      return a + separator + b;
    }
    exports.joinPathSegments = joinPathSegments;
  }
});

// node_modules/@nodelib/fs.scandir/out/providers/async.js
var require_async2 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/providers/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.readdir = exports.readdirWithFileTypes = exports.read = void 0;
    var fsStat = require_out();
    var rpl = require_run_parallel();
    var constants_1 = require_constants3();
    var utils = require_utils6();
    var common = require_common();
    function read7(directory, settings, callback) {
      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        readdirWithFileTypes(directory, settings, callback);
        return;
      }
      readdir4(directory, settings, callback);
    }
    exports.read = read7;
    function readdirWithFileTypes(directory, settings, callback) {
      settings.fs.readdir(directory, { withFileTypes: true }, (readdirError, dirents) => {
        if (readdirError !== null) {
          callFailureCallback(callback, readdirError);
          return;
        }
        const entries = dirents.map((dirent) => ({
          dirent,
          name: dirent.name,
          path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        }));
        if (!settings.followSymbolicLinks) {
          callSuccessCallback(callback, entries);
          return;
        }
        const tasks = entries.map((entry) => makeRplTaskEntry(entry, settings));
        rpl(tasks, (rplError, rplEntries) => {
          if (rplError !== null) {
            callFailureCallback(callback, rplError);
            return;
          }
          callSuccessCallback(callback, rplEntries);
        });
      });
    }
    exports.readdirWithFileTypes = readdirWithFileTypes;
    function makeRplTaskEntry(entry, settings) {
      return (done) => {
        if (!entry.dirent.isSymbolicLink()) {
          done(null, entry);
          return;
        }
        settings.fs.stat(entry.path, (statError, stats) => {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              done(statError);
              return;
            }
            done(null, entry);
            return;
          }
          entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
          done(null, entry);
        });
      };
    }
    function readdir4(directory, settings, callback) {
      settings.fs.readdir(directory, (readdirError, names) => {
        if (readdirError !== null) {
          callFailureCallback(callback, readdirError);
          return;
        }
        const tasks = names.map((name4) => {
          const path5 = common.joinPathSegments(directory, name4, settings.pathSegmentSeparator);
          return (done) => {
            fsStat.stat(path5, settings.fsStatSettings, (error4, stats) => {
              if (error4 !== null) {
                done(error4);
                return;
              }
              const entry = {
                name: name4,
                path: path5,
                dirent: utils.fs.createDirentFromStats(name4, stats)
              };
              if (settings.stats) {
                entry.stats = stats;
              }
              done(null, entry);
            });
          };
        });
        rpl(tasks, (rplError, entries) => {
          if (rplError !== null) {
            callFailureCallback(callback, rplError);
            return;
          }
          callSuccessCallback(callback, entries);
        });
      });
    }
    exports.readdir = readdir4;
    function callFailureCallback(callback, error4) {
      callback(error4);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  }
});

// node_modules/@nodelib/fs.scandir/out/providers/sync.js
var require_sync2 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/providers/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.readdir = exports.readdirWithFileTypes = exports.read = void 0;
    var fsStat = require_out();
    var constants_1 = require_constants3();
    var utils = require_utils6();
    var common = require_common();
    function read7(directory, settings) {
      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        return readdirWithFileTypes(directory, settings);
      }
      return readdir4(directory, settings);
    }
    exports.read = read7;
    function readdirWithFileTypes(directory, settings) {
      const dirents = settings.fs.readdirSync(directory, { withFileTypes: true });
      return dirents.map((dirent) => {
        const entry = {
          dirent,
          name: dirent.name,
          path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        };
        if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {
          try {
            const stats = settings.fs.statSync(entry.path);
            entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
          } catch (error4) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              throw error4;
            }
          }
        }
        return entry;
      });
    }
    exports.readdirWithFileTypes = readdirWithFileTypes;
    function readdir4(directory, settings) {
      const names = settings.fs.readdirSync(directory);
      return names.map((name4) => {
        const entryPath = common.joinPathSegments(directory, name4, settings.pathSegmentSeparator);
        const stats = fsStat.statSync(entryPath, settings.fsStatSettings);
        const entry = {
          name: name4,
          path: entryPath,
          dirent: utils.fs.createDirentFromStats(name4, stats)
        };
        if (settings.stats) {
          entry.stats = stats;
        }
        return entry;
      });
    }
    exports.readdir = readdir4;
  }
});

// node_modules/@nodelib/fs.scandir/out/adapters/fs.js
var require_fs5 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/adapters/fs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;
    var fs2 = __require("fs");
    exports.FILE_SYSTEM_ADAPTER = {
      lstat: fs2.lstat,
      stat: fs2.stat,
      lstatSync: fs2.lstatSync,
      statSync: fs2.statSync,
      readdir: fs2.readdir,
      readdirSync: fs2.readdirSync
    };
    function createFileSystemAdapter(fsMethods) {
      if (fsMethods === void 0) {
        return exports.FILE_SYSTEM_ADAPTER;
      }
      return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports.createFileSystemAdapter = createFileSystemAdapter;
  }
});

// node_modules/@nodelib/fs.scandir/out/settings.js
var require_settings2 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/settings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var path5 = __require("path");
    var fsStat = require_out();
    var fs2 = require_fs5();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
        this.fs = fs2.createFileSystemAdapter(this._options.fs);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path5.sep);
        this.stats = this._getValue(this._options.stats, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
        this.fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this.followSymbolicLinks,
          fs: this.fs,
          throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option3, value4) {
        return option3 !== null && option3 !== void 0 ? option3 : value4;
      }
    };
    exports.default = Settings;
  }
});

// node_modules/@nodelib/fs.scandir/out/index.js
var require_out2 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Settings = exports.scandirSync = exports.scandir = void 0;
    var async = require_async2();
    var sync = require_sync2();
    var settings_1 = require_settings2();
    exports.Settings = settings_1.default;
    function scandir(path5, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        async.read(path5, getSettings(), optionsOrSettingsOrCallback);
        return;
      }
      async.read(path5, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports.scandir = scandir;
    function scandirSync(path5, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      return sync.read(path5, settings);
    }
    exports.scandirSync = scandirSync;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// node_modules/reusify/reusify.js
var require_reusify = __commonJS({
  "node_modules/reusify/reusify.js"(exports, module) {
    "use strict";
    function reusify(Constructor2) {
      var head6 = new Constructor2();
      var tail3 = head6;
      function get7() {
        var current = head6;
        if (current.next) {
          head6 = current.next;
        } else {
          head6 = new Constructor2();
          tail3 = head6;
        }
        current.next = null;
        return current;
      }
      function release(obj) {
        tail3.next = obj;
        tail3 = obj;
      }
      return {
        get: get7,
        release
      };
    }
    module.exports = reusify;
  }
});

// node_modules/fastq/queue.js
var require_queue = __commonJS({
  "node_modules/fastq/queue.js"(exports, module) {
    "use strict";
    var reusify = require_reusify();
    function fastqueue(context, worker, concurrency) {
      if (typeof context === "function") {
        concurrency = worker;
        worker = context;
        context = null;
      }
      if (concurrency < 1) {
        throw new Error("fastqueue concurrency must be greater than 1");
      }
      var cache = reusify(Task);
      var queueHead = null;
      var queueTail = null;
      var _running = 0;
      var errorHandler = null;
      var self2 = {
        push: push2,
        drain: noop,
        saturated: noop,
        pause: pause2,
        paused: false,
        concurrency,
        running,
        resume: resume3,
        idle,
        length: length7,
        getQueue,
        unshift,
        empty: noop,
        kill: kill2,
        killAndDrain,
        error: error4
      };
      return self2;
      function running() {
        return _running;
      }
      function pause2() {
        self2.paused = true;
      }
      function length7() {
        var current = queueHead;
        var counter = 0;
        while (current) {
          current = current.next;
          counter++;
        }
        return counter;
      }
      function getQueue() {
        var current = queueHead;
        var tasks = [];
        while (current) {
          tasks.push(current.value);
          current = current.next;
        }
        return tasks;
      }
      function resume3() {
        if (!self2.paused)
          return;
        self2.paused = false;
        for (var i = 0; i < self2.concurrency; i++) {
          _running++;
          release();
        }
      }
      function idle() {
        return _running === 0 && self2.length() === 0;
      }
      function push2(value4, done) {
        var current = cache.get();
        current.context = context;
        current.release = release;
        current.value = value4;
        current.callback = done || noop;
        current.errorHandler = errorHandler;
        if (_running === self2.concurrency || self2.paused) {
          if (queueTail) {
            queueTail.next = current;
            queueTail = current;
          } else {
            queueHead = current;
            queueTail = current;
            self2.saturated();
          }
        } else {
          _running++;
          worker.call(context, current.value, current.worked);
        }
      }
      function unshift(value4, done) {
        var current = cache.get();
        current.context = context;
        current.release = release;
        current.value = value4;
        current.callback = done || noop;
        if (_running === self2.concurrency || self2.paused) {
          if (queueHead) {
            current.next = queueHead;
            queueHead = current;
          } else {
            queueHead = current;
            queueTail = current;
            self2.saturated();
          }
        } else {
          _running++;
          worker.call(context, current.value, current.worked);
        }
      }
      function release(holder) {
        if (holder) {
          cache.release(holder);
        }
        var next2 = queueHead;
        if (next2) {
          if (!self2.paused) {
            if (queueTail === queueHead) {
              queueTail = null;
            }
            queueHead = next2.next;
            next2.next = null;
            worker.call(context, next2.value, next2.worked);
            if (queueTail === null) {
              self2.empty();
            }
          } else {
            _running--;
          }
        } else if (--_running === 0) {
          self2.drain();
        }
      }
      function kill2() {
        queueHead = null;
        queueTail = null;
        self2.drain = noop;
      }
      function killAndDrain() {
        queueHead = null;
        queueTail = null;
        self2.drain();
        self2.drain = noop;
      }
      function error4(handler) {
        errorHandler = handler;
      }
    }
    function noop() {
    }
    function Task() {
      this.value = null;
      this.callback = noop;
      this.next = null;
      this.release = noop;
      this.context = null;
      this.errorHandler = null;
      var self2 = this;
      this.worked = function worked(err, result) {
        var callback = self2.callback;
        var errorHandler = self2.errorHandler;
        var val = self2.value;
        self2.value = null;
        self2.callback = noop;
        if (self2.errorHandler) {
          errorHandler(err, val);
        }
        callback.call(self2.context, err, result);
        self2.release(self2);
      };
    }
    function queueAsPromised(context, worker, concurrency) {
      if (typeof context === "function") {
        concurrency = worker;
        worker = context;
        context = null;
      }
      function asyncWrapper(arg, cb) {
        worker.call(this, arg).then(function(res) {
          cb(null, res);
        }, cb);
      }
      var queue = fastqueue(context, asyncWrapper, concurrency);
      var pushCb = queue.push;
      var unshiftCb = queue.unshift;
      queue.push = push2;
      queue.unshift = unshift;
      queue.drained = drained;
      return queue;
      function push2(value4) {
        var p = new Promise(function(resolve2, reject) {
          pushCb(value4, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve2(result);
          });
        });
        p.catch(noop);
        return p;
      }
      function unshift(value4) {
        var p = new Promise(function(resolve2, reject) {
          unshiftCb(value4, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve2(result);
          });
        });
        p.catch(noop);
        return p;
      }
      function drained() {
        if (queue.idle()) {
          return new Promise(function(resolve2) {
            resolve2();
          });
        }
        var previousDrain = queue.drain;
        var p = new Promise(function(resolve2) {
          queue.drain = function() {
            previousDrain();
            resolve2();
          };
        });
        return p;
      }
    }
    module.exports = fastqueue;
    module.exports.promise = queueAsPromised;
  }
});

// node_modules/@nodelib/fs.walk/out/readers/common.js
var require_common2 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/readers/common.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.joinPathSegments = exports.replacePathSegmentSeparator = exports.isAppliedFilter = exports.isFatalError = void 0;
    function isFatalError(settings, error4) {
      if (settings.errorFilter === null) {
        return true;
      }
      return !settings.errorFilter(error4);
    }
    exports.isFatalError = isFatalError;
    function isAppliedFilter(filter7, value4) {
      return filter7 === null || filter7(value4);
    }
    exports.isAppliedFilter = isAppliedFilter;
    function replacePathSegmentSeparator(filepath, separator) {
      return filepath.split(/[/\\]/).join(separator);
    }
    exports.replacePathSegmentSeparator = replacePathSegmentSeparator;
    function joinPathSegments(a, b, separator) {
      if (a === "") {
        return b;
      }
      if (a.endsWith(separator)) {
        return a + b;
      }
      return a + separator + b;
    }
    exports.joinPathSegments = joinPathSegments;
  }
});

// node_modules/@nodelib/fs.walk/out/readers/reader.js
var require_reader = __commonJS({
  "node_modules/@nodelib/fs.walk/out/readers/reader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var common = require_common2();
    var Reader = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._root = common.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
      }
    };
    exports.default = Reader;
  }
});

// node_modules/@nodelib/fs.walk/out/readers/async.js
var require_async3 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/readers/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var events_1 = __require("events");
    var fsScandir = require_out2();
    var fastq = require_queue();
    var common = require_common2();
    var reader_1 = require_reader();
    var AsyncReader = class extends reader_1.default {
      constructor(_root, _settings) {
        super(_root, _settings);
        this._settings = _settings;
        this._scandir = fsScandir.scandir;
        this._emitter = new events_1.EventEmitter();
        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
        this._isFatalError = false;
        this._isDestroyed = false;
        this._queue.drain = () => {
          if (!this._isFatalError) {
            this._emitter.emit("end");
          }
        };
      }
      read() {
        this._isFatalError = false;
        this._isDestroyed = false;
        setImmediate(() => {
          this._pushToQueue(this._root, this._settings.basePath);
        });
        return this._emitter;
      }
      get isDestroyed() {
        return this._isDestroyed;
      }
      destroy() {
        if (this._isDestroyed) {
          throw new Error("The reader is already destroyed");
        }
        this._isDestroyed = true;
        this._queue.killAndDrain();
      }
      onEntry(callback) {
        this._emitter.on("entry", callback);
      }
      onError(callback) {
        this._emitter.once("error", callback);
      }
      onEnd(callback) {
        this._emitter.once("end", callback);
      }
      _pushToQueue(directory, base) {
        const queueItem = { directory, base };
        this._queue.push(queueItem, (error4) => {
          if (error4 !== null) {
            this._handleError(error4);
          }
        });
      }
      _worker(item, done) {
        this._scandir(item.directory, this._settings.fsScandirSettings, (error4, entries) => {
          if (error4 !== null) {
            done(error4, void 0);
            return;
          }
          for (const entry of entries) {
            this._handleEntry(entry, item.base);
          }
          done(null, void 0);
        });
      }
      _handleError(error4) {
        if (this._isDestroyed || !common.isFatalError(this._settings, error4)) {
          return;
        }
        this._isFatalError = true;
        this._isDestroyed = true;
        this._emitter.emit("error", error4);
      }
      _handleEntry(entry, base) {
        if (this._isDestroyed || this._isFatalError) {
          return;
        }
        const fullpath = entry.path;
        if (base !== void 0) {
          entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
          this._emitEntry(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
          this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);
        }
      }
      _emitEntry(entry) {
        this._emitter.emit("entry", entry);
      }
    };
    exports.default = AsyncReader;
  }
});

// node_modules/@nodelib/fs.walk/out/providers/async.js
var require_async4 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/providers/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var async_1 = require_async3();
    var AsyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._storage = [];
      }
      read(callback) {
        this._reader.onError((error4) => {
          callFailureCallback(callback, error4);
        });
        this._reader.onEntry((entry) => {
          this._storage.push(entry);
        });
        this._reader.onEnd(() => {
          callSuccessCallback(callback, this._storage);
        });
        this._reader.read();
      }
    };
    exports.default = AsyncProvider;
    function callFailureCallback(callback, error4) {
      callback(error4);
    }
    function callSuccessCallback(callback, entries) {
      callback(null, entries);
    }
  }
});

// node_modules/@nodelib/fs.walk/out/providers/stream.js
var require_stream2 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/providers/stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var stream_1 = __require("stream");
    var async_1 = require_async3();
    var StreamProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._stream = new stream_1.Readable({
          objectMode: true,
          read: () => {
          },
          destroy: () => {
            if (!this._reader.isDestroyed) {
              this._reader.destroy();
            }
          }
        });
      }
      read() {
        this._reader.onError((error4) => {
          this._stream.emit("error", error4);
        });
        this._reader.onEntry((entry) => {
          this._stream.push(entry);
        });
        this._reader.onEnd(() => {
          this._stream.push(null);
        });
        this._reader.read();
        return this._stream;
      }
    };
    exports.default = StreamProvider;
  }
});

// node_modules/@nodelib/fs.walk/out/readers/sync.js
var require_sync3 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/readers/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var fsScandir = require_out2();
    var common = require_common2();
    var reader_1 = require_reader();
    var SyncReader = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._scandir = fsScandir.scandirSync;
        this._storage = [];
        this._queue = /* @__PURE__ */ new Set();
      }
      read() {
        this._pushToQueue(this._root, this._settings.basePath);
        this._handleQueue();
        return this._storage;
      }
      _pushToQueue(directory, base) {
        this._queue.add({ directory, base });
      }
      _handleQueue() {
        for (const item of this._queue.values()) {
          this._handleDirectory(item.directory, item.base);
        }
      }
      _handleDirectory(directory, base) {
        try {
          const entries = this._scandir(directory, this._settings.fsScandirSettings);
          for (const entry of entries) {
            this._handleEntry(entry, base);
          }
        } catch (error4) {
          this._handleError(error4);
        }
      }
      _handleError(error4) {
        if (!common.isFatalError(this._settings, error4)) {
          return;
        }
        throw error4;
      }
      _handleEntry(entry, base) {
        const fullpath = entry.path;
        if (base !== void 0) {
          entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
          this._pushToStorage(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
          this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);
        }
      }
      _pushToStorage(entry) {
        this._storage.push(entry);
      }
    };
    exports.default = SyncReader;
  }
});

// node_modules/@nodelib/fs.walk/out/providers/sync.js
var require_sync4 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/providers/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var sync_1 = require_sync3();
    var SyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new sync_1.default(this._root, this._settings);
      }
      read() {
        return this._reader.read();
      }
    };
    exports.default = SyncProvider;
  }
});

// node_modules/@nodelib/fs.walk/out/settings.js
var require_settings3 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/settings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var path5 = __require("path");
    var fsScandir = require_out2();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.basePath = this._getValue(this._options.basePath, void 0);
        this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY);
        this.deepFilter = this._getValue(this._options.deepFilter, null);
        this.entryFilter = this._getValue(this._options.entryFilter, null);
        this.errorFilter = this._getValue(this._options.errorFilter, null);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path5.sep);
        this.fsScandirSettings = new fsScandir.Settings({
          followSymbolicLinks: this._options.followSymbolicLinks,
          fs: this._options.fs,
          pathSegmentSeparator: this._options.pathSegmentSeparator,
          stats: this._options.stats,
          throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option3, value4) {
        return option3 !== null && option3 !== void 0 ? option3 : value4;
      }
    };
    exports.default = Settings;
  }
});

// node_modules/@nodelib/fs.walk/out/index.js
var require_out3 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Settings = exports.walkStream = exports.walkSync = exports.walk = void 0;
    var async_1 = require_async4();
    var stream_1 = require_stream2();
    var sync_1 = require_sync4();
    var settings_1 = require_settings3();
    exports.Settings = settings_1.default;
    function walk(directory, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
        return;
      }
      new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
    }
    exports.walk = walk;
    function walkSync(directory, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      const provider = new sync_1.default(directory, settings);
      return provider.read();
    }
    exports.walkSync = walkSync;
    function walkStream(directory, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      const provider = new stream_1.default(directory, settings);
      return provider.read();
    }
    exports.walkStream = walkStream;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// node_modules/fast-glob/out/readers/reader.js
var require_reader2 = __commonJS({
  "node_modules/fast-glob/out/readers/reader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var path5 = __require("path");
    var fsStat = require_out();
    var utils = require_utils5();
    var Reader = class {
      constructor(_settings) {
        this._settings = _settings;
        this._fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
        });
      }
      _getFullEntryPath(filepath) {
        return path5.resolve(this._settings.cwd, filepath);
      }
      _makeEntry(stats, pattern) {
        const entry = {
          name: pattern,
          path: pattern,
          dirent: utils.fs.createDirentFromStats(pattern, stats)
        };
        if (this._settings.stats) {
          entry.stats = stats;
        }
        return entry;
      }
      _isFatalError(error4) {
        return !utils.errno.isEnoentCodeError(error4) && !this._settings.suppressErrors;
      }
    };
    exports.default = Reader;
  }
});

// node_modules/fast-glob/out/readers/stream.js
var require_stream3 = __commonJS({
  "node_modules/fast-glob/out/readers/stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var stream_1 = __require("stream");
    var fsStat = require_out();
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var ReaderStream = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkStream = fsWalk.walkStream;
        this._stat = fsStat.stat;
      }
      dynamic(root2, options) {
        return this._walkStream(root2, options);
      }
      static(patterns, options) {
        const filepaths = patterns.map(this._getFullEntryPath, this);
        const stream3 = new stream_1.PassThrough({ objectMode: true });
        stream3._write = (index4, _enc, done) => {
          return this._getEntry(filepaths[index4], patterns[index4], options).then((entry) => {
            if (entry !== null && options.entryFilter(entry)) {
              stream3.push(entry);
            }
            if (index4 === filepaths.length - 1) {
              stream3.end();
            }
            done();
          }).catch(done);
        };
        for (let i = 0; i < filepaths.length; i++) {
          stream3.write(i);
        }
        return stream3;
      }
      _getEntry(filepath, pattern, options) {
        return this._getStat(filepath).then((stats) => this._makeEntry(stats, pattern)).catch((error4) => {
          if (options.errorFilter(error4)) {
            return null;
          }
          throw error4;
        });
      }
      _getStat(filepath) {
        return new Promise((resolve2, reject) => {
          this._stat(filepath, this._fsStatSettings, (error4, stats) => {
            return error4 === null ? resolve2(stats) : reject(error4);
          });
        });
      }
    };
    exports.default = ReaderStream;
  }
});

// node_modules/fast-glob/out/readers/async.js
var require_async5 = __commonJS({
  "node_modules/fast-glob/out/readers/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var stream_1 = require_stream3();
    var ReaderAsync = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkAsync = fsWalk.walk;
        this._readerStream = new stream_1.default(this._settings);
      }
      dynamic(root2, options) {
        return new Promise((resolve2, reject) => {
          this._walkAsync(root2, options, (error4, entries) => {
            if (error4 === null) {
              resolve2(entries);
            } else {
              reject(error4);
            }
          });
        });
      }
      async static(patterns, options) {
        const entries = [];
        const stream3 = this._readerStream.static(patterns, options);
        return new Promise((resolve2, reject) => {
          stream3.once("error", reject);
          stream3.on("data", (entry) => entries.push(entry));
          stream3.once("end", () => resolve2(entries));
        });
      }
    };
    exports.default = ReaderAsync;
  }
});

// node_modules/fast-glob/out/providers/matchers/matcher.js
var require_matcher = __commonJS({
  "node_modules/fast-glob/out/providers/matchers/matcher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils5();
    var Matcher = class {
      constructor(_patterns, _settings, _micromatchOptions) {
        this._patterns = _patterns;
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this._storage = [];
        this._fillStorage();
      }
      _fillStorage() {
        for (const pattern of this._patterns) {
          const segments = this._getPatternSegments(pattern);
          const sections = this._splitSegmentsIntoSections(segments);
          this._storage.push({
            complete: sections.length <= 1,
            pattern,
            segments,
            sections
          });
        }
      }
      _getPatternSegments(pattern) {
        const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);
        return parts.map((part) => {
          const dynamic = utils.pattern.isDynamicPattern(part, this._settings);
          if (!dynamic) {
            return {
              dynamic: false,
              pattern: part
            };
          }
          return {
            dynamic: true,
            pattern: part,
            patternRe: utils.pattern.makeRe(part, this._micromatchOptions)
          };
        });
      }
      _splitSegmentsIntoSections(segments) {
        return utils.array.splitWhen(segments, (segment2) => segment2.dynamic && utils.pattern.hasGlobStar(segment2.pattern));
      }
    };
    exports.default = Matcher;
  }
});

// node_modules/fast-glob/out/providers/matchers/partial.js
var require_partial = __commonJS({
  "node_modules/fast-glob/out/providers/matchers/partial.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var matcher_1 = require_matcher();
    var PartialMatcher = class extends matcher_1.default {
      match(filepath) {
        const parts = filepath.split("/");
        const levels = parts.length;
        const patterns = this._storage.filter((info4) => !info4.complete || info4.segments.length > levels);
        for (const pattern of patterns) {
          const section = pattern.sections[0];
          if (!pattern.complete && levels > section.length) {
            return true;
          }
          const match4 = parts.every((part, index4) => {
            const segment2 = pattern.segments[index4];
            if (segment2.dynamic && segment2.patternRe.test(part)) {
              return true;
            }
            if (!segment2.dynamic && segment2.pattern === part) {
              return true;
            }
            return false;
          });
          if (match4) {
            return true;
          }
        }
        return false;
      }
    };
    exports.default = PartialMatcher;
  }
});

// node_modules/fast-glob/out/providers/filters/deep.js
var require_deep = __commonJS({
  "node_modules/fast-glob/out/providers/filters/deep.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils5();
    var partial_1 = require_partial();
    var DeepFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
      }
      getFilter(basePath, positive, negative) {
        const matcher = this._getMatcher(positive);
        const negativeRe = this._getNegativePatternsRe(negative);
        return (entry) => this._filter(basePath, entry, matcher, negativeRe);
      }
      _getMatcher(patterns) {
        return new partial_1.default(patterns, this._settings, this._micromatchOptions);
      }
      _getNegativePatternsRe(patterns) {
        const affectDepthOfReadingPatterns = patterns.filter(utils.pattern.isAffectDepthOfReadingPattern);
        return utils.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
      }
      _filter(basePath, entry, matcher, negativeRe) {
        if (this._isSkippedByDeep(basePath, entry.path)) {
          return false;
        }
        if (this._isSkippedSymbolicLink(entry)) {
          return false;
        }
        const filepath = utils.path.removeLeadingDotSegment(entry.path);
        if (this._isSkippedByPositivePatterns(filepath, matcher)) {
          return false;
        }
        return this._isSkippedByNegativePatterns(filepath, negativeRe);
      }
      _isSkippedByDeep(basePath, entryPath) {
        if (this._settings.deep === Infinity) {
          return false;
        }
        return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
      }
      _getEntryLevel(basePath, entryPath) {
        const entryPathDepth = entryPath.split("/").length;
        if (basePath === "") {
          return entryPathDepth;
        }
        const basePathDepth = basePath.split("/").length;
        return entryPathDepth - basePathDepth;
      }
      _isSkippedSymbolicLink(entry) {
        return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();
      }
      _isSkippedByPositivePatterns(entryPath, matcher) {
        return !this._settings.baseNameMatch && !matcher.match(entryPath);
      }
      _isSkippedByNegativePatterns(entryPath, patternsRe) {
        return !utils.pattern.matchAny(entryPath, patternsRe);
      }
    };
    exports.default = DeepFilter;
  }
});

// node_modules/fast-glob/out/providers/filters/entry.js
var require_entry = __commonJS({
  "node_modules/fast-glob/out/providers/filters/entry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils5();
    var EntryFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this.index = /* @__PURE__ */ new Map();
      }
      getFilter(positive, negative) {
        const positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions);
        const negativeRe = utils.pattern.convertPatternsToRe(negative, Object.assign(Object.assign({}, this._micromatchOptions), { dot: true }));
        return (entry) => this._filter(entry, positiveRe, negativeRe);
      }
      _filter(entry, positiveRe, negativeRe) {
        const filepath = utils.path.removeLeadingDotSegment(entry.path);
        if (this._settings.unique && this._isDuplicateEntry(filepath)) {
          return false;
        }
        if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {
          return false;
        }
        if (this._isSkippedByAbsoluteNegativePatterns(filepath, negativeRe)) {
          return false;
        }
        const isDirectory2 = entry.dirent.isDirectory();
        const isMatched = this._isMatchToPatterns(filepath, positiveRe, isDirectory2) && !this._isMatchToPatterns(filepath, negativeRe, isDirectory2);
        if (this._settings.unique && isMatched) {
          this._createIndexRecord(filepath);
        }
        return isMatched;
      }
      _isDuplicateEntry(filepath) {
        return this.index.has(filepath);
      }
      _createIndexRecord(filepath) {
        this.index.set(filepath, void 0);
      }
      _onlyFileFilter(entry) {
        return this._settings.onlyFiles && !entry.dirent.isFile();
      }
      _onlyDirectoryFilter(entry) {
        return this._settings.onlyDirectories && !entry.dirent.isDirectory();
      }
      _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
        if (!this._settings.absolute) {
          return false;
        }
        const fullpath = utils.path.makeAbsolute(this._settings.cwd, entryPath);
        return utils.pattern.matchAny(fullpath, patternsRe);
      }
      _isMatchToPatterns(filepath, patternsRe, isDirectory2) {
        const isMatched = utils.pattern.matchAny(filepath, patternsRe);
        if (!isMatched && isDirectory2) {
          return utils.pattern.matchAny(filepath + "/", patternsRe);
        }
        return isMatched;
      }
    };
    exports.default = EntryFilter;
  }
});

// node_modules/fast-glob/out/providers/filters/error.js
var require_error = __commonJS({
  "node_modules/fast-glob/out/providers/filters/error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils5();
    var ErrorFilter = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getFilter() {
        return (error4) => this._isNonFatalError(error4);
      }
      _isNonFatalError(error4) {
        return utils.errno.isEnoentCodeError(error4) || this._settings.suppressErrors;
      }
    };
    exports.default = ErrorFilter;
  }
});

// node_modules/fast-glob/out/providers/transformers/entry.js
var require_entry2 = __commonJS({
  "node_modules/fast-glob/out/providers/transformers/entry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils5();
    var EntryTransformer = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getTransformer() {
        return (entry) => this._transform(entry);
      }
      _transform(entry) {
        let filepath = entry.path;
        if (this._settings.absolute) {
          filepath = utils.path.makeAbsolute(this._settings.cwd, filepath);
          filepath = utils.path.unixify(filepath);
        }
        if (this._settings.markDirectories && entry.dirent.isDirectory()) {
          filepath += "/";
        }
        if (!this._settings.objectMode) {
          return filepath;
        }
        return Object.assign(Object.assign({}, entry), { path: filepath });
      }
    };
    exports.default = EntryTransformer;
  }
});

// node_modules/fast-glob/out/providers/provider.js
var require_provider = __commonJS({
  "node_modules/fast-glob/out/providers/provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var path5 = __require("path");
    var deep_1 = require_deep();
    var entry_1 = require_entry();
    var error_1 = require_error();
    var entry_2 = require_entry2();
    var Provider = class {
      constructor(_settings) {
        this._settings = _settings;
        this.errorFilter = new error_1.default(this._settings);
        this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());
        this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());
        this.entryTransformer = new entry_2.default(this._settings);
      }
      _getRootDirectory(task) {
        return path5.resolve(this._settings.cwd, task.base);
      }
      _getReaderOptions(task) {
        const basePath = task.base === "." ? "" : task.base;
        return {
          basePath,
          pathSegmentSeparator: "/",
          concurrency: this._settings.concurrency,
          deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
          entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
          errorFilter: this.errorFilter.getFilter(),
          followSymbolicLinks: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          stats: this._settings.stats,
          throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
          transform: this.entryTransformer.getTransformer()
        };
      }
      _getMicromatchOptions() {
        return {
          dot: this._settings.dot,
          matchBase: this._settings.baseNameMatch,
          nobrace: !this._settings.braceExpansion,
          nocase: !this._settings.caseSensitiveMatch,
          noext: !this._settings.extglob,
          noglobstar: !this._settings.globstar,
          posix: true,
          strictSlashes: false
        };
      }
    };
    exports.default = Provider;
  }
});

// node_modules/fast-glob/out/providers/async.js
var require_async6 = __commonJS({
  "node_modules/fast-glob/out/providers/async.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var async_1 = require_async5();
    var provider_1 = require_provider();
    var ProviderAsync = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new async_1.default(this._settings);
      }
      async read(task) {
        const root2 = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = await this.api(root2, task, options);
        return entries.map((entry) => options.transform(entry));
      }
      api(root2, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root2, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports.default = ProviderAsync;
  }
});

// node_modules/fast-glob/out/providers/stream.js
var require_stream4 = __commonJS({
  "node_modules/fast-glob/out/providers/stream.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var stream_1 = __require("stream");
    var stream_2 = require_stream3();
    var provider_1 = require_provider();
    var ProviderStream = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new stream_2.default(this._settings);
      }
      read(task) {
        const root2 = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const source2 = this.api(root2, task, options);
        const destination = new stream_1.Readable({ objectMode: true, read: () => {
        } });
        source2.once("error", (error4) => destination.emit("error", error4)).on("data", (entry) => destination.emit("data", options.transform(entry))).once("end", () => destination.emit("end"));
        destination.once("close", () => source2.destroy());
        return destination;
      }
      api(root2, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root2, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports.default = ProviderStream;
  }
});

// node_modules/fast-glob/out/readers/sync.js
var require_sync5 = __commonJS({
  "node_modules/fast-glob/out/readers/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var fsStat = require_out();
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var ReaderSync = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkSync = fsWalk.walkSync;
        this._statSync = fsStat.statSync;
      }
      dynamic(root2, options) {
        return this._walkSync(root2, options);
      }
      static(patterns, options) {
        const entries = [];
        for (const pattern of patterns) {
          const filepath = this._getFullEntryPath(pattern);
          const entry = this._getEntry(filepath, pattern, options);
          if (entry === null || !options.entryFilter(entry)) {
            continue;
          }
          entries.push(entry);
        }
        return entries;
      }
      _getEntry(filepath, pattern, options) {
        try {
          const stats = this._getStat(filepath);
          return this._makeEntry(stats, pattern);
        } catch (error4) {
          if (options.errorFilter(error4)) {
            return null;
          }
          throw error4;
        }
      }
      _getStat(filepath) {
        return this._statSync(filepath, this._fsStatSettings);
      }
    };
    exports.default = ReaderSync;
  }
});

// node_modules/fast-glob/out/providers/sync.js
var require_sync6 = __commonJS({
  "node_modules/fast-glob/out/providers/sync.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var sync_1 = require_sync5();
    var provider_1 = require_provider();
    var ProviderSync = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new sync_1.default(this._settings);
      }
      read(task) {
        const root2 = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = this.api(root2, task, options);
        return entries.map(options.transform);
      }
      api(root2, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root2, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports.default = ProviderSync;
  }
});

// node_modules/fast-glob/out/settings.js
var require_settings4 = __commonJS({
  "node_modules/fast-glob/out/settings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
    var fs2 = __require("fs");
    var os3 = __require("os");
    var CPU_COUNT = Math.max(os3.cpus().length, 1);
    exports.DEFAULT_FILE_SYSTEM_ADAPTER = {
      lstat: fs2.lstat,
      lstatSync: fs2.lstatSync,
      stat: fs2.stat,
      statSync: fs2.statSync,
      readdir: fs2.readdir,
      readdirSync: fs2.readdirSync
    };
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.absolute = this._getValue(this._options.absolute, false);
        this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
        this.braceExpansion = this._getValue(this._options.braceExpansion, true);
        this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
        this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
        this.cwd = this._getValue(this._options.cwd, process.cwd());
        this.deep = this._getValue(this._options.deep, Infinity);
        this.dot = this._getValue(this._options.dot, false);
        this.extglob = this._getValue(this._options.extglob, true);
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
        this.fs = this._getFileSystemMethods(this._options.fs);
        this.globstar = this._getValue(this._options.globstar, true);
        this.ignore = this._getValue(this._options.ignore, []);
        this.markDirectories = this._getValue(this._options.markDirectories, false);
        this.objectMode = this._getValue(this._options.objectMode, false);
        this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
        this.onlyFiles = this._getValue(this._options.onlyFiles, true);
        this.stats = this._getValue(this._options.stats, false);
        this.suppressErrors = this._getValue(this._options.suppressErrors, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
        this.unique = this._getValue(this._options.unique, true);
        if (this.onlyDirectories) {
          this.onlyFiles = false;
        }
        if (this.stats) {
          this.objectMode = true;
        }
      }
      _getValue(option3, value4) {
        return option3 === void 0 ? value4 : option3;
      }
      _getFileSystemMethods(methods = {}) {
        return Object.assign(Object.assign({}, exports.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
      }
    };
    exports.default = Settings;
  }
});

// node_modules/fast-glob/out/index.js
var require_out4 = __commonJS({
  "node_modules/fast-glob/out/index.js"(exports, module) {
    "use strict";
    var taskManager = require_tasks();
    var async_1 = require_async6();
    var stream_1 = require_stream4();
    var sync_1 = require_sync6();
    var settings_1 = require_settings4();
    var utils = require_utils5();
    async function FastGlob(source2, options) {
      assertPatternsInput(source2);
      const works = getWorks(source2, async_1.default, options);
      const result = await Promise.all(works);
      return utils.array.flatten(result);
    }
    (function(FastGlob2) {
      FastGlob2.glob = FastGlob2;
      FastGlob2.globSync = sync;
      FastGlob2.globStream = stream3;
      FastGlob2.async = FastGlob2;
      function sync(source2, options) {
        assertPatternsInput(source2);
        const works = getWorks(source2, sync_1.default, options);
        return utils.array.flatten(works);
      }
      FastGlob2.sync = sync;
      function stream3(source2, options) {
        assertPatternsInput(source2);
        const works = getWorks(source2, stream_1.default, options);
        return utils.stream.merge(works);
      }
      FastGlob2.stream = stream3;
      function generateTasks(source2, options) {
        assertPatternsInput(source2);
        const patterns = [].concat(source2);
        const settings = new settings_1.default(options);
        return taskManager.generate(patterns, settings);
      }
      FastGlob2.generateTasks = generateTasks;
      function isDynamicPattern(source2, options) {
        assertPatternsInput(source2);
        const settings = new settings_1.default(options);
        return utils.pattern.isDynamicPattern(source2, settings);
      }
      FastGlob2.isDynamicPattern = isDynamicPattern;
      function escapePath(source2) {
        assertPatternsInput(source2);
        return utils.path.escape(source2);
      }
      FastGlob2.escapePath = escapePath;
      function convertPathToPattern(source2) {
        assertPatternsInput(source2);
        return utils.path.convertPathToPattern(source2);
      }
      FastGlob2.convertPathToPattern = convertPathToPattern;
      let posix;
      (function(posix2) {
        function escapePath2(source2) {
          assertPatternsInput(source2);
          return utils.path.escapePosixPath(source2);
        }
        posix2.escapePath = escapePath2;
        function convertPathToPattern2(source2) {
          assertPatternsInput(source2);
          return utils.path.convertPosixPathToPattern(source2);
        }
        posix2.convertPathToPattern = convertPathToPattern2;
      })(posix = FastGlob2.posix || (FastGlob2.posix = {}));
      let win32;
      (function(win322) {
        function escapePath2(source2) {
          assertPatternsInput(source2);
          return utils.path.escapeWindowsPath(source2);
        }
        win322.escapePath = escapePath2;
        function convertPathToPattern2(source2) {
          assertPatternsInput(source2);
          return utils.path.convertWindowsPathToPattern(source2);
        }
        win322.convertPathToPattern = convertPathToPattern2;
      })(win32 = FastGlob2.win32 || (FastGlob2.win32 = {}));
    })(FastGlob || (FastGlob = {}));
    function getWorks(source2, _Provider, options) {
      const patterns = [].concat(source2);
      const settings = new settings_1.default(options);
      const tasks = taskManager.generate(patterns, settings);
      const provider = new _Provider(settings);
      return tasks.map(provider.read, provider);
    }
    function assertPatternsInput(input) {
      const source2 = [].concat(input);
      const isValidSource = source2.every((item) => utils.string.isString(item) && !utils.string.isEmpty(item));
      if (!isValidSource) {
        throw new TypeError("Patterns must be a string (non empty) or an array of strings");
      }
    }
    module.exports = FastGlob;
  }
});

// node_modules/tar/lib/high-level-opt.js
var require_high_level_opt = __commonJS({
  "node_modules/tar/lib/high-level-opt.js"(exports, module) {
    "use strict";
    var argmap = /* @__PURE__ */ new Map([
      ["C", "cwd"],
      ["f", "file"],
      ["z", "gzip"],
      ["P", "preservePaths"],
      ["U", "unlink"],
      ["strip-components", "strip"],
      ["stripComponents", "strip"],
      ["keep-newer", "newer"],
      ["keepNewer", "newer"],
      ["keep-newer-files", "newer"],
      ["keepNewerFiles", "newer"],
      ["k", "keep"],
      ["keep-existing", "keep"],
      ["keepExisting", "keep"],
      ["m", "noMtime"],
      ["no-mtime", "noMtime"],
      ["p", "preserveOwner"],
      ["L", "follow"],
      ["h", "follow"]
    ]);
    module.exports = (opt) => opt ? Object.keys(opt).map((k) => [
      argmap.has(k) ? argmap.get(k) : k,
      opt[k]
    ]).reduce((set2, kv) => (set2[kv[0]] = kv[1], set2), /* @__PURE__ */ Object.create(null)) : {};
  }
});

// node_modules/minipass/index.js
var require_minipass = __commonJS({
  "node_modules/minipass/index.js"(exports) {
    "use strict";
    var proc = typeof process === "object" && process ? process : {
      stdout: null,
      stderr: null
    };
    var EE = __require("events");
    var Stream = __require("stream");
    var stringdecoder = __require("string_decoder");
    var SD = stringdecoder.StringDecoder;
    var EOF = Symbol("EOF");
    var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
    var EMITTED_END = Symbol("emittedEnd");
    var EMITTING_END = Symbol("emittingEnd");
    var EMITTED_ERROR = Symbol("emittedError");
    var CLOSED = Symbol("closed");
    var READ = Symbol("read");
    var FLUSH = Symbol("flush");
    var FLUSHCHUNK = Symbol("flushChunk");
    var ENCODING = Symbol("encoding");
    var DECODER = Symbol("decoder");
    var FLOWING = Symbol("flowing");
    var PAUSED = Symbol("paused");
    var RESUME = Symbol("resume");
    var BUFFER = Symbol("buffer");
    var PIPES = Symbol("pipes");
    var BUFFERLENGTH = Symbol("bufferLength");
    var BUFFERPUSH = Symbol("bufferPush");
    var BUFFERSHIFT = Symbol("bufferShift");
    var OBJECTMODE = Symbol("objectMode");
    var DESTROYED = Symbol("destroyed");
    var ERROR = Symbol("error");
    var EMITDATA = Symbol("emitData");
    var EMITEND = Symbol("emitEnd");
    var EMITEND2 = Symbol("emitEnd2");
    var ASYNC = Symbol("async");
    var ABORT = Symbol("abort");
    var ABORTED = Symbol("aborted");
    var SIGNAL = Symbol("signal");
    var defer6 = (fn) => Promise.resolve().then(fn);
    var doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
    var ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol("asyncIterator not implemented");
    var ITERATOR = doIter && Symbol.iterator || Symbol("iterator not implemented");
    var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
    var isArrayBuffer = (b) => b instanceof ArrayBuffer || typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
    var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
    var Pipe = class {
      constructor(src, dest, opts) {
        this.src = src;
        this.dest = dest;
        this.opts = opts;
        this.ondrain = () => src[RESUME]();
        dest.on("drain", this.ondrain);
      }
      unpipe() {
        this.dest.removeListener("drain", this.ondrain);
      }
      // istanbul ignore next - only here for the prototype
      proxyErrors() {
      }
      end() {
        this.unpipe();
        if (this.opts.end)
          this.dest.end();
      }
    };
    var PipeProxyErrors = class extends Pipe {
      unpipe() {
        this.src.removeListener("error", this.proxyErrors);
        super.unpipe();
      }
      constructor(src, dest, opts) {
        super(src, dest, opts);
        this.proxyErrors = (er) => dest.emit("error", er);
        src.on("error", this.proxyErrors);
      }
    };
    var Minipass = class _Minipass extends Stream {
      constructor(options) {
        super();
        this[FLOWING] = false;
        this[PAUSED] = false;
        this[PIPES] = [];
        this[BUFFER] = [];
        this[OBJECTMODE] = options && options.objectMode || false;
        if (this[OBJECTMODE])
          this[ENCODING] = null;
        else
          this[ENCODING] = options && options.encoding || null;
        if (this[ENCODING] === "buffer")
          this[ENCODING] = null;
        this[ASYNC] = options && !!options.async || false;
        this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
        this[EOF] = false;
        this[EMITTED_END] = false;
        this[EMITTING_END] = false;
        this[CLOSED] = false;
        this[EMITTED_ERROR] = null;
        this.writable = true;
        this.readable = true;
        this[BUFFERLENGTH] = 0;
        this[DESTROYED] = false;
        if (options && options.debugExposeBuffer === true) {
          Object.defineProperty(this, "buffer", { get: () => this[BUFFER] });
        }
        if (options && options.debugExposePipes === true) {
          Object.defineProperty(this, "pipes", { get: () => this[PIPES] });
        }
        this[SIGNAL] = options && options.signal;
        this[ABORTED] = false;
        if (this[SIGNAL]) {
          this[SIGNAL].addEventListener("abort", () => this[ABORT]());
          if (this[SIGNAL].aborted) {
            this[ABORT]();
          }
        }
      }
      get bufferLength() {
        return this[BUFFERLENGTH];
      }
      get encoding() {
        return this[ENCODING];
      }
      set encoding(enc) {
        if (this[OBJECTMODE])
          throw new Error("cannot set encoding in objectMode");
        if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))
          throw new Error("cannot change encoding");
        if (this[ENCODING] !== enc) {
          this[DECODER] = enc ? new SD(enc) : null;
          if (this[BUFFER].length)
            this[BUFFER] = this[BUFFER].map((chunk) => this[DECODER].write(chunk));
        }
        this[ENCODING] = enc;
      }
      setEncoding(enc) {
        this.encoding = enc;
      }
      get objectMode() {
        return this[OBJECTMODE];
      }
      set objectMode(om) {
        this[OBJECTMODE] = this[OBJECTMODE] || !!om;
      }
      get ["async"]() {
        return this[ASYNC];
      }
      set ["async"](a) {
        this[ASYNC] = this[ASYNC] || !!a;
      }
      // drop everything and get out of the flow completely
      [ABORT]() {
        this[ABORTED] = true;
        this.emit("abort", this[SIGNAL].reason);
        this.destroy(this[SIGNAL].reason);
      }
      get aborted() {
        return this[ABORTED];
      }
      set aborted(_) {
      }
      write(chunk, encoding, cb) {
        if (this[ABORTED])
          return false;
        if (this[EOF])
          throw new Error("write after end");
        if (this[DESTROYED]) {
          this.emit(
            "error",
            Object.assign(
              new Error("Cannot call write after a stream was destroyed"),
              { code: "ERR_STREAM_DESTROYED" }
            )
          );
          return true;
        }
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (!encoding)
          encoding = "utf8";
        const fn = this[ASYNC] ? defer6 : (f) => f();
        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
          if (isArrayBufferView(chunk))
            chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
          else if (isArrayBuffer(chunk))
            chunk = Buffer.from(chunk);
          else if (typeof chunk !== "string")
            this.objectMode = true;
        }
        if (this[OBJECTMODE]) {
          if (this.flowing && this[BUFFERLENGTH] !== 0)
            this[FLUSH](true);
          if (this.flowing)
            this.emit("data", chunk);
          else
            this[BUFFERPUSH](chunk);
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this.flowing;
        }
        if (!chunk.length) {
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this.flowing;
        }
        if (typeof chunk === "string" && // unless it is a string already ready for us to use
        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
          chunk = Buffer.from(chunk, encoding);
        }
        if (Buffer.isBuffer(chunk) && this[ENCODING])
          chunk = this[DECODER].write(chunk);
        if (this.flowing && this[BUFFERLENGTH] !== 0)
          this[FLUSH](true);
        if (this.flowing)
          this.emit("data", chunk);
        else
          this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this.flowing;
      }
      read(n) {
        if (this[DESTROYED])
          return null;
        if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
          this[MAYBE_EMIT_END]();
          return null;
        }
        if (this[OBJECTMODE])
          n = null;
        if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
          if (this.encoding)
            this[BUFFER] = [this[BUFFER].join("")];
          else
            this[BUFFER] = [Buffer.concat(this[BUFFER], this[BUFFERLENGTH])];
        }
        const ret = this[READ](n || null, this[BUFFER][0]);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [READ](n, chunk) {
        if (n === chunk.length || n === null)
          this[BUFFERSHIFT]();
        else {
          this[BUFFER][0] = chunk.slice(n);
          chunk = chunk.slice(0, n);
          this[BUFFERLENGTH] -= n;
        }
        this.emit("data", chunk);
        if (!this[BUFFER].length && !this[EOF])
          this.emit("drain");
        return chunk;
      }
      end(chunk, encoding, cb) {
        if (typeof chunk === "function")
          cb = chunk, chunk = null;
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (chunk)
          this.write(chunk, encoding);
        if (cb)
          this.once("end", cb);
        this[EOF] = true;
        this.writable = false;
        if (this.flowing || !this[PAUSED])
          this[MAYBE_EMIT_END]();
        return this;
      }
      // don't let the internal resume be overwritten
      [RESUME]() {
        if (this[DESTROYED])
          return;
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit("resume");
        if (this[BUFFER].length)
          this[FLUSH]();
        else if (this[EOF])
          this[MAYBE_EMIT_END]();
        else
          this.emit("drain");
      }
      resume() {
        return this[RESUME]();
      }
      pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
      }
      get destroyed() {
        return this[DESTROYED];
      }
      get flowing() {
        return this[FLOWING];
      }
      get paused() {
        return this[PAUSED];
      }
      [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] += 1;
        else
          this[BUFFERLENGTH] += chunk.length;
        this[BUFFER].push(chunk);
      }
      [BUFFERSHIFT]() {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] -= 1;
        else
          this[BUFFERLENGTH] -= this[BUFFER][0].length;
        return this[BUFFER].shift();
      }
      [FLUSH](noDrain) {
        do {
        } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);
        if (!noDrain && !this[BUFFER].length && !this[EOF])
          this.emit("drain");
      }
      [FLUSHCHUNK](chunk) {
        this.emit("data", chunk);
        return this.flowing;
      }
      pipe(dest, opts) {
        if (this[DESTROYED])
          return;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === proc.stdout || dest === proc.stderr)
          opts.end = false;
        else
          opts.end = opts.end !== false;
        opts.proxyErrors = !!opts.proxyErrors;
        if (ended) {
          if (opts.end)
            dest.end();
        } else {
          this[PIPES].push(
            !opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts)
          );
          if (this[ASYNC])
            defer6(() => this[RESUME]());
          else
            this[RESUME]();
        }
        return dest;
      }
      unpipe(dest) {
        const p = this[PIPES].find((p2) => p2.dest === dest);
        if (p) {
          this[PIPES].splice(this[PIPES].indexOf(p), 1);
          p.unpipe();
        }
      }
      addListener(ev, fn) {
        return this.on(ev, fn);
      }
      on(ev, fn) {
        const ret = super.on(ev, fn);
        if (ev === "data" && !this[PIPES].length && !this.flowing)
          this[RESUME]();
        else if (ev === "readable" && this[BUFFERLENGTH] !== 0)
          super.emit("readable");
        else if (isEndish(ev) && this[EMITTED_END]) {
          super.emit(ev);
          this.removeAllListeners(ev);
        } else if (ev === "error" && this[EMITTED_ERROR]) {
          if (this[ASYNC])
            defer6(() => fn.call(this, this[EMITTED_ERROR]));
          else
            fn.call(this, this[EMITTED_ERROR]);
        }
        return ret;
      }
      get emittedEnd() {
        return this[EMITTED_END];
      }
      [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {
          this[EMITTING_END] = true;
          this.emit("end");
          this.emit("prefinish");
          this.emit("finish");
          if (this[CLOSED])
            this.emit("close");
          this[EMITTING_END] = false;
        }
      }
      emit(ev, data, ...extra) {
        if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED])
          return;
        else if (ev === "data") {
          return !this[OBJECTMODE] && !data ? false : this[ASYNC] ? defer6(() => this[EMITDATA](data)) : this[EMITDATA](data);
        } else if (ev === "end") {
          return this[EMITEND]();
        } else if (ev === "close") {
          this[CLOSED] = true;
          if (!this[EMITTED_END] && !this[DESTROYED])
            return;
          const ret2 = super.emit("close");
          this.removeAllListeners("close");
          return ret2;
        } else if (ev === "error") {
          this[EMITTED_ERROR] = data;
          super.emit(ERROR, data);
          const ret2 = !this[SIGNAL] || this.listeners("error").length ? super.emit("error", data) : false;
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "resume") {
          const ret2 = super.emit("resume");
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "finish" || ev === "prefinish") {
          const ret2 = super.emit(ev);
          this.removeAllListeners(ev);
          return ret2;
        }
        const ret = super.emit(ev, data, ...extra);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITDATA](data) {
        for (const p of this[PIPES]) {
          if (p.dest.write(data) === false)
            this.pause();
        }
        const ret = super.emit("data", data);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITEND]() {
        if (this[EMITTED_END])
          return;
        this[EMITTED_END] = true;
        this.readable = false;
        if (this[ASYNC])
          defer6(() => this[EMITEND2]());
        else
          this[EMITEND2]();
      }
      [EMITEND2]() {
        if (this[DECODER]) {
          const data = this[DECODER].end();
          if (data) {
            for (const p of this[PIPES]) {
              p.dest.write(data);
            }
            super.emit("data", data);
          }
        }
        for (const p of this[PIPES]) {
          p.end();
        }
        const ret = super.emit("end");
        this.removeAllListeners("end");
        return ret;
      }
      // const all = await stream.collect()
      collect() {
        const buf = [];
        if (!this[OBJECTMODE])
          buf.dataLength = 0;
        const p = this.promise();
        this.on("data", (c) => {
          buf.push(c);
          if (!this[OBJECTMODE])
            buf.dataLength += c.length;
        });
        return p.then(() => buf);
      }
      // const data = await stream.concat()
      concat() {
        return this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this.collect().then(
          (buf) => this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength)
        );
      }
      // stream.promise().then(() => done, er => emitted error)
      promise() {
        return new Promise((resolve2, reject) => {
          this.on(DESTROYED, () => reject(new Error("stream destroyed")));
          this.on("error", (er) => reject(er));
          this.on("end", () => resolve2());
        });
      }
      // for await (let chunk of stream)
      [ASYNCITERATOR]() {
        let stopped = false;
        const stop = () => {
          this.pause();
          stopped = true;
          return Promise.resolve({ done: true });
        };
        const next2 = () => {
          if (stopped)
            return stop();
          const res = this.read();
          if (res !== null)
            return Promise.resolve({ done: false, value: res });
          if (this[EOF])
            return stop();
          let resolve2 = null;
          let reject = null;
          const onerr = (er) => {
            this.removeListener("data", ondata);
            this.removeListener("end", onend);
            this.removeListener(DESTROYED, ondestroy);
            stop();
            reject(er);
          };
          const ondata = (value4) => {
            this.removeListener("error", onerr);
            this.removeListener("end", onend);
            this.removeListener(DESTROYED, ondestroy);
            this.pause();
            resolve2({ value: value4, done: !!this[EOF] });
          };
          const onend = () => {
            this.removeListener("error", onerr);
            this.removeListener("data", ondata);
            this.removeListener(DESTROYED, ondestroy);
            stop();
            resolve2({ done: true });
          };
          const ondestroy = () => onerr(new Error("stream destroyed"));
          return new Promise((res2, rej) => {
            reject = rej;
            resolve2 = res2;
            this.once(DESTROYED, ondestroy);
            this.once("error", onerr);
            this.once("end", onend);
            this.once("data", ondata);
          });
        };
        return {
          next: next2,
          throw: stop,
          return: stop,
          [ASYNCITERATOR]() {
            return this;
          }
        };
      }
      // for (let chunk of stream)
      [ITERATOR]() {
        let stopped = false;
        const stop = () => {
          this.pause();
          this.removeListener(ERROR, stop);
          this.removeListener(DESTROYED, stop);
          this.removeListener("end", stop);
          stopped = true;
          return { done: true };
        };
        const next2 = () => {
          if (stopped)
            return stop();
          const value4 = this.read();
          return value4 === null ? stop() : { value: value4 };
        };
        this.once("end", stop);
        this.once(ERROR, stop);
        this.once(DESTROYED, stop);
        return {
          next: next2,
          throw: stop,
          return: stop,
          [ITERATOR]() {
            return this;
          }
        };
      }
      destroy(er) {
        if (this[DESTROYED]) {
          if (er)
            this.emit("error", er);
          else
            this.emit(DESTROYED);
          return this;
        }
        this[DESTROYED] = true;
        this[BUFFER].length = 0;
        this[BUFFERLENGTH] = 0;
        if (typeof this.close === "function" && !this[CLOSED])
          this.close();
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      static isStream(s) {
        return !!s && (s instanceof _Minipass || s instanceof Stream || s instanceof EE && // readable
        (typeof s.pipe === "function" || // writable
        typeof s.write === "function" && typeof s.end === "function"));
      }
    };
    exports.Minipass = Minipass;
  }
});

// node_modules/minizlib/constants.js
var require_constants4 = __commonJS({
  "node_modules/minizlib/constants.js"(exports, module) {
    var realZlibConstants = __require("zlib").constants || /* istanbul ignore next */
    { ZLIB_VERNUM: 4736 };
    module.exports = Object.freeze(Object.assign(/* @__PURE__ */ Object.create(null), {
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_MEM_ERROR: -4,
      Z_BUF_ERROR: -5,
      Z_VERSION_ERROR: -6,
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      DEFLATE: 1,
      INFLATE: 2,
      GZIP: 3,
      GUNZIP: 4,
      DEFLATERAW: 5,
      INFLATERAW: 6,
      UNZIP: 7,
      BROTLI_DECODE: 8,
      BROTLI_ENCODE: 9,
      Z_MIN_WINDOWBITS: 8,
      Z_MAX_WINDOWBITS: 15,
      Z_DEFAULT_WINDOWBITS: 15,
      Z_MIN_CHUNK: 64,
      Z_MAX_CHUNK: Infinity,
      Z_DEFAULT_CHUNK: 16384,
      Z_MIN_MEMLEVEL: 1,
      Z_MAX_MEMLEVEL: 9,
      Z_DEFAULT_MEMLEVEL: 8,
      Z_MIN_LEVEL: -1,
      Z_MAX_LEVEL: 9,
      Z_DEFAULT_LEVEL: -1,
      BROTLI_OPERATION_PROCESS: 0,
      BROTLI_OPERATION_FLUSH: 1,
      BROTLI_OPERATION_FINISH: 2,
      BROTLI_OPERATION_EMIT_METADATA: 3,
      BROTLI_MODE_GENERIC: 0,
      BROTLI_MODE_TEXT: 1,
      BROTLI_MODE_FONT: 2,
      BROTLI_DEFAULT_MODE: 0,
      BROTLI_MIN_QUALITY: 0,
      BROTLI_MAX_QUALITY: 11,
      BROTLI_DEFAULT_QUALITY: 11,
      BROTLI_MIN_WINDOW_BITS: 10,
      BROTLI_MAX_WINDOW_BITS: 24,
      BROTLI_LARGE_MAX_WINDOW_BITS: 30,
      BROTLI_DEFAULT_WINDOW: 22,
      BROTLI_MIN_INPUT_BLOCK_BITS: 16,
      BROTLI_MAX_INPUT_BLOCK_BITS: 24,
      BROTLI_PARAM_MODE: 0,
      BROTLI_PARAM_QUALITY: 1,
      BROTLI_PARAM_LGWIN: 2,
      BROTLI_PARAM_LGBLOCK: 3,
      BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
      BROTLI_PARAM_SIZE_HINT: 5,
      BROTLI_PARAM_LARGE_WINDOW: 6,
      BROTLI_PARAM_NPOSTFIX: 7,
      BROTLI_PARAM_NDIRECT: 8,
      BROTLI_DECODER_RESULT_ERROR: 0,
      BROTLI_DECODER_RESULT_SUCCESS: 1,
      BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
      BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
      BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
      BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
      BROTLI_DECODER_NO_ERROR: 0,
      BROTLI_DECODER_SUCCESS: 1,
      BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
      BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
      BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
      BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
      BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
      BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
      BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
      BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
      BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
      BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
      BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
      BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
      BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
      BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
      BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
      BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
      BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
      BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
      BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
      BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
      BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
      BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
      BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
      BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
      BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
      BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
      BROTLI_DECODER_ERROR_UNREACHABLE: -31
    }, realZlibConstants));
  }
});

// node_modules/minizlib/node_modules/minipass/index.js
var require_minipass2 = __commonJS({
  "node_modules/minizlib/node_modules/minipass/index.js"(exports, module) {
    "use strict";
    var proc = typeof process === "object" && process ? process : {
      stdout: null,
      stderr: null
    };
    var EE = __require("events");
    var Stream = __require("stream");
    var SD = __require("string_decoder").StringDecoder;
    var EOF = Symbol("EOF");
    var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
    var EMITTED_END = Symbol("emittedEnd");
    var EMITTING_END = Symbol("emittingEnd");
    var EMITTED_ERROR = Symbol("emittedError");
    var CLOSED = Symbol("closed");
    var READ = Symbol("read");
    var FLUSH = Symbol("flush");
    var FLUSHCHUNK = Symbol("flushChunk");
    var ENCODING = Symbol("encoding");
    var DECODER = Symbol("decoder");
    var FLOWING = Symbol("flowing");
    var PAUSED = Symbol("paused");
    var RESUME = Symbol("resume");
    var BUFFERLENGTH = Symbol("bufferLength");
    var BUFFERPUSH = Symbol("bufferPush");
    var BUFFERSHIFT = Symbol("bufferShift");
    var OBJECTMODE = Symbol("objectMode");
    var DESTROYED = Symbol("destroyed");
    var EMITDATA = Symbol("emitData");
    var EMITEND = Symbol("emitEnd");
    var EMITEND2 = Symbol("emitEnd2");
    var ASYNC = Symbol("async");
    var defer6 = (fn) => Promise.resolve().then(fn);
    var doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
    var ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol("asyncIterator not implemented");
    var ITERATOR = doIter && Symbol.iterator || Symbol("iterator not implemented");
    var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
    var isArrayBuffer = (b) => b instanceof ArrayBuffer || typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
    var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
    var Pipe = class {
      constructor(src, dest, opts) {
        this.src = src;
        this.dest = dest;
        this.opts = opts;
        this.ondrain = () => src[RESUME]();
        dest.on("drain", this.ondrain);
      }
      unpipe() {
        this.dest.removeListener("drain", this.ondrain);
      }
      // istanbul ignore next - only here for the prototype
      proxyErrors() {
      }
      end() {
        this.unpipe();
        if (this.opts.end)
          this.dest.end();
      }
    };
    var PipeProxyErrors = class extends Pipe {
      unpipe() {
        this.src.removeListener("error", this.proxyErrors);
        super.unpipe();
      }
      constructor(src, dest, opts) {
        super(src, dest, opts);
        this.proxyErrors = (er) => dest.emit("error", er);
        src.on("error", this.proxyErrors);
      }
    };
    module.exports = class Minipass extends Stream {
      constructor(options) {
        super();
        this[FLOWING] = false;
        this[PAUSED] = false;
        this.pipes = [];
        this.buffer = [];
        this[OBJECTMODE] = options && options.objectMode || false;
        if (this[OBJECTMODE])
          this[ENCODING] = null;
        else
          this[ENCODING] = options && options.encoding || null;
        if (this[ENCODING] === "buffer")
          this[ENCODING] = null;
        this[ASYNC] = options && !!options.async || false;
        this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
        this[EOF] = false;
        this[EMITTED_END] = false;
        this[EMITTING_END] = false;
        this[CLOSED] = false;
        this[EMITTED_ERROR] = null;
        this.writable = true;
        this.readable = true;
        this[BUFFERLENGTH] = 0;
        this[DESTROYED] = false;
      }
      get bufferLength() {
        return this[BUFFERLENGTH];
      }
      get encoding() {
        return this[ENCODING];
      }
      set encoding(enc) {
        if (this[OBJECTMODE])
          throw new Error("cannot set encoding in objectMode");
        if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))
          throw new Error("cannot change encoding");
        if (this[ENCODING] !== enc) {
          this[DECODER] = enc ? new SD(enc) : null;
          if (this.buffer.length)
            this.buffer = this.buffer.map((chunk) => this[DECODER].write(chunk));
        }
        this[ENCODING] = enc;
      }
      setEncoding(enc) {
        this.encoding = enc;
      }
      get objectMode() {
        return this[OBJECTMODE];
      }
      set objectMode(om) {
        this[OBJECTMODE] = this[OBJECTMODE] || !!om;
      }
      get ["async"]() {
        return this[ASYNC];
      }
      set ["async"](a) {
        this[ASYNC] = this[ASYNC] || !!a;
      }
      write(chunk, encoding, cb) {
        if (this[EOF])
          throw new Error("write after end");
        if (this[DESTROYED]) {
          this.emit("error", Object.assign(
            new Error("Cannot call write after a stream was destroyed"),
            { code: "ERR_STREAM_DESTROYED" }
          ));
          return true;
        }
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (!encoding)
          encoding = "utf8";
        const fn = this[ASYNC] ? defer6 : (f) => f();
        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
          if (isArrayBufferView(chunk))
            chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
          else if (isArrayBuffer(chunk))
            chunk = Buffer.from(chunk);
          else if (typeof chunk !== "string")
            this.objectMode = true;
        }
        if (this[OBJECTMODE]) {
          if (this.flowing && this[BUFFERLENGTH] !== 0)
            this[FLUSH](true);
          if (this.flowing)
            this.emit("data", chunk);
          else
            this[BUFFERPUSH](chunk);
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this.flowing;
        }
        if (!chunk.length) {
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this.flowing;
        }
        if (typeof chunk === "string" && // unless it is a string already ready for us to use
        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
          chunk = Buffer.from(chunk, encoding);
        }
        if (Buffer.isBuffer(chunk) && this[ENCODING])
          chunk = this[DECODER].write(chunk);
        if (this.flowing && this[BUFFERLENGTH] !== 0)
          this[FLUSH](true);
        if (this.flowing)
          this.emit("data", chunk);
        else
          this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this.flowing;
      }
      read(n) {
        if (this[DESTROYED])
          return null;
        if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
          this[MAYBE_EMIT_END]();
          return null;
        }
        if (this[OBJECTMODE])
          n = null;
        if (this.buffer.length > 1 && !this[OBJECTMODE]) {
          if (this.encoding)
            this.buffer = [this.buffer.join("")];
          else
            this.buffer = [Buffer.concat(this.buffer, this[BUFFERLENGTH])];
        }
        const ret = this[READ](n || null, this.buffer[0]);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [READ](n, chunk) {
        if (n === chunk.length || n === null)
          this[BUFFERSHIFT]();
        else {
          this.buffer[0] = chunk.slice(n);
          chunk = chunk.slice(0, n);
          this[BUFFERLENGTH] -= n;
        }
        this.emit("data", chunk);
        if (!this.buffer.length && !this[EOF])
          this.emit("drain");
        return chunk;
      }
      end(chunk, encoding, cb) {
        if (typeof chunk === "function")
          cb = chunk, chunk = null;
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (chunk)
          this.write(chunk, encoding);
        if (cb)
          this.once("end", cb);
        this[EOF] = true;
        this.writable = false;
        if (this.flowing || !this[PAUSED])
          this[MAYBE_EMIT_END]();
        return this;
      }
      // don't let the internal resume be overwritten
      [RESUME]() {
        if (this[DESTROYED])
          return;
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit("resume");
        if (this.buffer.length)
          this[FLUSH]();
        else if (this[EOF])
          this[MAYBE_EMIT_END]();
        else
          this.emit("drain");
      }
      resume() {
        return this[RESUME]();
      }
      pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
      }
      get destroyed() {
        return this[DESTROYED];
      }
      get flowing() {
        return this[FLOWING];
      }
      get paused() {
        return this[PAUSED];
      }
      [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] += 1;
        else
          this[BUFFERLENGTH] += chunk.length;
        this.buffer.push(chunk);
      }
      [BUFFERSHIFT]() {
        if (this.buffer.length) {
          if (this[OBJECTMODE])
            this[BUFFERLENGTH] -= 1;
          else
            this[BUFFERLENGTH] -= this.buffer[0].length;
        }
        return this.buffer.shift();
      }
      [FLUSH](noDrain) {
        do {
        } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));
        if (!noDrain && !this.buffer.length && !this[EOF])
          this.emit("drain");
      }
      [FLUSHCHUNK](chunk) {
        return chunk ? (this.emit("data", chunk), this.flowing) : false;
      }
      pipe(dest, opts) {
        if (this[DESTROYED])
          return;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === proc.stdout || dest === proc.stderr)
          opts.end = false;
        else
          opts.end = opts.end !== false;
        opts.proxyErrors = !!opts.proxyErrors;
        if (ended) {
          if (opts.end)
            dest.end();
        } else {
          this.pipes.push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
          if (this[ASYNC])
            defer6(() => this[RESUME]());
          else
            this[RESUME]();
        }
        return dest;
      }
      unpipe(dest) {
        const p = this.pipes.find((p2) => p2.dest === dest);
        if (p) {
          this.pipes.splice(this.pipes.indexOf(p), 1);
          p.unpipe();
        }
      }
      addListener(ev, fn) {
        return this.on(ev, fn);
      }
      on(ev, fn) {
        const ret = super.on(ev, fn);
        if (ev === "data" && !this.pipes.length && !this.flowing)
          this[RESUME]();
        else if (ev === "readable" && this[BUFFERLENGTH] !== 0)
          super.emit("readable");
        else if (isEndish(ev) && this[EMITTED_END]) {
          super.emit(ev);
          this.removeAllListeners(ev);
        } else if (ev === "error" && this[EMITTED_ERROR]) {
          if (this[ASYNC])
            defer6(() => fn.call(this, this[EMITTED_ERROR]));
          else
            fn.call(this, this[EMITTED_ERROR]);
        }
        return ret;
      }
      get emittedEnd() {
        return this[EMITTED_END];
      }
      [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this.buffer.length === 0 && this[EOF]) {
          this[EMITTING_END] = true;
          this.emit("end");
          this.emit("prefinish");
          this.emit("finish");
          if (this[CLOSED])
            this.emit("close");
          this[EMITTING_END] = false;
        }
      }
      emit(ev, data, ...extra) {
        if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED])
          return;
        else if (ev === "data") {
          return !data ? false : this[ASYNC] ? defer6(() => this[EMITDATA](data)) : this[EMITDATA](data);
        } else if (ev === "end") {
          return this[EMITEND]();
        } else if (ev === "close") {
          this[CLOSED] = true;
          if (!this[EMITTED_END] && !this[DESTROYED])
            return;
          const ret2 = super.emit("close");
          this.removeAllListeners("close");
          return ret2;
        } else if (ev === "error") {
          this[EMITTED_ERROR] = data;
          const ret2 = super.emit("error", data);
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "resume") {
          const ret2 = super.emit("resume");
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "finish" || ev === "prefinish") {
          const ret2 = super.emit(ev);
          this.removeAllListeners(ev);
          return ret2;
        }
        const ret = super.emit(ev, data, ...extra);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITDATA](data) {
        for (const p of this.pipes) {
          if (p.dest.write(data) === false)
            this.pause();
        }
        const ret = super.emit("data", data);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITEND]() {
        if (this[EMITTED_END])
          return;
        this[EMITTED_END] = true;
        this.readable = false;
        if (this[ASYNC])
          defer6(() => this[EMITEND2]());
        else
          this[EMITEND2]();
      }
      [EMITEND2]() {
        if (this[DECODER]) {
          const data = this[DECODER].end();
          if (data) {
            for (const p of this.pipes) {
              p.dest.write(data);
            }
            super.emit("data", data);
          }
        }
        for (const p of this.pipes) {
          p.end();
        }
        const ret = super.emit("end");
        this.removeAllListeners("end");
        return ret;
      }
      // const all = await stream.collect()
      collect() {
        const buf = [];
        if (!this[OBJECTMODE])
          buf.dataLength = 0;
        const p = this.promise();
        this.on("data", (c) => {
          buf.push(c);
          if (!this[OBJECTMODE])
            buf.dataLength += c.length;
        });
        return p.then(() => buf);
      }
      // const data = await stream.concat()
      concat() {
        return this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this.collect().then((buf) => this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength));
      }
      // stream.promise().then(() => done, er => emitted error)
      promise() {
        return new Promise((resolve2, reject) => {
          this.on(DESTROYED, () => reject(new Error("stream destroyed")));
          this.on("error", (er) => reject(er));
          this.on("end", () => resolve2());
        });
      }
      // for await (let chunk of stream)
      [ASYNCITERATOR]() {
        const next2 = () => {
          const res = this.read();
          if (res !== null)
            return Promise.resolve({ done: false, value: res });
          if (this[EOF])
            return Promise.resolve({ done: true });
          let resolve2 = null;
          let reject = null;
          const onerr = (er) => {
            this.removeListener("data", ondata);
            this.removeListener("end", onend);
            reject(er);
          };
          const ondata = (value4) => {
            this.removeListener("error", onerr);
            this.removeListener("end", onend);
            this.pause();
            resolve2({ value: value4, done: !!this[EOF] });
          };
          const onend = () => {
            this.removeListener("error", onerr);
            this.removeListener("data", ondata);
            resolve2({ done: true });
          };
          const ondestroy = () => onerr(new Error("stream destroyed"));
          return new Promise((res2, rej) => {
            reject = rej;
            resolve2 = res2;
            this.once(DESTROYED, ondestroy);
            this.once("error", onerr);
            this.once("end", onend);
            this.once("data", ondata);
          });
        };
        return { next: next2 };
      }
      // for (let chunk of stream)
      [ITERATOR]() {
        const next2 = () => {
          const value4 = this.read();
          const done = value4 === null;
          return { value: value4, done };
        };
        return { next: next2 };
      }
      destroy(er) {
        if (this[DESTROYED]) {
          if (er)
            this.emit("error", er);
          else
            this.emit(DESTROYED);
          return this;
        }
        this[DESTROYED] = true;
        this.buffer.length = 0;
        this[BUFFERLENGTH] = 0;
        if (typeof this.close === "function" && !this[CLOSED])
          this.close();
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      static isStream(s) {
        return !!s && (s instanceof Minipass || s instanceof Stream || s instanceof EE && (typeof s.pipe === "function" || // readable
        typeof s.write === "function" && typeof s.end === "function"));
      }
    };
  }
});

// node_modules/minizlib/index.js
var require_minizlib = __commonJS({
  "node_modules/minizlib/index.js"(exports) {
    "use strict";
    var assert = __require("assert");
    var Buffer2 = __require("buffer").Buffer;
    var realZlib = __require("zlib");
    var constants4 = exports.constants = require_constants4();
    var Minipass = require_minipass2();
    var OriginalBufferConcat = Buffer2.concat;
    var _superWrite = Symbol("_superWrite");
    var ZlibError = class extends Error {
      constructor(err) {
        super("zlib: " + err.message);
        this.code = err.code;
        this.errno = err.errno;
        if (!this.code)
          this.code = "ZLIB_ERROR";
        this.message = "zlib: " + err.message;
        Error.captureStackTrace(this, this.constructor);
      }
      get name() {
        return "ZlibError";
      }
    };
    var _opts = Symbol("opts");
    var _flushFlag = Symbol("flushFlag");
    var _finishFlushFlag = Symbol("finishFlushFlag");
    var _fullFlushFlag = Symbol("fullFlushFlag");
    var _handle = Symbol("handle");
    var _onError = Symbol("onError");
    var _sawError = Symbol("sawError");
    var _level = Symbol("level");
    var _strategy = Symbol("strategy");
    var _ended = Symbol("ended");
    var _defaultFullFlush = Symbol("_defaultFullFlush");
    var ZlibBase = class extends Minipass {
      constructor(opts, mode) {
        if (!opts || typeof opts !== "object")
          throw new TypeError("invalid options for ZlibBase constructor");
        super(opts);
        this[_sawError] = false;
        this[_ended] = false;
        this[_opts] = opts;
        this[_flushFlag] = opts.flush;
        this[_finishFlushFlag] = opts.finishFlush;
        try {
          this[_handle] = new realZlib[mode](opts);
        } catch (er) {
          throw new ZlibError(er);
        }
        this[_onError] = (err) => {
          if (this[_sawError])
            return;
          this[_sawError] = true;
          this.close();
          this.emit("error", err);
        };
        this[_handle].on("error", (er) => this[_onError](new ZlibError(er)));
        this.once("end", () => this.close);
      }
      close() {
        if (this[_handle]) {
          this[_handle].close();
          this[_handle] = null;
          this.emit("close");
        }
      }
      reset() {
        if (!this[_sawError]) {
          assert(this[_handle], "zlib binding closed");
          return this[_handle].reset();
        }
      }
      flush(flushFlag) {
        if (this.ended)
          return;
        if (typeof flushFlag !== "number")
          flushFlag = this[_fullFlushFlag];
        this.write(Object.assign(Buffer2.alloc(0), { [_flushFlag]: flushFlag }));
      }
      end(chunk, encoding, cb) {
        if (chunk)
          this.write(chunk, encoding);
        this.flush(this[_finishFlushFlag]);
        this[_ended] = true;
        return super.end(null, null, cb);
      }
      get ended() {
        return this[_ended];
      }
      write(chunk, encoding, cb) {
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (typeof chunk === "string")
          chunk = Buffer2.from(chunk, encoding);
        if (this[_sawError])
          return;
        assert(this[_handle], "zlib binding closed");
        const nativeHandle = this[_handle]._handle;
        const originalNativeClose = nativeHandle.close;
        nativeHandle.close = () => {
        };
        const originalClose = this[_handle].close;
        this[_handle].close = () => {
        };
        Buffer2.concat = (args) => args;
        let result;
        try {
          const flushFlag = typeof chunk[_flushFlag] === "number" ? chunk[_flushFlag] : this[_flushFlag];
          result = this[_handle]._processChunk(chunk, flushFlag);
          Buffer2.concat = OriginalBufferConcat;
        } catch (err) {
          Buffer2.concat = OriginalBufferConcat;
          this[_onError](new ZlibError(err));
        } finally {
          if (this[_handle]) {
            this[_handle]._handle = nativeHandle;
            nativeHandle.close = originalNativeClose;
            this[_handle].close = originalClose;
            this[_handle].removeAllListeners("error");
          }
        }
        if (this[_handle])
          this[_handle].on("error", (er) => this[_onError](new ZlibError(er)));
        let writeReturn;
        if (result) {
          if (Array.isArray(result) && result.length > 0) {
            writeReturn = this[_superWrite](Buffer2.from(result[0]));
            for (let i = 1; i < result.length; i++) {
              writeReturn = this[_superWrite](result[i]);
            }
          } else {
            writeReturn = this[_superWrite](Buffer2.from(result));
          }
        }
        if (cb)
          cb();
        return writeReturn;
      }
      [_superWrite](data) {
        return super.write(data);
      }
    };
    var Zlib = class extends ZlibBase {
      constructor(opts, mode) {
        opts = opts || {};
        opts.flush = opts.flush || constants4.Z_NO_FLUSH;
        opts.finishFlush = opts.finishFlush || constants4.Z_FINISH;
        super(opts, mode);
        this[_fullFlushFlag] = constants4.Z_FULL_FLUSH;
        this[_level] = opts.level;
        this[_strategy] = opts.strategy;
      }
      params(level, strategy) {
        if (this[_sawError])
          return;
        if (!this[_handle])
          throw new Error("cannot switch params when binding is closed");
        if (!this[_handle].params)
          throw new Error("not supported in this implementation");
        if (this[_level] !== level || this[_strategy] !== strategy) {
          this.flush(constants4.Z_SYNC_FLUSH);
          assert(this[_handle], "zlib binding closed");
          const origFlush = this[_handle].flush;
          this[_handle].flush = (flushFlag, cb) => {
            this.flush(flushFlag);
            cb();
          };
          try {
            this[_handle].params(level, strategy);
          } finally {
            this[_handle].flush = origFlush;
          }
          if (this[_handle]) {
            this[_level] = level;
            this[_strategy] = strategy;
          }
        }
      }
    };
    var Deflate = class extends Zlib {
      constructor(opts) {
        super(opts, "Deflate");
      }
    };
    var Inflate = class extends Zlib {
      constructor(opts) {
        super(opts, "Inflate");
      }
    };
    var _portable = Symbol("_portable");
    var Gzip = class extends Zlib {
      constructor(opts) {
        super(opts, "Gzip");
        this[_portable] = opts && !!opts.portable;
      }
      [_superWrite](data) {
        if (!this[_portable])
          return super[_superWrite](data);
        this[_portable] = false;
        data[9] = 255;
        return super[_superWrite](data);
      }
    };
    var Gunzip = class extends Zlib {
      constructor(opts) {
        super(opts, "Gunzip");
      }
    };
    var DeflateRaw = class extends Zlib {
      constructor(opts) {
        super(opts, "DeflateRaw");
      }
    };
    var InflateRaw = class extends Zlib {
      constructor(opts) {
        super(opts, "InflateRaw");
      }
    };
    var Unzip = class extends Zlib {
      constructor(opts) {
        super(opts, "Unzip");
      }
    };
    var Brotli = class extends ZlibBase {
      constructor(opts, mode) {
        opts = opts || {};
        opts.flush = opts.flush || constants4.BROTLI_OPERATION_PROCESS;
        opts.finishFlush = opts.finishFlush || constants4.BROTLI_OPERATION_FINISH;
        super(opts, mode);
        this[_fullFlushFlag] = constants4.BROTLI_OPERATION_FLUSH;
      }
    };
    var BrotliCompress = class extends Brotli {
      constructor(opts) {
        super(opts, "BrotliCompress");
      }
    };
    var BrotliDecompress = class extends Brotli {
      constructor(opts) {
        super(opts, "BrotliDecompress");
      }
    };
    exports.Deflate = Deflate;
    exports.Inflate = Inflate;
    exports.Gzip = Gzip;
    exports.Gunzip = Gunzip;
    exports.DeflateRaw = DeflateRaw;
    exports.InflateRaw = InflateRaw;
    exports.Unzip = Unzip;
    if (typeof realZlib.BrotliCompress === "function") {
      exports.BrotliCompress = BrotliCompress;
      exports.BrotliDecompress = BrotliDecompress;
    } else {
      exports.BrotliCompress = exports.BrotliDecompress = class {
        constructor() {
          throw new Error("Brotli is not supported in this version of Node.js");
        }
      };
    }
  }
});

// node_modules/tar/lib/normalize-windows-path.js
var require_normalize_windows_path = __commonJS({
  "node_modules/tar/lib/normalize-windows-path.js"(exports, module) {
    var platform3 = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
    module.exports = platform3 !== "win32" ? (p) => p : (p) => p && p.replace(/\\/g, "/");
  }
});

// node_modules/tar/lib/read-entry.js
var require_read_entry = __commonJS({
  "node_modules/tar/lib/read-entry.js"(exports, module) {
    "use strict";
    var { Minipass } = require_minipass();
    var normPath = require_normalize_windows_path();
    var SLURP = Symbol("slurp");
    module.exports = class ReadEntry extends Minipass {
      constructor(header, ex, gex) {
        super();
        this.pause();
        this.extended = ex;
        this.globalExtended = gex;
        this.header = header;
        this.startBlockSize = 512 * Math.ceil(header.size / 512);
        this.blockRemain = this.startBlockSize;
        this.remain = header.size;
        this.type = header.type;
        this.meta = false;
        this.ignore = false;
        switch (this.type) {
          case "File":
          case "OldFile":
          case "Link":
          case "SymbolicLink":
          case "CharacterDevice":
          case "BlockDevice":
          case "Directory":
          case "FIFO":
          case "ContiguousFile":
          case "GNUDumpDir":
            break;
          case "NextFileHasLongLinkpath":
          case "NextFileHasLongPath":
          case "OldGnuLongPath":
          case "GlobalExtendedHeader":
          case "ExtendedHeader":
          case "OldExtendedHeader":
            this.meta = true;
            break;
          default:
            this.ignore = true;
        }
        this.path = normPath(header.path);
        this.mode = header.mode;
        if (this.mode) {
          this.mode = this.mode & 4095;
        }
        this.uid = header.uid;
        this.gid = header.gid;
        this.uname = header.uname;
        this.gname = header.gname;
        this.size = header.size;
        this.mtime = header.mtime;
        this.atime = header.atime;
        this.ctime = header.ctime;
        this.linkpath = normPath(header.linkpath);
        this.uname = header.uname;
        this.gname = header.gname;
        if (ex) {
          this[SLURP](ex);
        }
        if (gex) {
          this[SLURP](gex, true);
        }
      }
      write(data) {
        const writeLen = data.length;
        if (writeLen > this.blockRemain) {
          throw new Error("writing more to entry than is appropriate");
        }
        const r = this.remain;
        const br = this.blockRemain;
        this.remain = Math.max(0, r - writeLen);
        this.blockRemain = Math.max(0, br - writeLen);
        if (this.ignore) {
          return true;
        }
        if (r >= writeLen) {
          return super.write(data);
        }
        return super.write(data.slice(0, r));
      }
      [SLURP](ex, global3) {
        for (const k in ex) {
          if (ex[k] !== null && ex[k] !== void 0 && !(global3 && k === "path")) {
            this[k] = k === "path" || k === "linkpath" ? normPath(ex[k]) : ex[k];
          }
        }
      }
    };
  }
});

// node_modules/tar/lib/types.js
var require_types = __commonJS({
  "node_modules/tar/lib/types.js"(exports) {
    "use strict";
    exports.name = /* @__PURE__ */ new Map([
      ["0", "File"],
      // same as File
      ["", "OldFile"],
      ["1", "Link"],
      ["2", "SymbolicLink"],
      // Devices and FIFOs aren't fully supported
      // they are parsed, but skipped when unpacking
      ["3", "CharacterDevice"],
      ["4", "BlockDevice"],
      ["5", "Directory"],
      ["6", "FIFO"],
      // same as File
      ["7", "ContiguousFile"],
      // pax headers
      ["g", "GlobalExtendedHeader"],
      ["x", "ExtendedHeader"],
      // vendor-specific stuff
      // skip
      ["A", "SolarisACL"],
      // like 5, but with data, which should be skipped
      ["D", "GNUDumpDir"],
      // metadata only, skip
      ["I", "Inode"],
      // data = link path of next file
      ["K", "NextFileHasLongLinkpath"],
      // data = path of next file
      ["L", "NextFileHasLongPath"],
      // skip
      ["M", "ContinuationFile"],
      // like L
      ["N", "OldGnuLongPath"],
      // skip
      ["S", "SparseFile"],
      // skip
      ["V", "TapeVolumeHeader"],
      // like x
      ["X", "OldExtendedHeader"]
    ]);
    exports.code = new Map(Array.from(exports.name).map((kv) => [kv[1], kv[0]]));
  }
});

// node_modules/tar/lib/large-numbers.js
var require_large_numbers = __commonJS({
  "node_modules/tar/lib/large-numbers.js"(exports, module) {
    "use strict";
    var encode3 = (num, buf) => {
      if (!Number.isSafeInteger(num)) {
        throw Error("cannot encode number outside of javascript safe integer range");
      } else if (num < 0) {
        encodeNegative(num, buf);
      } else {
        encodePositive(num, buf);
      }
      return buf;
    };
    var encodePositive = (num, buf) => {
      buf[0] = 128;
      for (var i = buf.length; i > 1; i--) {
        buf[i - 1] = num & 255;
        num = Math.floor(num / 256);
      }
    };
    var encodeNegative = (num, buf) => {
      buf[0] = 255;
      var flipped = false;
      num = num * -1;
      for (var i = buf.length; i > 1; i--) {
        var byte = num & 255;
        num = Math.floor(num / 256);
        if (flipped) {
          buf[i - 1] = onesComp(byte);
        } else if (byte === 0) {
          buf[i - 1] = 0;
        } else {
          flipped = true;
          buf[i - 1] = twosComp(byte);
        }
      }
    };
    var parse10 = (buf) => {
      const pre = buf[0];
      const value4 = pre === 128 ? pos(buf.slice(1, buf.length)) : pre === 255 ? twos(buf) : null;
      if (value4 === null) {
        throw Error("invalid base256 encoding");
      }
      if (!Number.isSafeInteger(value4)) {
        throw Error("parsed number outside of javascript safe integer range");
      }
      return value4;
    };
    var twos = (buf) => {
      var len = buf.length;
      var sum3 = 0;
      var flipped = false;
      for (var i = len - 1; i > -1; i--) {
        var byte = buf[i];
        var f;
        if (flipped) {
          f = onesComp(byte);
        } else if (byte === 0) {
          f = byte;
        } else {
          flipped = true;
          f = twosComp(byte);
        }
        if (f !== 0) {
          sum3 -= f * Math.pow(256, len - i - 1);
        }
      }
      return sum3;
    };
    var pos = (buf) => {
      var len = buf.length;
      var sum3 = 0;
      for (var i = len - 1; i > -1; i--) {
        var byte = buf[i];
        if (byte !== 0) {
          sum3 += byte * Math.pow(256, len - i - 1);
        }
      }
      return sum3;
    };
    var onesComp = (byte) => (255 ^ byte) & 255;
    var twosComp = (byte) => (255 ^ byte) + 1 & 255;
    module.exports = {
      encode: encode3,
      parse: parse10
    };
  }
});

// node_modules/tar/lib/header.js
var require_header = __commonJS({
  "node_modules/tar/lib/header.js"(exports, module) {
    "use strict";
    var types = require_types();
    var pathModule = __require("path").posix;
    var large = require_large_numbers();
    var SLURP = Symbol("slurp");
    var TYPE = Symbol("type");
    var Header = class {
      constructor(data, off, ex, gex) {
        this.cksumValid = false;
        this.needPax = false;
        this.nullBlock = false;
        this.block = null;
        this.path = null;
        this.mode = null;
        this.uid = null;
        this.gid = null;
        this.size = null;
        this.mtime = null;
        this.cksum = null;
        this[TYPE] = "0";
        this.linkpath = null;
        this.uname = null;
        this.gname = null;
        this.devmaj = 0;
        this.devmin = 0;
        this.atime = null;
        this.ctime = null;
        if (Buffer.isBuffer(data)) {
          this.decode(data, off || 0, ex, gex);
        } else if (data) {
          this.set(data);
        }
      }
      decode(buf, off, ex, gex) {
        if (!off) {
          off = 0;
        }
        if (!buf || !(buf.length >= off + 512)) {
          throw new Error("need 512 bytes for header");
        }
        this.path = decString(buf, off, 100);
        this.mode = decNumber(buf, off + 100, 8);
        this.uid = decNumber(buf, off + 108, 8);
        this.gid = decNumber(buf, off + 116, 8);
        this.size = decNumber(buf, off + 124, 12);
        this.mtime = decDate(buf, off + 136, 12);
        this.cksum = decNumber(buf, off + 148, 12);
        this[SLURP](ex);
        this[SLURP](gex, true);
        this[TYPE] = decString(buf, off + 156, 1);
        if (this[TYPE] === "") {
          this[TYPE] = "0";
        }
        if (this[TYPE] === "0" && this.path.slice(-1) === "/") {
          this[TYPE] = "5";
        }
        if (this[TYPE] === "5") {
          this.size = 0;
        }
        this.linkpath = decString(buf, off + 157, 100);
        if (buf.slice(off + 257, off + 265).toString() === "ustar\x0000") {
          this.uname = decString(buf, off + 265, 32);
          this.gname = decString(buf, off + 297, 32);
          this.devmaj = decNumber(buf, off + 329, 8);
          this.devmin = decNumber(buf, off + 337, 8);
          if (buf[off + 475] !== 0) {
            const prefix4 = decString(buf, off + 345, 155);
            this.path = prefix4 + "/" + this.path;
          } else {
            const prefix4 = decString(buf, off + 345, 130);
            if (prefix4) {
              this.path = prefix4 + "/" + this.path;
            }
            this.atime = decDate(buf, off + 476, 12);
            this.ctime = decDate(buf, off + 488, 12);
          }
        }
        let sum3 = 8 * 32;
        for (let i = off; i < off + 148; i++) {
          sum3 += buf[i];
        }
        for (let i = off + 156; i < off + 512; i++) {
          sum3 += buf[i];
        }
        this.cksumValid = sum3 === this.cksum;
        if (this.cksum === null && sum3 === 8 * 32) {
          this.nullBlock = true;
        }
      }
      [SLURP](ex, global3) {
        for (const k in ex) {
          if (ex[k] !== null && ex[k] !== void 0 && !(global3 && k === "path")) {
            this[k] = ex[k];
          }
        }
      }
      encode(buf, off) {
        if (!buf) {
          buf = this.block = Buffer.alloc(512);
          off = 0;
        }
        if (!off) {
          off = 0;
        }
        if (!(buf.length >= off + 512)) {
          throw new Error("need 512 bytes for header");
        }
        const prefixSize = this.ctime || this.atime ? 130 : 155;
        const split3 = splitPrefix(this.path || "", prefixSize);
        const path5 = split3[0];
        const prefix4 = split3[1];
        this.needPax = split3[2];
        this.needPax = encString(buf, off, 100, path5) || this.needPax;
        this.needPax = encNumber(buf, off + 100, 8, this.mode) || this.needPax;
        this.needPax = encNumber(buf, off + 108, 8, this.uid) || this.needPax;
        this.needPax = encNumber(buf, off + 116, 8, this.gid) || this.needPax;
        this.needPax = encNumber(buf, off + 124, 12, this.size) || this.needPax;
        this.needPax = encDate(buf, off + 136, 12, this.mtime) || this.needPax;
        buf[off + 156] = this[TYPE].charCodeAt(0);
        this.needPax = encString(buf, off + 157, 100, this.linkpath) || this.needPax;
        buf.write("ustar\x0000", off + 257, 8);
        this.needPax = encString(buf, off + 265, 32, this.uname) || this.needPax;
        this.needPax = encString(buf, off + 297, 32, this.gname) || this.needPax;
        this.needPax = encNumber(buf, off + 329, 8, this.devmaj) || this.needPax;
        this.needPax = encNumber(buf, off + 337, 8, this.devmin) || this.needPax;
        this.needPax = encString(buf, off + 345, prefixSize, prefix4) || this.needPax;
        if (buf[off + 475] !== 0) {
          this.needPax = encString(buf, off + 345, 155, prefix4) || this.needPax;
        } else {
          this.needPax = encString(buf, off + 345, 130, prefix4) || this.needPax;
          this.needPax = encDate(buf, off + 476, 12, this.atime) || this.needPax;
          this.needPax = encDate(buf, off + 488, 12, this.ctime) || this.needPax;
        }
        let sum3 = 8 * 32;
        for (let i = off; i < off + 148; i++) {
          sum3 += buf[i];
        }
        for (let i = off + 156; i < off + 512; i++) {
          sum3 += buf[i];
        }
        this.cksum = sum3;
        encNumber(buf, off + 148, 8, this.cksum);
        this.cksumValid = true;
        return this.needPax;
      }
      set(data) {
        for (const i in data) {
          if (data[i] !== null && data[i] !== void 0) {
            this[i] = data[i];
          }
        }
      }
      get type() {
        return types.name.get(this[TYPE]) || this[TYPE];
      }
      get typeKey() {
        return this[TYPE];
      }
      set type(type) {
        if (types.code.has(type)) {
          this[TYPE] = types.code.get(type);
        } else {
          this[TYPE] = type;
        }
      }
    };
    var splitPrefix = (p, prefixSize) => {
      const pathSize = 100;
      let pp = p;
      let prefix4 = "";
      let ret;
      const root2 = pathModule.parse(p).root || ".";
      if (Buffer.byteLength(pp) < pathSize) {
        ret = [pp, prefix4, false];
      } else {
        prefix4 = pathModule.dirname(pp);
        pp = pathModule.basename(pp);
        do {
          if (Buffer.byteLength(pp) <= pathSize && Buffer.byteLength(prefix4) <= prefixSize) {
            ret = [pp, prefix4, false];
          } else if (Buffer.byteLength(pp) > pathSize && Buffer.byteLength(prefix4) <= prefixSize) {
            ret = [pp.slice(0, pathSize - 1), prefix4, true];
          } else {
            pp = pathModule.join(pathModule.basename(prefix4), pp);
            prefix4 = pathModule.dirname(prefix4);
          }
        } while (prefix4 !== root2 && !ret);
        if (!ret) {
          ret = [p.slice(0, pathSize - 1), "", true];
        }
      }
      return ret;
    };
    var decString = (buf, off, size10) => buf.slice(off, off + size10).toString("utf8").replace(/\0.*/, "");
    var decDate = (buf, off, size10) => numToDate(decNumber(buf, off, size10));
    var numToDate = (num) => num === null ? null : new Date(num * 1e3);
    var decNumber = (buf, off, size10) => buf[off] & 128 ? large.parse(buf.slice(off, off + size10)) : decSmallNumber(buf, off, size10);
    var nanNull = (value4) => isNaN(value4) ? null : value4;
    var decSmallNumber = (buf, off, size10) => nanNull(parseInt(
      buf.slice(off, off + size10).toString("utf8").replace(/\0.*$/, "").trim(),
      8
    ));
    var MAXNUM = {
      12: 8589934591,
      8: 2097151
    };
    var encNumber = (buf, off, size10, number2) => number2 === null ? false : number2 > MAXNUM[size10] || number2 < 0 ? (large.encode(number2, buf.slice(off, off + size10)), true) : (encSmallNumber(buf, off, size10, number2), false);
    var encSmallNumber = (buf, off, size10, number2) => buf.write(octalString(number2, size10), off, size10, "ascii");
    var octalString = (number2, size10) => padOctal(Math.floor(number2).toString(8), size10);
    var padOctal = (string7, size10) => (string7.length === size10 - 1 ? string7 : new Array(size10 - string7.length - 1).join("0") + string7 + " ") + "\0";
    var encDate = (buf, off, size10, date2) => date2 === null ? false : encNumber(buf, off, size10, date2.getTime() / 1e3);
    var NULLS = new Array(156).join("\0");
    var encString = (buf, off, size10, string7) => string7 === null ? false : (buf.write(string7 + NULLS, off, size10, "utf8"), string7.length !== Buffer.byteLength(string7) || string7.length > size10);
    module.exports = Header;
  }
});

// node_modules/tar/lib/pax.js
var require_pax = __commonJS({
  "node_modules/tar/lib/pax.js"(exports, module) {
    "use strict";
    var Header = require_header();
    var path5 = __require("path");
    var Pax = class {
      constructor(obj, global3) {
        this.atime = obj.atime || null;
        this.charset = obj.charset || null;
        this.comment = obj.comment || null;
        this.ctime = obj.ctime || null;
        this.gid = obj.gid || null;
        this.gname = obj.gname || null;
        this.linkpath = obj.linkpath || null;
        this.mtime = obj.mtime || null;
        this.path = obj.path || null;
        this.size = obj.size || null;
        this.uid = obj.uid || null;
        this.uname = obj.uname || null;
        this.dev = obj.dev || null;
        this.ino = obj.ino || null;
        this.nlink = obj.nlink || null;
        this.global = global3 || false;
      }
      encode() {
        const body = this.encodeBody();
        if (body === "") {
          return null;
        }
        const bodyLen = Buffer.byteLength(body);
        const bufLen = 512 * Math.ceil(1 + bodyLen / 512);
        const buf = Buffer.allocUnsafe(bufLen);
        for (let i = 0; i < 512; i++) {
          buf[i] = 0;
        }
        new Header({
          // XXX split the path
          // then the path should be PaxHeader + basename, but less than 99,
          // prepend with the dirname
          path: ("PaxHeader/" + path5.basename(this.path)).slice(0, 99),
          mode: this.mode || 420,
          uid: this.uid || null,
          gid: this.gid || null,
          size: bodyLen,
          mtime: this.mtime || null,
          type: this.global ? "GlobalExtendedHeader" : "ExtendedHeader",
          linkpath: "",
          uname: this.uname || "",
          gname: this.gname || "",
          devmaj: 0,
          devmin: 0,
          atime: this.atime || null,
          ctime: this.ctime || null
        }).encode(buf);
        buf.write(body, 512, bodyLen, "utf8");
        for (let i = bodyLen + 512; i < buf.length; i++) {
          buf[i] = 0;
        }
        return buf;
      }
      encodeBody() {
        return this.encodeField("path") + this.encodeField("ctime") + this.encodeField("atime") + this.encodeField("dev") + this.encodeField("ino") + this.encodeField("nlink") + this.encodeField("charset") + this.encodeField("comment") + this.encodeField("gid") + this.encodeField("gname") + this.encodeField("linkpath") + this.encodeField("mtime") + this.encodeField("size") + this.encodeField("uid") + this.encodeField("uname");
      }
      encodeField(field) {
        if (this[field] === null || this[field] === void 0) {
          return "";
        }
        const v = this[field] instanceof Date ? this[field].getTime() / 1e3 : this[field];
        const s = " " + (field === "dev" || field === "ino" || field === "nlink" ? "SCHILY." : "") + field + "=" + v + "\n";
        const byteLen = Buffer.byteLength(s);
        let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1;
        if (byteLen + digits >= Math.pow(10, digits)) {
          digits += 1;
        }
        const len = digits + byteLen;
        return len + s;
      }
    };
    Pax.parse = (string7, ex, g) => new Pax(merge4(parseKV(string7), ex), g);
    var merge4 = (a, b) => b ? Object.keys(a).reduce((s, k) => (s[k] = a[k], s), b) : a;
    var parseKV = (string7) => string7.replace(/\n$/, "").split("\n").reduce(parseKVLine, /* @__PURE__ */ Object.create(null));
    var parseKVLine = (set2, line2) => {
      const n = parseInt(line2, 10);
      if (n !== Buffer.byteLength(line2) + 1) {
        return set2;
      }
      line2 = line2.slice((n + " ").length);
      const kv = line2.split("=");
      const k = kv.shift().replace(/^SCHILY\.(dev|ino|nlink)/, "$1");
      if (!k) {
        return set2;
      }
      const v = kv.join("=");
      set2[k] = /^([A-Z]+\.)?([mac]|birth|creation)time$/.test(k) ? new Date(v * 1e3) : /^[0-9]+$/.test(v) ? +v : v;
      return set2;
    };
    module.exports = Pax;
  }
});

// node_modules/tar/lib/strip-trailing-slashes.js
var require_strip_trailing_slashes = __commonJS({
  "node_modules/tar/lib/strip-trailing-slashes.js"(exports, module) {
    module.exports = (str2) => {
      let i = str2.length - 1;
      let slashesStart = -1;
      while (i > -1 && str2.charAt(i) === "/") {
        slashesStart = i;
        i--;
      }
      return slashesStart === -1 ? str2 : str2.slice(0, slashesStart);
    };
  }
});

// node_modules/tar/lib/warn-mixin.js
var require_warn_mixin = __commonJS({
  "node_modules/tar/lib/warn-mixin.js"(exports, module) {
    "use strict";
    module.exports = (Base) => class extends Base {
      warn(code, message2, data = {}) {
        if (this.file) {
          data.file = this.file;
        }
        if (this.cwd) {
          data.cwd = this.cwd;
        }
        data.code = message2 instanceof Error && message2.code || code;
        data.tarCode = code;
        if (!this.strict && data.recoverable !== false) {
          if (message2 instanceof Error) {
            data = Object.assign(message2, data);
            message2 = message2.message;
          }
          this.emit("warn", data.tarCode, message2, data);
        } else if (message2 instanceof Error) {
          this.emit("error", Object.assign(message2, data));
        } else {
          this.emit("error", Object.assign(new Error(`${code}: ${message2}`), data));
        }
      }
    };
  }
});

// node_modules/tar/lib/winchars.js
var require_winchars = __commonJS({
  "node_modules/tar/lib/winchars.js"(exports, module) {
    "use strict";
    var raw = [
      "|",
      "<",
      ">",
      "?",
      ":"
    ];
    var win = raw.map((char2) => String.fromCharCode(61440 + char2.charCodeAt(0)));
    var toWin = new Map(raw.map((char2, i) => [char2, win[i]]));
    var toRaw = new Map(win.map((char2, i) => [char2, raw[i]]));
    module.exports = {
      encode: (s) => raw.reduce((s2, c) => s2.split(c).join(toWin.get(c)), s),
      decode: (s) => win.reduce((s2, c) => s2.split(c).join(toRaw.get(c)), s)
    };
  }
});

// node_modules/tar/lib/strip-absolute-path.js
var require_strip_absolute_path = __commonJS({
  "node_modules/tar/lib/strip-absolute-path.js"(exports, module) {
    var { isAbsolute: isAbsolute2, parse: parse10 } = __require("path").win32;
    module.exports = (path5) => {
      let r = "";
      let parsed = parse10(path5);
      while (isAbsolute2(path5) || parsed.root) {
        const root2 = path5.charAt(0) === "/" && path5.slice(0, 4) !== "//?/" ? "/" : parsed.root;
        path5 = path5.slice(root2.length);
        r += root2;
        parsed = parse10(path5);
      }
      return [r, path5];
    };
  }
});

// node_modules/tar/lib/mode-fix.js
var require_mode_fix = __commonJS({
  "node_modules/tar/lib/mode-fix.js"(exports, module) {
    "use strict";
    module.exports = (mode, isDir, portable) => {
      mode &= 4095;
      if (portable) {
        mode = (mode | 384) & ~18;
      }
      if (isDir) {
        if (mode & 256) {
          mode |= 64;
        }
        if (mode & 32) {
          mode |= 8;
        }
        if (mode & 4) {
          mode |= 1;
        }
      }
      return mode;
    };
  }
});

// node_modules/tar/lib/write-entry.js
var require_write_entry = __commonJS({
  "node_modules/tar/lib/write-entry.js"(exports, module) {
    "use strict";
    var { Minipass } = require_minipass();
    var Pax = require_pax();
    var Header = require_header();
    var fs2 = __require("fs");
    var path5 = __require("path");
    var normPath = require_normalize_windows_path();
    var stripSlash = require_strip_trailing_slashes();
    var prefixPath = (path6, prefix4) => {
      if (!prefix4) {
        return normPath(path6);
      }
      path6 = normPath(path6).replace(/^\.(\/|$)/, "");
      return stripSlash(prefix4) + "/" + path6;
    };
    var maxReadSize = 16 * 1024 * 1024;
    var PROCESS = Symbol("process");
    var FILE = Symbol("file");
    var DIRECTORY = Symbol("directory");
    var SYMLINK = Symbol("symlink");
    var HARDLINK = Symbol("hardlink");
    var HEADER = Symbol("header");
    var READ = Symbol("read");
    var LSTAT = Symbol("lstat");
    var ONLSTAT = Symbol("onlstat");
    var ONREAD = Symbol("onread");
    var ONREADLINK = Symbol("onreadlink");
    var OPENFILE = Symbol("openfile");
    var ONOPENFILE = Symbol("onopenfile");
    var CLOSE = Symbol("close");
    var MODE = Symbol("mode");
    var AWAITDRAIN = Symbol("awaitDrain");
    var ONDRAIN = Symbol("ondrain");
    var PREFIX = Symbol("prefix");
    var HAD_ERROR = Symbol("hadError");
    var warner = require_warn_mixin();
    var winchars = require_winchars();
    var stripAbsolutePath = require_strip_absolute_path();
    var modeFix = require_mode_fix();
    var WriteEntry = warner(class WriteEntry extends Minipass {
      constructor(p, opt) {
        opt = opt || {};
        super(opt);
        if (typeof p !== "string") {
          throw new TypeError("path is required");
        }
        this.path = normPath(p);
        this.portable = !!opt.portable;
        this.myuid = process.getuid && process.getuid() || 0;
        this.myuser = process.env.USER || "";
        this.maxReadSize = opt.maxReadSize || maxReadSize;
        this.linkCache = opt.linkCache || /* @__PURE__ */ new Map();
        this.statCache = opt.statCache || /* @__PURE__ */ new Map();
        this.preservePaths = !!opt.preservePaths;
        this.cwd = normPath(opt.cwd || process.cwd());
        this.strict = !!opt.strict;
        this.noPax = !!opt.noPax;
        this.noMtime = !!opt.noMtime;
        this.mtime = opt.mtime || null;
        this.prefix = opt.prefix ? normPath(opt.prefix) : null;
        this.fd = null;
        this.blockLen = null;
        this.blockRemain = null;
        this.buf = null;
        this.offset = null;
        this.length = null;
        this.pos = null;
        this.remain = null;
        if (typeof opt.onwarn === "function") {
          this.on("warn", opt.onwarn);
        }
        let pathWarn = false;
        if (!this.preservePaths) {
          const [root2, stripped] = stripAbsolutePath(this.path);
          if (root2) {
            this.path = stripped;
            pathWarn = root2;
          }
        }
        this.win32 = !!opt.win32 || process.platform === "win32";
        if (this.win32) {
          this.path = winchars.decode(this.path.replace(/\\/g, "/"));
          p = p.replace(/\\/g, "/");
        }
        this.absolute = normPath(opt.absolute || path5.resolve(this.cwd, p));
        if (this.path === "") {
          this.path = "./";
        }
        if (pathWarn) {
          this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
            entry: this,
            path: pathWarn + this.path
          });
        }
        if (this.statCache.has(this.absolute)) {
          this[ONLSTAT](this.statCache.get(this.absolute));
        } else {
          this[LSTAT]();
        }
      }
      emit(ev, ...data) {
        if (ev === "error") {
          this[HAD_ERROR] = true;
        }
        return super.emit(ev, ...data);
      }
      [LSTAT]() {
        fs2.lstat(this.absolute, (er, stat6) => {
          if (er) {
            return this.emit("error", er);
          }
          this[ONLSTAT](stat6);
        });
      }
      [ONLSTAT](stat6) {
        this.statCache.set(this.absolute, stat6);
        this.stat = stat6;
        if (!stat6.isFile()) {
          stat6.size = 0;
        }
        this.type = getType(stat6);
        this.emit("stat", stat6);
        this[PROCESS]();
      }
      [PROCESS]() {
        switch (this.type) {
          case "File":
            return this[FILE]();
          case "Directory":
            return this[DIRECTORY]();
          case "SymbolicLink":
            return this[SYMLINK]();
          default:
            return this.end();
        }
      }
      [MODE](mode) {
        return modeFix(mode, this.type === "Directory", this.portable);
      }
      [PREFIX](path6) {
        return prefixPath(path6, this.prefix);
      }
      [HEADER]() {
        if (this.type === "Directory" && this.portable) {
          this.noMtime = true;
        }
        this.header = new Header({
          path: this[PREFIX](this.path),
          // only apply the prefix to hard links.
          linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
          // only the permissions and setuid/setgid/sticky bitflags
          // not the higher-order bits that specify file type
          mode: this[MODE](this.stat.mode),
          uid: this.portable ? null : this.stat.uid,
          gid: this.portable ? null : this.stat.gid,
          size: this.stat.size,
          mtime: this.noMtime ? null : this.mtime || this.stat.mtime,
          type: this.type,
          uname: this.portable ? null : this.stat.uid === this.myuid ? this.myuser : "",
          atime: this.portable ? null : this.stat.atime,
          ctime: this.portable ? null : this.stat.ctime
        });
        if (this.header.encode() && !this.noPax) {
          super.write(new Pax({
            atime: this.portable ? null : this.header.atime,
            ctime: this.portable ? null : this.header.ctime,
            gid: this.portable ? null : this.header.gid,
            mtime: this.noMtime ? null : this.mtime || this.header.mtime,
            path: this[PREFIX](this.path),
            linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
            size: this.header.size,
            uid: this.portable ? null : this.header.uid,
            uname: this.portable ? null : this.header.uname,
            dev: this.portable ? null : this.stat.dev,
            ino: this.portable ? null : this.stat.ino,
            nlink: this.portable ? null : this.stat.nlink
          }).encode());
        }
        super.write(this.header.block);
      }
      [DIRECTORY]() {
        if (this.path.slice(-1) !== "/") {
          this.path += "/";
        }
        this.stat.size = 0;
        this[HEADER]();
        this.end();
      }
      [SYMLINK]() {
        fs2.readlink(this.absolute, (er, linkpath) => {
          if (er) {
            return this.emit("error", er);
          }
          this[ONREADLINK](linkpath);
        });
      }
      [ONREADLINK](linkpath) {
        this.linkpath = normPath(linkpath);
        this[HEADER]();
        this.end();
      }
      [HARDLINK](linkpath) {
        this.type = "Link";
        this.linkpath = normPath(path5.relative(this.cwd, linkpath));
        this.stat.size = 0;
        this[HEADER]();
        this.end();
      }
      [FILE]() {
        if (this.stat.nlink > 1) {
          const linkKey = this.stat.dev + ":" + this.stat.ino;
          if (this.linkCache.has(linkKey)) {
            const linkpath = this.linkCache.get(linkKey);
            if (linkpath.indexOf(this.cwd) === 0) {
              return this[HARDLINK](linkpath);
            }
          }
          this.linkCache.set(linkKey, this.absolute);
        }
        this[HEADER]();
        if (this.stat.size === 0) {
          return this.end();
        }
        this[OPENFILE]();
      }
      [OPENFILE]() {
        fs2.open(this.absolute, "r", (er, fd) => {
          if (er) {
            return this.emit("error", er);
          }
          this[ONOPENFILE](fd);
        });
      }
      [ONOPENFILE](fd) {
        this.fd = fd;
        if (this[HAD_ERROR]) {
          return this[CLOSE]();
        }
        this.blockLen = 512 * Math.ceil(this.stat.size / 512);
        this.blockRemain = this.blockLen;
        const bufLen = Math.min(this.blockLen, this.maxReadSize);
        this.buf = Buffer.allocUnsafe(bufLen);
        this.offset = 0;
        this.pos = 0;
        this.remain = this.stat.size;
        this.length = this.buf.length;
        this[READ]();
      }
      [READ]() {
        const { fd, buf, offset, length: length7, pos } = this;
        fs2.read(fd, buf, offset, length7, pos, (er, bytesRead) => {
          if (er) {
            return this[CLOSE](() => this.emit("error", er));
          }
          this[ONREAD](bytesRead);
        });
      }
      [CLOSE](cb) {
        fs2.close(this.fd, cb);
      }
      [ONREAD](bytesRead) {
        if (bytesRead <= 0 && this.remain > 0) {
          const er = new Error("encountered unexpected EOF");
          er.path = this.absolute;
          er.syscall = "read";
          er.code = "EOF";
          return this[CLOSE](() => this.emit("error", er));
        }
        if (bytesRead > this.remain) {
          const er = new Error("did not encounter expected EOF");
          er.path = this.absolute;
          er.syscall = "read";
          er.code = "EOF";
          return this[CLOSE](() => this.emit("error", er));
        }
        if (bytesRead === this.remain) {
          for (let i = bytesRead; i < this.length && bytesRead < this.blockRemain; i++) {
            this.buf[i + this.offset] = 0;
            bytesRead++;
            this.remain++;
          }
        }
        const writeBuf = this.offset === 0 && bytesRead === this.buf.length ? this.buf : this.buf.slice(this.offset, this.offset + bytesRead);
        const flushed = this.write(writeBuf);
        if (!flushed) {
          this[AWAITDRAIN](() => this[ONDRAIN]());
        } else {
          this[ONDRAIN]();
        }
      }
      [AWAITDRAIN](cb) {
        this.once("drain", cb);
      }
      write(writeBuf) {
        if (this.blockRemain < writeBuf.length) {
          const er = new Error("writing more data than expected");
          er.path = this.absolute;
          return this.emit("error", er);
        }
        this.remain -= writeBuf.length;
        this.blockRemain -= writeBuf.length;
        this.pos += writeBuf.length;
        this.offset += writeBuf.length;
        return super.write(writeBuf);
      }
      [ONDRAIN]() {
        if (!this.remain) {
          if (this.blockRemain) {
            super.write(Buffer.alloc(this.blockRemain));
          }
          return this[CLOSE]((er) => er ? this.emit("error", er) : this.end());
        }
        if (this.offset >= this.length) {
          this.buf = Buffer.allocUnsafe(Math.min(this.blockRemain, this.buf.length));
          this.offset = 0;
        }
        this.length = this.buf.length - this.offset;
        this[READ]();
      }
    });
    var WriteEntrySync = class extends WriteEntry {
      [LSTAT]() {
        this[ONLSTAT](fs2.lstatSync(this.absolute));
      }
      [SYMLINK]() {
        this[ONREADLINK](fs2.readlinkSync(this.absolute));
      }
      [OPENFILE]() {
        this[ONOPENFILE](fs2.openSync(this.absolute, "r"));
      }
      [READ]() {
        let threw = true;
        try {
          const { fd, buf, offset, length: length7, pos } = this;
          const bytesRead = fs2.readSync(fd, buf, offset, length7, pos);
          this[ONREAD](bytesRead);
          threw = false;
        } finally {
          if (threw) {
            try {
              this[CLOSE](() => {
              });
            } catch (er) {
            }
          }
        }
      }
      [AWAITDRAIN](cb) {
        cb();
      }
      [CLOSE](cb) {
        fs2.closeSync(this.fd);
        cb();
      }
    };
    var WriteEntryTar = warner(class WriteEntryTar extends Minipass {
      constructor(readEntry, opt) {
        opt = opt || {};
        super(opt);
        this.preservePaths = !!opt.preservePaths;
        this.portable = !!opt.portable;
        this.strict = !!opt.strict;
        this.noPax = !!opt.noPax;
        this.noMtime = !!opt.noMtime;
        this.readEntry = readEntry;
        this.type = readEntry.type;
        if (this.type === "Directory" && this.portable) {
          this.noMtime = true;
        }
        this.prefix = opt.prefix || null;
        this.path = normPath(readEntry.path);
        this.mode = this[MODE](readEntry.mode);
        this.uid = this.portable ? null : readEntry.uid;
        this.gid = this.portable ? null : readEntry.gid;
        this.uname = this.portable ? null : readEntry.uname;
        this.gname = this.portable ? null : readEntry.gname;
        this.size = readEntry.size;
        this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime;
        this.atime = this.portable ? null : readEntry.atime;
        this.ctime = this.portable ? null : readEntry.ctime;
        this.linkpath = normPath(readEntry.linkpath);
        if (typeof opt.onwarn === "function") {
          this.on("warn", opt.onwarn);
        }
        let pathWarn = false;
        if (!this.preservePaths) {
          const [root2, stripped] = stripAbsolutePath(this.path);
          if (root2) {
            this.path = stripped;
            pathWarn = root2;
          }
        }
        this.remain = readEntry.size;
        this.blockRemain = readEntry.startBlockSize;
        this.header = new Header({
          path: this[PREFIX](this.path),
          linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
          // only the permissions and setuid/setgid/sticky bitflags
          // not the higher-order bits that specify file type
          mode: this.mode,
          uid: this.portable ? null : this.uid,
          gid: this.portable ? null : this.gid,
          size: this.size,
          mtime: this.noMtime ? null : this.mtime,
          type: this.type,
          uname: this.portable ? null : this.uname,
          atime: this.portable ? null : this.atime,
          ctime: this.portable ? null : this.ctime
        });
        if (pathWarn) {
          this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
            entry: this,
            path: pathWarn + this.path
          });
        }
        if (this.header.encode() && !this.noPax) {
          super.write(new Pax({
            atime: this.portable ? null : this.atime,
            ctime: this.portable ? null : this.ctime,
            gid: this.portable ? null : this.gid,
            mtime: this.noMtime ? null : this.mtime,
            path: this[PREFIX](this.path),
            linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
            size: this.size,
            uid: this.portable ? null : this.uid,
            uname: this.portable ? null : this.uname,
            dev: this.portable ? null : this.readEntry.dev,
            ino: this.portable ? null : this.readEntry.ino,
            nlink: this.portable ? null : this.readEntry.nlink
          }).encode());
        }
        super.write(this.header.block);
        readEntry.pipe(this);
      }
      [PREFIX](path6) {
        return prefixPath(path6, this.prefix);
      }
      [MODE](mode) {
        return modeFix(mode, this.type === "Directory", this.portable);
      }
      write(data) {
        const writeLen = data.length;
        if (writeLen > this.blockRemain) {
          throw new Error("writing more to entry than is appropriate");
        }
        this.blockRemain -= writeLen;
        return super.write(data);
      }
      end() {
        if (this.blockRemain) {
          super.write(Buffer.alloc(this.blockRemain));
        }
        return super.end();
      }
    });
    WriteEntry.Sync = WriteEntrySync;
    WriteEntry.Tar = WriteEntryTar;
    var getType = (stat6) => stat6.isFile() ? "File" : stat6.isDirectory() ? "Directory" : stat6.isSymbolicLink() ? "SymbolicLink" : "Unsupported";
    module.exports = WriteEntry;
  }
});

// node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "node_modules/yallist/iterator.js"(exports, module) {
    "use strict";
    module.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "node_modules/yallist/yallist.js"(exports, module) {
    "use strict";
    module.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list2) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list2 && typeof list2.forEach === "function") {
        list2.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self2.push(arguments[i]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next2 = node.next;
      var prev = node.prev;
      if (next2) {
        next2.prev = prev;
      }
      if (prev) {
        prev.next = next2;
      }
      if (node === this.head) {
        this.head = next2;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next2;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head6 = this.head;
      node.list = this;
      node.next = head6;
      if (head6) {
        head6.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail3 = this.tail;
      node.list = this;
      node.prev = tail3;
      if (tail3) {
        tail3.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push2(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from3, to2) {
      to2 = to2 || this.length;
      if (to2 < 0) {
        to2 += this.length;
      }
      from3 = from3 || 0;
      if (from3 < 0) {
        from3 += this.length;
      }
      var ret = new Yallist();
      if (to2 < from3 || to2 < 0) {
        return ret;
      }
      if (from3 < 0) {
        from3 = 0;
      }
      if (to2 > this.length) {
        to2 = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from3; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to2; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from3, to2) {
      to2 = to2 || this.length;
      if (to2 < 0) {
        to2 += this.length;
      }
      from3 = from3 || 0;
      if (from3 < 0) {
        from3 += this.length;
      }
      var ret = new Yallist();
      if (to2 < from3 || to2 < 0) {
        return ret;
      }
      if (from3 < 0) {
        from3 = 0;
      }
      if (to2 > this.length) {
        to2 = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to2; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from3; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 0; i < nodes.length; i++) {
        walker = insert20(this, walker, nodes[i]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head6 = this.head;
      var tail3 = this.tail;
      for (var walker = head6; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail3;
      this.tail = head6;
      return this;
    };
    function insert20(self2, node, value4) {
      var inserted = node === self2.head ? new Node(value4, null, node, self2) : new Node(value4, node, node.next, self2);
      if (inserted.next === null) {
        self2.tail = inserted;
      }
      if (inserted.prev === null) {
        self2.head = inserted;
      }
      self2.length++;
      return inserted;
    }
    function push2(self2, item) {
      self2.tail = new Node(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node(value4, prev, next2, list2) {
      if (!(this instanceof Node)) {
        return new Node(value4, prev, next2, list2);
      }
      this.list = list2;
      this.value = value4;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next2) {
        next2.prev = this;
        this.next = next2;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  }
});

// node_modules/tar/lib/pack.js
var require_pack = __commonJS({
  "node_modules/tar/lib/pack.js"(exports, module) {
    "use strict";
    var PackJob = class {
      constructor(path6, absolute) {
        this.path = path6 || "./";
        this.absolute = absolute;
        this.entry = null;
        this.stat = null;
        this.readdir = null;
        this.pending = false;
        this.ignore = false;
        this.piped = false;
      }
    };
    var { Minipass } = require_minipass();
    var zlib = require_minizlib();
    var ReadEntry = require_read_entry();
    var WriteEntry = require_write_entry();
    var WriteEntrySync = WriteEntry.Sync;
    var WriteEntryTar = WriteEntry.Tar;
    var Yallist = require_yallist();
    var EOF = Buffer.alloc(1024);
    var ONSTAT = Symbol("onStat");
    var ENDED = Symbol("ended");
    var QUEUE = Symbol("queue");
    var CURRENT = Symbol("current");
    var PROCESS = Symbol("process");
    var PROCESSING = Symbol("processing");
    var PROCESSJOB = Symbol("processJob");
    var JOBS = Symbol("jobs");
    var JOBDONE = Symbol("jobDone");
    var ADDFSENTRY = Symbol("addFSEntry");
    var ADDTARENTRY = Symbol("addTarEntry");
    var STAT = Symbol("stat");
    var READDIR = Symbol("readdir");
    var ONREADDIR = Symbol("onreaddir");
    var PIPE = Symbol("pipe");
    var ENTRY = Symbol("entry");
    var ENTRYOPT = Symbol("entryOpt");
    var WRITEENTRYCLASS = Symbol("writeEntryClass");
    var WRITE = Symbol("write");
    var ONDRAIN = Symbol("ondrain");
    var fs2 = __require("fs");
    var path5 = __require("path");
    var warner = require_warn_mixin();
    var normPath = require_normalize_windows_path();
    var Pack = warner(class Pack extends Minipass {
      constructor(opt) {
        super(opt);
        opt = opt || /* @__PURE__ */ Object.create(null);
        this.opt = opt;
        this.file = opt.file || "";
        this.cwd = opt.cwd || process.cwd();
        this.maxReadSize = opt.maxReadSize;
        this.preservePaths = !!opt.preservePaths;
        this.strict = !!opt.strict;
        this.noPax = !!opt.noPax;
        this.prefix = normPath(opt.prefix || "");
        this.linkCache = opt.linkCache || /* @__PURE__ */ new Map();
        this.statCache = opt.statCache || /* @__PURE__ */ new Map();
        this.readdirCache = opt.readdirCache || /* @__PURE__ */ new Map();
        this[WRITEENTRYCLASS] = WriteEntry;
        if (typeof opt.onwarn === "function") {
          this.on("warn", opt.onwarn);
        }
        this.portable = !!opt.portable;
        this.zip = null;
        if (opt.gzip) {
          if (typeof opt.gzip !== "object") {
            opt.gzip = {};
          }
          if (this.portable) {
            opt.gzip.portable = true;
          }
          this.zip = new zlib.Gzip(opt.gzip);
          this.zip.on("data", (chunk) => super.write(chunk));
          this.zip.on("end", (_) => super.end());
          this.zip.on("drain", (_) => this[ONDRAIN]());
          this.on("resume", (_) => this.zip.resume());
        } else {
          this.on("drain", this[ONDRAIN]);
        }
        this.noDirRecurse = !!opt.noDirRecurse;
        this.follow = !!opt.follow;
        this.noMtime = !!opt.noMtime;
        this.mtime = opt.mtime || null;
        this.filter = typeof opt.filter === "function" ? opt.filter : (_) => true;
        this[QUEUE] = new Yallist();
        this[JOBS] = 0;
        this.jobs = +opt.jobs || 4;
        this[PROCESSING] = false;
        this[ENDED] = false;
      }
      [WRITE](chunk) {
        return super.write(chunk);
      }
      add(path6) {
        this.write(path6);
        return this;
      }
      end(path6) {
        if (path6) {
          this.write(path6);
        }
        this[ENDED] = true;
        this[PROCESS]();
        return this;
      }
      write(path6) {
        if (this[ENDED]) {
          throw new Error("write after end");
        }
        if (path6 instanceof ReadEntry) {
          this[ADDTARENTRY](path6);
        } else {
          this[ADDFSENTRY](path6);
        }
        return this.flowing;
      }
      [ADDTARENTRY](p) {
        const absolute = normPath(path5.resolve(this.cwd, p.path));
        if (!this.filter(p.path, p)) {
          p.resume();
        } else {
          const job = new PackJob(p.path, absolute, false);
          job.entry = new WriteEntryTar(p, this[ENTRYOPT](job));
          job.entry.on("end", (_) => this[JOBDONE](job));
          this[JOBS] += 1;
          this[QUEUE].push(job);
        }
        this[PROCESS]();
      }
      [ADDFSENTRY](p) {
        const absolute = normPath(path5.resolve(this.cwd, p));
        this[QUEUE].push(new PackJob(p, absolute));
        this[PROCESS]();
      }
      [STAT](job) {
        job.pending = true;
        this[JOBS] += 1;
        const stat6 = this.follow ? "stat" : "lstat";
        fs2[stat6](job.absolute, (er, stat7) => {
          job.pending = false;
          this[JOBS] -= 1;
          if (er) {
            this.emit("error", er);
          } else {
            this[ONSTAT](job, stat7);
          }
        });
      }
      [ONSTAT](job, stat6) {
        this.statCache.set(job.absolute, stat6);
        job.stat = stat6;
        if (!this.filter(job.path, stat6)) {
          job.ignore = true;
        }
        this[PROCESS]();
      }
      [READDIR](job) {
        job.pending = true;
        this[JOBS] += 1;
        fs2.readdir(job.absolute, (er, entries) => {
          job.pending = false;
          this[JOBS] -= 1;
          if (er) {
            return this.emit("error", er);
          }
          this[ONREADDIR](job, entries);
        });
      }
      [ONREADDIR](job, entries) {
        this.readdirCache.set(job.absolute, entries);
        job.readdir = entries;
        this[PROCESS]();
      }
      [PROCESS]() {
        if (this[PROCESSING]) {
          return;
        }
        this[PROCESSING] = true;
        for (let w = this[QUEUE].head; w !== null && this[JOBS] < this.jobs; w = w.next) {
          this[PROCESSJOB](w.value);
          if (w.value.ignore) {
            const p = w.next;
            this[QUEUE].removeNode(w);
            w.next = p;
          }
        }
        this[PROCESSING] = false;
        if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {
          if (this.zip) {
            this.zip.end(EOF);
          } else {
            super.write(EOF);
            super.end();
          }
        }
      }
      get [CURRENT]() {
        return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value;
      }
      [JOBDONE](job) {
        this[QUEUE].shift();
        this[JOBS] -= 1;
        this[PROCESS]();
      }
      [PROCESSJOB](job) {
        if (job.pending) {
          return;
        }
        if (job.entry) {
          if (job === this[CURRENT] && !job.piped) {
            this[PIPE](job);
          }
          return;
        }
        if (!job.stat) {
          if (this.statCache.has(job.absolute)) {
            this[ONSTAT](job, this.statCache.get(job.absolute));
          } else {
            this[STAT](job);
          }
        }
        if (!job.stat) {
          return;
        }
        if (job.ignore) {
          return;
        }
        if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {
          if (this.readdirCache.has(job.absolute)) {
            this[ONREADDIR](job, this.readdirCache.get(job.absolute));
          } else {
            this[READDIR](job);
          }
          if (!job.readdir) {
            return;
          }
        }
        job.entry = this[ENTRY](job);
        if (!job.entry) {
          job.ignore = true;
          return;
        }
        if (job === this[CURRENT] && !job.piped) {
          this[PIPE](job);
        }
      }
      [ENTRYOPT](job) {
        return {
          onwarn: (code, msg, data) => this.warn(code, msg, data),
          noPax: this.noPax,
          cwd: this.cwd,
          absolute: job.absolute,
          preservePaths: this.preservePaths,
          maxReadSize: this.maxReadSize,
          strict: this.strict,
          portable: this.portable,
          linkCache: this.linkCache,
          statCache: this.statCache,
          noMtime: this.noMtime,
          mtime: this.mtime,
          prefix: this.prefix
        };
      }
      [ENTRY](job) {
        this[JOBS] += 1;
        try {
          return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job)).on("end", () => this[JOBDONE](job)).on("error", (er) => this.emit("error", er));
        } catch (er) {
          this.emit("error", er);
        }
      }
      [ONDRAIN]() {
        if (this[CURRENT] && this[CURRENT].entry) {
          this[CURRENT].entry.resume();
        }
      }
      // like .pipe() but using super, because our write() is special
      [PIPE](job) {
        job.piped = true;
        if (job.readdir) {
          job.readdir.forEach((entry) => {
            const p = job.path;
            const base = p === "./" ? "" : p.replace(/\/*$/, "/");
            this[ADDFSENTRY](base + entry);
          });
        }
        const source2 = job.entry;
        const zip2 = this.zip;
        if (zip2) {
          source2.on("data", (chunk) => {
            if (!zip2.write(chunk)) {
              source2.pause();
            }
          });
        } else {
          source2.on("data", (chunk) => {
            if (!super.write(chunk)) {
              source2.pause();
            }
          });
        }
      }
      pause() {
        if (this.zip) {
          this.zip.pause();
        }
        return super.pause();
      }
    });
    var PackSync = class extends Pack {
      constructor(opt) {
        super(opt);
        this[WRITEENTRYCLASS] = WriteEntrySync;
      }
      // pause/resume are no-ops in sync streams.
      pause() {
      }
      resume() {
      }
      [STAT](job) {
        const stat6 = this.follow ? "statSync" : "lstatSync";
        this[ONSTAT](job, fs2[stat6](job.absolute));
      }
      [READDIR](job, stat6) {
        this[ONREADDIR](job, fs2.readdirSync(job.absolute));
      }
      // gotta get it all in this tick
      [PIPE](job) {
        const source2 = job.entry;
        const zip2 = this.zip;
        if (job.readdir) {
          job.readdir.forEach((entry) => {
            const p = job.path;
            const base = p === "./" ? "" : p.replace(/\/*$/, "/");
            this[ADDFSENTRY](base + entry);
          });
        }
        if (zip2) {
          source2.on("data", (chunk) => {
            zip2.write(chunk);
          });
        } else {
          source2.on("data", (chunk) => {
            super[WRITE](chunk);
          });
        }
      }
    };
    Pack.Sync = PackSync;
    module.exports = Pack;
  }
});

// node_modules/fs-minipass/node_modules/minipass/index.js
var require_minipass3 = __commonJS({
  "node_modules/fs-minipass/node_modules/minipass/index.js"(exports, module) {
    "use strict";
    var proc = typeof process === "object" && process ? process : {
      stdout: null,
      stderr: null
    };
    var EE = __require("events");
    var Stream = __require("stream");
    var SD = __require("string_decoder").StringDecoder;
    var EOF = Symbol("EOF");
    var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
    var EMITTED_END = Symbol("emittedEnd");
    var EMITTING_END = Symbol("emittingEnd");
    var EMITTED_ERROR = Symbol("emittedError");
    var CLOSED = Symbol("closed");
    var READ = Symbol("read");
    var FLUSH = Symbol("flush");
    var FLUSHCHUNK = Symbol("flushChunk");
    var ENCODING = Symbol("encoding");
    var DECODER = Symbol("decoder");
    var FLOWING = Symbol("flowing");
    var PAUSED = Symbol("paused");
    var RESUME = Symbol("resume");
    var BUFFERLENGTH = Symbol("bufferLength");
    var BUFFERPUSH = Symbol("bufferPush");
    var BUFFERSHIFT = Symbol("bufferShift");
    var OBJECTMODE = Symbol("objectMode");
    var DESTROYED = Symbol("destroyed");
    var EMITDATA = Symbol("emitData");
    var EMITEND = Symbol("emitEnd");
    var EMITEND2 = Symbol("emitEnd2");
    var ASYNC = Symbol("async");
    var defer6 = (fn) => Promise.resolve().then(fn);
    var doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
    var ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol("asyncIterator not implemented");
    var ITERATOR = doIter && Symbol.iterator || Symbol("iterator not implemented");
    var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
    var isArrayBuffer = (b) => b instanceof ArrayBuffer || typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
    var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
    var Pipe = class {
      constructor(src, dest, opts) {
        this.src = src;
        this.dest = dest;
        this.opts = opts;
        this.ondrain = () => src[RESUME]();
        dest.on("drain", this.ondrain);
      }
      unpipe() {
        this.dest.removeListener("drain", this.ondrain);
      }
      // istanbul ignore next - only here for the prototype
      proxyErrors() {
      }
      end() {
        this.unpipe();
        if (this.opts.end)
          this.dest.end();
      }
    };
    var PipeProxyErrors = class extends Pipe {
      unpipe() {
        this.src.removeListener("error", this.proxyErrors);
        super.unpipe();
      }
      constructor(src, dest, opts) {
        super(src, dest, opts);
        this.proxyErrors = (er) => dest.emit("error", er);
        src.on("error", this.proxyErrors);
      }
    };
    module.exports = class Minipass extends Stream {
      constructor(options) {
        super();
        this[FLOWING] = false;
        this[PAUSED] = false;
        this.pipes = [];
        this.buffer = [];
        this[OBJECTMODE] = options && options.objectMode || false;
        if (this[OBJECTMODE])
          this[ENCODING] = null;
        else
          this[ENCODING] = options && options.encoding || null;
        if (this[ENCODING] === "buffer")
          this[ENCODING] = null;
        this[ASYNC] = options && !!options.async || false;
        this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
        this[EOF] = false;
        this[EMITTED_END] = false;
        this[EMITTING_END] = false;
        this[CLOSED] = false;
        this[EMITTED_ERROR] = null;
        this.writable = true;
        this.readable = true;
        this[BUFFERLENGTH] = 0;
        this[DESTROYED] = false;
      }
      get bufferLength() {
        return this[BUFFERLENGTH];
      }
      get encoding() {
        return this[ENCODING];
      }
      set encoding(enc) {
        if (this[OBJECTMODE])
          throw new Error("cannot set encoding in objectMode");
        if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))
          throw new Error("cannot change encoding");
        if (this[ENCODING] !== enc) {
          this[DECODER] = enc ? new SD(enc) : null;
          if (this.buffer.length)
            this.buffer = this.buffer.map((chunk) => this[DECODER].write(chunk));
        }
        this[ENCODING] = enc;
      }
      setEncoding(enc) {
        this.encoding = enc;
      }
      get objectMode() {
        return this[OBJECTMODE];
      }
      set objectMode(om) {
        this[OBJECTMODE] = this[OBJECTMODE] || !!om;
      }
      get ["async"]() {
        return this[ASYNC];
      }
      set ["async"](a) {
        this[ASYNC] = this[ASYNC] || !!a;
      }
      write(chunk, encoding, cb) {
        if (this[EOF])
          throw new Error("write after end");
        if (this[DESTROYED]) {
          this.emit("error", Object.assign(
            new Error("Cannot call write after a stream was destroyed"),
            { code: "ERR_STREAM_DESTROYED" }
          ));
          return true;
        }
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (!encoding)
          encoding = "utf8";
        const fn = this[ASYNC] ? defer6 : (f) => f();
        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
          if (isArrayBufferView(chunk))
            chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
          else if (isArrayBuffer(chunk))
            chunk = Buffer.from(chunk);
          else if (typeof chunk !== "string")
            this.objectMode = true;
        }
        if (this[OBJECTMODE]) {
          if (this.flowing && this[BUFFERLENGTH] !== 0)
            this[FLUSH](true);
          if (this.flowing)
            this.emit("data", chunk);
          else
            this[BUFFERPUSH](chunk);
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this.flowing;
        }
        if (!chunk.length) {
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this.flowing;
        }
        if (typeof chunk === "string" && // unless it is a string already ready for us to use
        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
          chunk = Buffer.from(chunk, encoding);
        }
        if (Buffer.isBuffer(chunk) && this[ENCODING])
          chunk = this[DECODER].write(chunk);
        if (this.flowing && this[BUFFERLENGTH] !== 0)
          this[FLUSH](true);
        if (this.flowing)
          this.emit("data", chunk);
        else
          this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this.flowing;
      }
      read(n) {
        if (this[DESTROYED])
          return null;
        if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
          this[MAYBE_EMIT_END]();
          return null;
        }
        if (this[OBJECTMODE])
          n = null;
        if (this.buffer.length > 1 && !this[OBJECTMODE]) {
          if (this.encoding)
            this.buffer = [this.buffer.join("")];
          else
            this.buffer = [Buffer.concat(this.buffer, this[BUFFERLENGTH])];
        }
        const ret = this[READ](n || null, this.buffer[0]);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [READ](n, chunk) {
        if (n === chunk.length || n === null)
          this[BUFFERSHIFT]();
        else {
          this.buffer[0] = chunk.slice(n);
          chunk = chunk.slice(0, n);
          this[BUFFERLENGTH] -= n;
        }
        this.emit("data", chunk);
        if (!this.buffer.length && !this[EOF])
          this.emit("drain");
        return chunk;
      }
      end(chunk, encoding, cb) {
        if (typeof chunk === "function")
          cb = chunk, chunk = null;
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (chunk)
          this.write(chunk, encoding);
        if (cb)
          this.once("end", cb);
        this[EOF] = true;
        this.writable = false;
        if (this.flowing || !this[PAUSED])
          this[MAYBE_EMIT_END]();
        return this;
      }
      // don't let the internal resume be overwritten
      [RESUME]() {
        if (this[DESTROYED])
          return;
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit("resume");
        if (this.buffer.length)
          this[FLUSH]();
        else if (this[EOF])
          this[MAYBE_EMIT_END]();
        else
          this.emit("drain");
      }
      resume() {
        return this[RESUME]();
      }
      pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
      }
      get destroyed() {
        return this[DESTROYED];
      }
      get flowing() {
        return this[FLOWING];
      }
      get paused() {
        return this[PAUSED];
      }
      [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] += 1;
        else
          this[BUFFERLENGTH] += chunk.length;
        this.buffer.push(chunk);
      }
      [BUFFERSHIFT]() {
        if (this.buffer.length) {
          if (this[OBJECTMODE])
            this[BUFFERLENGTH] -= 1;
          else
            this[BUFFERLENGTH] -= this.buffer[0].length;
        }
        return this.buffer.shift();
      }
      [FLUSH](noDrain) {
        do {
        } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));
        if (!noDrain && !this.buffer.length && !this[EOF])
          this.emit("drain");
      }
      [FLUSHCHUNK](chunk) {
        return chunk ? (this.emit("data", chunk), this.flowing) : false;
      }
      pipe(dest, opts) {
        if (this[DESTROYED])
          return;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === proc.stdout || dest === proc.stderr)
          opts.end = false;
        else
          opts.end = opts.end !== false;
        opts.proxyErrors = !!opts.proxyErrors;
        if (ended) {
          if (opts.end)
            dest.end();
        } else {
          this.pipes.push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
          if (this[ASYNC])
            defer6(() => this[RESUME]());
          else
            this[RESUME]();
        }
        return dest;
      }
      unpipe(dest) {
        const p = this.pipes.find((p2) => p2.dest === dest);
        if (p) {
          this.pipes.splice(this.pipes.indexOf(p), 1);
          p.unpipe();
        }
      }
      addListener(ev, fn) {
        return this.on(ev, fn);
      }
      on(ev, fn) {
        const ret = super.on(ev, fn);
        if (ev === "data" && !this.pipes.length && !this.flowing)
          this[RESUME]();
        else if (ev === "readable" && this[BUFFERLENGTH] !== 0)
          super.emit("readable");
        else if (isEndish(ev) && this[EMITTED_END]) {
          super.emit(ev);
          this.removeAllListeners(ev);
        } else if (ev === "error" && this[EMITTED_ERROR]) {
          if (this[ASYNC])
            defer6(() => fn.call(this, this[EMITTED_ERROR]));
          else
            fn.call(this, this[EMITTED_ERROR]);
        }
        return ret;
      }
      get emittedEnd() {
        return this[EMITTED_END];
      }
      [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this.buffer.length === 0 && this[EOF]) {
          this[EMITTING_END] = true;
          this.emit("end");
          this.emit("prefinish");
          this.emit("finish");
          if (this[CLOSED])
            this.emit("close");
          this[EMITTING_END] = false;
        }
      }
      emit(ev, data, ...extra) {
        if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED])
          return;
        else if (ev === "data") {
          return !data ? false : this[ASYNC] ? defer6(() => this[EMITDATA](data)) : this[EMITDATA](data);
        } else if (ev === "end") {
          return this[EMITEND]();
        } else if (ev === "close") {
          this[CLOSED] = true;
          if (!this[EMITTED_END] && !this[DESTROYED])
            return;
          const ret2 = super.emit("close");
          this.removeAllListeners("close");
          return ret2;
        } else if (ev === "error") {
          this[EMITTED_ERROR] = data;
          const ret2 = super.emit("error", data);
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "resume") {
          const ret2 = super.emit("resume");
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "finish" || ev === "prefinish") {
          const ret2 = super.emit(ev);
          this.removeAllListeners(ev);
          return ret2;
        }
        const ret = super.emit(ev, data, ...extra);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITDATA](data) {
        for (const p of this.pipes) {
          if (p.dest.write(data) === false)
            this.pause();
        }
        const ret = super.emit("data", data);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITEND]() {
        if (this[EMITTED_END])
          return;
        this[EMITTED_END] = true;
        this.readable = false;
        if (this[ASYNC])
          defer6(() => this[EMITEND2]());
        else
          this[EMITEND2]();
      }
      [EMITEND2]() {
        if (this[DECODER]) {
          const data = this[DECODER].end();
          if (data) {
            for (const p of this.pipes) {
              p.dest.write(data);
            }
            super.emit("data", data);
          }
        }
        for (const p of this.pipes) {
          p.end();
        }
        const ret = super.emit("end");
        this.removeAllListeners("end");
        return ret;
      }
      // const all = await stream.collect()
      collect() {
        const buf = [];
        if (!this[OBJECTMODE])
          buf.dataLength = 0;
        const p = this.promise();
        this.on("data", (c) => {
          buf.push(c);
          if (!this[OBJECTMODE])
            buf.dataLength += c.length;
        });
        return p.then(() => buf);
      }
      // const data = await stream.concat()
      concat() {
        return this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this.collect().then((buf) => this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength));
      }
      // stream.promise().then(() => done, er => emitted error)
      promise() {
        return new Promise((resolve2, reject) => {
          this.on(DESTROYED, () => reject(new Error("stream destroyed")));
          this.on("error", (er) => reject(er));
          this.on("end", () => resolve2());
        });
      }
      // for await (let chunk of stream)
      [ASYNCITERATOR]() {
        const next2 = () => {
          const res = this.read();
          if (res !== null)
            return Promise.resolve({ done: false, value: res });
          if (this[EOF])
            return Promise.resolve({ done: true });
          let resolve2 = null;
          let reject = null;
          const onerr = (er) => {
            this.removeListener("data", ondata);
            this.removeListener("end", onend);
            reject(er);
          };
          const ondata = (value4) => {
            this.removeListener("error", onerr);
            this.removeListener("end", onend);
            this.pause();
            resolve2({ value: value4, done: !!this[EOF] });
          };
          const onend = () => {
            this.removeListener("error", onerr);
            this.removeListener("data", ondata);
            resolve2({ done: true });
          };
          const ondestroy = () => onerr(new Error("stream destroyed"));
          return new Promise((res2, rej) => {
            reject = rej;
            resolve2 = res2;
            this.once(DESTROYED, ondestroy);
            this.once("error", onerr);
            this.once("end", onend);
            this.once("data", ondata);
          });
        };
        return { next: next2 };
      }
      // for (let chunk of stream)
      [ITERATOR]() {
        const next2 = () => {
          const value4 = this.read();
          const done = value4 === null;
          return { value: value4, done };
        };
        return { next: next2 };
      }
      destroy(er) {
        if (this[DESTROYED]) {
          if (er)
            this.emit("error", er);
          else
            this.emit(DESTROYED);
          return this;
        }
        this[DESTROYED] = true;
        this.buffer.length = 0;
        this[BUFFERLENGTH] = 0;
        if (typeof this.close === "function" && !this[CLOSED])
          this.close();
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      static isStream(s) {
        return !!s && (s instanceof Minipass || s instanceof Stream || s instanceof EE && (typeof s.pipe === "function" || // readable
        typeof s.write === "function" && typeof s.end === "function"));
      }
    };
  }
});

// node_modules/fs-minipass/index.js
var require_fs_minipass = __commonJS({
  "node_modules/fs-minipass/index.js"(exports) {
    "use strict";
    var MiniPass = require_minipass3();
    var EE = __require("events").EventEmitter;
    var fs2 = __require("fs");
    var writev = fs2.writev;
    if (!writev) {
      const binding = process.binding("fs");
      const FSReqWrap = binding.FSReqWrap || binding.FSReqCallback;
      writev = (fd, iovec, pos, cb) => {
        const done = (er, bw) => cb(er, bw, iovec);
        const req = new FSReqWrap();
        req.oncomplete = done;
        binding.writeBuffers(fd, iovec, pos, req);
      };
    }
    var _autoClose = Symbol("_autoClose");
    var _close = Symbol("_close");
    var _ended = Symbol("_ended");
    var _fd = Symbol("_fd");
    var _finished = Symbol("_finished");
    var _flags = Symbol("_flags");
    var _flush = Symbol("_flush");
    var _handleChunk = Symbol("_handleChunk");
    var _makeBuf = Symbol("_makeBuf");
    var _mode = Symbol("_mode");
    var _needDrain = Symbol("_needDrain");
    var _onerror = Symbol("_onerror");
    var _onopen = Symbol("_onopen");
    var _onread = Symbol("_onread");
    var _onwrite = Symbol("_onwrite");
    var _open = Symbol("_open");
    var _path = Symbol("_path");
    var _pos = Symbol("_pos");
    var _queue = Symbol("_queue");
    var _read = Symbol("_read");
    var _readSize = Symbol("_readSize");
    var _reading = Symbol("_reading");
    var _remain = Symbol("_remain");
    var _size = Symbol("_size");
    var _write = Symbol("_write");
    var _writing = Symbol("_writing");
    var _defaultFlag = Symbol("_defaultFlag");
    var _errored = Symbol("_errored");
    var ReadStream = class extends MiniPass {
      constructor(path5, opt) {
        opt = opt || {};
        super(opt);
        this.readable = true;
        this.writable = false;
        if (typeof path5 !== "string")
          throw new TypeError("path must be a string");
        this[_errored] = false;
        this[_fd] = typeof opt.fd === "number" ? opt.fd : null;
        this[_path] = path5;
        this[_readSize] = opt.readSize || 16 * 1024 * 1024;
        this[_reading] = false;
        this[_size] = typeof opt.size === "number" ? opt.size : Infinity;
        this[_remain] = this[_size];
        this[_autoClose] = typeof opt.autoClose === "boolean" ? opt.autoClose : true;
        if (typeof this[_fd] === "number")
          this[_read]();
        else
          this[_open]();
      }
      get fd() {
        return this[_fd];
      }
      get path() {
        return this[_path];
      }
      write() {
        throw new TypeError("this is a readable stream");
      }
      end() {
        throw new TypeError("this is a readable stream");
      }
      [_open]() {
        fs2.open(this[_path], "r", (er, fd) => this[_onopen](er, fd));
      }
      [_onopen](er, fd) {
        if (er)
          this[_onerror](er);
        else {
          this[_fd] = fd;
          this.emit("open", fd);
          this[_read]();
        }
      }
      [_makeBuf]() {
        return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]));
      }
      [_read]() {
        if (!this[_reading]) {
          this[_reading] = true;
          const buf = this[_makeBuf]();
          if (buf.length === 0)
            return process.nextTick(() => this[_onread](null, 0, buf));
          fs2.read(this[_fd], buf, 0, buf.length, null, (er, br, buf2) => this[_onread](er, br, buf2));
        }
      }
      [_onread](er, br, buf) {
        this[_reading] = false;
        if (er)
          this[_onerror](er);
        else if (this[_handleChunk](br, buf))
          this[_read]();
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs2.close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
        }
      }
      [_onerror](er) {
        this[_reading] = true;
        this[_close]();
        this.emit("error", er);
      }
      [_handleChunk](br, buf) {
        let ret = false;
        this[_remain] -= br;
        if (br > 0)
          ret = super.write(br < buf.length ? buf.slice(0, br) : buf);
        if (br === 0 || this[_remain] <= 0) {
          ret = false;
          this[_close]();
          super.end();
        }
        return ret;
      }
      emit(ev, data) {
        switch (ev) {
          case "prefinish":
          case "finish":
            break;
          case "drain":
            if (typeof this[_fd] === "number")
              this[_read]();
            break;
          case "error":
            if (this[_errored])
              return;
            this[_errored] = true;
            return super.emit(ev, data);
          default:
            return super.emit(ev, data);
        }
      }
    };
    var ReadStreamSync = class extends ReadStream {
      [_open]() {
        let threw = true;
        try {
          this[_onopen](null, fs2.openSync(this[_path], "r"));
          threw = false;
        } finally {
          if (threw)
            this[_close]();
        }
      }
      [_read]() {
        let threw = true;
        try {
          if (!this[_reading]) {
            this[_reading] = true;
            do {
              const buf = this[_makeBuf]();
              const br = buf.length === 0 ? 0 : fs2.readSync(this[_fd], buf, 0, buf.length, null);
              if (!this[_handleChunk](br, buf))
                break;
            } while (true);
            this[_reading] = false;
          }
          threw = false;
        } finally {
          if (threw)
            this[_close]();
        }
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs2.closeSync(fd);
          this.emit("close");
        }
      }
    };
    var WriteStream = class extends EE {
      constructor(path5, opt) {
        opt = opt || {};
        super(opt);
        this.readable = false;
        this.writable = true;
        this[_errored] = false;
        this[_writing] = false;
        this[_ended] = false;
        this[_needDrain] = false;
        this[_queue] = [];
        this[_path] = path5;
        this[_fd] = typeof opt.fd === "number" ? opt.fd : null;
        this[_mode] = opt.mode === void 0 ? 438 : opt.mode;
        this[_pos] = typeof opt.start === "number" ? opt.start : null;
        this[_autoClose] = typeof opt.autoClose === "boolean" ? opt.autoClose : true;
        const defaultFlag = this[_pos] !== null ? "r+" : "w";
        this[_defaultFlag] = opt.flags === void 0;
        this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags;
        if (this[_fd] === null)
          this[_open]();
      }
      emit(ev, data) {
        if (ev === "error") {
          if (this[_errored])
            return;
          this[_errored] = true;
        }
        return super.emit(ev, data);
      }
      get fd() {
        return this[_fd];
      }
      get path() {
        return this[_path];
      }
      [_onerror](er) {
        this[_close]();
        this[_writing] = true;
        this.emit("error", er);
      }
      [_open]() {
        fs2.open(
          this[_path],
          this[_flags],
          this[_mode],
          (er, fd) => this[_onopen](er, fd)
        );
      }
      [_onopen](er, fd) {
        if (this[_defaultFlag] && this[_flags] === "r+" && er && er.code === "ENOENT") {
          this[_flags] = "w";
          this[_open]();
        } else if (er)
          this[_onerror](er);
        else {
          this[_fd] = fd;
          this.emit("open", fd);
          this[_flush]();
        }
      }
      end(buf, enc) {
        if (buf)
          this.write(buf, enc);
        this[_ended] = true;
        if (!this[_writing] && !this[_queue].length && typeof this[_fd] === "number")
          this[_onwrite](null, 0);
        return this;
      }
      write(buf, enc) {
        if (typeof buf === "string")
          buf = Buffer.from(buf, enc);
        if (this[_ended]) {
          this.emit("error", new Error("write() after end()"));
          return false;
        }
        if (this[_fd] === null || this[_writing] || this[_queue].length) {
          this[_queue].push(buf);
          this[_needDrain] = true;
          return false;
        }
        this[_writing] = true;
        this[_write](buf);
        return true;
      }
      [_write](buf) {
        fs2.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) => this[_onwrite](er, bw));
      }
      [_onwrite](er, bw) {
        if (er)
          this[_onerror](er);
        else {
          if (this[_pos] !== null)
            this[_pos] += bw;
          if (this[_queue].length)
            this[_flush]();
          else {
            this[_writing] = false;
            if (this[_ended] && !this[_finished]) {
              this[_finished] = true;
              this[_close]();
              this.emit("finish");
            } else if (this[_needDrain]) {
              this[_needDrain] = false;
              this.emit("drain");
            }
          }
        }
      }
      [_flush]() {
        if (this[_queue].length === 0) {
          if (this[_ended])
            this[_onwrite](null, 0);
        } else if (this[_queue].length === 1)
          this[_write](this[_queue].pop());
        else {
          const iovec = this[_queue];
          this[_queue] = [];
          writev(
            this[_fd],
            iovec,
            this[_pos],
            (er, bw) => this[_onwrite](er, bw)
          );
        }
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs2.close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
        }
      }
    };
    var WriteStreamSync = class extends WriteStream {
      [_open]() {
        let fd;
        if (this[_defaultFlag] && this[_flags] === "r+") {
          try {
            fd = fs2.openSync(this[_path], this[_flags], this[_mode]);
          } catch (er) {
            if (er.code === "ENOENT") {
              this[_flags] = "w";
              return this[_open]();
            } else
              throw er;
          }
        } else
          fd = fs2.openSync(this[_path], this[_flags], this[_mode]);
        this[_onopen](null, fd);
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs2.closeSync(fd);
          this.emit("close");
        }
      }
      [_write](buf) {
        let threw = true;
        try {
          this[_onwrite](
            null,
            fs2.writeSync(this[_fd], buf, 0, buf.length, this[_pos])
          );
          threw = false;
        } finally {
          if (threw)
            try {
              this[_close]();
            } catch (_) {
            }
        }
      }
    };
    exports.ReadStream = ReadStream;
    exports.ReadStreamSync = ReadStreamSync;
    exports.WriteStream = WriteStream;
    exports.WriteStreamSync = WriteStreamSync;
  }
});

// node_modules/tar/lib/parse.js
var require_parse4 = __commonJS({
  "node_modules/tar/lib/parse.js"(exports, module) {
    "use strict";
    var warner = require_warn_mixin();
    var Header = require_header();
    var EE = __require("events");
    var Yallist = require_yallist();
    var maxMetaEntrySize = 1024 * 1024;
    var Entry = require_read_entry();
    var Pax = require_pax();
    var zlib = require_minizlib();
    var { nextTick } = __require("process");
    var gzipHeader = Buffer.from([31, 139]);
    var STATE = Symbol("state");
    var WRITEENTRY = Symbol("writeEntry");
    var READENTRY = Symbol("readEntry");
    var NEXTENTRY = Symbol("nextEntry");
    var PROCESSENTRY = Symbol("processEntry");
    var EX = Symbol("extendedHeader");
    var GEX = Symbol("globalExtendedHeader");
    var META = Symbol("meta");
    var EMITMETA = Symbol("emitMeta");
    var BUFFER = Symbol("buffer");
    var QUEUE = Symbol("queue");
    var ENDED = Symbol("ended");
    var EMITTEDEND = Symbol("emittedEnd");
    var EMIT = Symbol("emit");
    var UNZIP = Symbol("unzip");
    var CONSUMECHUNK = Symbol("consumeChunk");
    var CONSUMECHUNKSUB = Symbol("consumeChunkSub");
    var CONSUMEBODY = Symbol("consumeBody");
    var CONSUMEMETA = Symbol("consumeMeta");
    var CONSUMEHEADER = Symbol("consumeHeader");
    var CONSUMING = Symbol("consuming");
    var BUFFERCONCAT = Symbol("bufferConcat");
    var MAYBEEND = Symbol("maybeEnd");
    var WRITING = Symbol("writing");
    var ABORTED = Symbol("aborted");
    var DONE = Symbol("onDone");
    var SAW_VALID_ENTRY = Symbol("sawValidEntry");
    var SAW_NULL_BLOCK = Symbol("sawNullBlock");
    var SAW_EOF = Symbol("sawEOF");
    var CLOSESTREAM = Symbol("closeStream");
    var noop = (_) => true;
    module.exports = warner(class Parser extends EE {
      constructor(opt) {
        opt = opt || {};
        super(opt);
        this.file = opt.file || "";
        this[SAW_VALID_ENTRY] = null;
        this.on(DONE, (_) => {
          if (this[STATE] === "begin" || this[SAW_VALID_ENTRY] === false) {
            this.warn("TAR_BAD_ARCHIVE", "Unrecognized archive format");
          }
        });
        if (opt.ondone) {
          this.on(DONE, opt.ondone);
        } else {
          this.on(DONE, (_) => {
            this.emit("prefinish");
            this.emit("finish");
            this.emit("end");
          });
        }
        this.strict = !!opt.strict;
        this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize;
        this.filter = typeof opt.filter === "function" ? opt.filter : noop;
        this.writable = true;
        this.readable = false;
        this[QUEUE] = new Yallist();
        this[BUFFER] = null;
        this[READENTRY] = null;
        this[WRITEENTRY] = null;
        this[STATE] = "begin";
        this[META] = "";
        this[EX] = null;
        this[GEX] = null;
        this[ENDED] = false;
        this[UNZIP] = null;
        this[ABORTED] = false;
        this[SAW_NULL_BLOCK] = false;
        this[SAW_EOF] = false;
        this.on("end", () => this[CLOSESTREAM]());
        if (typeof opt.onwarn === "function") {
          this.on("warn", opt.onwarn);
        }
        if (typeof opt.onentry === "function") {
          this.on("entry", opt.onentry);
        }
      }
      [CONSUMEHEADER](chunk, position2) {
        if (this[SAW_VALID_ENTRY] === null) {
          this[SAW_VALID_ENTRY] = false;
        }
        let header;
        try {
          header = new Header(chunk, position2, this[EX], this[GEX]);
        } catch (er) {
          return this.warn("TAR_ENTRY_INVALID", er);
        }
        if (header.nullBlock) {
          if (this[SAW_NULL_BLOCK]) {
            this[SAW_EOF] = true;
            if (this[STATE] === "begin") {
              this[STATE] = "header";
            }
            this[EMIT]("eof");
          } else {
            this[SAW_NULL_BLOCK] = true;
            this[EMIT]("nullBlock");
          }
        } else {
          this[SAW_NULL_BLOCK] = false;
          if (!header.cksumValid) {
            this.warn("TAR_ENTRY_INVALID", "checksum failure", { header });
          } else if (!header.path) {
            this.warn("TAR_ENTRY_INVALID", "path is required", { header });
          } else {
            const type = header.type;
            if (/^(Symbolic)?Link$/.test(type) && !header.linkpath) {
              this.warn("TAR_ENTRY_INVALID", "linkpath required", { header });
            } else if (!/^(Symbolic)?Link$/.test(type) && header.linkpath) {
              this.warn("TAR_ENTRY_INVALID", "linkpath forbidden", { header });
            } else {
              const entry = this[WRITEENTRY] = new Entry(header, this[EX], this[GEX]);
              if (!this[SAW_VALID_ENTRY]) {
                if (entry.remain) {
                  const onend = () => {
                    if (!entry.invalid) {
                      this[SAW_VALID_ENTRY] = true;
                    }
                  };
                  entry.on("end", onend);
                } else {
                  this[SAW_VALID_ENTRY] = true;
                }
              }
              if (entry.meta) {
                if (entry.size > this.maxMetaEntrySize) {
                  entry.ignore = true;
                  this[EMIT]("ignoredEntry", entry);
                  this[STATE] = "ignore";
                  entry.resume();
                } else if (entry.size > 0) {
                  this[META] = "";
                  entry.on("data", (c) => this[META] += c);
                  this[STATE] = "meta";
                }
              } else {
                this[EX] = null;
                entry.ignore = entry.ignore || !this.filter(entry.path, entry);
                if (entry.ignore) {
                  this[EMIT]("ignoredEntry", entry);
                  this[STATE] = entry.remain ? "ignore" : "header";
                  entry.resume();
                } else {
                  if (entry.remain) {
                    this[STATE] = "body";
                  } else {
                    this[STATE] = "header";
                    entry.end();
                  }
                  if (!this[READENTRY]) {
                    this[QUEUE].push(entry);
                    this[NEXTENTRY]();
                  } else {
                    this[QUEUE].push(entry);
                  }
                }
              }
            }
          }
        }
      }
      [CLOSESTREAM]() {
        nextTick(() => this.emit("close"));
      }
      [PROCESSENTRY](entry) {
        let go = true;
        if (!entry) {
          this[READENTRY] = null;
          go = false;
        } else if (Array.isArray(entry)) {
          this.emit.apply(this, entry);
        } else {
          this[READENTRY] = entry;
          this.emit("entry", entry);
          if (!entry.emittedEnd) {
            entry.on("end", (_) => this[NEXTENTRY]());
            go = false;
          }
        }
        return go;
      }
      [NEXTENTRY]() {
        do {
        } while (this[PROCESSENTRY](this[QUEUE].shift()));
        if (!this[QUEUE].length) {
          const re = this[READENTRY];
          const drainNow = !re || re.flowing || re.size === re.remain;
          if (drainNow) {
            if (!this[WRITING]) {
              this.emit("drain");
            }
          } else {
            re.once("drain", (_) => this.emit("drain"));
          }
        }
      }
      [CONSUMEBODY](chunk, position2) {
        const entry = this[WRITEENTRY];
        const br = entry.blockRemain;
        const c = br >= chunk.length && position2 === 0 ? chunk : chunk.slice(position2, position2 + br);
        entry.write(c);
        if (!entry.blockRemain) {
          this[STATE] = "header";
          this[WRITEENTRY] = null;
          entry.end();
        }
        return c.length;
      }
      [CONSUMEMETA](chunk, position2) {
        const entry = this[WRITEENTRY];
        const ret = this[CONSUMEBODY](chunk, position2);
        if (!this[WRITEENTRY]) {
          this[EMITMETA](entry);
        }
        return ret;
      }
      [EMIT](ev, data, extra) {
        if (!this[QUEUE].length && !this[READENTRY]) {
          this.emit(ev, data, extra);
        } else {
          this[QUEUE].push([ev, data, extra]);
        }
      }
      [EMITMETA](entry) {
        this[EMIT]("meta", this[META]);
        switch (entry.type) {
          case "ExtendedHeader":
          case "OldExtendedHeader":
            this[EX] = Pax.parse(this[META], this[EX], false);
            break;
          case "GlobalExtendedHeader":
            this[GEX] = Pax.parse(this[META], this[GEX], true);
            break;
          case "NextFileHasLongPath":
          case "OldGnuLongPath":
            this[EX] = this[EX] || /* @__PURE__ */ Object.create(null);
            this[EX].path = this[META].replace(/\0.*/, "");
            break;
          case "NextFileHasLongLinkpath":
            this[EX] = this[EX] || /* @__PURE__ */ Object.create(null);
            this[EX].linkpath = this[META].replace(/\0.*/, "");
            break;
          default:
            throw new Error("unknown meta: " + entry.type);
        }
      }
      abort(error4) {
        this[ABORTED] = true;
        this.emit("abort", error4);
        this.warn("TAR_ABORT", error4, { recoverable: false });
      }
      write(chunk) {
        if (this[ABORTED]) {
          return;
        }
        if (this[UNZIP] === null && chunk) {
          if (this[BUFFER]) {
            chunk = Buffer.concat([this[BUFFER], chunk]);
            this[BUFFER] = null;
          }
          if (chunk.length < gzipHeader.length) {
            this[BUFFER] = chunk;
            return true;
          }
          for (let i = 0; this[UNZIP] === null && i < gzipHeader.length; i++) {
            if (chunk[i] !== gzipHeader[i]) {
              this[UNZIP] = false;
            }
          }
          if (this[UNZIP] === null) {
            const ended = this[ENDED];
            this[ENDED] = false;
            this[UNZIP] = new zlib.Unzip();
            this[UNZIP].on("data", (chunk2) => this[CONSUMECHUNK](chunk2));
            this[UNZIP].on("error", (er) => this.abort(er));
            this[UNZIP].on("end", (_) => {
              this[ENDED] = true;
              this[CONSUMECHUNK]();
            });
            this[WRITING] = true;
            const ret2 = this[UNZIP][ended ? "end" : "write"](chunk);
            this[WRITING] = false;
            return ret2;
          }
        }
        this[WRITING] = true;
        if (this[UNZIP]) {
          this[UNZIP].write(chunk);
        } else {
          this[CONSUMECHUNK](chunk);
        }
        this[WRITING] = false;
        const ret = this[QUEUE].length ? false : this[READENTRY] ? this[READENTRY].flowing : true;
        if (!ret && !this[QUEUE].length) {
          this[READENTRY].once("drain", (_) => this.emit("drain"));
        }
        return ret;
      }
      [BUFFERCONCAT](c) {
        if (c && !this[ABORTED]) {
          this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c;
        }
      }
      [MAYBEEND]() {
        if (this[ENDED] && !this[EMITTEDEND] && !this[ABORTED] && !this[CONSUMING]) {
          this[EMITTEDEND] = true;
          const entry = this[WRITEENTRY];
          if (entry && entry.blockRemain) {
            const have = this[BUFFER] ? this[BUFFER].length : 0;
            this.warn("TAR_BAD_ARCHIVE", `Truncated input (needed ${entry.blockRemain} more bytes, only ${have} available)`, { entry });
            if (this[BUFFER]) {
              entry.write(this[BUFFER]);
            }
            entry.end();
          }
          this[EMIT](DONE);
        }
      }
      [CONSUMECHUNK](chunk) {
        if (this[CONSUMING]) {
          this[BUFFERCONCAT](chunk);
        } else if (!chunk && !this[BUFFER]) {
          this[MAYBEEND]();
        } else {
          this[CONSUMING] = true;
          if (this[BUFFER]) {
            this[BUFFERCONCAT](chunk);
            const c = this[BUFFER];
            this[BUFFER] = null;
            this[CONSUMECHUNKSUB](c);
          } else {
            this[CONSUMECHUNKSUB](chunk);
          }
          while (this[BUFFER] && this[BUFFER].length >= 512 && !this[ABORTED] && !this[SAW_EOF]) {
            const c = this[BUFFER];
            this[BUFFER] = null;
            this[CONSUMECHUNKSUB](c);
          }
          this[CONSUMING] = false;
        }
        if (!this[BUFFER] || this[ENDED]) {
          this[MAYBEEND]();
        }
      }
      [CONSUMECHUNKSUB](chunk) {
        let position2 = 0;
        const length7 = chunk.length;
        while (position2 + 512 <= length7 && !this[ABORTED] && !this[SAW_EOF]) {
          switch (this[STATE]) {
            case "begin":
            case "header":
              this[CONSUMEHEADER](chunk, position2);
              position2 += 512;
              break;
            case "ignore":
            case "body":
              position2 += this[CONSUMEBODY](chunk, position2);
              break;
            case "meta":
              position2 += this[CONSUMEMETA](chunk, position2);
              break;
            default:
              throw new Error("invalid state: " + this[STATE]);
          }
        }
        if (position2 < length7) {
          if (this[BUFFER]) {
            this[BUFFER] = Buffer.concat([chunk.slice(position2), this[BUFFER]]);
          } else {
            this[BUFFER] = chunk.slice(position2);
          }
        }
      }
      end(chunk) {
        if (!this[ABORTED]) {
          if (this[UNZIP]) {
            this[UNZIP].end(chunk);
          } else {
            this[ENDED] = true;
            this.write(chunk);
          }
        }
      }
    });
  }
});

// node_modules/tar/lib/list.js
var require_list = __commonJS({
  "node_modules/tar/lib/list.js"(exports, module) {
    "use strict";
    var hlo = require_high_level_opt();
    var Parser = require_parse4();
    var fs2 = __require("fs");
    var fsm = require_fs_minipass();
    var path5 = __require("path");
    var stripSlash = require_strip_trailing_slashes();
    module.exports = (opt_, files, cb) => {
      if (typeof opt_ === "function") {
        cb = opt_, files = null, opt_ = {};
      } else if (Array.isArray(opt_)) {
        files = opt_, opt_ = {};
      }
      if (typeof files === "function") {
        cb = files, files = null;
      }
      if (!files) {
        files = [];
      } else {
        files = Array.from(files);
      }
      const opt = hlo(opt_);
      if (opt.sync && typeof cb === "function") {
        throw new TypeError("callback not supported for sync tar functions");
      }
      if (!opt.file && typeof cb === "function") {
        throw new TypeError("callback only supported with file option");
      }
      if (files.length) {
        filesFilter(opt, files);
      }
      if (!opt.noResume) {
        onentryFunction(opt);
      }
      return opt.file && opt.sync ? listFileSync(opt) : opt.file ? listFile(opt, cb) : list2(opt);
    };
    var onentryFunction = (opt) => {
      const onentry = opt.onentry;
      opt.onentry = onentry ? (e) => {
        onentry(e);
        e.resume();
      } : (e) => e.resume();
    };
    var filesFilter = (opt, files) => {
      const map86 = new Map(files.map((f) => [stripSlash(f), true]));
      const filter7 = opt.filter;
      const mapHas = (file, r) => {
        const root2 = r || path5.parse(file).root || ".";
        const ret = file === root2 ? false : map86.has(file) ? map86.get(file) : mapHas(path5.dirname(file), root2);
        map86.set(file, ret);
        return ret;
      };
      opt.filter = filter7 ? (file, entry) => filter7(file, entry) && mapHas(stripSlash(file)) : (file) => mapHas(stripSlash(file));
    };
    var listFileSync = (opt) => {
      const p = list2(opt);
      const file = opt.file;
      let threw = true;
      let fd;
      try {
        const stat6 = fs2.statSync(file);
        const readSize = opt.maxReadSize || 16 * 1024 * 1024;
        if (stat6.size < readSize) {
          p.end(fs2.readFileSync(file));
        } else {
          let pos = 0;
          const buf = Buffer.allocUnsafe(readSize);
          fd = fs2.openSync(file, "r");
          while (pos < stat6.size) {
            const bytesRead = fs2.readSync(fd, buf, 0, readSize, pos);
            pos += bytesRead;
            p.write(buf.slice(0, bytesRead));
          }
          p.end();
        }
        threw = false;
      } finally {
        if (threw && fd) {
          try {
            fs2.closeSync(fd);
          } catch (er) {
          }
        }
      }
    };
    var listFile = (opt, cb) => {
      const parse10 = new Parser(opt);
      const readSize = opt.maxReadSize || 16 * 1024 * 1024;
      const file = opt.file;
      const p = new Promise((resolve2, reject) => {
        parse10.on("error", reject);
        parse10.on("end", resolve2);
        fs2.stat(file, (er, stat6) => {
          if (er) {
            reject(er);
          } else {
            const stream3 = new fsm.ReadStream(file, {
              readSize,
              size: stat6.size
            });
            stream3.on("error", reject);
            stream3.pipe(parse10);
          }
        });
      });
      return cb ? p.then(cb, cb) : p;
    };
    var list2 = (opt) => new Parser(opt);
  }
});

// node_modules/tar/lib/create.js
var require_create = __commonJS({
  "node_modules/tar/lib/create.js"(exports, module) {
    "use strict";
    var hlo = require_high_level_opt();
    var Pack = require_pack();
    var fsm = require_fs_minipass();
    var t = require_list();
    var path5 = __require("path");
    module.exports = (opt_, files, cb) => {
      if (typeof files === "function") {
        cb = files;
      }
      if (Array.isArray(opt_)) {
        files = opt_, opt_ = {};
      }
      if (!files || !Array.isArray(files) || !files.length) {
        throw new TypeError("no files or directories specified");
      }
      files = Array.from(files);
      const opt = hlo(opt_);
      if (opt.sync && typeof cb === "function") {
        throw new TypeError("callback not supported for sync tar functions");
      }
      if (!opt.file && typeof cb === "function") {
        throw new TypeError("callback only supported with file option");
      }
      return opt.file && opt.sync ? createFileSync(opt, files) : opt.file ? createFile(opt, files, cb) : opt.sync ? createSync(opt, files) : create5(opt, files);
    };
    var createFileSync = (opt, files) => {
      const p = new Pack.Sync(opt);
      const stream3 = new fsm.WriteStreamSync(opt.file, {
        mode: opt.mode || 438
      });
      p.pipe(stream3);
      addFilesSync(p, files);
    };
    var createFile = (opt, files, cb) => {
      const p = new Pack(opt);
      const stream3 = new fsm.WriteStream(opt.file, {
        mode: opt.mode || 438
      });
      p.pipe(stream3);
      const promise2 = new Promise((res, rej) => {
        stream3.on("error", rej);
        stream3.on("close", res);
        p.on("error", rej);
      });
      addFilesAsync(p, files);
      return cb ? promise2.then(cb, cb) : promise2;
    };
    var addFilesSync = (p, files) => {
      files.forEach((file) => {
        if (file.charAt(0) === "@") {
          t({
            file: path5.resolve(p.cwd, file.slice(1)),
            sync: true,
            noResume: true,
            onentry: (entry) => p.add(entry)
          });
        } else {
          p.add(file);
        }
      });
      p.end();
    };
    var addFilesAsync = (p, files) => {
      while (files.length) {
        const file = files.shift();
        if (file.charAt(0) === "@") {
          return t({
            file: path5.resolve(p.cwd, file.slice(1)),
            noResume: true,
            onentry: (entry) => p.add(entry)
          }).then((_) => addFilesAsync(p, files));
        } else {
          p.add(file);
        }
      }
      p.end();
    };
    var createSync = (opt, files) => {
      const p = new Pack.Sync(opt);
      addFilesSync(p, files);
      return p;
    };
    var create5 = (opt, files) => {
      const p = new Pack(opt);
      addFilesAsync(p, files);
      return p;
    };
  }
});

// node_modules/tar/lib/replace.js
var require_replace = __commonJS({
  "node_modules/tar/lib/replace.js"(exports, module) {
    "use strict";
    var hlo = require_high_level_opt();
    var Pack = require_pack();
    var fs2 = __require("fs");
    var fsm = require_fs_minipass();
    var t = require_list();
    var path5 = __require("path");
    var Header = require_header();
    module.exports = (opt_, files, cb) => {
      const opt = hlo(opt_);
      if (!opt.file) {
        throw new TypeError("file is required");
      }
      if (opt.gzip) {
        throw new TypeError("cannot append to compressed archives");
      }
      if (!files || !Array.isArray(files) || !files.length) {
        throw new TypeError("no files or directories specified");
      }
      files = Array.from(files);
      return opt.sync ? replaceSync(opt, files) : replace3(opt, files, cb);
    };
    var replaceSync = (opt, files) => {
      const p = new Pack.Sync(opt);
      let threw = true;
      let fd;
      let position2;
      try {
        try {
          fd = fs2.openSync(opt.file, "r+");
        } catch (er) {
          if (er.code === "ENOENT") {
            fd = fs2.openSync(opt.file, "w+");
          } else {
            throw er;
          }
        }
        const st = fs2.fstatSync(fd);
        const headBuf = Buffer.alloc(512);
        POSITION:
          for (position2 = 0; position2 < st.size; position2 += 512) {
            for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {
              bytes = fs2.readSync(
                fd,
                headBuf,
                bufPos,
                headBuf.length - bufPos,
                position2 + bufPos
              );
              if (position2 === 0 && headBuf[0] === 31 && headBuf[1] === 139) {
                throw new Error("cannot append to compressed archives");
              }
              if (!bytes) {
                break POSITION;
              }
            }
            const h = new Header(headBuf);
            if (!h.cksumValid) {
              break;
            }
            const entryBlockSize = 512 * Math.ceil(h.size / 512);
            if (position2 + entryBlockSize + 512 > st.size) {
              break;
            }
            position2 += entryBlockSize;
            if (opt.mtimeCache) {
              opt.mtimeCache.set(h.path, h.mtime);
            }
          }
        threw = false;
        streamSync(opt, p, position2, fd, files);
      } finally {
        if (threw) {
          try {
            fs2.closeSync(fd);
          } catch (er) {
          }
        }
      }
    };
    var streamSync = (opt, p, position2, fd, files) => {
      const stream3 = new fsm.WriteStreamSync(opt.file, {
        fd,
        start: position2
      });
      p.pipe(stream3);
      addFilesSync(p, files);
    };
    var replace3 = (opt, files, cb) => {
      files = Array.from(files);
      const p = new Pack(opt);
      const getPos2 = (fd, size10, cb_) => {
        const cb2 = (er, pos) => {
          if (er) {
            fs2.close(fd, (_) => cb_(er));
          } else {
            cb_(null, pos);
          }
        };
        let position2 = 0;
        if (size10 === 0) {
          return cb2(null, 0);
        }
        let bufPos = 0;
        const headBuf = Buffer.alloc(512);
        const onread = (er, bytes) => {
          if (er) {
            return cb2(er);
          }
          bufPos += bytes;
          if (bufPos < 512 && bytes) {
            return fs2.read(
              fd,
              headBuf,
              bufPos,
              headBuf.length - bufPos,
              position2 + bufPos,
              onread
            );
          }
          if (position2 === 0 && headBuf[0] === 31 && headBuf[1] === 139) {
            return cb2(new Error("cannot append to compressed archives"));
          }
          if (bufPos < 512) {
            return cb2(null, position2);
          }
          const h = new Header(headBuf);
          if (!h.cksumValid) {
            return cb2(null, position2);
          }
          const entryBlockSize = 512 * Math.ceil(h.size / 512);
          if (position2 + entryBlockSize + 512 > size10) {
            return cb2(null, position2);
          }
          position2 += entryBlockSize + 512;
          if (position2 >= size10) {
            return cb2(null, position2);
          }
          if (opt.mtimeCache) {
            opt.mtimeCache.set(h.path, h.mtime);
          }
          bufPos = 0;
          fs2.read(fd, headBuf, 0, 512, position2, onread);
        };
        fs2.read(fd, headBuf, 0, 512, position2, onread);
      };
      const promise2 = new Promise((resolve2, reject) => {
        p.on("error", reject);
        let flag2 = "r+";
        const onopen = (er, fd) => {
          if (er && er.code === "ENOENT" && flag2 === "r+") {
            flag2 = "w+";
            return fs2.open(opt.file, flag2, onopen);
          }
          if (er) {
            return reject(er);
          }
          fs2.fstat(fd, (er2, st) => {
            if (er2) {
              return fs2.close(fd, () => reject(er2));
            }
            getPos2(fd, st.size, (er3, position2) => {
              if (er3) {
                return reject(er3);
              }
              const stream3 = new fsm.WriteStream(opt.file, {
                fd,
                start: position2
              });
              p.pipe(stream3);
              stream3.on("error", reject);
              stream3.on("close", resolve2);
              addFilesAsync(p, files);
            });
          });
        };
        fs2.open(opt.file, flag2, onopen);
      });
      return cb ? promise2.then(cb, cb) : promise2;
    };
    var addFilesSync = (p, files) => {
      files.forEach((file) => {
        if (file.charAt(0) === "@") {
          t({
            file: path5.resolve(p.cwd, file.slice(1)),
            sync: true,
            noResume: true,
            onentry: (entry) => p.add(entry)
          });
        } else {
          p.add(file);
        }
      });
      p.end();
    };
    var addFilesAsync = (p, files) => {
      while (files.length) {
        const file = files.shift();
        if (file.charAt(0) === "@") {
          return t({
            file: path5.resolve(p.cwd, file.slice(1)),
            noResume: true,
            onentry: (entry) => p.add(entry)
          }).then((_) => addFilesAsync(p, files));
        } else {
          p.add(file);
        }
      }
      p.end();
    };
  }
});

// node_modules/tar/lib/update.js
var require_update = __commonJS({
  "node_modules/tar/lib/update.js"(exports, module) {
    "use strict";
    var hlo = require_high_level_opt();
    var r = require_replace();
    module.exports = (opt_, files, cb) => {
      const opt = hlo(opt_);
      if (!opt.file) {
        throw new TypeError("file is required");
      }
      if (opt.gzip) {
        throw new TypeError("cannot append to compressed archives");
      }
      if (!files || !Array.isArray(files) || !files.length) {
        throw new TypeError("no files or directories specified");
      }
      files = Array.from(files);
      mtimeFilter(opt);
      return r(opt, files, cb);
    };
    var mtimeFilter = (opt) => {
      const filter7 = opt.filter;
      if (!opt.mtimeCache) {
        opt.mtimeCache = /* @__PURE__ */ new Map();
      }
      opt.filter = filter7 ? (path5, stat6) => filter7(path5, stat6) && !(opt.mtimeCache.get(path5) > stat6.mtime) : (path5, stat6) => !(opt.mtimeCache.get(path5) > stat6.mtime);
    };
  }
});

// node_modules/mkdirp/lib/opts-arg.js
var require_opts_arg = __commonJS({
  "node_modules/mkdirp/lib/opts-arg.js"(exports, module) {
    var { promisify } = __require("util");
    var fs2 = __require("fs");
    var optsArg = (opts) => {
      if (!opts)
        opts = { mode: 511, fs: fs2 };
      else if (typeof opts === "object")
        opts = { mode: 511, fs: fs2, ...opts };
      else if (typeof opts === "number")
        opts = { mode: opts, fs: fs2 };
      else if (typeof opts === "string")
        opts = { mode: parseInt(opts, 8), fs: fs2 };
      else
        throw new TypeError("invalid options argument");
      opts.mkdir = opts.mkdir || opts.fs.mkdir || fs2.mkdir;
      opts.mkdirAsync = promisify(opts.mkdir);
      opts.stat = opts.stat || opts.fs.stat || fs2.stat;
      opts.statAsync = promisify(opts.stat);
      opts.statSync = opts.statSync || opts.fs.statSync || fs2.statSync;
      opts.mkdirSync = opts.mkdirSync || opts.fs.mkdirSync || fs2.mkdirSync;
      return opts;
    };
    module.exports = optsArg;
  }
});

// node_modules/mkdirp/lib/path-arg.js
var require_path_arg = __commonJS({
  "node_modules/mkdirp/lib/path-arg.js"(exports, module) {
    var platform3 = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform;
    var { resolve: resolve2, parse: parse10 } = __require("path");
    var pathArg = (path5) => {
      if (/\0/.test(path5)) {
        throw Object.assign(
          new TypeError("path must be a string without null bytes"),
          {
            path: path5,
            code: "ERR_INVALID_ARG_VALUE"
          }
        );
      }
      path5 = resolve2(path5);
      if (platform3 === "win32") {
        const badWinChars = /[*|"<>?:]/;
        const { root: root2 } = parse10(path5);
        if (badWinChars.test(path5.substr(root2.length))) {
          throw Object.assign(new Error("Illegal characters in path."), {
            path: path5,
            code: "EINVAL"
          });
        }
      }
      return path5;
    };
    module.exports = pathArg;
  }
});

// node_modules/mkdirp/lib/find-made.js
var require_find_made = __commonJS({
  "node_modules/mkdirp/lib/find-made.js"(exports, module) {
    var { dirname: dirname2 } = __require("path");
    var findMade = (opts, parent, path5 = void 0) => {
      if (path5 === parent)
        return Promise.resolve();
      return opts.statAsync(parent).then(
        (st) => st.isDirectory() ? path5 : void 0,
        // will fail later
        (er) => er.code === "ENOENT" ? findMade(opts, dirname2(parent), parent) : void 0
      );
    };
    var findMadeSync = (opts, parent, path5 = void 0) => {
      if (path5 === parent)
        return void 0;
      try {
        return opts.statSync(parent).isDirectory() ? path5 : void 0;
      } catch (er) {
        return er.code === "ENOENT" ? findMadeSync(opts, dirname2(parent), parent) : void 0;
      }
    };
    module.exports = { findMade, findMadeSync };
  }
});

// node_modules/mkdirp/lib/mkdirp-manual.js
var require_mkdirp_manual = __commonJS({
  "node_modules/mkdirp/lib/mkdirp-manual.js"(exports, module) {
    var { dirname: dirname2 } = __require("path");
    var mkdirpManual = (path5, opts, made) => {
      opts.recursive = false;
      const parent = dirname2(path5);
      if (parent === path5) {
        return opts.mkdirAsync(path5, opts).catch((er) => {
          if (er.code !== "EISDIR")
            throw er;
        });
      }
      return opts.mkdirAsync(path5, opts).then(() => made || path5, (er) => {
        if (er.code === "ENOENT")
          return mkdirpManual(parent, opts).then((made2) => mkdirpManual(path5, opts, made2));
        if (er.code !== "EEXIST" && er.code !== "EROFS")
          throw er;
        return opts.statAsync(path5).then((st) => {
          if (st.isDirectory())
            return made;
          else
            throw er;
        }, () => {
          throw er;
        });
      });
    };
    var mkdirpManualSync = (path5, opts, made) => {
      const parent = dirname2(path5);
      opts.recursive = false;
      if (parent === path5) {
        try {
          return opts.mkdirSync(path5, opts);
        } catch (er) {
          if (er.code !== "EISDIR")
            throw er;
          else
            return;
        }
      }
      try {
        opts.mkdirSync(path5, opts);
        return made || path5;
      } catch (er) {
        if (er.code === "ENOENT")
          return mkdirpManualSync(path5, opts, mkdirpManualSync(parent, opts, made));
        if (er.code !== "EEXIST" && er.code !== "EROFS")
          throw er;
        try {
          if (!opts.statSync(path5).isDirectory())
            throw er;
        } catch (_) {
          throw er;
        }
      }
    };
    module.exports = { mkdirpManual, mkdirpManualSync };
  }
});

// node_modules/mkdirp/lib/mkdirp-native.js
var require_mkdirp_native = __commonJS({
  "node_modules/mkdirp/lib/mkdirp-native.js"(exports, module) {
    var { dirname: dirname2 } = __require("path");
    var { findMade, findMadeSync } = require_find_made();
    var { mkdirpManual, mkdirpManualSync } = require_mkdirp_manual();
    var mkdirpNative = (path5, opts) => {
      opts.recursive = true;
      const parent = dirname2(path5);
      if (parent === path5)
        return opts.mkdirAsync(path5, opts);
      return findMade(opts, path5).then((made) => opts.mkdirAsync(path5, opts).then(() => made).catch((er) => {
        if (er.code === "ENOENT")
          return mkdirpManual(path5, opts);
        else
          throw er;
      }));
    };
    var mkdirpNativeSync = (path5, opts) => {
      opts.recursive = true;
      const parent = dirname2(path5);
      if (parent === path5)
        return opts.mkdirSync(path5, opts);
      const made = findMadeSync(opts, path5);
      try {
        opts.mkdirSync(path5, opts);
        return made;
      } catch (er) {
        if (er.code === "ENOENT")
          return mkdirpManualSync(path5, opts);
        else
          throw er;
      }
    };
    module.exports = { mkdirpNative, mkdirpNativeSync };
  }
});

// node_modules/mkdirp/lib/use-native.js
var require_use_native = __commonJS({
  "node_modules/mkdirp/lib/use-native.js"(exports, module) {
    var fs2 = __require("fs");
    var version = process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version;
    var versArr = version.replace(/^v/, "").split(".");
    var hasNative = +versArr[0] > 10 || +versArr[0] === 10 && +versArr[1] >= 12;
    var useNative = !hasNative ? () => false : (opts) => opts.mkdir === fs2.mkdir;
    var useNativeSync = !hasNative ? () => false : (opts) => opts.mkdirSync === fs2.mkdirSync;
    module.exports = { useNative, useNativeSync };
  }
});

// node_modules/mkdirp/index.js
var require_mkdirp = __commonJS({
  "node_modules/mkdirp/index.js"(exports, module) {
    var optsArg = require_opts_arg();
    var pathArg = require_path_arg();
    var { mkdirpNative, mkdirpNativeSync } = require_mkdirp_native();
    var { mkdirpManual, mkdirpManualSync } = require_mkdirp_manual();
    var { useNative, useNativeSync } = require_use_native();
    var mkdirp7 = (path5, opts) => {
      path5 = pathArg(path5);
      opts = optsArg(opts);
      return useNative(opts) ? mkdirpNative(path5, opts) : mkdirpManual(path5, opts);
    };
    var mkdirpSync = (path5, opts) => {
      path5 = pathArg(path5);
      opts = optsArg(opts);
      return useNativeSync(opts) ? mkdirpNativeSync(path5, opts) : mkdirpManualSync(path5, opts);
    };
    mkdirp7.sync = mkdirpSync;
    mkdirp7.native = (path5, opts) => mkdirpNative(pathArg(path5), optsArg(opts));
    mkdirp7.manual = (path5, opts) => mkdirpManual(pathArg(path5), optsArg(opts));
    mkdirp7.nativeSync = (path5, opts) => mkdirpNativeSync(pathArg(path5), optsArg(opts));
    mkdirp7.manualSync = (path5, opts) => mkdirpManualSync(pathArg(path5), optsArg(opts));
    module.exports = mkdirp7;
  }
});

// node_modules/chownr/chownr.js
var require_chownr = __commonJS({
  "node_modules/chownr/chownr.js"(exports, module) {
    "use strict";
    var fs2 = __require("fs");
    var path5 = __require("path");
    var LCHOWN = fs2.lchown ? "lchown" : "chown";
    var LCHOWNSYNC = fs2.lchownSync ? "lchownSync" : "chownSync";
    var needEISDIRHandled = fs2.lchown && !process.version.match(/v1[1-9]+\./) && !process.version.match(/v10\.[6-9]/);
    var lchownSync = (path6, uid, gid) => {
      try {
        return fs2[LCHOWNSYNC](path6, uid, gid);
      } catch (er) {
        if (er.code !== "ENOENT")
          throw er;
      }
    };
    var chownSync2 = (path6, uid, gid) => {
      try {
        return fs2.chownSync(path6, uid, gid);
      } catch (er) {
        if (er.code !== "ENOENT")
          throw er;
      }
    };
    var handleEISDIR = needEISDIRHandled ? (path6, uid, gid, cb) => (er) => {
      if (!er || er.code !== "EISDIR")
        cb(er);
      else
        fs2.chown(path6, uid, gid, cb);
    } : (_, __, ___, cb) => cb;
    var handleEISDirSync = needEISDIRHandled ? (path6, uid, gid) => {
      try {
        return lchownSync(path6, uid, gid);
      } catch (er) {
        if (er.code !== "EISDIR")
          throw er;
        chownSync2(path6, uid, gid);
      }
    } : (path6, uid, gid) => lchownSync(path6, uid, gid);
    var nodeVersion2 = process.version;
    var readdir4 = (path6, options, cb) => fs2.readdir(path6, options, cb);
    var readdirSync2 = (path6, options) => fs2.readdirSync(path6, options);
    if (/^v4\./.test(nodeVersion2))
      readdir4 = (path6, options, cb) => fs2.readdir(path6, cb);
    var chown3 = (cpath, uid, gid, cb) => {
      fs2[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, (er) => {
        cb(er && er.code !== "ENOENT" ? er : null);
      }));
    };
    var chownrKid = (p, child, uid, gid, cb) => {
      if (typeof child === "string")
        return fs2.lstat(path5.resolve(p, child), (er, stats) => {
          if (er)
            return cb(er.code !== "ENOENT" ? er : null);
          stats.name = child;
          chownrKid(p, stats, uid, gid, cb);
        });
      if (child.isDirectory()) {
        chownr(path5.resolve(p, child.name), uid, gid, (er) => {
          if (er)
            return cb(er);
          const cpath = path5.resolve(p, child.name);
          chown3(cpath, uid, gid, cb);
        });
      } else {
        const cpath = path5.resolve(p, child.name);
        chown3(cpath, uid, gid, cb);
      }
    };
    var chownr = (p, uid, gid, cb) => {
      readdir4(p, { withFileTypes: true }, (er, children) => {
        if (er) {
          if (er.code === "ENOENT")
            return cb();
          else if (er.code !== "ENOTDIR" && er.code !== "ENOTSUP")
            return cb(er);
        }
        if (er || !children.length)
          return chown3(p, uid, gid, cb);
        let len = children.length;
        let errState = null;
        const then = (er2) => {
          if (errState)
            return;
          if (er2)
            return cb(errState = er2);
          if (--len === 0)
            return chown3(p, uid, gid, cb);
        };
        children.forEach((child) => chownrKid(p, child, uid, gid, then));
      });
    };
    var chownrKidSync = (p, child, uid, gid) => {
      if (typeof child === "string") {
        try {
          const stats = fs2.lstatSync(path5.resolve(p, child));
          stats.name = child;
          child = stats;
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          else
            throw er;
        }
      }
      if (child.isDirectory())
        chownrSync(path5.resolve(p, child.name), uid, gid);
      handleEISDirSync(path5.resolve(p, child.name), uid, gid);
    };
    var chownrSync = (p, uid, gid) => {
      let children;
      try {
        children = readdirSync2(p, { withFileTypes: true });
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        else if (er.code === "ENOTDIR" || er.code === "ENOTSUP")
          return handleEISDirSync(p, uid, gid);
        else
          throw er;
      }
      if (children && children.length)
        children.forEach((child) => chownrKidSync(p, child, uid, gid));
      return handleEISDirSync(p, uid, gid);
    };
    module.exports = chownr;
    chownr.sync = chownrSync;
  }
});

// node_modules/tar/lib/mkdir.js
var require_mkdir = __commonJS({
  "node_modules/tar/lib/mkdir.js"(exports, module) {
    "use strict";
    var mkdirp7 = require_mkdirp();
    var fs2 = __require("fs");
    var path5 = __require("path");
    var chownr = require_chownr();
    var normPath = require_normalize_windows_path();
    var SymlinkError = class extends Error {
      constructor(symlink3, path6) {
        super("Cannot extract through symbolic link");
        this.path = path6;
        this.symlink = symlink3;
      }
      get name() {
        return "SylinkError";
      }
    };
    var CwdError = class extends Error {
      constructor(path6, code) {
        super(code + ": Cannot cd into '" + path6 + "'");
        this.path = path6;
        this.code = code;
      }
      get name() {
        return "CwdError";
      }
    };
    var cGet = (cache, key) => cache.get(normPath(key));
    var cSet = (cache, key, val) => cache.set(normPath(key), val);
    var checkCwd = (dir, cb) => {
      fs2.stat(dir, (er, st) => {
        if (er || !st.isDirectory()) {
          er = new CwdError(dir, er && er.code || "ENOTDIR");
        }
        cb(er);
      });
    };
    module.exports = (dir, opt, cb) => {
      dir = normPath(dir);
      const umask = opt.umask;
      const mode = opt.mode | 448;
      const needChmod = (mode & umask) !== 0;
      const uid = opt.uid;
      const gid = opt.gid;
      const doChown = typeof uid === "number" && typeof gid === "number" && (uid !== opt.processUid || gid !== opt.processGid);
      const preserve = opt.preserve;
      const unlink4 = opt.unlink;
      const cache = opt.cache;
      const cwd3 = normPath(opt.cwd);
      const done = (er, created) => {
        if (er) {
          cb(er);
        } else {
          cSet(cache, dir, true);
          if (created && doChown) {
            chownr(created, uid, gid, (er2) => done(er2));
          } else if (needChmod) {
            fs2.chmod(dir, mode, cb);
          } else {
            cb();
          }
        }
      };
      if (cache && cGet(cache, dir) === true) {
        return done();
      }
      if (dir === cwd3) {
        return checkCwd(dir, done);
      }
      if (preserve) {
        return mkdirp7(dir, { mode }).then((made) => done(null, made), done);
      }
      const sub2 = normPath(path5.relative(cwd3, dir));
      const parts = sub2.split("/");
      mkdir_(cwd3, parts, mode, cache, unlink4, cwd3, null, done);
    };
    var mkdir_ = (base, parts, mode, cache, unlink4, cwd3, created, cb) => {
      if (!parts.length) {
        return cb(null, created);
      }
      const p = parts.shift();
      const part = normPath(path5.resolve(base + "/" + p));
      if (cGet(cache, part)) {
        return mkdir_(part, parts, mode, cache, unlink4, cwd3, created, cb);
      }
      fs2.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink4, cwd3, created, cb));
    };
    var onmkdir = (part, parts, mode, cache, unlink4, cwd3, created, cb) => (er) => {
      if (er) {
        fs2.lstat(part, (statEr, st) => {
          if (statEr) {
            statEr.path = statEr.path && normPath(statEr.path);
            cb(statEr);
          } else if (st.isDirectory()) {
            mkdir_(part, parts, mode, cache, unlink4, cwd3, created, cb);
          } else if (unlink4) {
            fs2.unlink(part, (er2) => {
              if (er2) {
                return cb(er2);
              }
              fs2.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink4, cwd3, created, cb));
            });
          } else if (st.isSymbolicLink()) {
            return cb(new SymlinkError(part, part + "/" + parts.join("/")));
          } else {
            cb(er);
          }
        });
      } else {
        created = created || part;
        mkdir_(part, parts, mode, cache, unlink4, cwd3, created, cb);
      }
    };
    var checkCwdSync = (dir) => {
      let ok = false;
      let code = "ENOTDIR";
      try {
        ok = fs2.statSync(dir).isDirectory();
      } catch (er) {
        code = er.code;
      } finally {
        if (!ok) {
          throw new CwdError(dir, code);
        }
      }
    };
    module.exports.sync = (dir, opt) => {
      dir = normPath(dir);
      const umask = opt.umask;
      const mode = opt.mode | 448;
      const needChmod = (mode & umask) !== 0;
      const uid = opt.uid;
      const gid = opt.gid;
      const doChown = typeof uid === "number" && typeof gid === "number" && (uid !== opt.processUid || gid !== opt.processGid);
      const preserve = opt.preserve;
      const unlink4 = opt.unlink;
      const cache = opt.cache;
      const cwd3 = normPath(opt.cwd);
      const done = (created2) => {
        cSet(cache, dir, true);
        if (created2 && doChown) {
          chownr.sync(created2, uid, gid);
        }
        if (needChmod) {
          fs2.chmodSync(dir, mode);
        }
      };
      if (cache && cGet(cache, dir) === true) {
        return done();
      }
      if (dir === cwd3) {
        checkCwdSync(cwd3);
        return done();
      }
      if (preserve) {
        return done(mkdirp7.sync(dir, mode));
      }
      const sub2 = normPath(path5.relative(cwd3, dir));
      const parts = sub2.split("/");
      let created = null;
      for (let p = parts.shift(), part = cwd3; p && (part += "/" + p); p = parts.shift()) {
        part = normPath(path5.resolve(part));
        if (cGet(cache, part)) {
          continue;
        }
        try {
          fs2.mkdirSync(part, mode);
          created = created || part;
          cSet(cache, part, true);
        } catch (er) {
          const st = fs2.lstatSync(part);
          if (st.isDirectory()) {
            cSet(cache, part, true);
            continue;
          } else if (unlink4) {
            fs2.unlinkSync(part);
            fs2.mkdirSync(part, mode);
            created = created || part;
            cSet(cache, part, true);
            continue;
          } else if (st.isSymbolicLink()) {
            return new SymlinkError(part, part + "/" + parts.join("/"));
          }
        }
      }
      return done(created);
    };
  }
});

// node_modules/tar/lib/normalize-unicode.js
var require_normalize_unicode = __commonJS({
  "node_modules/tar/lib/normalize-unicode.js"(exports, module) {
    var normalizeCache = /* @__PURE__ */ Object.create(null);
    var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
    module.exports = (s) => {
      if (!hasOwnProperty2.call(normalizeCache, s)) {
        normalizeCache[s] = s.normalize("NFD");
      }
      return normalizeCache[s];
    };
  }
});

// node_modules/tar/lib/path-reservations.js
var require_path_reservations = __commonJS({
  "node_modules/tar/lib/path-reservations.js"(exports, module) {
    var assert = __require("assert");
    var normalize2 = require_normalize_unicode();
    var stripSlashes = require_strip_trailing_slashes();
    var { join: join5 } = __require("path");
    var platform3 = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
    var isWindows3 = platform3 === "win32";
    module.exports = () => {
      const queues = /* @__PURE__ */ new Map();
      const reservations = /* @__PURE__ */ new Map();
      const getDirs = (path5) => {
        const dirs = path5.split("/").slice(0, -1).reduce((set2, path6) => {
          if (set2.length) {
            path6 = join5(set2[set2.length - 1], path6);
          }
          set2.push(path6 || "/");
          return set2;
        }, []);
        return dirs;
      };
      const running = /* @__PURE__ */ new Set();
      const getQueues = (fn) => {
        const res = reservations.get(fn);
        if (!res) {
          throw new Error("function does not have any path reservations");
        }
        return {
          paths: res.paths.map((path5) => queues.get(path5)),
          dirs: [...res.dirs].map((path5) => queues.get(path5))
        };
      };
      const check = (fn) => {
        const { paths: paths2, dirs } = getQueues(fn);
        return paths2.every((q) => q[0] === fn) && dirs.every((q) => q[0] instanceof Set && q[0].has(fn));
      };
      const run13 = (fn) => {
        if (running.has(fn) || !check(fn)) {
          return false;
        }
        running.add(fn);
        fn(() => clear2(fn));
        return true;
      };
      const clear2 = (fn) => {
        if (!running.has(fn)) {
          return false;
        }
        const { paths: paths2, dirs } = reservations.get(fn);
        const next2 = /* @__PURE__ */ new Set();
        paths2.forEach((path5) => {
          const q = queues.get(path5);
          assert.equal(q[0], fn);
          if (q.length === 1) {
            queues.delete(path5);
          } else {
            q.shift();
            if (typeof q[0] === "function") {
              next2.add(q[0]);
            } else {
              q[0].forEach((fn2) => next2.add(fn2));
            }
          }
        });
        dirs.forEach((dir) => {
          const q = queues.get(dir);
          assert(q[0] instanceof Set);
          if (q[0].size === 1 && q.length === 1) {
            queues.delete(dir);
          } else if (q[0].size === 1) {
            q.shift();
            next2.add(q[0]);
          } else {
            q[0].delete(fn);
          }
        });
        running.delete(fn);
        next2.forEach((fn2) => run13(fn2));
        return true;
      };
      const reserve = (paths2, fn) => {
        paths2 = isWindows3 ? ["win32 parallelization disabled"] : paths2.map((p) => {
          return stripSlashes(join5(normalize2(p))).toLowerCase();
        });
        const dirs = new Set(
          paths2.map((path5) => getDirs(path5)).reduce((a, b) => a.concat(b))
        );
        reservations.set(fn, { dirs, paths: paths2 });
        paths2.forEach((path5) => {
          const q = queues.get(path5);
          if (!q) {
            queues.set(path5, [fn]);
          } else {
            q.push(fn);
          }
        });
        dirs.forEach((dir) => {
          const q = queues.get(dir);
          if (!q) {
            queues.set(dir, [/* @__PURE__ */ new Set([fn])]);
          } else if (q[q.length - 1] instanceof Set) {
            q[q.length - 1].add(fn);
          } else {
            q.push(/* @__PURE__ */ new Set([fn]));
          }
        });
        return run13(fn);
      };
      return { check, reserve };
    };
  }
});

// node_modules/tar/lib/get-write-flag.js
var require_get_write_flag = __commonJS({
  "node_modules/tar/lib/get-write-flag.js"(exports, module) {
    var platform3 = process.env.__FAKE_PLATFORM__ || process.platform;
    var isWindows3 = platform3 === "win32";
    var fs2 = global.__FAKE_TESTING_FS__ || __require("fs");
    var { O_CREAT, O_TRUNC, O_WRONLY, UV_FS_O_FILEMAP = 0 } = fs2.constants;
    var fMapEnabled = isWindows3 && !!UV_FS_O_FILEMAP;
    var fMapLimit = 512 * 1024;
    var fMapFlag = UV_FS_O_FILEMAP | O_TRUNC | O_CREAT | O_WRONLY;
    module.exports = !fMapEnabled ? () => "w" : (size10) => size10 < fMapLimit ? fMapFlag : "w";
  }
});

// node_modules/tar/lib/unpack.js
var require_unpack = __commonJS({
  "node_modules/tar/lib/unpack.js"(exports, module) {
    "use strict";
    var assert = __require("assert");
    var Parser = require_parse4();
    var fs2 = __require("fs");
    var fsm = require_fs_minipass();
    var path5 = __require("path");
    var mkdir3 = require_mkdir();
    var wc = require_winchars();
    var pathReservations = require_path_reservations();
    var stripAbsolutePath = require_strip_absolute_path();
    var normPath = require_normalize_windows_path();
    var stripSlash = require_strip_trailing_slashes();
    var normalize2 = require_normalize_unicode();
    var ONENTRY = Symbol("onEntry");
    var CHECKFS = Symbol("checkFs");
    var CHECKFS2 = Symbol("checkFs2");
    var PRUNECACHE = Symbol("pruneCache");
    var ISREUSABLE = Symbol("isReusable");
    var MAKEFS = Symbol("makeFs");
    var FILE = Symbol("file");
    var DIRECTORY = Symbol("directory");
    var LINK = Symbol("link");
    var SYMLINK = Symbol("symlink");
    var HARDLINK = Symbol("hardlink");
    var UNSUPPORTED = Symbol("unsupported");
    var CHECKPATH = Symbol("checkPath");
    var MKDIR = Symbol("mkdir");
    var ONERROR = Symbol("onError");
    var PENDING = Symbol("pending");
    var PEND = Symbol("pend");
    var UNPEND = Symbol("unpend");
    var ENDED = Symbol("ended");
    var MAYBECLOSE = Symbol("maybeClose");
    var SKIP = Symbol("skip");
    var DOCHOWN = Symbol("doChown");
    var UID = Symbol("uid");
    var GID = Symbol("gid");
    var CHECKED_CWD = Symbol("checkedCwd");
    var crypto2 = __require("crypto");
    var getFlag = require_get_write_flag();
    var platform3 = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
    var isWindows3 = platform3 === "win32";
    var unlinkFile = (path6, cb) => {
      if (!isWindows3) {
        return fs2.unlink(path6, cb);
      }
      const name4 = path6 + ".DELETE." + crypto2.randomBytes(16).toString("hex");
      fs2.rename(path6, name4, (er) => {
        if (er) {
          return cb(er);
        }
        fs2.unlink(name4, cb);
      });
    };
    var unlinkFileSync = (path6) => {
      if (!isWindows3) {
        return fs2.unlinkSync(path6);
      }
      const name4 = path6 + ".DELETE." + crypto2.randomBytes(16).toString("hex");
      fs2.renameSync(path6, name4);
      fs2.unlinkSync(name4);
    };
    var uint32 = (a, b, c) => a === a >>> 0 ? a : b === b >>> 0 ? b : c;
    var cacheKeyNormalize = (path6) => stripSlash(normPath(normalize2(path6))).toLowerCase();
    var pruneCache = (cache, abs4) => {
      abs4 = cacheKeyNormalize(abs4);
      for (const path6 of cache.keys()) {
        const pnorm = cacheKeyNormalize(path6);
        if (pnorm === abs4 || pnorm.indexOf(abs4 + "/") === 0) {
          cache.delete(path6);
        }
      }
    };
    var dropCache = (cache) => {
      for (const key of cache.keys()) {
        cache.delete(key);
      }
    };
    var Unpack = class extends Parser {
      constructor(opt) {
        if (!opt) {
          opt = {};
        }
        opt.ondone = (_) => {
          this[ENDED] = true;
          this[MAYBECLOSE]();
        };
        super(opt);
        this[CHECKED_CWD] = false;
        this.reservations = pathReservations();
        this.transform = typeof opt.transform === "function" ? opt.transform : null;
        this.writable = true;
        this.readable = false;
        this[PENDING] = 0;
        this[ENDED] = false;
        this.dirCache = opt.dirCache || /* @__PURE__ */ new Map();
        if (typeof opt.uid === "number" || typeof opt.gid === "number") {
          if (typeof opt.uid !== "number" || typeof opt.gid !== "number") {
            throw new TypeError("cannot set owner without number uid and gid");
          }
          if (opt.preserveOwner) {
            throw new TypeError(
              "cannot preserve owner in archive and also set owner explicitly"
            );
          }
          this.uid = opt.uid;
          this.gid = opt.gid;
          this.setOwner = true;
        } else {
          this.uid = null;
          this.gid = null;
          this.setOwner = false;
        }
        if (opt.preserveOwner === void 0 && typeof opt.uid !== "number") {
          this.preserveOwner = process.getuid && process.getuid() === 0;
        } else {
          this.preserveOwner = !!opt.preserveOwner;
        }
        this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ? process.getuid() : null;
        this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ? process.getgid() : null;
        this.forceChown = opt.forceChown === true;
        this.win32 = !!opt.win32 || isWindows3;
        this.newer = !!opt.newer;
        this.keep = !!opt.keep;
        this.noMtime = !!opt.noMtime;
        this.preservePaths = !!opt.preservePaths;
        this.unlink = !!opt.unlink;
        this.cwd = normPath(path5.resolve(opt.cwd || process.cwd()));
        this.strip = +opt.strip || 0;
        this.processUmask = opt.noChmod ? 0 : process.umask();
        this.umask = typeof opt.umask === "number" ? opt.umask : this.processUmask;
        this.dmode = opt.dmode || 511 & ~this.umask;
        this.fmode = opt.fmode || 438 & ~this.umask;
        this.on("entry", (entry) => this[ONENTRY](entry));
      }
      // a bad or damaged archive is a warning for Parser, but an error
      // when extracting.  Mark those errors as unrecoverable, because
      // the Unpack contract cannot be met.
      warn(code, msg, data = {}) {
        if (code === "TAR_BAD_ARCHIVE" || code === "TAR_ABORT") {
          data.recoverable = false;
        }
        return super.warn(code, msg, data);
      }
      [MAYBECLOSE]() {
        if (this[ENDED] && this[PENDING] === 0) {
          this.emit("prefinish");
          this.emit("finish");
          this.emit("end");
        }
      }
      [CHECKPATH](entry) {
        if (this.strip) {
          const parts = normPath(entry.path).split("/");
          if (parts.length < this.strip) {
            return false;
          }
          entry.path = parts.slice(this.strip).join("/");
          if (entry.type === "Link") {
            const linkparts = normPath(entry.linkpath).split("/");
            if (linkparts.length >= this.strip) {
              entry.linkpath = linkparts.slice(this.strip).join("/");
            } else {
              return false;
            }
          }
        }
        if (!this.preservePaths) {
          const p = normPath(entry.path);
          const parts = p.split("/");
          if (parts.includes("..") || isWindows3 && /^[a-z]:\.\.$/i.test(parts[0])) {
            this.warn("TAR_ENTRY_ERROR", `path contains '..'`, {
              entry,
              path: p
            });
            return false;
          }
          const [root2, stripped] = stripAbsolutePath(p);
          if (root2) {
            entry.path = stripped;
            this.warn("TAR_ENTRY_INFO", `stripping ${root2} from absolute path`, {
              entry,
              path: p
            });
          }
        }
        if (path5.isAbsolute(entry.path)) {
          entry.absolute = normPath(path5.resolve(entry.path));
        } else {
          entry.absolute = normPath(path5.resolve(this.cwd, entry.path));
        }
        if (!this.preservePaths && entry.absolute.indexOf(this.cwd + "/") !== 0 && entry.absolute !== this.cwd) {
          this.warn("TAR_ENTRY_ERROR", "path escaped extraction target", {
            entry,
            path: normPath(entry.path),
            resolvedPath: entry.absolute,
            cwd: this.cwd
          });
          return false;
        }
        if (entry.absolute === this.cwd && entry.type !== "Directory" && entry.type !== "GNUDumpDir") {
          return false;
        }
        if (this.win32) {
          const { root: aRoot } = path5.win32.parse(entry.absolute);
          entry.absolute = aRoot + wc.encode(entry.absolute.slice(aRoot.length));
          const { root: pRoot } = path5.win32.parse(entry.path);
          entry.path = pRoot + wc.encode(entry.path.slice(pRoot.length));
        }
        return true;
      }
      [ONENTRY](entry) {
        if (!this[CHECKPATH](entry)) {
          return entry.resume();
        }
        assert.equal(typeof entry.absolute, "string");
        switch (entry.type) {
          case "Directory":
          case "GNUDumpDir":
            if (entry.mode) {
              entry.mode = entry.mode | 448;
            }
          case "File":
          case "OldFile":
          case "ContiguousFile":
          case "Link":
          case "SymbolicLink":
            return this[CHECKFS](entry);
          case "CharacterDevice":
          case "BlockDevice":
          case "FIFO":
          default:
            return this[UNSUPPORTED](entry);
        }
      }
      [ONERROR](er, entry) {
        if (er.name === "CwdError") {
          this.emit("error", er);
        } else {
          this.warn("TAR_ENTRY_ERROR", er, { entry });
          this[UNPEND]();
          entry.resume();
        }
      }
      [MKDIR](dir, mode, cb) {
        mkdir3(normPath(dir), {
          uid: this.uid,
          gid: this.gid,
          processUid: this.processUid,
          processGid: this.processGid,
          umask: this.processUmask,
          preserve: this.preservePaths,
          unlink: this.unlink,
          cache: this.dirCache,
          cwd: this.cwd,
          mode,
          noChmod: this.noChmod
        }, cb);
      }
      [DOCHOWN](entry) {
        return this.forceChown || this.preserveOwner && (typeof entry.uid === "number" && entry.uid !== this.processUid || typeof entry.gid === "number" && entry.gid !== this.processGid) || (typeof this.uid === "number" && this.uid !== this.processUid || typeof this.gid === "number" && this.gid !== this.processGid);
      }
      [UID](entry) {
        return uint32(this.uid, entry.uid, this.processUid);
      }
      [GID](entry) {
        return uint32(this.gid, entry.gid, this.processGid);
      }
      [FILE](entry, fullyDone) {
        const mode = entry.mode & 4095 || this.fmode;
        const stream3 = new fsm.WriteStream(entry.absolute, {
          flags: getFlag(entry.size),
          mode,
          autoClose: false
        });
        stream3.on("error", (er) => {
          if (stream3.fd) {
            fs2.close(stream3.fd, () => {
            });
          }
          stream3.write = () => true;
          this[ONERROR](er, entry);
          fullyDone();
        });
        let actions = 1;
        const done = (er) => {
          if (er) {
            if (stream3.fd) {
              fs2.close(stream3.fd, () => {
              });
            }
            this[ONERROR](er, entry);
            fullyDone();
            return;
          }
          if (--actions === 0) {
            fs2.close(stream3.fd, (er2) => {
              if (er2) {
                this[ONERROR](er2, entry);
              } else {
                this[UNPEND]();
              }
              fullyDone();
            });
          }
        };
        stream3.on("finish", (_) => {
          const abs4 = entry.absolute;
          const fd = stream3.fd;
          if (entry.mtime && !this.noMtime) {
            actions++;
            const atime = entry.atime || /* @__PURE__ */ new Date();
            const mtime = entry.mtime;
            fs2.futimes(fd, atime, mtime, (er) => er ? fs2.utimes(abs4, atime, mtime, (er2) => done(er2 && er)) : done());
          }
          if (this[DOCHOWN](entry)) {
            actions++;
            const uid = this[UID](entry);
            const gid = this[GID](entry);
            fs2.fchown(fd, uid, gid, (er) => er ? fs2.chown(abs4, uid, gid, (er2) => done(er2 && er)) : done());
          }
          done();
        });
        const tx = this.transform ? this.transform(entry) || entry : entry;
        if (tx !== entry) {
          tx.on("error", (er) => {
            this[ONERROR](er, entry);
            fullyDone();
          });
          entry.pipe(tx);
        }
        tx.pipe(stream3);
      }
      [DIRECTORY](entry, fullyDone) {
        const mode = entry.mode & 4095 || this.dmode;
        this[MKDIR](entry.absolute, mode, (er) => {
          if (er) {
            this[ONERROR](er, entry);
            fullyDone();
            return;
          }
          let actions = 1;
          const done = (_) => {
            if (--actions === 0) {
              fullyDone();
              this[UNPEND]();
              entry.resume();
            }
          };
          if (entry.mtime && !this.noMtime) {
            actions++;
            fs2.utimes(entry.absolute, entry.atime || /* @__PURE__ */ new Date(), entry.mtime, done);
          }
          if (this[DOCHOWN](entry)) {
            actions++;
            fs2.chown(entry.absolute, this[UID](entry), this[GID](entry), done);
          }
          done();
        });
      }
      [UNSUPPORTED](entry) {
        entry.unsupported = true;
        this.warn(
          "TAR_ENTRY_UNSUPPORTED",
          `unsupported entry type: ${entry.type}`,
          { entry }
        );
        entry.resume();
      }
      [SYMLINK](entry, done) {
        this[LINK](entry, entry.linkpath, "symlink", done);
      }
      [HARDLINK](entry, done) {
        const linkpath = normPath(path5.resolve(this.cwd, entry.linkpath));
        this[LINK](entry, linkpath, "link", done);
      }
      [PEND]() {
        this[PENDING]++;
      }
      [UNPEND]() {
        this[PENDING]--;
        this[MAYBECLOSE]();
      }
      [SKIP](entry) {
        this[UNPEND]();
        entry.resume();
      }
      // Check if we can reuse an existing filesystem entry safely and
      // overwrite it, rather than unlinking and recreating
      // Windows doesn't report a useful nlink, so we just never reuse entries
      [ISREUSABLE](entry, st) {
        return entry.type === "File" && !this.unlink && st.isFile() && st.nlink <= 1 && !isWindows3;
      }
      // check if a thing is there, and if so, try to clobber it
      [CHECKFS](entry) {
        this[PEND]();
        const paths2 = [entry.path];
        if (entry.linkpath) {
          paths2.push(entry.linkpath);
        }
        this.reservations.reserve(paths2, (done) => this[CHECKFS2](entry, done));
      }
      [PRUNECACHE](entry) {
        if (entry.type === "SymbolicLink") {
          dropCache(this.dirCache);
        } else if (entry.type !== "Directory") {
          pruneCache(this.dirCache, entry.absolute);
        }
      }
      [CHECKFS2](entry, fullyDone) {
        this[PRUNECACHE](entry);
        const done = (er) => {
          this[PRUNECACHE](entry);
          fullyDone(er);
        };
        const checkCwd = () => {
          this[MKDIR](this.cwd, this.dmode, (er) => {
            if (er) {
              this[ONERROR](er, entry);
              done();
              return;
            }
            this[CHECKED_CWD] = true;
            start();
          });
        };
        const start = () => {
          if (entry.absolute !== this.cwd) {
            const parent = normPath(path5.dirname(entry.absolute));
            if (parent !== this.cwd) {
              return this[MKDIR](parent, this.dmode, (er) => {
                if (er) {
                  this[ONERROR](er, entry);
                  done();
                  return;
                }
                afterMakeParent();
              });
            }
          }
          afterMakeParent();
        };
        const afterMakeParent = () => {
          fs2.lstat(entry.absolute, (lstatEr, st) => {
            if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {
              this[SKIP](entry);
              done();
              return;
            }
            if (lstatEr || this[ISREUSABLE](entry, st)) {
              return this[MAKEFS](null, entry, done);
            }
            if (st.isDirectory()) {
              if (entry.type === "Directory") {
                const needChmod = !this.noChmod && entry.mode && (st.mode & 4095) !== entry.mode;
                const afterChmod = (er) => this[MAKEFS](er, entry, done);
                if (!needChmod) {
                  return afterChmod();
                }
                return fs2.chmod(entry.absolute, entry.mode, afterChmod);
              }
              if (entry.absolute !== this.cwd) {
                return fs2.rmdir(entry.absolute, (er) => this[MAKEFS](er, entry, done));
              }
            }
            if (entry.absolute === this.cwd) {
              return this[MAKEFS](null, entry, done);
            }
            unlinkFile(entry.absolute, (er) => this[MAKEFS](er, entry, done));
          });
        };
        if (this[CHECKED_CWD]) {
          start();
        } else {
          checkCwd();
        }
      }
      [MAKEFS](er, entry, done) {
        if (er) {
          this[ONERROR](er, entry);
          done();
          return;
        }
        switch (entry.type) {
          case "File":
          case "OldFile":
          case "ContiguousFile":
            return this[FILE](entry, done);
          case "Link":
            return this[HARDLINK](entry, done);
          case "SymbolicLink":
            return this[SYMLINK](entry, done);
          case "Directory":
          case "GNUDumpDir":
            return this[DIRECTORY](entry, done);
        }
      }
      [LINK](entry, linkpath, link4, done) {
        fs2[link4](linkpath, entry.absolute, (er) => {
          if (er) {
            this[ONERROR](er, entry);
          } else {
            this[UNPEND]();
            entry.resume();
          }
          done();
        });
      }
    };
    var callSync = (fn) => {
      try {
        return [null, fn()];
      } catch (er) {
        return [er, null];
      }
    };
    var UnpackSync = class extends Unpack {
      [MAKEFS](er, entry) {
        return super[MAKEFS](er, entry, () => {
        });
      }
      [CHECKFS](entry) {
        this[PRUNECACHE](entry);
        if (!this[CHECKED_CWD]) {
          const er2 = this[MKDIR](this.cwd, this.dmode);
          if (er2) {
            return this[ONERROR](er2, entry);
          }
          this[CHECKED_CWD] = true;
        }
        if (entry.absolute !== this.cwd) {
          const parent = normPath(path5.dirname(entry.absolute));
          if (parent !== this.cwd) {
            const mkParent = this[MKDIR](parent, this.dmode);
            if (mkParent) {
              return this[ONERROR](mkParent, entry);
            }
          }
        }
        const [lstatEr, st] = callSync(() => fs2.lstatSync(entry.absolute));
        if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {
          return this[SKIP](entry);
        }
        if (lstatEr || this[ISREUSABLE](entry, st)) {
          return this[MAKEFS](null, entry);
        }
        if (st.isDirectory()) {
          if (entry.type === "Directory") {
            const needChmod = !this.noChmod && entry.mode && (st.mode & 4095) !== entry.mode;
            const [er3] = needChmod ? callSync(() => {
              fs2.chmodSync(entry.absolute, entry.mode);
            }) : [];
            return this[MAKEFS](er3, entry);
          }
          const [er2] = callSync(() => fs2.rmdirSync(entry.absolute));
          this[MAKEFS](er2, entry);
        }
        const [er] = entry.absolute === this.cwd ? [] : callSync(() => unlinkFileSync(entry.absolute));
        this[MAKEFS](er, entry);
      }
      [FILE](entry, done) {
        const mode = entry.mode & 4095 || this.fmode;
        const oner = (er) => {
          let closeError;
          try {
            fs2.closeSync(fd);
          } catch (e) {
            closeError = e;
          }
          if (er || closeError) {
            this[ONERROR](er || closeError, entry);
          }
          done();
        };
        let fd;
        try {
          fd = fs2.openSync(entry.absolute, getFlag(entry.size), mode);
        } catch (er) {
          return oner(er);
        }
        const tx = this.transform ? this.transform(entry) || entry : entry;
        if (tx !== entry) {
          tx.on("error", (er) => this[ONERROR](er, entry));
          entry.pipe(tx);
        }
        tx.on("data", (chunk) => {
          try {
            fs2.writeSync(fd, chunk, 0, chunk.length);
          } catch (er) {
            oner(er);
          }
        });
        tx.on("end", (_) => {
          let er = null;
          if (entry.mtime && !this.noMtime) {
            const atime = entry.atime || /* @__PURE__ */ new Date();
            const mtime = entry.mtime;
            try {
              fs2.futimesSync(fd, atime, mtime);
            } catch (futimeser) {
              try {
                fs2.utimesSync(entry.absolute, atime, mtime);
              } catch (utimeser) {
                er = futimeser;
              }
            }
          }
          if (this[DOCHOWN](entry)) {
            const uid = this[UID](entry);
            const gid = this[GID](entry);
            try {
              fs2.fchownSync(fd, uid, gid);
            } catch (fchowner) {
              try {
                fs2.chownSync(entry.absolute, uid, gid);
              } catch (chowner) {
                er = er || fchowner;
              }
            }
          }
          oner(er);
        });
      }
      [DIRECTORY](entry, done) {
        const mode = entry.mode & 4095 || this.dmode;
        const er = this[MKDIR](entry.absolute, mode);
        if (er) {
          this[ONERROR](er, entry);
          done();
          return;
        }
        if (entry.mtime && !this.noMtime) {
          try {
            fs2.utimesSync(entry.absolute, entry.atime || /* @__PURE__ */ new Date(), entry.mtime);
          } catch (er2) {
          }
        }
        if (this[DOCHOWN](entry)) {
          try {
            fs2.chownSync(entry.absolute, this[UID](entry), this[GID](entry));
          } catch (er2) {
          }
        }
        done();
        entry.resume();
      }
      [MKDIR](dir, mode) {
        try {
          return mkdir3.sync(normPath(dir), {
            uid: this.uid,
            gid: this.gid,
            processUid: this.processUid,
            processGid: this.processGid,
            umask: this.processUmask,
            preserve: this.preservePaths,
            unlink: this.unlink,
            cache: this.dirCache,
            cwd: this.cwd,
            mode
          });
        } catch (er) {
          return er;
        }
      }
      [LINK](entry, linkpath, link4, done) {
        try {
          fs2[link4 + "Sync"](linkpath, entry.absolute);
          done();
          entry.resume();
        } catch (er) {
          return this[ONERROR](er, entry);
        }
      }
    };
    Unpack.Sync = UnpackSync;
    module.exports = Unpack;
  }
});

// node_modules/tar/lib/extract.js
var require_extract = __commonJS({
  "node_modules/tar/lib/extract.js"(exports, module) {
    "use strict";
    var hlo = require_high_level_opt();
    var Unpack = require_unpack();
    var fs2 = __require("fs");
    var fsm = require_fs_minipass();
    var path5 = __require("path");
    var stripSlash = require_strip_trailing_slashes();
    module.exports = (opt_, files, cb) => {
      if (typeof opt_ === "function") {
        cb = opt_, files = null, opt_ = {};
      } else if (Array.isArray(opt_)) {
        files = opt_, opt_ = {};
      }
      if (typeof files === "function") {
        cb = files, files = null;
      }
      if (!files) {
        files = [];
      } else {
        files = Array.from(files);
      }
      const opt = hlo(opt_);
      if (opt.sync && typeof cb === "function") {
        throw new TypeError("callback not supported for sync tar functions");
      }
      if (!opt.file && typeof cb === "function") {
        throw new TypeError("callback only supported with file option");
      }
      if (files.length) {
        filesFilter(opt, files);
      }
      return opt.file && opt.sync ? extractFileSync(opt) : opt.file ? extractFile(opt, cb) : opt.sync ? extractSync(opt) : extract4(opt);
    };
    var filesFilter = (opt, files) => {
      const map86 = new Map(files.map((f) => [stripSlash(f), true]));
      const filter7 = opt.filter;
      const mapHas = (file, r) => {
        const root2 = r || path5.parse(file).root || ".";
        const ret = file === root2 ? false : map86.has(file) ? map86.get(file) : mapHas(path5.dirname(file), root2);
        map86.set(file, ret);
        return ret;
      };
      opt.filter = filter7 ? (file, entry) => filter7(file, entry) && mapHas(stripSlash(file)) : (file) => mapHas(stripSlash(file));
    };
    var extractFileSync = (opt) => {
      const u = new Unpack.Sync(opt);
      const file = opt.file;
      const stat6 = fs2.statSync(file);
      const readSize = opt.maxReadSize || 16 * 1024 * 1024;
      const stream3 = new fsm.ReadStreamSync(file, {
        readSize,
        size: stat6.size
      });
      stream3.pipe(u);
    };
    var extractFile = (opt, cb) => {
      const u = new Unpack(opt);
      const readSize = opt.maxReadSize || 16 * 1024 * 1024;
      const file = opt.file;
      const p = new Promise((resolve2, reject) => {
        u.on("error", reject);
        u.on("close", resolve2);
        fs2.stat(file, (er, stat6) => {
          if (er) {
            reject(er);
          } else {
            const stream3 = new fsm.ReadStream(file, {
              readSize,
              size: stat6.size
            });
            stream3.on("error", reject);
            stream3.pipe(u);
          }
        });
      });
      return cb ? p.then(cb, cb) : p;
    };
    var extractSync = (opt) => new Unpack.Sync(opt);
    var extract4 = (opt) => new Unpack(opt);
  }
});

// node_modules/tar/index.js
var require_tar = __commonJS({
  "node_modules/tar/index.js"(exports) {
    "use strict";
    exports.c = exports.create = require_create();
    exports.r = exports.replace = require_replace();
    exports.t = exports.list = require_list();
    exports.u = exports.update = require_update();
    exports.x = exports.extract = require_extract();
    exports.Pack = require_pack();
    exports.Unpack = require_unpack();
    exports.Parse = require_parse4();
    exports.ReadEntry = require_read_entry();
    exports.WriteEntry = require_write_entry();
    exports.Header = require_header();
    exports.Pax = require_pax();
    exports.types = require_types();
  }
});

// node_modules/asn1/lib/ber/errors.js
var require_errors2 = __commonJS({
  "node_modules/asn1/lib/ber/errors.js"(exports, module) {
    module.exports = {
      newInvalidAsn1Error: function(msg) {
        var e = new Error();
        e.name = "InvalidAsn1Error";
        e.message = msg || "";
        return e;
      }
    };
  }
});

// node_modules/asn1/lib/ber/types.js
var require_types2 = __commonJS({
  "node_modules/asn1/lib/ber/types.js"(exports, module) {
    module.exports = {
      EOC: 0,
      Boolean: 1,
      Integer: 2,
      BitString: 3,
      OctetString: 4,
      Null: 5,
      OID: 6,
      ObjectDescriptor: 7,
      External: 8,
      Real: 9,
      // float
      Enumeration: 10,
      PDV: 11,
      Utf8String: 12,
      RelativeOID: 13,
      Sequence: 16,
      Set: 17,
      NumericString: 18,
      PrintableString: 19,
      T61String: 20,
      VideotexString: 21,
      IA5String: 22,
      UTCTime: 23,
      GeneralizedTime: 24,
      GraphicString: 25,
      VisibleString: 26,
      GeneralString: 28,
      UniversalString: 29,
      CharacterString: 30,
      BMPString: 31,
      Constructor: 32,
      Context: 128
    };
  }
});

// node_modules/safer-buffer/safer.js
var require_safer = __commonJS({
  "node_modules/safer-buffer/safer.js"(exports, module) {
    "use strict";
    var buffer = __require("buffer");
    var Buffer2 = buffer.Buffer;
    var safer = {};
    var key;
    for (key in buffer) {
      if (!buffer.hasOwnProperty(key))
        continue;
      if (key === "SlowBuffer" || key === "Buffer")
        continue;
      safer[key] = buffer[key];
    }
    var Safer = safer.Buffer = {};
    for (key in Buffer2) {
      if (!Buffer2.hasOwnProperty(key))
        continue;
      if (key === "allocUnsafe" || key === "allocUnsafeSlow")
        continue;
      Safer[key] = Buffer2[key];
    }
    safer.Buffer.prototype = Buffer2.prototype;
    if (!Safer.from || Safer.from === Uint8Array.from) {
      Safer.from = function(value4, encodingOrOffset, length7) {
        if (typeof value4 === "number") {
          throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value4);
        }
        if (value4 && typeof value4.length === "undefined") {
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value4);
        }
        return Buffer2(value4, encodingOrOffset, length7);
      };
    }
    if (!Safer.alloc) {
      Safer.alloc = function(size10, fill4, encoding) {
        if (typeof size10 !== "number") {
          throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size10);
        }
        if (size10 < 0 || size10 >= 2 * (1 << 30)) {
          throw new RangeError('The value "' + size10 + '" is invalid for option "size"');
        }
        var buf = Buffer2(size10);
        if (!fill4 || fill4.length === 0) {
          buf.fill(0);
        } else if (typeof encoding === "string") {
          buf.fill(fill4, encoding);
        } else {
          buf.fill(fill4);
        }
        return buf;
      };
    }
    if (!safer.kStringMaxLength) {
      try {
        safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
      } catch (e) {
      }
    }
    if (!safer.constants) {
      safer.constants = {
        MAX_LENGTH: safer.kMaxLength
      };
      if (safer.kStringMaxLength) {
        safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
      }
    }
    module.exports = safer;
  }
});

// node_modules/asn1/lib/ber/reader.js
var require_reader3 = __commonJS({
  "node_modules/asn1/lib/ber/reader.js"(exports, module) {
    var assert = __require("assert");
    var Buffer2 = require_safer().Buffer;
    var ASN1 = require_types2();
    var errors = require_errors2();
    var newInvalidAsn1Error = errors.newInvalidAsn1Error;
    function Reader(data) {
      if (!data || !Buffer2.isBuffer(data))
        throw new TypeError("data must be a node Buffer");
      this._buf = data;
      this._size = data.length;
      this._len = 0;
      this._offset = 0;
    }
    Object.defineProperty(Reader.prototype, "length", {
      enumerable: true,
      get: function() {
        return this._len;
      }
    });
    Object.defineProperty(Reader.prototype, "offset", {
      enumerable: true,
      get: function() {
        return this._offset;
      }
    });
    Object.defineProperty(Reader.prototype, "remain", {
      get: function() {
        return this._size - this._offset;
      }
    });
    Object.defineProperty(Reader.prototype, "buffer", {
      get: function() {
        return this._buf.slice(this._offset);
      }
    });
    Reader.prototype.readByte = function(peek2) {
      if (this._size - this._offset < 1)
        return null;
      var b = this._buf[this._offset] & 255;
      if (!peek2)
        this._offset += 1;
      return b;
    };
    Reader.prototype.peek = function() {
      return this.readByte(true);
    };
    Reader.prototype.readLength = function(offset) {
      if (offset === void 0)
        offset = this._offset;
      if (offset >= this._size)
        return null;
      var lenB = this._buf[offset++] & 255;
      if (lenB === null)
        return null;
      if ((lenB & 128) === 128) {
        lenB &= 127;
        if (lenB === 0)
          throw newInvalidAsn1Error("Indefinite length not supported");
        if (lenB > 4)
          throw newInvalidAsn1Error("encoding too long");
        if (this._size - offset < lenB)
          return null;
        this._len = 0;
        for (var i = 0; i < lenB; i++)
          this._len = (this._len << 8) + (this._buf[offset++] & 255);
      } else {
        this._len = lenB;
      }
      return offset;
    };
    Reader.prototype.readSequence = function(tag) {
      var seq = this.peek();
      if (seq === null)
        return null;
      if (tag !== void 0 && tag !== seq)
        throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + seq.toString(16));
      var o = this.readLength(this._offset + 1);
      if (o === null)
        return null;
      this._offset = o;
      return seq;
    };
    Reader.prototype.readInt = function() {
      return this._readTag(ASN1.Integer);
    };
    Reader.prototype.readBoolean = function() {
      return this._readTag(ASN1.Boolean) === 0 ? false : true;
    };
    Reader.prototype.readEnumeration = function() {
      return this._readTag(ASN1.Enumeration);
    };
    Reader.prototype.readString = function(tag, retbuf) {
      if (!tag)
        tag = ASN1.OctetString;
      var b = this.peek();
      if (b === null)
        return null;
      if (b !== tag)
        throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + b.toString(16));
      var o = this.readLength(this._offset + 1);
      if (o === null)
        return null;
      if (this.length > this._size - o)
        return null;
      this._offset = o;
      if (this.length === 0)
        return retbuf ? Buffer2.alloc(0) : "";
      var str2 = this._buf.slice(this._offset, this._offset + this.length);
      this._offset += this.length;
      return retbuf ? str2 : str2.toString("utf8");
    };
    Reader.prototype.readOID = function(tag) {
      if (!tag)
        tag = ASN1.OID;
      var b = this.readString(tag, true);
      if (b === null)
        return null;
      var values2 = [];
      var value4 = 0;
      for (var i = 0; i < b.length; i++) {
        var byte = b[i] & 255;
        value4 <<= 7;
        value4 += byte & 127;
        if ((byte & 128) === 0) {
          values2.push(value4);
          value4 = 0;
        }
      }
      value4 = values2.shift();
      values2.unshift(value4 % 40);
      values2.unshift(value4 / 40 >> 0);
      return values2.join(".");
    };
    Reader.prototype._readTag = function(tag) {
      assert.ok(tag !== void 0);
      var b = this.peek();
      if (b === null)
        return null;
      if (b !== tag)
        throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + b.toString(16));
      var o = this.readLength(this._offset + 1);
      if (o === null)
        return null;
      if (this.length > 4)
        throw newInvalidAsn1Error("Integer too long: " + this.length);
      if (this.length > this._size - o)
        return null;
      this._offset = o;
      var fb = this._buf[this._offset];
      var value4 = 0;
      for (var i = 0; i < this.length; i++) {
        value4 <<= 8;
        value4 |= this._buf[this._offset++] & 255;
      }
      if ((fb & 128) === 128 && i !== 4)
        value4 -= 1 << i * 8;
      return value4 >> 0;
    };
    module.exports = Reader;
  }
});

// node_modules/asn1/lib/ber/writer.js
var require_writer = __commonJS({
  "node_modules/asn1/lib/ber/writer.js"(exports, module) {
    var assert = __require("assert");
    var Buffer2 = require_safer().Buffer;
    var ASN1 = require_types2();
    var errors = require_errors2();
    var newInvalidAsn1Error = errors.newInvalidAsn1Error;
    var DEFAULT_OPTS = {
      size: 1024,
      growthFactor: 8
    };
    function merge4(from3, to2) {
      assert.ok(from3);
      assert.equal(typeof from3, "object");
      assert.ok(to2);
      assert.equal(typeof to2, "object");
      var keys4 = Object.getOwnPropertyNames(from3);
      keys4.forEach(function(key) {
        if (to2[key])
          return;
        var value4 = Object.getOwnPropertyDescriptor(from3, key);
        Object.defineProperty(to2, key, value4);
      });
      return to2;
    }
    function Writer(options) {
      options = merge4(DEFAULT_OPTS, options || {});
      this._buf = Buffer2.alloc(options.size || 1024);
      this._size = this._buf.length;
      this._offset = 0;
      this._options = options;
      this._seq = [];
    }
    Object.defineProperty(Writer.prototype, "buffer", {
      get: function() {
        if (this._seq.length)
          throw newInvalidAsn1Error(this._seq.length + " unended sequence(s)");
        return this._buf.slice(0, this._offset);
      }
    });
    Writer.prototype.writeByte = function(b) {
      if (typeof b !== "number")
        throw new TypeError("argument must be a Number");
      this._ensure(1);
      this._buf[this._offset++] = b;
    };
    Writer.prototype.writeInt = function(i, tag) {
      if (typeof i !== "number")
        throw new TypeError("argument must be a Number");
      if (typeof tag !== "number")
        tag = ASN1.Integer;
      var sz = 4;
      while (((i & 4286578688) === 0 || (i & 4286578688) === 4286578688 >> 0) && sz > 1) {
        sz--;
        i <<= 8;
      }
      if (sz > 4)
        throw newInvalidAsn1Error("BER ints cannot be > 0xffffffff");
      this._ensure(2 + sz);
      this._buf[this._offset++] = tag;
      this._buf[this._offset++] = sz;
      while (sz-- > 0) {
        this._buf[this._offset++] = (i & 4278190080) >>> 24;
        i <<= 8;
      }
    };
    Writer.prototype.writeNull = function() {
      this.writeByte(ASN1.Null);
      this.writeByte(0);
    };
    Writer.prototype.writeEnumeration = function(i, tag) {
      if (typeof i !== "number")
        throw new TypeError("argument must be a Number");
      if (typeof tag !== "number")
        tag = ASN1.Enumeration;
      return this.writeInt(i, tag);
    };
    Writer.prototype.writeBoolean = function(b, tag) {
      if (typeof b !== "boolean")
        throw new TypeError("argument must be a Boolean");
      if (typeof tag !== "number")
        tag = ASN1.Boolean;
      this._ensure(3);
      this._buf[this._offset++] = tag;
      this._buf[this._offset++] = 1;
      this._buf[this._offset++] = b ? 255 : 0;
    };
    Writer.prototype.writeString = function(s, tag) {
      if (typeof s !== "string")
        throw new TypeError("argument must be a string (was: " + typeof s + ")");
      if (typeof tag !== "number")
        tag = ASN1.OctetString;
      var len = Buffer2.byteLength(s);
      this.writeByte(tag);
      this.writeLength(len);
      if (len) {
        this._ensure(len);
        this._buf.write(s, this._offset);
        this._offset += len;
      }
    };
    Writer.prototype.writeBuffer = function(buf, tag) {
      if (typeof tag !== "number")
        throw new TypeError("tag must be a number");
      if (!Buffer2.isBuffer(buf))
        throw new TypeError("argument must be a buffer");
      this.writeByte(tag);
      this.writeLength(buf.length);
      this._ensure(buf.length);
      buf.copy(this._buf, this._offset, 0, buf.length);
      this._offset += buf.length;
    };
    Writer.prototype.writeStringArray = function(strings) {
      if (!strings instanceof Array)
        throw new TypeError("argument must be an Array[String]");
      var self2 = this;
      strings.forEach(function(s) {
        self2.writeString(s);
      });
    };
    Writer.prototype.writeOID = function(s, tag) {
      if (typeof s !== "string")
        throw new TypeError("argument must be a string");
      if (typeof tag !== "number")
        tag = ASN1.OID;
      if (!/^([0-9]+\.){3,}[0-9]+$/.test(s))
        throw new Error("argument is not a valid OID string");
      function encodeOctet(bytes2, octet) {
        if (octet < 128) {
          bytes2.push(octet);
        } else if (octet < 16384) {
          bytes2.push(octet >>> 7 | 128);
          bytes2.push(octet & 127);
        } else if (octet < 2097152) {
          bytes2.push(octet >>> 14 | 128);
          bytes2.push((octet >>> 7 | 128) & 255);
          bytes2.push(octet & 127);
        } else if (octet < 268435456) {
          bytes2.push(octet >>> 21 | 128);
          bytes2.push((octet >>> 14 | 128) & 255);
          bytes2.push((octet >>> 7 | 128) & 255);
          bytes2.push(octet & 127);
        } else {
          bytes2.push((octet >>> 28 | 128) & 255);
          bytes2.push((octet >>> 21 | 128) & 255);
          bytes2.push((octet >>> 14 | 128) & 255);
          bytes2.push((octet >>> 7 | 128) & 255);
          bytes2.push(octet & 127);
        }
      }
      var tmp = s.split(".");
      var bytes = [];
      bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));
      tmp.slice(2).forEach(function(b) {
        encodeOctet(bytes, parseInt(b, 10));
      });
      var self2 = this;
      this._ensure(2 + bytes.length);
      this.writeByte(tag);
      this.writeLength(bytes.length);
      bytes.forEach(function(b) {
        self2.writeByte(b);
      });
    };
    Writer.prototype.writeLength = function(len) {
      if (typeof len !== "number")
        throw new TypeError("argument must be a Number");
      this._ensure(4);
      if (len <= 127) {
        this._buf[this._offset++] = len;
      } else if (len <= 255) {
        this._buf[this._offset++] = 129;
        this._buf[this._offset++] = len;
      } else if (len <= 65535) {
        this._buf[this._offset++] = 130;
        this._buf[this._offset++] = len >> 8;
        this._buf[this._offset++] = len;
      } else if (len <= 16777215) {
        this._buf[this._offset++] = 131;
        this._buf[this._offset++] = len >> 16;
        this._buf[this._offset++] = len >> 8;
        this._buf[this._offset++] = len;
      } else {
        throw newInvalidAsn1Error("Length too long (> 4 bytes)");
      }
    };
    Writer.prototype.startSequence = function(tag) {
      if (typeof tag !== "number")
        tag = ASN1.Sequence | ASN1.Constructor;
      this.writeByte(tag);
      this._seq.push(this._offset);
      this._ensure(3);
      this._offset += 3;
    };
    Writer.prototype.endSequence = function() {
      var seq = this._seq.pop();
      var start = seq + 3;
      var len = this._offset - start;
      if (len <= 127) {
        this._shift(start, len, -2);
        this._buf[seq] = len;
      } else if (len <= 255) {
        this._shift(start, len, -1);
        this._buf[seq] = 129;
        this._buf[seq + 1] = len;
      } else if (len <= 65535) {
        this._buf[seq] = 130;
        this._buf[seq + 1] = len >> 8;
        this._buf[seq + 2] = len;
      } else if (len <= 16777215) {
        this._shift(start, len, 1);
        this._buf[seq] = 131;
        this._buf[seq + 1] = len >> 16;
        this._buf[seq + 2] = len >> 8;
        this._buf[seq + 3] = len;
      } else {
        throw newInvalidAsn1Error("Sequence too long");
      }
    };
    Writer.prototype._shift = function(start, len, shift) {
      assert.ok(start !== void 0);
      assert.ok(len !== void 0);
      assert.ok(shift);
      this._buf.copy(this._buf, start + shift, start, start + len);
      this._offset += shift;
    };
    Writer.prototype._ensure = function(len) {
      assert.ok(len);
      if (this._size - this._offset < len) {
        var sz = this._size * this._options.growthFactor;
        if (sz - this._offset < len)
          sz += len;
        var buf = Buffer2.alloc(sz);
        this._buf.copy(buf, 0, 0, this._offset);
        this._buf = buf;
        this._size = sz;
      }
    };
    module.exports = Writer;
  }
});

// node_modules/asn1/lib/ber/index.js
var require_ber = __commonJS({
  "node_modules/asn1/lib/ber/index.js"(exports, module) {
    var errors = require_errors2();
    var types = require_types2();
    var Reader = require_reader3();
    var Writer = require_writer();
    module.exports = {
      Reader,
      Writer
    };
    for (t in types) {
      if (types.hasOwnProperty(t))
        module.exports[t] = types[t];
    }
    var t;
    for (e in errors) {
      if (errors.hasOwnProperty(e))
        module.exports[e] = errors[e];
    }
    var e;
  }
});

// node_modules/asn1/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/asn1/lib/index.js"(exports, module) {
    var Ber = require_ber();
    module.exports = {
      Ber,
      BerReader: Ber.Reader,
      BerWriter: Ber.Writer
    };
  }
});

// node_modules/tweetnacl/nacl-fast.js
var require_nacl_fast = __commonJS({
  "node_modules/tweetnacl/nacl-fast.js"(exports, module) {
    (function(nacl) {
      "use strict";
      var gf = function(init4) {
        var i, r = new Float64Array(16);
        if (init4)
          for (i = 0; i < init4.length; i++)
            r[i] = init4[i];
        return r;
      };
      var randombytes = function() {
        throw new Error("no PRNG");
      };
      var _0 = new Uint8Array(16);
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D2 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function ts64(x, i, h, l) {
        x[i] = h >> 24 & 255;
        x[i + 1] = h >> 16 & 255;
        x[i + 2] = h >> 8 & 255;
        x[i + 3] = h & 255;
        x[i + 4] = l >> 24 & 255;
        x[i + 5] = l >> 16 & 255;
        x[i + 6] = l >> 8 & 255;
        x[i + 7] = l & 255;
      }
      function vn(x, xi, y, yi, n) {
        var i, d = 0;
        for (i = 0; i < n; i++)
          d |= x[xi + i] ^ y[yi + i];
        return (1 & d - 1 >>> 8) - 1;
      }
      function crypto_verify_16(x, xi, y, yi) {
        return vn(x, xi, y, yi, 16);
      }
      function crypto_verify_32(x, xi, y, yi) {
        return vn(x, xi, y, yi, 32);
      }
      function core_salsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x2 = x2 + j2 | 0;
        x3 = x3 + j3 | 0;
        x4 = x4 + j4 | 0;
        x5 = x5 + j5 | 0;
        x6 = x6 + j6 | 0;
        x7 = x7 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x1 >>> 0 & 255;
        o[5] = x1 >>> 8 & 255;
        o[6] = x1 >>> 16 & 255;
        o[7] = x1 >>> 24 & 255;
        o[8] = x2 >>> 0 & 255;
        o[9] = x2 >>> 8 & 255;
        o[10] = x2 >>> 16 & 255;
        o[11] = x2 >>> 24 & 255;
        o[12] = x3 >>> 0 & 255;
        o[13] = x3 >>> 8 & 255;
        o[14] = x3 >>> 16 & 255;
        o[15] = x3 >>> 24 & 255;
        o[16] = x4 >>> 0 & 255;
        o[17] = x4 >>> 8 & 255;
        o[18] = x4 >>> 16 & 255;
        o[19] = x4 >>> 24 & 255;
        o[20] = x5 >>> 0 & 255;
        o[21] = x5 >>> 8 & 255;
        o[22] = x5 >>> 16 & 255;
        o[23] = x5 >>> 24 & 255;
        o[24] = x6 >>> 0 & 255;
        o[25] = x6 >>> 8 & 255;
        o[26] = x6 >>> 16 & 255;
        o[27] = x6 >>> 24 & 255;
        o[28] = x7 >>> 0 & 255;
        o[29] = x7 >>> 8 & 255;
        o[30] = x7 >>> 16 & 255;
        o[31] = x7 >>> 24 & 255;
        o[32] = x8 >>> 0 & 255;
        o[33] = x8 >>> 8 & 255;
        o[34] = x8 >>> 16 & 255;
        o[35] = x8 >>> 24 & 255;
        o[36] = x9 >>> 0 & 255;
        o[37] = x9 >>> 8 & 255;
        o[38] = x9 >>> 16 & 255;
        o[39] = x9 >>> 24 & 255;
        o[40] = x10 >>> 0 & 255;
        o[41] = x10 >>> 8 & 255;
        o[42] = x10 >>> 16 & 255;
        o[43] = x10 >>> 24 & 255;
        o[44] = x11 >>> 0 & 255;
        o[45] = x11 >>> 8 & 255;
        o[46] = x11 >>> 16 & 255;
        o[47] = x11 >>> 24 & 255;
        o[48] = x12 >>> 0 & 255;
        o[49] = x12 >>> 8 & 255;
        o[50] = x12 >>> 16 & 255;
        o[51] = x12 >>> 24 & 255;
        o[52] = x13 >>> 0 & 255;
        o[53] = x13 >>> 8 & 255;
        o[54] = x13 >>> 16 & 255;
        o[55] = x13 >>> 24 & 255;
        o[56] = x14 >>> 0 & 255;
        o[57] = x14 >>> 8 & 255;
        o[58] = x14 >>> 16 & 255;
        o[59] = x14 >>> 24 & 255;
        o[60] = x15 >>> 0 & 255;
        o[61] = x15 >>> 8 & 255;
        o[62] = x15 >>> 16 & 255;
        o[63] = x15 >>> 24 & 255;
      }
      function core_hsalsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x5 >>> 0 & 255;
        o[5] = x5 >>> 8 & 255;
        o[6] = x5 >>> 16 & 255;
        o[7] = x5 >>> 24 & 255;
        o[8] = x10 >>> 0 & 255;
        o[9] = x10 >>> 8 & 255;
        o[10] = x10 >>> 16 & 255;
        o[11] = x10 >>> 24 & 255;
        o[12] = x15 >>> 0 & 255;
        o[13] = x15 >>> 8 & 255;
        o[14] = x15 >>> 16 & 255;
        o[15] = x15 >>> 24 & 255;
        o[16] = x6 >>> 0 & 255;
        o[17] = x6 >>> 8 & 255;
        o[18] = x6 >>> 16 & 255;
        o[19] = x6 >>> 24 & 255;
        o[20] = x7 >>> 0 & 255;
        o[21] = x7 >>> 8 & 255;
        o[22] = x7 >>> 16 & 255;
        o[23] = x7 >>> 24 & 255;
        o[24] = x8 >>> 0 & 255;
        o[25] = x8 >>> 8 & 255;
        o[26] = x8 >>> 16 & 255;
        o[27] = x8 >>> 24 & 255;
        o[28] = x9 >>> 0 & 255;
        o[29] = x9 >>> 8 & 255;
        o[30] = x9 >>> 16 & 255;
        o[31] = x9 >>> 24 & 255;
      }
      function crypto_core_salsa20(out, inp, k, c) {
        core_salsa20(out, inp, k, c);
      }
      function crypto_core_hsalsa20(out, inp, k, c) {
        core_hsalsa20(out, inp, k, c);
      }
      var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
      function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++)
          z[i] = 0;
        for (i = 0; i < 8; i++)
          z[i] = n[i];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < 64; i++)
            c[cpos + i] = m[mpos + i] ^ x[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z[i] & 255) | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
          mpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < b; i++)
            c[cpos + i] = m[mpos + i] ^ x[i];
        }
        return 0;
      }
      function crypto_stream_salsa20(c, cpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++)
          z[i] = 0;
        for (i = 0; i < 8; i++)
          z[i] = n[i];
        while (b >= 64) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < 64; i++)
            c[cpos + i] = x[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z[i] & 255) | 0;
            z[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z, k, sigma);
          for (i = 0; i < b; i++)
            c[cpos + i] = x[i];
        }
        return 0;
      }
      function crypto_stream(c, cpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++)
          sn[i] = n[i + 16];
        return crypto_stream_salsa20(c, cpos, d, sn, s);
      }
      function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++)
          sn[i] = n[i + 16];
        return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
      }
      var poly1305 = function(key) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t2, t3, t4, t5, t6, t7;
        t0 = key[0] & 255 | (key[1] & 255) << 8;
        this.r[0] = t0 & 8191;
        t1 = key[2] & 255 | (key[3] & 255) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        t2 = key[4] & 255 | (key[5] & 255) << 8;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        t3 = key[6] & 255 | (key[7] & 255) << 8;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        t4 = key[8] & 255 | (key[9] & 255) << 8;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this.r[5] = t4 >>> 1 & 8190;
        t5 = key[10] & 255 | (key[11] & 255) << 8;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        t6 = key[12] & 255 | (key[13] & 255) << 8;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        t7 = key[14] & 255 | (key[15] & 255) << 8;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this.r[9] = t7 >>> 5 & 127;
        this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
        this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
        this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
        this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
        this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
        this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
        this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
        this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
      };
      poly1305.prototype.blocks = function(m, mpos, bytes) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t0, t1, t2, t3, t4, t5, t6, t7, c;
        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
        var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
        while (bytes >= 16) {
          t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8;
          h0 += t0 & 8191;
          t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          t2 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 8191;
          t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          c = 0;
          d0 = c;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c += d0 >>> 13;
          d0 &= 8191;
          d1 = c;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c += d1 >>> 13;
          d1 &= 8191;
          d2 = c;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c += d2 >>> 13;
          d2 &= 8191;
          d3 = c;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c += d3 >>> 13;
          d3 &= 8191;
          d4 = c;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c += d4 >>> 13;
          d4 &= 8191;
          d5 = c;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c += d5 >>> 13;
          d5 &= 8191;
          d6 = c;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c += d6 >>> 13;
          d6 &= 8191;
          d7 = c;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c += d7 >>> 13;
          d7 &= 8191;
          d8 = c;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c += d8 >>> 13;
          d8 &= 8191;
          d9 = c;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c += d9 >>> 13;
          d9 &= 8191;
          c = (c << 2) + c | 0;
          c = c + d0 | 0;
          d0 = c & 8191;
          c = c >>> 13;
          d1 += c;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h2;
        this.h[3] = h3;
        this.h[4] = h4;
        this.h[5] = h5;
        this.h[6] = h6;
        this.h[7] = h7;
        this.h[8] = h8;
        this.h[9] = h9;
      };
      poly1305.prototype.finish = function(mac, macpos) {
        var g = new Uint16Array(10);
        var c, mask, f, i;
        if (this.leftover) {
          i = this.leftover;
          this.buffer[i++] = 1;
          for (; i < 16; i++)
            this.buffer[i] = 0;
          this.fin = 1;
          this.blocks(this.buffer, 0, 16);
        }
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        for (i = 2; i < 10; i++) {
          this.h[i] += c;
          c = this.h[i] >>> 13;
          this.h[i] &= 8191;
        }
        this.h[0] += c * 5;
        c = this.h[0] >>> 13;
        this.h[0] &= 8191;
        this.h[1] += c;
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        this.h[2] += c;
        g[0] = this.h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 8191;
        for (i = 1; i < 10; i++) {
          g[i] = this.h[i] + c;
          c = g[i] >>> 13;
          g[i] &= 8191;
        }
        g[9] -= 1 << 13;
        mask = (c ^ 1) - 1;
        for (i = 0; i < 10; i++)
          g[i] &= mask;
        mask = ~mask;
        for (i = 0; i < 10; i++)
          this.h[i] = this.h[i] & mask | g[i];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
        f = this.h[0] + this.pad[0];
        this.h[0] = f & 65535;
        for (i = 1; i < 8; i++) {
          f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;
          this.h[i] = f & 65535;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 255;
        mac[macpos + 1] = this.h[0] >>> 8 & 255;
        mac[macpos + 2] = this.h[1] >>> 0 & 255;
        mac[macpos + 3] = this.h[1] >>> 8 & 255;
        mac[macpos + 4] = this.h[2] >>> 0 & 255;
        mac[macpos + 5] = this.h[2] >>> 8 & 255;
        mac[macpos + 6] = this.h[3] >>> 0 & 255;
        mac[macpos + 7] = this.h[3] >>> 8 & 255;
        mac[macpos + 8] = this.h[4] >>> 0 & 255;
        mac[macpos + 9] = this.h[4] >>> 8 & 255;
        mac[macpos + 10] = this.h[5] >>> 0 & 255;
        mac[macpos + 11] = this.h[5] >>> 8 & 255;
        mac[macpos + 12] = this.h[6] >>> 0 & 255;
        mac[macpos + 13] = this.h[6] >>> 8 & 255;
        mac[macpos + 14] = this.h[7] >>> 0 & 255;
        mac[macpos + 15] = this.h[7] >>> 8 & 255;
      };
      poly1305.prototype.update = function(m, mpos, bytes) {
        var i, want;
        if (this.leftover) {
          want = 16 - this.leftover;
          if (want > bytes)
            want = bytes;
          for (i = 0; i < want; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          bytes -= want;
          mpos += want;
          this.leftover += want;
          if (this.leftover < 16)
            return;
          this.blocks(this.buffer, 0, 16);
          this.leftover = 0;
        }
        if (bytes >= 16) {
          want = bytes - bytes % 16;
          this.blocks(m, mpos, want);
          mpos += want;
          bytes -= want;
        }
        if (bytes) {
          for (i = 0; i < bytes; i++)
            this.buffer[this.leftover + i] = m[mpos + i];
          this.leftover += bytes;
        }
      };
      function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
        var s = new poly1305(k);
        s.update(m, mpos, n);
        s.finish(out, outpos);
        return 0;
      }
      function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
        var x = new Uint8Array(16);
        crypto_onetimeauth(x, 0, m, mpos, n, k);
        return crypto_verify_16(h, hpos, x, 0);
      }
      function crypto_secretbox(c, m, d, n, k) {
        var i;
        if (d < 32)
          return -1;
        crypto_stream_xor(c, 0, m, 0, d, n, k);
        crypto_onetimeauth(c, 16, c, 32, d - 32, c);
        for (i = 0; i < 16; i++)
          c[i] = 0;
        return 0;
      }
      function crypto_secretbox_open(m, c, d, n, k) {
        var i;
        var x = new Uint8Array(32);
        if (d < 32)
          return -1;
        crypto_stream(x, 0, 32, n, k);
        if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0)
          return -1;
        crypto_stream_xor(m, 0, c, 0, d, n, k);
        for (i = 0; i < 32; i++)
          m[i] = 0;
        return 0;
      }
      function set25519(r, a) {
        var i;
        for (i = 0; i < 16; i++)
          r[i] = a[i] | 0;
      }
      function car25519(o) {
        var i, v, c = 1;
        for (i = 0; i < 16; i++) {
          v = o[i] + c + 65535;
          c = Math.floor(v / 65536);
          o[i] = v - c * 65536;
        }
        o[0] += c - 1 + 37 * (c - 1);
      }
      function sel25519(p, q, b) {
        var t, c = ~(b - 1);
        for (var i = 0; i < 16; i++) {
          t = c & (p[i] ^ q[i]);
          p[i] ^= t;
          q[i] ^= t;
        }
      }
      function pack25519(o, n) {
        var i, j, b;
        var m = gf(), t = gf();
        for (i = 0; i < 16; i++)
          t[i] = n[i];
        car25519(t);
        car25519(t);
        car25519(t);
        for (j = 0; j < 2; j++) {
          m[0] = t[0] - 65517;
          for (i = 1; i < 15; i++) {
            m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
            m[i - 1] &= 65535;
          }
          m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
          b = m[15] >> 16 & 1;
          m[14] &= 65535;
          sel25519(t, m, 1 - b);
        }
        for (i = 0; i < 16; i++) {
          o[2 * i] = t[i] & 255;
          o[2 * i + 1] = t[i] >> 8;
        }
      }
      function neq25519(a, b) {
        var c = new Uint8Array(32), d = new Uint8Array(32);
        pack25519(c, a);
        pack25519(d, b);
        return crypto_verify_32(c, 0, d, 0);
      }
      function par25519(a) {
        var d = new Uint8Array(32);
        pack25519(d, a);
        return d[0] & 1;
      }
      function unpack25519(o, n) {
        var i;
        for (i = 0; i < 16; i++)
          o[i] = n[2 * i] + (n[2 * i + 1] << 8);
        o[15] &= 32767;
      }
      function A2(o, a, b) {
        for (var i = 0; i < 16; i++)
          o[i] = a[i] + b[i];
      }
      function Z(o, a, b) {
        for (var i = 0; i < 16; i++)
          o[i] = a[i] - b[i];
      }
      function M(o, a, b) {
        var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
        v = a[0];
        t0 += v * b0;
        t1 += v * b1;
        t2 += v * b2;
        t3 += v * b3;
        t4 += v * b4;
        t5 += v * b5;
        t6 += v * b6;
        t7 += v * b7;
        t8 += v * b8;
        t9 += v * b9;
        t10 += v * b10;
        t11 += v * b11;
        t12 += v * b12;
        t13 += v * b13;
        t14 += v * b14;
        t15 += v * b15;
        v = a[1];
        t1 += v * b0;
        t2 += v * b1;
        t3 += v * b2;
        t4 += v * b3;
        t5 += v * b4;
        t6 += v * b5;
        t7 += v * b6;
        t8 += v * b7;
        t9 += v * b8;
        t10 += v * b9;
        t11 += v * b10;
        t12 += v * b11;
        t13 += v * b12;
        t14 += v * b13;
        t15 += v * b14;
        t16 += v * b15;
        v = a[2];
        t2 += v * b0;
        t3 += v * b1;
        t4 += v * b2;
        t5 += v * b3;
        t6 += v * b4;
        t7 += v * b5;
        t8 += v * b6;
        t9 += v * b7;
        t10 += v * b8;
        t11 += v * b9;
        t12 += v * b10;
        t13 += v * b11;
        t14 += v * b12;
        t15 += v * b13;
        t16 += v * b14;
        t17 += v * b15;
        v = a[3];
        t3 += v * b0;
        t4 += v * b1;
        t5 += v * b2;
        t6 += v * b3;
        t7 += v * b4;
        t8 += v * b5;
        t9 += v * b6;
        t10 += v * b7;
        t11 += v * b8;
        t12 += v * b9;
        t13 += v * b10;
        t14 += v * b11;
        t15 += v * b12;
        t16 += v * b13;
        t17 += v * b14;
        t18 += v * b15;
        v = a[4];
        t4 += v * b0;
        t5 += v * b1;
        t6 += v * b2;
        t7 += v * b3;
        t8 += v * b4;
        t9 += v * b5;
        t10 += v * b6;
        t11 += v * b7;
        t12 += v * b8;
        t13 += v * b9;
        t14 += v * b10;
        t15 += v * b11;
        t16 += v * b12;
        t17 += v * b13;
        t18 += v * b14;
        t19 += v * b15;
        v = a[5];
        t5 += v * b0;
        t6 += v * b1;
        t7 += v * b2;
        t8 += v * b3;
        t9 += v * b4;
        t10 += v * b5;
        t11 += v * b6;
        t12 += v * b7;
        t13 += v * b8;
        t14 += v * b9;
        t15 += v * b10;
        t16 += v * b11;
        t17 += v * b12;
        t18 += v * b13;
        t19 += v * b14;
        t20 += v * b15;
        v = a[6];
        t6 += v * b0;
        t7 += v * b1;
        t8 += v * b2;
        t9 += v * b3;
        t10 += v * b4;
        t11 += v * b5;
        t12 += v * b6;
        t13 += v * b7;
        t14 += v * b8;
        t15 += v * b9;
        t16 += v * b10;
        t17 += v * b11;
        t18 += v * b12;
        t19 += v * b13;
        t20 += v * b14;
        t21 += v * b15;
        v = a[7];
        t7 += v * b0;
        t8 += v * b1;
        t9 += v * b2;
        t10 += v * b3;
        t11 += v * b4;
        t12 += v * b5;
        t13 += v * b6;
        t14 += v * b7;
        t15 += v * b8;
        t16 += v * b9;
        t17 += v * b10;
        t18 += v * b11;
        t19 += v * b12;
        t20 += v * b13;
        t21 += v * b14;
        t22 += v * b15;
        v = a[8];
        t8 += v * b0;
        t9 += v * b1;
        t10 += v * b2;
        t11 += v * b3;
        t12 += v * b4;
        t13 += v * b5;
        t14 += v * b6;
        t15 += v * b7;
        t16 += v * b8;
        t17 += v * b9;
        t18 += v * b10;
        t19 += v * b11;
        t20 += v * b12;
        t21 += v * b13;
        t22 += v * b14;
        t23 += v * b15;
        v = a[9];
        t9 += v * b0;
        t10 += v * b1;
        t11 += v * b2;
        t12 += v * b3;
        t13 += v * b4;
        t14 += v * b5;
        t15 += v * b6;
        t16 += v * b7;
        t17 += v * b8;
        t18 += v * b9;
        t19 += v * b10;
        t20 += v * b11;
        t21 += v * b12;
        t22 += v * b13;
        t23 += v * b14;
        t24 += v * b15;
        v = a[10];
        t10 += v * b0;
        t11 += v * b1;
        t12 += v * b2;
        t13 += v * b3;
        t14 += v * b4;
        t15 += v * b5;
        t16 += v * b6;
        t17 += v * b7;
        t18 += v * b8;
        t19 += v * b9;
        t20 += v * b10;
        t21 += v * b11;
        t22 += v * b12;
        t23 += v * b13;
        t24 += v * b14;
        t25 += v * b15;
        v = a[11];
        t11 += v * b0;
        t12 += v * b1;
        t13 += v * b2;
        t14 += v * b3;
        t15 += v * b4;
        t16 += v * b5;
        t17 += v * b6;
        t18 += v * b7;
        t19 += v * b8;
        t20 += v * b9;
        t21 += v * b10;
        t22 += v * b11;
        t23 += v * b12;
        t24 += v * b13;
        t25 += v * b14;
        t26 += v * b15;
        v = a[12];
        t12 += v * b0;
        t13 += v * b1;
        t14 += v * b2;
        t15 += v * b3;
        t16 += v * b4;
        t17 += v * b5;
        t18 += v * b6;
        t19 += v * b7;
        t20 += v * b8;
        t21 += v * b9;
        t22 += v * b10;
        t23 += v * b11;
        t24 += v * b12;
        t25 += v * b13;
        t26 += v * b14;
        t27 += v * b15;
        v = a[13];
        t13 += v * b0;
        t14 += v * b1;
        t15 += v * b2;
        t16 += v * b3;
        t17 += v * b4;
        t18 += v * b5;
        t19 += v * b6;
        t20 += v * b7;
        t21 += v * b8;
        t22 += v * b9;
        t23 += v * b10;
        t24 += v * b11;
        t25 += v * b12;
        t26 += v * b13;
        t27 += v * b14;
        t28 += v * b15;
        v = a[14];
        t14 += v * b0;
        t15 += v * b1;
        t16 += v * b2;
        t17 += v * b3;
        t18 += v * b4;
        t19 += v * b5;
        t20 += v * b6;
        t21 += v * b7;
        t22 += v * b8;
        t23 += v * b9;
        t24 += v * b10;
        t25 += v * b11;
        t26 += v * b12;
        t27 += v * b13;
        t28 += v * b14;
        t29 += v * b15;
        v = a[15];
        t15 += v * b0;
        t16 += v * b1;
        t17 += v * b2;
        t18 += v * b3;
        t19 += v * b4;
        t20 += v * b5;
        t21 += v * b6;
        t22 += v * b7;
        t23 += v * b8;
        t24 += v * b9;
        t25 += v * b10;
        t26 += v * b11;
        t27 += v * b12;
        t28 += v * b13;
        t29 += v * b14;
        t30 += v * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t2 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t22;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        o[0] = t0;
        o[1] = t1;
        o[2] = t2;
        o[3] = t3;
        o[4] = t4;
        o[5] = t5;
        o[6] = t6;
        o[7] = t7;
        o[8] = t8;
        o[9] = t9;
        o[10] = t10;
        o[11] = t11;
        o[12] = t12;
        o[13] = t13;
        o[14] = t14;
        o[15] = t15;
      }
      function S(o, a) {
        M(o, a, a);
      }
      function inv25519(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++)
          c[a] = i[a];
        for (a = 253; a >= 0; a--) {
          S(c, c);
          if (a !== 2 && a !== 4)
            M(c, c, i);
        }
        for (a = 0; a < 16; a++)
          o[a] = c[a];
      }
      function pow2523(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++)
          c[a] = i[a];
        for (a = 250; a >= 0; a--) {
          S(c, c);
          if (a !== 1)
            M(c, c, i);
        }
        for (a = 0; a < 16; a++)
          o[a] = c[a];
      }
      function crypto_scalarmult(q, n, p) {
        var z = new Uint8Array(32);
        var x = new Float64Array(80), r, i;
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
        for (i = 0; i < 31; i++)
          z[i] = n[i];
        z[31] = n[31] & 127 | 64;
        z[0] &= 248;
        unpack25519(x, p);
        for (i = 0; i < 16; i++) {
          b[i] = x[i];
          d[i] = a[i] = c[i] = 0;
        }
        a[0] = d[0] = 1;
        for (i = 254; i >= 0; --i) {
          r = z[i >>> 3] >>> (i & 7) & 1;
          sel25519(a, b, r);
          sel25519(c, d, r);
          A2(e, a, c);
          Z(a, a, c);
          A2(c, b, d);
          Z(b, b, d);
          S(d, e);
          S(f, a);
          M(a, c, a);
          M(c, b, e);
          A2(e, a, c);
          Z(a, a, c);
          S(b, a);
          Z(c, d, f);
          M(a, c, _121665);
          A2(a, a, d);
          M(c, c, a);
          M(a, d, f);
          M(d, b, x);
          S(b, e);
          sel25519(a, b, r);
          sel25519(c, d, r);
        }
        for (i = 0; i < 16; i++) {
          x[i + 16] = a[i];
          x[i + 32] = c[i];
          x[i + 48] = b[i];
          x[i + 64] = d[i];
        }
        var x32 = x.subarray(32);
        var x16 = x.subarray(16);
        inv25519(x32, x32);
        M(x16, x16, x32);
        pack25519(q, x16);
        return 0;
      }
      function crypto_scalarmult_base(q, n) {
        return crypto_scalarmult(q, n, _9);
      }
      function crypto_box_keypair(y, x) {
        randombytes(x, 32);
        return crypto_scalarmult_base(y, x);
      }
      function crypto_box_beforenm(k, y, x) {
        var s = new Uint8Array(32);
        crypto_scalarmult(s, x, y);
        return crypto_core_hsalsa20(k, _0, s, sigma);
      }
      var crypto_box_afternm = crypto_secretbox;
      var crypto_box_open_afternm = crypto_secretbox_open;
      function crypto_box(c, m, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_afternm(c, m, d, n, k);
      }
      function crypto_box_open(m, c, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_open_afternm(m, c, d, n, k);
      }
      var K = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function crypto_hashblocks_hl(hh, hl, m, n) {
        var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l, a, b, c, d;
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
        var pos = 0;
        while (n >= 128) {
          for (i = 0; i < 16; i++) {
            j = 8 * i + pos;
            wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
            wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
          }
          for (i = 0; i < 80; i++) {
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h = ah7;
            l = al7;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah4 & ah5 ^ ~ah4 & ah6;
            l = al4 & al5 ^ ~al4 & al6;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = K[i * 2];
            l = K[i * 2 + 1];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = wh[i % 16];
            l = wl[i % 16];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            th = c & 65535 | d << 16;
            tl = a & 65535 | b << 16;
            h = th;
            l = tl;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh7 = c & 65535 | d << 16;
            bl7 = a & 65535 | b << 16;
            h = bh3;
            l = bl3;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = th;
            l = tl;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh3 = c & 65535 | d << 16;
            bl3 = a & 65535 | b << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i % 16 === 15) {
              for (j = 0; j < 16; j++) {
                h = wh[j];
                l = wl[j];
                a = l & 65535;
                b = l >>> 16;
                c = h & 65535;
                d = h >>> 16;
                h = wh[(j + 9) % 16];
                l = wl[(j + 9) % 16];
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 1) % 16];
                tl = wl[(j + 1) % 16];
                h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 14) % 16];
                tl = wl[(j + 14) % 16];
                h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                wh[j] = c & 65535 | d << 16;
                wl[j] = a & 65535 | b << 16;
              }
            }
          }
          h = ah0;
          l = al0;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[0];
          l = hl[0];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[0] = ah0 = c & 65535 | d << 16;
          hl[0] = al0 = a & 65535 | b << 16;
          h = ah1;
          l = al1;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[1];
          l = hl[1];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[1] = ah1 = c & 65535 | d << 16;
          hl[1] = al1 = a & 65535 | b << 16;
          h = ah2;
          l = al2;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[2];
          l = hl[2];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[2] = ah2 = c & 65535 | d << 16;
          hl[2] = al2 = a & 65535 | b << 16;
          h = ah3;
          l = al3;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[3];
          l = hl[3];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[3] = ah3 = c & 65535 | d << 16;
          hl[3] = al3 = a & 65535 | b << 16;
          h = ah4;
          l = al4;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[4];
          l = hl[4];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[4] = ah4 = c & 65535 | d << 16;
          hl[4] = al4 = a & 65535 | b << 16;
          h = ah5;
          l = al5;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[5];
          l = hl[5];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[5] = ah5 = c & 65535 | d << 16;
          hl[5] = al5 = a & 65535 | b << 16;
          h = ah6;
          l = al6;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[6];
          l = hl[6];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[6] = ah6 = c & 65535 | d << 16;
          hl[6] = al6 = a & 65535 | b << 16;
          h = ah7;
          l = al7;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[7];
          l = hl[7];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[7] = ah7 = c & 65535 | d << 16;
          hl[7] = al7 = a & 65535 | b << 16;
          pos += 128;
          n -= 128;
        }
        return n;
      }
      function crypto_hash(out, m, n) {
        var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i, b = n;
        hh[0] = 1779033703;
        hh[1] = 3144134277;
        hh[2] = 1013904242;
        hh[3] = 2773480762;
        hh[4] = 1359893119;
        hh[5] = 2600822924;
        hh[6] = 528734635;
        hh[7] = 1541459225;
        hl[0] = 4089235720;
        hl[1] = 2227873595;
        hl[2] = 4271175723;
        hl[3] = 1595750129;
        hl[4] = 2917565137;
        hl[5] = 725511199;
        hl[6] = 4215389547;
        hl[7] = 327033209;
        crypto_hashblocks_hl(hh, hl, m, n);
        n %= 128;
        for (i = 0; i < n; i++)
          x[i] = m[b - n + i];
        x[n] = 128;
        n = 256 - 128 * (n < 112 ? 1 : 0);
        x[n - 9] = 0;
        ts64(x, n - 8, b / 536870912 | 0, b << 3);
        crypto_hashblocks_hl(hh, hl, x, n);
        for (i = 0; i < 8; i++)
          ts64(out, 8 * i, hh[i], hl[i]);
        return 0;
      }
      function add3(p, q) {
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
        Z(a, p[1], p[0]);
        Z(t, q[1], q[0]);
        M(a, a, t);
        A2(b, p[0], p[1]);
        A2(t, q[0], q[1]);
        M(b, b, t);
        M(c, p[3], q[3]);
        M(c, c, D2);
        M(d, p[2], q[2]);
        A2(d, d, d);
        Z(e, b, a);
        Z(f, d, c);
        A2(g, d, c);
        A2(h, b, a);
        M(p[0], e, f);
        M(p[1], h, g);
        M(p[2], g, f);
        M(p[3], e, h);
      }
      function cswap(p, q, b) {
        var i;
        for (i = 0; i < 4; i++) {
          sel25519(p[i], q[i], b);
        }
      }
      function pack(r, p) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p[2]);
        M(tx, p[0], zi);
        M(ty, p[1], zi);
        pack25519(r, ty);
        r[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p, q, s) {
        var b, i;
        set25519(p[0], gf0);
        set25519(p[1], gf1);
        set25519(p[2], gf1);
        set25519(p[3], gf0);
        for (i = 255; i >= 0; --i) {
          b = s[i / 8 | 0] >> (i & 7) & 1;
          cswap(p, q, b);
          add3(q, p);
          add3(p, p);
          cswap(p, q, b);
        }
      }
      function scalarbase(p, s) {
        var q = [gf(), gf(), gf(), gf()];
        set25519(q[0], X);
        set25519(q[1], Y);
        set25519(q[2], gf1);
        M(q[3], X, Y);
        scalarmult(p, q, s);
      }
      function crypto_sign_keypair(pk, sk, seeded) {
        var d = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()];
        var i;
        if (!seeded)
          randombytes(sk, 32);
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        scalarbase(p, d);
        pack(pk, p);
        for (i = 0; i < 32; i++)
          sk[i + 32] = pk[i];
        return 0;
      }
      var L = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
      function modL(r, x) {
        var carry, i, j, k;
        for (i = 63; i >= 32; --i) {
          carry = 0;
          for (j = i - 32, k = i - 12; j < k; ++j) {
            x[j] += carry - 16 * x[i] * L[j - (i - 32)];
            carry = x[j] + 128 >> 8;
            x[j] -= carry * 256;
          }
          x[j] += carry;
          x[i] = 0;
        }
        carry = 0;
        for (j = 0; j < 32; j++) {
          x[j] += carry - (x[31] >> 4) * L[j];
          carry = x[j] >> 8;
          x[j] &= 255;
        }
        for (j = 0; j < 32; j++)
          x[j] -= carry * L[j];
        for (i = 0; i < 32; i++) {
          x[i + 1] += x[i] >> 8;
          r[i] = x[i] & 255;
        }
      }
      function reduce(r) {
        var x = new Float64Array(64), i;
        for (i = 0; i < 64; i++)
          x[i] = r[i];
        for (i = 0; i < 64; i++)
          r[i] = 0;
        modL(r, x);
      }
      function crypto_sign(sm, m, n, sk) {
        var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
        var i, j, x = new Float64Array(64);
        var p = [gf(), gf(), gf(), gf()];
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        var smlen = n + 64;
        for (i = 0; i < n; i++)
          sm[64 + i] = m[i];
        for (i = 0; i < 32; i++)
          sm[32 + i] = d[32 + i];
        crypto_hash(r, sm.subarray(32), n + 32);
        reduce(r);
        scalarbase(p, r);
        pack(sm, p);
        for (i = 32; i < 64; i++)
          sm[i] = sk[i];
        crypto_hash(h, sm, n + 64);
        reduce(h);
        for (i = 0; i < 64; i++)
          x[i] = 0;
        for (i = 0; i < 32; i++)
          x[i] = r[i];
        for (i = 0; i < 32; i++) {
          for (j = 0; j < 32; j++) {
            x[i + j] += h[i] * d[j];
          }
        }
        modL(sm.subarray(32), x);
        return smlen;
      }
      function unpackneg(r, p) {
        var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r[2], gf1);
        unpack25519(r[1], p);
        S(num, r[1]);
        M(den, num, D);
        Z(num, num, r[2]);
        A2(den, r[2], den);
        S(den2, den);
        S(den4, den2);
        M(den6, den4, den2);
        M(t, den6, num);
        M(t, t, den);
        pow2523(t, t);
        M(t, t, num);
        M(t, t, den);
        M(t, t, den);
        M(r[0], t, den);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num))
          M(r[0], r[0], I);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num))
          return -1;
        if (par25519(r[0]) === p[31] >> 7)
          Z(r[0], gf0, r[0]);
        M(r[3], r[0], r[1]);
        return 0;
      }
      function crypto_sign_open(m, sm, n, pk) {
        var i, mlen;
        var t = new Uint8Array(32), h = new Uint8Array(64);
        var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
        mlen = -1;
        if (n < 64)
          return -1;
        if (unpackneg(q, pk))
          return -1;
        for (i = 0; i < n; i++)
          m[i] = sm[i];
        for (i = 0; i < 32; i++)
          m[i + 32] = pk[i];
        crypto_hash(h, m, n);
        reduce(h);
        scalarmult(p, q, h);
        scalarbase(q, sm.subarray(32));
        add3(p, q);
        pack(t, p);
        n -= 64;
        if (crypto_verify_32(sm, 0, t, 0)) {
          for (i = 0; i < n; i++)
            m[i] = 0;
          return -1;
        }
        for (i = 0; i < n; i++)
          m[i] = sm[i + 64];
        mlen = n;
        return mlen;
      }
      var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
      nacl.lowlevel = {
        crypto_core_hsalsa20,
        crypto_stream_xor,
        crypto_stream,
        crypto_stream_salsa20_xor,
        crypto_stream_salsa20,
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_verify_16,
        crypto_verify_32,
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_box_beforenm,
        crypto_box_afternm,
        crypto_box,
        crypto_box_open,
        crypto_box_keypair,
        crypto_hash,
        crypto_sign,
        crypto_sign_keypair,
        crypto_sign_open,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES,
        crypto_hash_BYTES
      };
      function checkLengths(k, n) {
        if (k.length !== crypto_secretbox_KEYBYTES)
          throw new Error("bad key size");
        if (n.length !== crypto_secretbox_NONCEBYTES)
          throw new Error("bad nonce size");
      }
      function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
      }
      function checkArrayTypes() {
        var t, i;
        for (i = 0; i < arguments.length; i++) {
          if ((t = Object.prototype.toString.call(arguments[i])) !== "[object Uint8Array]")
            throw new TypeError("unexpected type " + t + ", use Uint8Array");
        }
      }
      function cleanup(arr) {
        for (var i = 0; i < arr.length; i++)
          arr[i] = 0;
      }
      if (!nacl.util) {
        nacl.util = {};
        nacl.util.decodeUTF8 = nacl.util.encodeUTF8 = nacl.util.encodeBase64 = nacl.util.decodeBase64 = function() {
          throw new Error("nacl.util moved into separate package: https://github.com/dchest/tweetnacl-util-js");
        };
      }
      nacl.randomBytes = function(n) {
        var b = new Uint8Array(n);
        randombytes(b, n);
        return b;
      };
      nacl.secretbox = function(msg, nonce, key) {
        checkArrayTypes(msg, nonce, key);
        checkLengths(key, nonce);
        var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c = new Uint8Array(m.length);
        for (var i = 0; i < msg.length; i++)
          m[i + crypto_secretbox_ZEROBYTES] = msg[i];
        crypto_secretbox(c, m, m.length, nonce, key);
        return c.subarray(crypto_secretbox_BOXZEROBYTES);
      };
      nacl.secretbox.open = function(box, nonce, key) {
        checkArrayTypes(box, nonce, key);
        checkLengths(key, nonce);
        var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m = new Uint8Array(c.length);
        for (var i = 0; i < box.length; i++)
          c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
        if (c.length < 32)
          return false;
        if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0)
          return false;
        return m.subarray(crypto_secretbox_ZEROBYTES);
      };
      nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
      nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
      nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
      nacl.scalarMult = function(n, p) {
        checkArrayTypes(n, p);
        if (n.length !== crypto_scalarmult_SCALARBYTES)
          throw new Error("bad n size");
        if (p.length !== crypto_scalarmult_BYTES)
          throw new Error("bad p size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q, n, p);
        return q;
      };
      nacl.scalarMult.base = function(n) {
        checkArrayTypes(n);
        if (n.length !== crypto_scalarmult_SCALARBYTES)
          throw new Error("bad n size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q, n);
        return q;
      };
      nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
      nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
      nacl.box = function(msg, nonce, publicKey, secretKey) {
        var k = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox(msg, nonce, k);
      };
      nacl.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k, publicKey, secretKey);
        return k;
      };
      nacl.box.after = nacl.secretbox;
      nacl.box.open = function(msg, nonce, publicKey, secretKey) {
        var k = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox.open(msg, nonce, k);
      };
      nacl.box.open.after = nacl.secretbox.open;
      nacl.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
      nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
      nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
      nacl.box.nonceLength = crypto_box_NONCEBYTES;
      nacl.box.overheadLength = nacl.secretbox.overheadLength;
      nacl.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
      };
      nacl.sign.open = function(signedMsg, publicKey) {
        if (arguments.length !== 2)
          throw new Error("nacl.sign.open accepts 2 arguments; did you mean to use nacl.sign.detached.verify?");
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0)
          return null;
        var m = new Uint8Array(mlen);
        for (var i = 0; i < m.length; i++)
          m[i] = tmp[i];
        return m;
      };
      nacl.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for (var i = 0; i < sig.length; i++)
          sig[i] = signedMsg[i];
        return sig;
      };
      nacl.sign.detached.verify = function(msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES)
          throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i;
        for (i = 0; i < crypto_sign_BYTES; i++)
          sm[i] = sig[i];
        for (i = 0; i < msg.length; i++)
          sm[i + crypto_sign_BYTES] = msg[i];
        return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
      };
      nacl.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for (var i = 0; i < pk.length; i++)
          pk[i] = secretKey[32 + i];
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl.sign.keyPair.fromSeed = function(seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES)
          throw new Error("bad seed size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for (var i = 0; i < 32; i++)
          sk[i] = seed[i];
        crypto_sign_keypair(pk, sk, true);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
      nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
      nacl.sign.seedLength = crypto_sign_SEEDBYTES;
      nacl.sign.signatureLength = crypto_sign_BYTES;
      nacl.hash = function(msg) {
        checkArrayTypes(msg);
        var h = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h, msg, msg.length);
        return h;
      };
      nacl.hash.hashLength = crypto_hash_BYTES;
      nacl.verify = function(x, y) {
        checkArrayTypes(x, y);
        if (x.length === 0 || y.length === 0)
          return false;
        if (x.length !== y.length)
          return false;
        return vn(x, 0, y, 0, x.length) === 0 ? true : false;
      };
      nacl.setPRNG = function(fn) {
        randombytes = fn;
      };
      (function() {
        var crypto2 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto2 && crypto2.getRandomValues) {
          var QUOTA = 65536;
          nacl.setPRNG(function(x, n) {
            var i, v = new Uint8Array(n);
            for (i = 0; i < n; i += QUOTA) {
              crypto2.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
            }
            for (i = 0; i < n; i++)
              x[i] = v[i];
            cleanup(v);
          });
        } else if (typeof __require !== "undefined") {
          crypto2 = __require("crypto");
          if (crypto2 && crypto2.randomBytes) {
            nacl.setPRNG(function(x, n) {
              var i, v = crypto2.randomBytes(n);
              for (i = 0; i < n; i++)
                x[i] = v[i];
              cleanup(v);
            });
          }
        }
      })();
    })(typeof module !== "undefined" && module.exports ? module.exports : self.nacl = self.nacl || {});
  }
});

// node_modules/bcrypt-pbkdf/index.js
var require_bcrypt_pbkdf = __commonJS({
  "node_modules/bcrypt-pbkdf/index.js"(exports, module) {
    "use strict";
    var crypto_hash_sha512 = require_nacl_fast().lowlevel.crypto_hash;
    var BLF_J = 0;
    var Blowfish = function() {
      this.S = [
        new Uint32Array([
          3509652390,
          2564797868,
          805139163,
          3491422135,
          3101798381,
          1780907670,
          3128725573,
          4046225305,
          614570311,
          3012652279,
          134345442,
          2240740374,
          1667834072,
          1901547113,
          2757295779,
          4103290238,
          227898511,
          1921955416,
          1904987480,
          2182433518,
          2069144605,
          3260701109,
          2620446009,
          720527379,
          3318853667,
          677414384,
          3393288472,
          3101374703,
          2390351024,
          1614419982,
          1822297739,
          2954791486,
          3608508353,
          3174124327,
          2024746970,
          1432378464,
          3864339955,
          2857741204,
          1464375394,
          1676153920,
          1439316330,
          715854006,
          3033291828,
          289532110,
          2706671279,
          2087905683,
          3018724369,
          1668267050,
          732546397,
          1947742710,
          3462151702,
          2609353502,
          2950085171,
          1814351708,
          2050118529,
          680887927,
          999245976,
          1800124847,
          3300911131,
          1713906067,
          1641548236,
          4213287313,
          1216130144,
          1575780402,
          4018429277,
          3917837745,
          3693486850,
          3949271944,
          596196993,
          3549867205,
          258830323,
          2213823033,
          772490370,
          2760122372,
          1774776394,
          2652871518,
          566650946,
          4142492826,
          1728879713,
          2882767088,
          1783734482,
          3629395816,
          2517608232,
          2874225571,
          1861159788,
          326777828,
          3124490320,
          2130389656,
          2716951837,
          967770486,
          1724537150,
          2185432712,
          2364442137,
          1164943284,
          2105845187,
          998989502,
          3765401048,
          2244026483,
          1075463327,
          1455516326,
          1322494562,
          910128902,
          469688178,
          1117454909,
          936433444,
          3490320968,
          3675253459,
          1240580251,
          122909385,
          2157517691,
          634681816,
          4142456567,
          3825094682,
          3061402683,
          2540495037,
          79693498,
          3249098678,
          1084186820,
          1583128258,
          426386531,
          1761308591,
          1047286709,
          322548459,
          995290223,
          1845252383,
          2603652396,
          3431023940,
          2942221577,
          3202600964,
          3727903485,
          1712269319,
          422464435,
          3234572375,
          1170764815,
          3523960633,
          3117677531,
          1434042557,
          442511882,
          3600875718,
          1076654713,
          1738483198,
          4213154764,
          2393238008,
          3677496056,
          1014306527,
          4251020053,
          793779912,
          2902807211,
          842905082,
          4246964064,
          1395751752,
          1040244610,
          2656851899,
          3396308128,
          445077038,
          3742853595,
          3577915638,
          679411651,
          2892444358,
          2354009459,
          1767581616,
          3150600392,
          3791627101,
          3102740896,
          284835224,
          4246832056,
          1258075500,
          768725851,
          2589189241,
          3069724005,
          3532540348,
          1274779536,
          3789419226,
          2764799539,
          1660621633,
          3471099624,
          4011903706,
          913787905,
          3497959166,
          737222580,
          2514213453,
          2928710040,
          3937242737,
          1804850592,
          3499020752,
          2949064160,
          2386320175,
          2390070455,
          2415321851,
          4061277028,
          2290661394,
          2416832540,
          1336762016,
          1754252060,
          3520065937,
          3014181293,
          791618072,
          3188594551,
          3933548030,
          2332172193,
          3852520463,
          3043980520,
          413987798,
          3465142937,
          3030929376,
          4245938359,
          2093235073,
          3534596313,
          375366246,
          2157278981,
          2479649556,
          555357303,
          3870105701,
          2008414854,
          3344188149,
          4221384143,
          3956125452,
          2067696032,
          3594591187,
          2921233993,
          2428461,
          544322398,
          577241275,
          1471733935,
          610547355,
          4027169054,
          1432588573,
          1507829418,
          2025931657,
          3646575487,
          545086370,
          48609733,
          2200306550,
          1653985193,
          298326376,
          1316178497,
          3007786442,
          2064951626,
          458293330,
          2589141269,
          3591329599,
          3164325604,
          727753846,
          2179363840,
          146436021,
          1461446943,
          4069977195,
          705550613,
          3059967265,
          3887724982,
          4281599278,
          3313849956,
          1404054877,
          2845806497,
          146425753,
          1854211946
        ]),
        new Uint32Array([
          1266315497,
          3048417604,
          3681880366,
          3289982499,
          290971e4,
          1235738493,
          2632868024,
          2414719590,
          3970600049,
          1771706367,
          1449415276,
          3266420449,
          422970021,
          1963543593,
          2690192192,
          3826793022,
          1062508698,
          1531092325,
          1804592342,
          2583117782,
          2714934279,
          4024971509,
          1294809318,
          4028980673,
          1289560198,
          2221992742,
          1669523910,
          35572830,
          157838143,
          1052438473,
          1016535060,
          1802137761,
          1753167236,
          1386275462,
          3080475397,
          2857371447,
          1040679964,
          2145300060,
          2390574316,
          1461121720,
          2956646967,
          4031777805,
          4028374788,
          33600511,
          2920084762,
          1018524850,
          629373528,
          3691585981,
          3515945977,
          2091462646,
          2486323059,
          586499841,
          988145025,
          935516892,
          3367335476,
          2599673255,
          2839830854,
          265290510,
          3972581182,
          2759138881,
          3795373465,
          1005194799,
          847297441,
          406762289,
          1314163512,
          1332590856,
          1866599683,
          4127851711,
          750260880,
          613907577,
          1450815602,
          3165620655,
          3734664991,
          3650291728,
          3012275730,
          3704569646,
          1427272223,
          778793252,
          1343938022,
          2676280711,
          2052605720,
          1946737175,
          3164576444,
          3914038668,
          3967478842,
          3682934266,
          1661551462,
          3294938066,
          4011595847,
          840292616,
          3712170807,
          616741398,
          312560963,
          711312465,
          1351876610,
          322626781,
          1910503582,
          271666773,
          2175563734,
          1594956187,
          70604529,
          3617834859,
          1007753275,
          1495573769,
          4069517037,
          2549218298,
          2663038764,
          504708206,
          2263041392,
          3941167025,
          2249088522,
          1514023603,
          1998579484,
          1312622330,
          694541497,
          2582060303,
          2151582166,
          1382467621,
          776784248,
          2618340202,
          3323268794,
          2497899128,
          2784771155,
          503983604,
          4076293799,
          907881277,
          423175695,
          432175456,
          1378068232,
          4145222326,
          3954048622,
          3938656102,
          3820766613,
          2793130115,
          2977904593,
          26017576,
          3274890735,
          3194772133,
          1700274565,
          1756076034,
          4006520079,
          3677328699,
          720338349,
          1533947780,
          354530856,
          688349552,
          3973924725,
          1637815568,
          332179504,
          3949051286,
          53804574,
          2852348879,
          3044236432,
          1282449977,
          3583942155,
          3416972820,
          4006381244,
          1617046695,
          2628476075,
          3002303598,
          1686838959,
          431878346,
          2686675385,
          1700445008,
          1080580658,
          1009431731,
          832498133,
          3223435511,
          2605976345,
          2271191193,
          2516031870,
          1648197032,
          4164389018,
          2548247927,
          300782431,
          375919233,
          238389289,
          3353747414,
          2531188641,
          2019080857,
          1475708069,
          455242339,
          2609103871,
          448939670,
          3451063019,
          1395535956,
          2413381860,
          1841049896,
          1491858159,
          885456874,
          4264095073,
          4001119347,
          1565136089,
          3898914787,
          1108368660,
          540939232,
          1173283510,
          2745871338,
          3681308437,
          4207628240,
          3343053890,
          4016749493,
          1699691293,
          1103962373,
          3625875870,
          2256883143,
          3830138730,
          1031889488,
          3479347698,
          1535977030,
          4236805024,
          3251091107,
          2132092099,
          1774941330,
          1199868427,
          1452454533,
          157007616,
          2904115357,
          342012276,
          595725824,
          1480756522,
          206960106,
          497939518,
          591360097,
          863170706,
          2375253569,
          3596610801,
          1814182875,
          2094937945,
          3421402208,
          1082520231,
          3463918190,
          2785509508,
          435703966,
          3908032597,
          1641649973,
          2842273706,
          3305899714,
          1510255612,
          2148256476,
          2655287854,
          3276092548,
          4258621189,
          236887753,
          3681803219,
          274041037,
          1734335097,
          3815195456,
          3317970021,
          1899903192,
          1026095262,
          4050517792,
          356393447,
          2410691914,
          3873677099,
          3682840055
        ]),
        new Uint32Array([
          3913112168,
          2491498743,
          4132185628,
          2489919796,
          1091903735,
          1979897079,
          3170134830,
          3567386728,
          3557303409,
          857797738,
          1136121015,
          1342202287,
          507115054,
          2535736646,
          337727348,
          3213592640,
          1301675037,
          2528481711,
          1895095763,
          1721773893,
          3216771564,
          62756741,
          2142006736,
          835421444,
          2531993523,
          1442658625,
          3659876326,
          2882144922,
          676362277,
          1392781812,
          170690266,
          3921047035,
          1759253602,
          3611846912,
          1745797284,
          664899054,
          1329594018,
          3901205900,
          3045908486,
          2062866102,
          2865634940,
          3543621612,
          3464012697,
          1080764994,
          553557557,
          3656615353,
          3996768171,
          991055499,
          499776247,
          1265440854,
          648242737,
          3940784050,
          980351604,
          3713745714,
          1749149687,
          3396870395,
          4211799374,
          3640570775,
          1161844396,
          3125318951,
          1431517754,
          545492359,
          4268468663,
          3499529547,
          1437099964,
          2702547544,
          3433638243,
          2581715763,
          2787789398,
          1060185593,
          1593081372,
          2418618748,
          4260947970,
          69676912,
          2159744348,
          86519011,
          2512459080,
          3838209314,
          1220612927,
          3339683548,
          133810670,
          1090789135,
          1078426020,
          1569222167,
          845107691,
          3583754449,
          4072456591,
          1091646820,
          628848692,
          1613405280,
          3757631651,
          526609435,
          236106946,
          48312990,
          2942717905,
          3402727701,
          1797494240,
          859738849,
          992217954,
          4005476642,
          2243076622,
          3870952857,
          3732016268,
          765654824,
          3490871365,
          2511836413,
          1685915746,
          3888969200,
          1414112111,
          2273134842,
          3281911079,
          4080962846,
          172450625,
          2569994100,
          980381355,
          4109958455,
          2819808352,
          2716589560,
          2568741196,
          3681446669,
          3329971472,
          1835478071,
          660984891,
          3704678404,
          4045999559,
          3422617507,
          3040415634,
          1762651403,
          1719377915,
          3470491036,
          2693910283,
          3642056355,
          3138596744,
          1364962596,
          2073328063,
          1983633131,
          926494387,
          3423689081,
          2150032023,
          4096667949,
          1749200295,
          3328846651,
          309677260,
          2016342300,
          1779581495,
          3079819751,
          111262694,
          1274766160,
          443224088,
          298511866,
          1025883608,
          3806446537,
          1145181785,
          168956806,
          3641502830,
          3584813610,
          1689216846,
          3666258015,
          3200248200,
          1692713982,
          2646376535,
          4042768518,
          1618508792,
          1610833997,
          3523052358,
          4130873264,
          2001055236,
          3610705100,
          2202168115,
          4028541809,
          2961195399,
          1006657119,
          2006996926,
          3186142756,
          1430667929,
          3210227297,
          1314452623,
          4074634658,
          4101304120,
          2273951170,
          1399257539,
          3367210612,
          3027628629,
          1190975929,
          2062231137,
          2333990788,
          2221543033,
          2438960610,
          1181637006,
          548689776,
          2362791313,
          3372408396,
          3104550113,
          3145860560,
          296247880,
          1970579870,
          3078560182,
          3769228297,
          1714227617,
          3291629107,
          3898220290,
          166772364,
          1251581989,
          493813264,
          448347421,
          195405023,
          2709975567,
          677966185,
          3703036547,
          1463355134,
          2715995803,
          1338867538,
          1343315457,
          2802222074,
          2684532164,
          233230375,
          2599980071,
          2000651841,
          3277868038,
          1638401717,
          4028070440,
          3237316320,
          6314154,
          819756386,
          300326615,
          590932579,
          1405279636,
          3267499572,
          3150704214,
          2428286686,
          3959192993,
          3461946742,
          1862657033,
          1266418056,
          963775037,
          2089974820,
          2263052895,
          1917689273,
          448879540,
          3550394620,
          3981727096,
          150775221,
          3627908307,
          1303187396,
          508620638,
          2975983352,
          2726630617,
          1817252668,
          1876281319,
          1457606340,
          908771278,
          3720792119,
          3617206836,
          2455994898,
          1729034894,
          1080033504
        ]),
        new Uint32Array([
          976866871,
          3556439503,
          2881648439,
          1522871579,
          1555064734,
          1336096578,
          3548522304,
          2579274686,
          3574697629,
          3205460757,
          3593280638,
          3338716283,
          3079412587,
          564236357,
          2993598910,
          1781952180,
          1464380207,
          3163844217,
          3332601554,
          1699332808,
          1393555694,
          1183702653,
          3581086237,
          1288719814,
          691649499,
          2847557200,
          2895455976,
          3193889540,
          2717570544,
          1781354906,
          1676643554,
          2592534050,
          3230253752,
          1126444790,
          2770207658,
          2633158820,
          2210423226,
          2615765581,
          2414155088,
          3127139286,
          673620729,
          2805611233,
          1269405062,
          4015350505,
          3341807571,
          4149409754,
          1057255273,
          2012875353,
          2162469141,
          2276492801,
          2601117357,
          993977747,
          3918593370,
          2654263191,
          753973209,
          36408145,
          2530585658,
          25011837,
          3520020182,
          2088578344,
          530523599,
          2918365339,
          1524020338,
          1518925132,
          3760827505,
          3759777254,
          1202760957,
          3985898139,
          3906192525,
          674977740,
          4174734889,
          2031300136,
          2019492241,
          3983892565,
          4153806404,
          3822280332,
          352677332,
          2297720250,
          60907813,
          90501309,
          3286998549,
          1016092578,
          2535922412,
          2839152426,
          457141659,
          509813237,
          4120667899,
          652014361,
          1966332200,
          2975202805,
          55981186,
          2327461051,
          676427537,
          3255491064,
          2882294119,
          3433927263,
          1307055953,
          942726286,
          933058658,
          2468411793,
          3933900994,
          4215176142,
          1361170020,
          2001714738,
          2830558078,
          3274259782,
          1222529897,
          1679025792,
          2729314320,
          3714953764,
          1770335741,
          151462246,
          3013232138,
          1682292957,
          1483529935,
          471910574,
          1539241949,
          458788160,
          3436315007,
          1807016891,
          3718408830,
          978976581,
          1043663428,
          3165965781,
          1927990952,
          4200891579,
          2372276910,
          3208408903,
          3533431907,
          1412390302,
          2931980059,
          4132332400,
          1947078029,
          3881505623,
          4168226417,
          2941484381,
          1077988104,
          1320477388,
          886195818,
          18198404,
          3786409e3,
          2509781533,
          112762804,
          3463356488,
          1866414978,
          891333506,
          18488651,
          661792760,
          1628790961,
          3885187036,
          3141171499,
          876946877,
          2693282273,
          1372485963,
          791857591,
          2686433993,
          3759982718,
          3167212022,
          3472953795,
          2716379847,
          445679433,
          3561995674,
          3504004811,
          3574258232,
          54117162,
          3331405415,
          2381918588,
          3769707343,
          4154350007,
          1140177722,
          4074052095,
          668550556,
          3214352940,
          367459370,
          261225585,
          2610173221,
          4209349473,
          3468074219,
          3265815641,
          314222801,
          3066103646,
          3808782860,
          282218597,
          3406013506,
          3773591054,
          379116347,
          1285071038,
          846784868,
          2669647154,
          3771962079,
          3550491691,
          2305946142,
          453669953,
          1268987020,
          3317592352,
          3279303384,
          3744833421,
          2610507566,
          3859509063,
          266596637,
          3847019092,
          517658769,
          3462560207,
          3443424879,
          370717030,
          4247526661,
          2224018117,
          4143653529,
          4112773975,
          2788324899,
          2477274417,
          1456262402,
          2901442914,
          1517677493,
          1846949527,
          2295493580,
          3734397586,
          2176403920,
          1280348187,
          1908823572,
          3871786941,
          846861322,
          1172426758,
          3287448474,
          3383383037,
          1655181056,
          3139813346,
          901632758,
          1897031941,
          2986607138,
          3066810236,
          3447102507,
          1393639104,
          373351379,
          950779232,
          625454576,
          3124240540,
          4148612726,
          2007998917,
          544563296,
          2244738638,
          2330496472,
          2058025392,
          1291430526,
          424198748,
          50039436,
          29584100,
          3605783033,
          2429876329,
          2791104160,
          1057563949,
          3255363231,
          3075367218,
          3463963227,
          1469046755,
          985887462
        ])
      ];
      this.P = new Uint32Array([
        608135816,
        2242054355,
        320440878,
        57701188,
        2752067618,
        698298832,
        137296536,
        3964562569,
        1160258022,
        953160567,
        3193202383,
        887688300,
        3232508343,
        3380367581,
        1065670069,
        3041331479,
        2450970073,
        2306472731
      ]);
    };
    function F(S, x8, i) {
      return (S[0][x8[i + 3]] + S[1][x8[i + 2]] ^ S[2][x8[i + 1]]) + S[3][x8[i]];
    }
    Blowfish.prototype.encipher = function(x, x8) {
      if (x8 === void 0) {
        x8 = new Uint8Array(x.buffer);
        if (x.byteOffset !== 0)
          x8 = x8.subarray(x.byteOffset);
      }
      x[0] ^= this.P[0];
      for (var i = 1; i < 16; i += 2) {
        x[1] ^= F(this.S, x8, 0) ^ this.P[i];
        x[0] ^= F(this.S, x8, 4) ^ this.P[i + 1];
      }
      var t = x[0];
      x[0] = x[1] ^ this.P[17];
      x[1] = t;
    };
    Blowfish.prototype.decipher = function(x) {
      var x8 = new Uint8Array(x.buffer);
      if (x.byteOffset !== 0)
        x8 = x8.subarray(x.byteOffset);
      x[0] ^= this.P[17];
      for (var i = 16; i > 0; i -= 2) {
        x[1] ^= F(this.S, x8, 0) ^ this.P[i];
        x[0] ^= F(this.S, x8, 4) ^ this.P[i - 1];
      }
      var t = x[0];
      x[0] = x[1] ^ this.P[0];
      x[1] = t;
    };
    function stream2word(data, databytes) {
      var i, temp = 0;
      for (i = 0; i < 4; i++, BLF_J++) {
        if (BLF_J >= databytes)
          BLF_J = 0;
        temp = temp << 8 | data[BLF_J];
      }
      return temp;
    }
    Blowfish.prototype.expand0state = function(key, keybytes) {
      var d = new Uint32Array(2), i, k;
      var d8 = new Uint8Array(d.buffer);
      for (i = 0, BLF_J = 0; i < 18; i++) {
        this.P[i] ^= stream2word(key, keybytes);
      }
      BLF_J = 0;
      for (i = 0; i < 18; i += 2) {
        this.encipher(d, d8);
        this.P[i] = d[0];
        this.P[i + 1] = d[1];
      }
      for (i = 0; i < 4; i++) {
        for (k = 0; k < 256; k += 2) {
          this.encipher(d, d8);
          this.S[i][k] = d[0];
          this.S[i][k + 1] = d[1];
        }
      }
    };
    Blowfish.prototype.expandstate = function(data, databytes, key, keybytes) {
      var d = new Uint32Array(2), i, k;
      for (i = 0, BLF_J = 0; i < 18; i++) {
        this.P[i] ^= stream2word(key, keybytes);
      }
      for (i = 0, BLF_J = 0; i < 18; i += 2) {
        d[0] ^= stream2word(data, databytes);
        d[1] ^= stream2word(data, databytes);
        this.encipher(d);
        this.P[i] = d[0];
        this.P[i + 1] = d[1];
      }
      for (i = 0; i < 4; i++) {
        for (k = 0; k < 256; k += 2) {
          d[0] ^= stream2word(data, databytes);
          d[1] ^= stream2word(data, databytes);
          this.encipher(d);
          this.S[i][k] = d[0];
          this.S[i][k + 1] = d[1];
        }
      }
      BLF_J = 0;
    };
    Blowfish.prototype.enc = function(data, blocks) {
      for (var i = 0; i < blocks; i++) {
        this.encipher(data.subarray(i * 2));
      }
    };
    Blowfish.prototype.dec = function(data, blocks) {
      for (var i = 0; i < blocks; i++) {
        this.decipher(data.subarray(i * 2));
      }
    };
    var BCRYPT_BLOCKS = 8;
    var BCRYPT_HASHSIZE = 32;
    function bcrypt_hash(sha2pass, sha2salt, out) {
      var state2 = new Blowfish(), cdata = new Uint32Array(BCRYPT_BLOCKS), i, ciphertext = new Uint8Array([
        79,
        120,
        121,
        99,
        104,
        114,
        111,
        109,
        97,
        116,
        105,
        99,
        66,
        108,
        111,
        119,
        102,
        105,
        115,
        104,
        83,
        119,
        97,
        116,
        68,
        121,
        110,
        97,
        109,
        105,
        116,
        101
      ]);
      state2.expandstate(sha2salt, 64, sha2pass, 64);
      for (i = 0; i < 64; i++) {
        state2.expand0state(sha2salt, 64);
        state2.expand0state(sha2pass, 64);
      }
      for (i = 0; i < BCRYPT_BLOCKS; i++)
        cdata[i] = stream2word(ciphertext, ciphertext.byteLength);
      for (i = 0; i < 64; i++)
        state2.enc(cdata, cdata.byteLength / 8);
      for (i = 0; i < BCRYPT_BLOCKS; i++) {
        out[4 * i + 3] = cdata[i] >>> 24;
        out[4 * i + 2] = cdata[i] >>> 16;
        out[4 * i + 1] = cdata[i] >>> 8;
        out[4 * i + 0] = cdata[i];
      }
    }
    function bcrypt_pbkdf(pass2, passlen, salt, saltlen, key, keylen, rounds) {
      var sha2pass = new Uint8Array(64), sha2salt = new Uint8Array(64), out = new Uint8Array(BCRYPT_HASHSIZE), tmpout = new Uint8Array(BCRYPT_HASHSIZE), countsalt = new Uint8Array(saltlen + 4), i, j, amt, stride, dest, count, origkeylen = keylen;
      if (rounds < 1)
        return -1;
      if (passlen === 0 || saltlen === 0 || keylen === 0 || keylen > out.byteLength * out.byteLength || saltlen > 1 << 20)
        return -1;
      stride = Math.floor((keylen + out.byteLength - 1) / out.byteLength);
      amt = Math.floor((keylen + stride - 1) / stride);
      for (i = 0; i < saltlen; i++)
        countsalt[i] = salt[i];
      crypto_hash_sha512(sha2pass, pass2, passlen);
      for (count = 1; keylen > 0; count++) {
        countsalt[saltlen + 0] = count >>> 24;
        countsalt[saltlen + 1] = count >>> 16;
        countsalt[saltlen + 2] = count >>> 8;
        countsalt[saltlen + 3] = count;
        crypto_hash_sha512(sha2salt, countsalt, saltlen + 4);
        bcrypt_hash(sha2pass, sha2salt, tmpout);
        for (i = out.byteLength; i--; )
          out[i] = tmpout[i];
        for (i = 1; i < rounds; i++) {
          crypto_hash_sha512(sha2salt, tmpout, tmpout.byteLength);
          bcrypt_hash(sha2pass, sha2salt, tmpout);
          for (j = 0; j < out.byteLength; j++)
            out[j] ^= tmpout[j];
        }
        amt = Math.min(amt, keylen);
        for (i = 0; i < amt; i++) {
          dest = i * stride + (count - 1);
          if (dest >= origkeylen)
            break;
          key[dest] = out[i];
        }
        keylen -= i;
      }
      return 0;
    }
    module.exports = {
      BLOCKS: BCRYPT_BLOCKS,
      HASHSIZE: BCRYPT_HASHSIZE,
      hash: bcrypt_hash,
      pbkdf: bcrypt_pbkdf
    };
  }
});

// node_modules/cpu-features/build/Release/cpufeatures.node
var require_cpufeatures = __commonJS({
  "node_modules/cpu-features/build/Release/cpufeatures.node"(exports, module) {
    module.exports = "./cpufeatures-RO7VYSCH.node";
  }
});

// node_modules/cpu-features/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/cpu-features/lib/index.js"(exports, module) {
    "use strict";
    var binding = require_cpufeatures();
    module.exports = binding.getCPUInfo;
  }
});

// node_modules/ssh2/lib/protocol/constants.js
var require_constants5 = __commonJS({
  "node_modules/ssh2/lib/protocol/constants.js"(exports, module) {
    "use strict";
    var crypto2 = __require("crypto");
    var cpuInfo;
    try {
      cpuInfo = require_lib3()();
    } catch {
    }
    var { bindingAvailable, CIPHER_INFO, MAC_INFO } = require_crypto();
    var eddsaSupported = (() => {
      if (typeof crypto2.sign === "function" && typeof crypto2.verify === "function") {
        const key = "-----BEGIN PRIVATE KEY-----\r\nMC4CAQAwBQYDK2VwBCIEIHKj+sVa9WcD/q2DJUJaf43Kptc8xYuUQA4bOFj9vC8T\r\n-----END PRIVATE KEY-----";
        const data = Buffer.from("a");
        let sig;
        let verified;
        try {
          sig = crypto2.sign(null, data, key);
          verified = crypto2.verify(null, data, key, sig);
        } catch {
        }
        return Buffer.isBuffer(sig) && sig.length === 64 && verified === true;
      }
      return false;
    })();
    var curve25519Supported = typeof crypto2.diffieHellman === "function" && typeof crypto2.generateKeyPairSync === "function" && typeof crypto2.createPublicKey === "function";
    var DEFAULT_KEX = [
      // https://tools.ietf.org/html/rfc5656#section-10.1
      "ecdh-sha2-nistp256",
      "ecdh-sha2-nistp384",
      "ecdh-sha2-nistp521",
      // https://tools.ietf.org/html/rfc4419#section-4
      "diffie-hellman-group-exchange-sha256",
      // https://tools.ietf.org/html/rfc8268
      "diffie-hellman-group14-sha256",
      "diffie-hellman-group15-sha512",
      "diffie-hellman-group16-sha512",
      "diffie-hellman-group17-sha512",
      "diffie-hellman-group18-sha512"
    ];
    if (curve25519Supported) {
      DEFAULT_KEX.unshift("curve25519-sha256");
      DEFAULT_KEX.unshift("curve25519-sha256@libssh.org");
    }
    var SUPPORTED_KEX = DEFAULT_KEX.concat([
      // https://tools.ietf.org/html/rfc4419#section-4
      "diffie-hellman-group-exchange-sha1",
      "diffie-hellman-group14-sha1",
      // REQUIRED
      "diffie-hellman-group1-sha1"
      // REQUIRED
    ]);
    var DEFAULT_SERVER_HOST_KEY = [
      "ecdsa-sha2-nistp256",
      "ecdsa-sha2-nistp384",
      "ecdsa-sha2-nistp521",
      "rsa-sha2-512",
      // RFC 8332
      "rsa-sha2-256",
      // RFC 8332
      "ssh-rsa"
    ];
    if (eddsaSupported)
      DEFAULT_SERVER_HOST_KEY.unshift("ssh-ed25519");
    var SUPPORTED_SERVER_HOST_KEY = DEFAULT_SERVER_HOST_KEY.concat([
      "ssh-dss"
    ]);
    var canUseCipher = (() => {
      const ciphers = crypto2.getCiphers();
      return (name4) => ciphers.includes(CIPHER_INFO[name4].sslName);
    })();
    var DEFAULT_CIPHER = [
      // http://tools.ietf.org/html/rfc5647
      "aes128-gcm@openssh.com",
      "aes256-gcm@openssh.com",
      // http://tools.ietf.org/html/rfc4344#section-4
      "aes128-ctr",
      "aes192-ctr",
      "aes256-ctr"
    ];
    if (cpuInfo && cpuInfo.flags && !cpuInfo.flags.aes) {
      if (bindingAvailable)
        DEFAULT_CIPHER.unshift("chacha20-poly1305@openssh.com");
      else
        DEFAULT_CIPHER.push("chacha20-poly1305@openssh.com");
    } else if (bindingAvailable && cpuInfo && cpuInfo.arch === "x86") {
      DEFAULT_CIPHER.splice(4, 0, "chacha20-poly1305@openssh.com");
    } else {
      DEFAULT_CIPHER.push("chacha20-poly1305@openssh.com");
    }
    DEFAULT_CIPHER = DEFAULT_CIPHER.filter(canUseCipher);
    var SUPPORTED_CIPHER = DEFAULT_CIPHER.concat([
      "aes256-cbc",
      "aes192-cbc",
      "aes128-cbc",
      "blowfish-cbc",
      "3des-cbc",
      "aes128-gcm",
      "aes256-gcm",
      // http://tools.ietf.org/html/rfc4345#section-4:
      "arcfour256",
      "arcfour128",
      "cast128-cbc",
      "arcfour"
    ].filter(canUseCipher));
    var canUseMAC = (() => {
      const hashes = crypto2.getHashes();
      return (name4) => hashes.includes(MAC_INFO[name4].sslName);
    })();
    var DEFAULT_MAC = [
      "hmac-sha2-256-etm@openssh.com",
      "hmac-sha2-512-etm@openssh.com",
      "hmac-sha1-etm@openssh.com",
      "hmac-sha2-256",
      "hmac-sha2-512",
      "hmac-sha1"
    ].filter(canUseMAC);
    var SUPPORTED_MAC = DEFAULT_MAC.concat([
      "hmac-md5",
      "hmac-sha2-256-96",
      // first 96 bits of HMAC-SHA256
      "hmac-sha2-512-96",
      // first 96 bits of HMAC-SHA512
      "hmac-ripemd160",
      "hmac-sha1-96",
      // first 96 bits of HMAC-SHA1
      "hmac-md5-96"
      // first 96 bits of HMAC-MD5
    ].filter(canUseMAC));
    var DEFAULT_COMPRESSION = [
      "none",
      "zlib@openssh.com",
      // ZLIB (LZ77) compression, except
      // compression/decompression does not start until after
      // successful user authentication
      "zlib"
      // ZLIB (LZ77) compression
    ];
    var SUPPORTED_COMPRESSION = DEFAULT_COMPRESSION.concat([]);
    var COMPAT = {
      BAD_DHGEX: 1 << 0,
      OLD_EXIT: 1 << 1,
      DYN_RPORT_BUG: 1 << 2,
      BUG_DHGEX_LARGE: 1 << 3,
      IMPLY_RSA_SHA2_SIGALGS: 1 << 4
    };
    module.exports = {
      MESSAGE: {
        // Transport layer protocol -- generic (1-19)
        DISCONNECT: 1,
        IGNORE: 2,
        UNIMPLEMENTED: 3,
        DEBUG: 4,
        SERVICE_REQUEST: 5,
        SERVICE_ACCEPT: 6,
        EXT_INFO: 7,
        // RFC 8308
        // Transport layer protocol -- algorithm negotiation (20-29)
        KEXINIT: 20,
        NEWKEYS: 21,
        // Transport layer protocol -- key exchange method-specific (30-49)
        KEXDH_INIT: 30,
        KEXDH_REPLY: 31,
        KEXDH_GEX_GROUP: 31,
        KEXDH_GEX_INIT: 32,
        KEXDH_GEX_REPLY: 33,
        KEXDH_GEX_REQUEST: 34,
        KEXECDH_INIT: 30,
        KEXECDH_REPLY: 31,
        // User auth protocol -- generic (50-59)
        USERAUTH_REQUEST: 50,
        USERAUTH_FAILURE: 51,
        USERAUTH_SUCCESS: 52,
        USERAUTH_BANNER: 53,
        // User auth protocol -- user auth method-specific (60-79)
        USERAUTH_PASSWD_CHANGEREQ: 60,
        USERAUTH_PK_OK: 60,
        USERAUTH_INFO_REQUEST: 60,
        USERAUTH_INFO_RESPONSE: 61,
        // Connection protocol -- generic (80-89)
        GLOBAL_REQUEST: 80,
        REQUEST_SUCCESS: 81,
        REQUEST_FAILURE: 82,
        // Connection protocol -- channel-related (90-127)
        CHANNEL_OPEN: 90,
        CHANNEL_OPEN_CONFIRMATION: 91,
        CHANNEL_OPEN_FAILURE: 92,
        CHANNEL_WINDOW_ADJUST: 93,
        CHANNEL_DATA: 94,
        CHANNEL_EXTENDED_DATA: 95,
        CHANNEL_EOF: 96,
        CHANNEL_CLOSE: 97,
        CHANNEL_REQUEST: 98,
        CHANNEL_SUCCESS: 99,
        CHANNEL_FAILURE: 100
        // Reserved for client protocols (128-191)
        // Local extensions (192-155)
      },
      DISCONNECT_REASON: {
        HOST_NOT_ALLOWED_TO_CONNECT: 1,
        PROTOCOL_ERROR: 2,
        KEY_EXCHANGE_FAILED: 3,
        RESERVED: 4,
        MAC_ERROR: 5,
        COMPRESSION_ERROR: 6,
        SERVICE_NOT_AVAILABLE: 7,
        PROTOCOL_VERSION_NOT_SUPPORTED: 8,
        HOST_KEY_NOT_VERIFIABLE: 9,
        CONNECTION_LOST: 10,
        BY_APPLICATION: 11,
        TOO_MANY_CONNECTIONS: 12,
        AUTH_CANCELED_BY_USER: 13,
        NO_MORE_AUTH_METHODS_AVAILABLE: 14,
        ILLEGAL_USER_NAME: 15
      },
      DISCONNECT_REASON_STR: void 0,
      CHANNEL_OPEN_FAILURE: {
        ADMINISTRATIVELY_PROHIBITED: 1,
        CONNECT_FAILED: 2,
        UNKNOWN_CHANNEL_TYPE: 3,
        RESOURCE_SHORTAGE: 4
      },
      TERMINAL_MODE: {
        TTY_OP_END: 0,
        // Indicates end of options.
        VINTR: 1,
        // Interrupt character; 255 if none. Similarly for the
        //  other characters.  Not all of these characters are
        //  supported on all systems.
        VQUIT: 2,
        // The quit character (sends SIGQUIT signal on POSIX
        //  systems).
        VERASE: 3,
        // Erase the character to left of the cursor.
        VKILL: 4,
        // Kill the current input line.
        VEOF: 5,
        // End-of-file character (sends EOF from the
        //  terminal).
        VEOL: 6,
        // End-of-line character in addition to carriage
        //  return and/or linefeed.
        VEOL2: 7,
        // Additional end-of-line character.
        VSTART: 8,
        // Continues paused output (normally control-Q).
        VSTOP: 9,
        // Pauses output (normally control-S).
        VSUSP: 10,
        // Suspends the current program.
        VDSUSP: 11,
        // Another suspend character.
        VREPRINT: 12,
        // Reprints the current input line.
        VWERASE: 13,
        // Erases a word left of cursor.
        VLNEXT: 14,
        // Enter the next character typed literally, even if
        //  it is a special character
        VFLUSH: 15,
        // Character to flush output.
        VSWTCH: 16,
        // Switch to a different shell layer.
        VSTATUS: 17,
        // Prints system status line (load, command, pid,
        //  etc).
        VDISCARD: 18,
        // Toggles the flushing of terminal output.
        IGNPAR: 30,
        // The ignore parity flag.  The parameter SHOULD be 0
        //  if this flag is FALSE, and 1 if it is TRUE.
        PARMRK: 31,
        // Mark parity and framing errors.
        INPCK: 32,
        // Enable checking of parity errors.
        ISTRIP: 33,
        // Strip 8th bit off characters.
        INLCR: 34,
        // Map NL into CR on input.
        IGNCR: 35,
        // Ignore CR on input.
        ICRNL: 36,
        // Map CR to NL on input.
        IUCLC: 37,
        // Translate uppercase characters to lowercase.
        IXON: 38,
        // Enable output flow control.
        IXANY: 39,
        // Any char will restart after stop.
        IXOFF: 40,
        // Enable input flow control.
        IMAXBEL: 41,
        // Ring bell on input queue full.
        ISIG: 50,
        // Enable signals INTR, QUIT, [D]SUSP.
        ICANON: 51,
        // Canonicalize input lines.
        XCASE: 52,
        // Enable input and output of uppercase characters by
        //  preceding their lowercase equivalents with "\".
        ECHO: 53,
        // Enable echoing.
        ECHOE: 54,
        // Visually erase chars.
        ECHOK: 55,
        // Kill character discards current line.
        ECHONL: 56,
        // Echo NL even if ECHO is off.
        NOFLSH: 57,
        // Don't flush after interrupt.
        TOSTOP: 58,
        // Stop background jobs from output.
        IEXTEN: 59,
        // Enable extensions.
        ECHOCTL: 60,
        // Echo control characters as ^(Char).
        ECHOKE: 61,
        // Visual erase for line kill.
        PENDIN: 62,
        // Retype pending input.
        OPOST: 70,
        // Enable output processing.
        OLCUC: 71,
        // Convert lowercase to uppercase.
        ONLCR: 72,
        // Map NL to CR-NL.
        OCRNL: 73,
        // Translate carriage return to newline (output).
        ONOCR: 74,
        // Translate newline to carriage return-newline
        //  (output).
        ONLRET: 75,
        // Newline performs a carriage return (output).
        CS7: 90,
        // 7 bit mode.
        CS8: 91,
        // 8 bit mode.
        PARENB: 92,
        // Parity enable.
        PARODD: 93,
        // Odd parity, else even.
        TTY_OP_ISPEED: 128,
        // Specifies the input baud rate in bits per second.
        TTY_OP_OSPEED: 129
        // Specifies the output baud rate in bits per second.
      },
      CHANNEL_EXTENDED_DATATYPE: {
        STDERR: 1
      },
      SIGNALS: [
        "ABRT",
        "ALRM",
        "FPE",
        "HUP",
        "ILL",
        "INT",
        "QUIT",
        "SEGV",
        "TERM",
        "USR1",
        "USR2",
        "KILL",
        "PIPE"
      ].reduce((cur, val) => ({ ...cur, [val]: 1 }), {}),
      COMPAT,
      COMPAT_CHECKS: [
        ["Cisco-1.25", COMPAT.BAD_DHGEX],
        [/^Cisco-1[.]/, COMPAT.BUG_DHGEX_LARGE],
        [/^[0-9.]+$/, COMPAT.OLD_EXIT],
        // old SSH.com implementations
        [/^OpenSSH_5[.][0-9]+/, COMPAT.DYN_RPORT_BUG],
        [/^OpenSSH_7[.]4/, COMPAT.IMPLY_RSA_SHA2_SIGALGS]
      ],
      // KEX proposal-related
      DEFAULT_KEX,
      SUPPORTED_KEX,
      DEFAULT_SERVER_HOST_KEY,
      SUPPORTED_SERVER_HOST_KEY,
      DEFAULT_CIPHER,
      SUPPORTED_CIPHER,
      DEFAULT_MAC,
      SUPPORTED_MAC,
      DEFAULT_COMPRESSION,
      SUPPORTED_COMPRESSION,
      curve25519Supported,
      eddsaSupported
    };
    module.exports.DISCONNECT_REASON_BY_VALUE = Array.from(Object.entries(module.exports.DISCONNECT_REASON)).reduce((obj, [key, value4]) => ({ ...obj, [value4]: key }), {});
  }
});

// node_modules/ssh2/lib/protocol/utils.js
var require_utils7 = __commonJS({
  "node_modules/ssh2/lib/protocol/utils.js"(exports, module) {
    "use strict";
    var Ber = require_lib2().Ber;
    var DISCONNECT_REASON;
    var FastBuffer = Buffer[Symbol.species];
    var TypedArrayFill = Object.getPrototypeOf(Uint8Array.prototype).fill;
    function readUInt32BE(buf, offset) {
      return buf[offset++] * 16777216 + buf[offset++] * 65536 + buf[offset++] * 256 + buf[offset];
    }
    function bufferCopy(src, dest, srcStart, srcEnd, destStart) {
      if (!destStart)
        destStart = 0;
      if (srcEnd > src.length)
        srcEnd = src.length;
      let nb = srcEnd - srcStart;
      const destLeft = dest.length - destStart;
      if (nb > destLeft)
        nb = destLeft;
      dest.set(
        new Uint8Array(src.buffer, src.byteOffset + srcStart, nb),
        destStart
      );
      return nb;
    }
    function bufferSlice(buf, start, end4) {
      if (end4 === void 0)
        end4 = buf.length;
      return new FastBuffer(buf.buffer, buf.byteOffset + start, end4 - start);
    }
    function makeBufferParser() {
      let pos = 0;
      let buffer;
      const self2 = {
        init: (buf, start) => {
          buffer = buf;
          pos = typeof start === "number" ? start : 0;
        },
        pos: () => pos,
        length: () => buffer ? buffer.length : 0,
        avail: () => buffer && pos < buffer.length ? buffer.length - pos : 0,
        clear: () => {
          buffer = void 0;
        },
        readUInt32BE: () => {
          if (!buffer || pos + 3 >= buffer.length)
            return;
          return buffer[pos++] * 16777216 + buffer[pos++] * 65536 + buffer[pos++] * 256 + buffer[pos++];
        },
        readUInt64BE: (behavior) => {
          if (!buffer || pos + 7 >= buffer.length)
            return;
          switch (behavior) {
            case "always":
              return BigInt(`0x${buffer.hexSlice(pos, pos += 8)}`);
            case "maybe":
              if (buffer[pos] > 31)
                return BigInt(`0x${buffer.hexSlice(pos, pos += 8)}`);
            default:
              return buffer[pos++] * 72057594037927940 + buffer[pos++] * 281474976710656 + buffer[pos++] * 1099511627776 + buffer[pos++] * 4294967296 + buffer[pos++] * 16777216 + buffer[pos++] * 65536 + buffer[pos++] * 256 + buffer[pos++];
          }
        },
        skip: (n) => {
          if (buffer && n > 0)
            pos += n;
        },
        skipString: () => {
          const len = self2.readUInt32BE();
          if (len === void 0)
            return;
          pos += len;
          return pos <= buffer.length ? len : void 0;
        },
        readByte: () => {
          if (buffer && pos < buffer.length)
            return buffer[pos++];
        },
        readBool: () => {
          if (buffer && pos < buffer.length)
            return !!buffer[pos++];
        },
        readList: () => {
          const list2 = self2.readString(true);
          if (list2 === void 0)
            return;
          return list2 ? list2.split(",") : [];
        },
        readString: (dest, maxLen) => {
          if (typeof dest === "number") {
            maxLen = dest;
            dest = void 0;
          }
          const len = self2.readUInt32BE();
          if (len === void 0)
            return;
          if (buffer.length - pos < len || typeof maxLen === "number" && len > maxLen) {
            return;
          }
          if (dest) {
            if (Buffer.isBuffer(dest))
              return bufferCopy(buffer, dest, pos, pos += len);
            return buffer.utf8Slice(pos, pos += len);
          }
          return bufferSlice(buffer, pos, pos += len);
        },
        readRaw: (len) => {
          if (!buffer)
            return;
          if (typeof len !== "number")
            return bufferSlice(buffer, pos, pos += buffer.length - pos);
          if (buffer.length - pos >= len)
            return bufferSlice(buffer, pos, pos += len);
        }
      };
      return self2;
    }
    function makeError(msg, level, fatal) {
      const err = new Error(msg);
      if (typeof level === "boolean") {
        fatal = level;
        err.level = "protocol";
      } else {
        err.level = level || "protocol";
      }
      err.fatal = !!fatal;
      return err;
    }
    function writeUInt32BE(buf, value4, offset) {
      buf[offset++] = value4 >>> 24;
      buf[offset++] = value4 >>> 16;
      buf[offset++] = value4 >>> 8;
      buf[offset++] = value4;
      return offset;
    }
    var utilBufferParser = makeBufferParser();
    module.exports = {
      bufferCopy,
      bufferSlice,
      FastBuffer,
      bufferFill: (buf, value4, start, end4) => {
        return TypedArrayFill.call(buf, value4, start, end4);
      },
      makeError,
      doFatalError: (protocol, msg, level, reason) => {
        let err;
        if (DISCONNECT_REASON === void 0)
          ({ DISCONNECT_REASON } = require_constants5());
        if (msg instanceof Error) {
          err = msg;
          if (typeof level !== "number")
            reason = DISCONNECT_REASON.PROTOCOL_ERROR;
          else
            reason = level;
        } else {
          err = makeError(msg, level, true);
        }
        if (typeof reason !== "number")
          reason = DISCONNECT_REASON.PROTOCOL_ERROR;
        protocol.disconnect(reason);
        protocol._destruct();
        protocol._onError(err);
        return Infinity;
      },
      readUInt32BE,
      writeUInt32BE,
      writeUInt32LE: (buf, value4, offset) => {
        buf[offset++] = value4;
        buf[offset++] = value4 >>> 8;
        buf[offset++] = value4 >>> 16;
        buf[offset++] = value4 >>> 24;
        return offset;
      },
      makeBufferParser,
      bufferParser: makeBufferParser(),
      readString: (buffer, start, dest, maxLen) => {
        if (typeof dest === "number") {
          maxLen = dest;
          dest = void 0;
        }
        if (start === void 0)
          start = 0;
        const left2 = buffer.length - start;
        if (start < 0 || start >= buffer.length || left2 < 4)
          return;
        const len = readUInt32BE(buffer, start);
        if (left2 < 4 + len || typeof maxLen === "number" && len > maxLen)
          return;
        start += 4;
        const end4 = start + len;
        buffer._pos = end4;
        if (dest) {
          if (Buffer.isBuffer(dest))
            return bufferCopy(buffer, dest, start, end4);
          return buffer.utf8Slice(start, end4);
        }
        return bufferSlice(buffer, start, end4);
      },
      sigSSHToASN1: (sig, type) => {
        switch (type) {
          case "ssh-dss": {
            if (sig.length > 40)
              return sig;
            const asnWriter = new Ber.Writer();
            asnWriter.startSequence();
            let r = sig.slice(0, 20);
            let s = sig.slice(20);
            if (r[0] & 128) {
              const rNew = Buffer.allocUnsafe(21);
              rNew[0] = 0;
              r.copy(rNew, 1);
              r = rNew;
            } else if (r[0] === 0 && !(r[1] & 128)) {
              r = r.slice(1);
            }
            if (s[0] & 128) {
              const sNew = Buffer.allocUnsafe(21);
              sNew[0] = 0;
              s.copy(sNew, 1);
              s = sNew;
            } else if (s[0] === 0 && !(s[1] & 128)) {
              s = s.slice(1);
            }
            asnWriter.writeBuffer(r, Ber.Integer);
            asnWriter.writeBuffer(s, Ber.Integer);
            asnWriter.endSequence();
            return asnWriter.buffer;
          }
          case "ecdsa-sha2-nistp256":
          case "ecdsa-sha2-nistp384":
          case "ecdsa-sha2-nistp521": {
            utilBufferParser.init(sig, 0);
            const r = utilBufferParser.readString();
            const s = utilBufferParser.readString();
            utilBufferParser.clear();
            if (r === void 0 || s === void 0)
              return;
            const asnWriter = new Ber.Writer();
            asnWriter.startSequence();
            asnWriter.writeBuffer(r, Ber.Integer);
            asnWriter.writeBuffer(s, Ber.Integer);
            asnWriter.endSequence();
            return asnWriter.buffer;
          }
          default:
            return sig;
        }
      },
      convertSignature: (signature, keyType) => {
        switch (keyType) {
          case "ssh-dss": {
            if (signature.length <= 40)
              return signature;
            const asnReader = new Ber.Reader(signature);
            asnReader.readSequence();
            let r = asnReader.readString(Ber.Integer, true);
            let s = asnReader.readString(Ber.Integer, true);
            let rOffset = 0;
            let sOffset = 0;
            if (r.length < 20) {
              const rNew = Buffer.allocUnsafe(20);
              rNew.set(r, 1);
              r = rNew;
              r[0] = 0;
            }
            if (s.length < 20) {
              const sNew = Buffer.allocUnsafe(20);
              sNew.set(s, 1);
              s = sNew;
              s[0] = 0;
            }
            if (r.length > 20 && r[0] === 0)
              rOffset = 1;
            if (s.length > 20 && s[0] === 0)
              sOffset = 1;
            const newSig = Buffer.allocUnsafe(r.length - rOffset + (s.length - sOffset));
            bufferCopy(r, newSig, rOffset, r.length, 0);
            bufferCopy(s, newSig, sOffset, s.length, r.length - rOffset);
            return newSig;
          }
          case "ecdsa-sha2-nistp256":
          case "ecdsa-sha2-nistp384":
          case "ecdsa-sha2-nistp521": {
            if (signature[0] === 0)
              return signature;
            const asnReader = new Ber.Reader(signature);
            asnReader.readSequence();
            const r = asnReader.readString(Ber.Integer, true);
            const s = asnReader.readString(Ber.Integer, true);
            if (r === null || s === null)
              return;
            const newSig = Buffer.allocUnsafe(4 + r.length + 4 + s.length);
            writeUInt32BE(newSig, r.length, 0);
            newSig.set(r, 4);
            writeUInt32BE(newSig, s.length, 4 + r.length);
            newSig.set(s, 4 + 4 + r.length);
            return newSig;
          }
        }
        return signature;
      },
      sendPacket: (proto, packet, bypass) => {
        if (!bypass && proto._kexinit !== void 0) {
          if (proto._queue === void 0)
            proto._queue = [];
          proto._queue.push(packet);
          proto._debug && proto._debug("Outbound: ... packet queued");
          return false;
        }
        proto._cipher.encrypt(packet);
        return true;
      }
    };
  }
});

// node_modules/ssh2/lib/protocol/crypto/build/Release/sshcrypto.node
var require_sshcrypto = __commonJS({
  "node_modules/ssh2/lib/protocol/crypto/build/Release/sshcrypto.node"(exports, module) {
    module.exports = "./sshcrypto-AVVVH2XR.node";
  }
});

// node_modules/ssh2/lib/protocol/crypto/poly1305.js
var require_poly1305 = __commonJS({
  "node_modules/ssh2/lib/protocol/crypto/poly1305.js"(exports, module) {
    var createPoly1305 = function() {
      var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
      if (typeof __filename !== "undefined")
        _scriptDir = _scriptDir || __filename;
      return function(createPoly13052) {
        createPoly13052 = createPoly13052 || {};
        var b;
        b || (b = typeof createPoly13052 !== "undefined" ? createPoly13052 : {});
        var q, r;
        b.ready = new Promise(function(a, c) {
          q = a;
          r = c;
        });
        var u = {}, w;
        for (w in b)
          b.hasOwnProperty(w) && (u[w] = b[w]);
        var x = "object" === typeof window, y = "function" === typeof importScripts, z = "object" === typeof process && "object" === typeof process.versions && "string" === typeof process.versions.node, B = "", C, D, E, F, G;
        if (z)
          B = y ? __require("path").dirname(B) + "/" : __dirname + "/", C = function(a, c) {
            var d = H(a);
            if (d)
              return c ? d : d.toString();
            F || (F = __require("fs"));
            G || (G = __require("path"));
            a = G.normalize(a);
            return F.readFileSync(a, c ? null : "utf8");
          }, E = function(a) {
            a = C(a, true);
            a.buffer || (a = new Uint8Array(a));
            assert(a.buffer);
            return a;
          }, D = function(a, c, d) {
            var e = H(a);
            e && c(e);
            F || (F = __require("fs"));
            G || (G = __require("path"));
            a = G.normalize(a);
            F.readFile(a, function(f, l) {
              f ? d(f) : c(l.buffer);
            });
          }, 1 < process.argv.length && process.argv[1].replace(/\\/g, "/"), process.argv.slice(2), b.inspect = function() {
            return "[Emscripten Module object]";
          };
        else if (x || y)
          y ? B = self.location.href : "undefined" !== typeof document && document.currentScript && (B = document.currentScript.src), _scriptDir && (B = _scriptDir), 0 !== B.indexOf("blob:") ? B = B.substr(0, B.lastIndexOf("/") + 1) : B = "", C = function(a) {
            try {
              var c = new XMLHttpRequest();
              c.open("GET", a, false);
              c.send(null);
              return c.responseText;
            } catch (f) {
              if (a = H(a)) {
                c = [];
                for (var d = 0; d < a.length; d++) {
                  var e = a[d];
                  255 < e && (ba && assert(false, "Character code " + e + " (" + String.fromCharCode(e) + ")  at offset " + d + " not in 0x00-0xFF."), e &= 255);
                  c.push(String.fromCharCode(e));
                }
                return c.join("");
              }
              throw f;
            }
          }, y && (E = function(a) {
            try {
              var c = new XMLHttpRequest();
              c.open("GET", a, false);
              c.responseType = "arraybuffer";
              c.send(null);
              return new Uint8Array(c.response);
            } catch (d) {
              if (a = H(a))
                return a;
              throw d;
            }
          }), D = function(a, c, d) {
            var e = new XMLHttpRequest();
            e.open("GET", a, true);
            e.responseType = "arraybuffer";
            e.onload = function() {
              if (200 == e.status || 0 == e.status && e.response)
                c(e.response);
              else {
                var f = H(a);
                f ? c(f.buffer) : d();
              }
            };
            e.onerror = d;
            e.send(null);
          };
        b.print || console.log.bind(console);
        var I = b.printErr || console.warn.bind(console);
        for (w in u)
          u.hasOwnProperty(w) && (b[w] = u[w]);
        u = null;
        var J;
        b.wasmBinary && (J = b.wasmBinary);
        var noExitRuntime = b.noExitRuntime || true;
        "object" !== typeof WebAssembly && K("no native wasm support detected");
        var L, M = false;
        function assert(a, c) {
          a || K("Assertion failed: " + c);
        }
        function N(a) {
          var c = b["_" + a];
          assert(c, "Cannot call unknown function " + a + ", make sure it is exported");
          return c;
        }
        function ca(a, c, d, e) {
          var f = { string: function(g) {
            var p = 0;
            if (null !== g && void 0 !== g && 0 !== g) {
              var n = (g.length << 2) + 1;
              p = O(n);
              var k = p, h = P2;
              if (0 < n) {
                n = k + n - 1;
                for (var v = 0; v < g.length; ++v) {
                  var m = g.charCodeAt(v);
                  if (55296 <= m && 57343 >= m) {
                    var oa = g.charCodeAt(++v);
                    m = 65536 + ((m & 1023) << 10) | oa & 1023;
                  }
                  if (127 >= m) {
                    if (k >= n)
                      break;
                    h[k++] = m;
                  } else {
                    if (2047 >= m) {
                      if (k + 1 >= n)
                        break;
                      h[k++] = 192 | m >> 6;
                    } else {
                      if (65535 >= m) {
                        if (k + 2 >= n)
                          break;
                        h[k++] = 224 | m >> 12;
                      } else {
                        if (k + 3 >= n)
                          break;
                        h[k++] = 240 | m >> 18;
                        h[k++] = 128 | m >> 12 & 63;
                      }
                      h[k++] = 128 | m >> 6 & 63;
                    }
                    h[k++] = 128 | m & 63;
                  }
                }
                h[k] = 0;
              }
            }
            return p;
          }, array: function(g) {
            var p = O(g.length);
            Q.set(g, p);
            return p;
          } }, l = N(a), A2 = [];
          a = 0;
          if (e)
            for (var t = 0; t < e.length; t++) {
              var aa = f[d[t]];
              aa ? (0 === a && (a = da()), A2[t] = aa(e[t])) : A2[t] = e[t];
            }
          d = l.apply(null, A2);
          d = function(g) {
            if ("string" === c)
              if (g) {
                for (var p = P2, n = g + NaN, k = g; p[k] && !(k >= n); )
                  ++k;
                if (16 < k - g && p.subarray && ea)
                  g = ea.decode(p.subarray(g, k));
                else {
                  for (n = ""; g < k; ) {
                    var h = p[g++];
                    if (h & 128) {
                      var v = p[g++] & 63;
                      if (192 == (h & 224))
                        n += String.fromCharCode((h & 31) << 6 | v);
                      else {
                        var m = p[g++] & 63;
                        h = 224 == (h & 240) ? (h & 15) << 12 | v << 6 | m : (h & 7) << 18 | v << 12 | m << 6 | p[g++] & 63;
                        65536 > h ? n += String.fromCharCode(h) : (h -= 65536, n += String.fromCharCode(55296 | h >> 10, 56320 | h & 1023));
                      }
                    } else
                      n += String.fromCharCode(h);
                  }
                  g = n;
                }
              } else
                g = "";
            else
              g = "boolean" === c ? !!g : g;
            return g;
          }(d);
          0 !== a && fa(a);
          return d;
        }
        var ea = "undefined" !== typeof TextDecoder ? new TextDecoder("utf8") : void 0, ha, Q, P2;
        function ia() {
          var a = L.buffer;
          ha = a;
          b.HEAP8 = Q = new Int8Array(a);
          b.HEAP16 = new Int16Array(a);
          b.HEAP32 = new Int32Array(a);
          b.HEAPU8 = P2 = new Uint8Array(a);
          b.HEAPU16 = new Uint16Array(a);
          b.HEAPU32 = new Uint32Array(a);
          b.HEAPF32 = new Float32Array(a);
          b.HEAPF64 = new Float64Array(a);
        }
        var R2, ja = [], ka = [], la = [];
        function ma() {
          var a = b.preRun.shift();
          ja.unshift(a);
        }
        var S = 0, T = null, U = null;
        b.preloadedImages = {};
        b.preloadedAudios = {};
        function K(a) {
          if (b.onAbort)
            b.onAbort(a);
          I(a);
          M = true;
          a = new WebAssembly.RuntimeError("abort(" + a + "). Build with -s ASSERTIONS=1 for more info.");
          r(a);
          throw a;
        }
        var V = "data:application/octet-stream;base64,", W2;
        W2 = "data:application/octet-stream;base64,AGFzbQEAAAABIAZgAX8Bf2ADf39/AGABfwBgAABgAAF/YAZ/f39/f38AAgcBAWEBYQAAAwsKAAEDAQAAAgQFAgQFAXABAQEFBwEBgAKAgAIGCQF/AUGAjMACCwclCQFiAgABYwADAWQACQFlAAgBZgAHAWcABgFoAAUBaQAKAWoBAAqGTQpPAQJ/QYAIKAIAIgEgAEEDakF8cSICaiEAAkAgAkEAIAAgAU0bDQAgAD8AQRB0SwRAIAAQAEUNAQtBgAggADYCACABDwtBhAhBMDYCAEF/C4wFAg5+Cn8gACgCJCEUIAAoAiAhFSAAKAIcIREgACgCGCESIAAoAhQhEyACQRBPBEAgAC0ATEVBGHQhFyAAKAIEIhZBBWytIQ8gACgCCCIYQQVsrSENIAAoAgwiGUEFbK0hCyAAKAIQIhpBBWytIQkgADUCACEIIBqtIRAgGa0hDiAYrSEMIBatIQoDQCASIAEtAAMiEiABLQAEQQh0ciABLQAFQRB0ciABLQAGIhZBGHRyQQJ2Qf///x9xaq0iAyAOfiABLwAAIAEtAAJBEHRyIBNqIBJBGHRBgICAGHFqrSIEIBB+fCARIAEtAAdBCHQgFnIgAS0ACEEQdHIgAS0ACSIRQRh0ckEEdkH///8fcWqtIgUgDH58IAEtAApBCHQgEXIgAS0AC0EQdHIgAS0ADEEYdHJBBnYgFWqtIgYgCn58IBQgF2ogAS8ADSABLQAPQRB0cmqtIgcgCH58IAMgDH4gBCAOfnwgBSAKfnwgBiAIfnwgByAJfnwgAyAKfiAEIAx+fCAFIAh+fCAGIAl+fCAHIAt+fCADIAh+IAQgCn58IAUgCX58IAYgC358IAcgDX58IAMgCX4gBCAIfnwgBSALfnwgBiANfnwgByAPfnwiA0IaiEL/////D4N8IgRCGohC/////w+DfCIFQhqIQv////8Pg3wiBkIaiEL/////D4N8IgdCGoinQQVsIAOnQf///x9xaiITQRp2IASnQf///x9xaiESIAWnQf///x9xIREgBqdB////H3EhFSAHp0H///8fcSEUIBNB////H3EhEyABQRBqIQEgAkEQayICQQ9LDQALCyAAIBQ2AiQgACAVNgIgIAAgETYCHCAAIBI2AhggACATNgIUCwMAAQu2BAEGfwJAIAAoAjgiBARAIABBPGohBQJAIAJBECAEayIDIAIgA0kbIgZFDQAgBkEDcSEHAkAgBkEBa0EDSQRAQQAhAwwBCyAGQXxxIQhBACEDA0AgBSADIARqaiABIANqLQAAOgAAIAUgA0EBciIEIAAoAjhqaiABIARqLQAAOgAAIAUgA0ECciIEIAAoAjhqaiABIARqLQAAOgAAIAUgA0EDciIEIAAoAjhqaiABIARqLQAAOgAAIANBBGohAyAAKAI4IQQgCEEEayIIDQALCyAHRQ0AA0AgBSADIARqaiABIANqLQAAOgAAIANBAWohAyAAKAI4IQQgB0EBayIHDQALCyAAIAQgBmoiAzYCOCADQRBJDQEgACAFQRAQAiAAQQA2AjggAiAGayECIAEgBmohAQsgAkEQTwRAIAAgASACQXBxIgMQAiACQQ9xIQIgASADaiEBCyACRQ0AIAJBA3EhBCAAQTxqIQVBACEDIAJBAWtBA08EQCACQXxxIQcDQCAFIAAoAjggA2pqIAEgA2otAAA6AAAgBSADQQFyIgYgACgCOGpqIAEgBmotAAA6AAAgBSADQQJyIgYgACgCOGpqIAEgBmotAAA6AAAgBSADQQNyIgYgACgCOGpqIAEgBmotAAA6AAAgA0EEaiEDIAdBBGsiBw0ACwsgBARAA0AgBSAAKAI4IANqaiABIANqLQAAOgAAIANBAWohAyAEQQFrIgQNAAsLIAAgACgCOCACajYCOAsLoS0BDH8jAEEQayIMJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEH0AU0EQEGICCgCACIFQRAgAEELakF4cSAAQQtJGyIIQQN2IgJ2IgFBA3EEQCABQX9zQQFxIAJqIgNBA3QiAUG4CGooAgAiBEEIaiEAAkAgBCgCCCICIAFBsAhqIgFGBEBBiAggBUF+IAN3cTYCAAwBCyACIAE2AgwgASACNgIICyAEIANBA3QiAUEDcjYCBCABIARqIgEgASgCBEEBcjYCBAwNCyAIQZAIKAIAIgpNDQEgAQRAAkBBAiACdCIAQQAgAGtyIAEgAnRxIgBBACAAa3FBAWsiACAAQQx2QRBxIgJ2IgFBBXZBCHEiACACciABIAB2IgFBAnZBBHEiAHIgASAAdiIBQQF2QQJxIgByIAEgAHYiAUEBdkEBcSIAciABIAB2aiIDQQN0IgBBuAhqKAIAIgQoAggiASAAQbAIaiIARgRAQYgIIAVBfiADd3EiBTYCAAwBCyABIAA2AgwgACABNgIICyAEQQhqIQAgBCAIQQNyNgIEIAQgCGoiAiADQQN0IgEgCGsiA0EBcjYCBCABIARqIAM2AgAgCgRAIApBA3YiAUEDdEGwCGohB0GcCCgCACEEAn8gBUEBIAF0IgFxRQRAQYgIIAEgBXI2AgAgBwwBCyAHKAIICyEBIAcgBDYCCCABIAQ2AgwgBCAHNgIMIAQgATYCCAtBnAggAjYCAEGQCCADNgIADA0LQYwIKAIAIgZFDQEgBkEAIAZrcUEBayIAIABBDHZBEHEiAnYiAUEFdkEIcSIAIAJyIAEgAHYiAUECdkEEcSIAciABIAB2IgFBAXZBAnEiAHIgASAAdiIBQQF2QQFxIgByIAEgAHZqQQJ0QbgKaigCACIBKAIEQXhxIAhrIQMgASECA0ACQCACKAIQIgBFBEAgAigCFCIARQ0BCyAAKAIEQXhxIAhrIgIgAyACIANJIgIbIQMgACABIAIbIQEgACECDAELCyABIAhqIgkgAU0NAiABKAIYIQsgASABKAIMIgRHBEAgASgCCCIAQZgIKAIASRogACAENgIMIAQgADYCCAwMCyABQRRqIgIoAgAiAEUEQCABKAIQIgBFDQQgAUEQaiECCwNAIAIhByAAIgRBFGoiAigCACIADQAgBEEQaiECIAQoAhAiAA0ACyAHQQA2AgAMCwtBfyEIIABBv39LDQAgAEELaiIAQXhxIQhBjAgoAgAiCUUNAEEAIAhrIQMCQAJAAkACf0EAIAhBgAJJDQAaQR8gCEH///8HSw0AGiAAQQh2IgAgAEGA/j9qQRB2QQhxIgJ0IgAgAEGA4B9qQRB2QQRxIgF0IgAgAEGAgA9qQRB2QQJxIgB0QQ92IAEgAnIgAHJrIgBBAXQgCCAAQRVqdkEBcXJBHGoLIgVBAnRBuApqKAIAIgJFBEBBACEADAELQQAhACAIQQBBGSAFQQF2ayAFQR9GG3QhAQNAAkAgAigCBEF4cSAIayIHIANPDQAgAiEEIAciAw0AQQAhAyACIQAMAwsgACACKAIUIgcgByACIAFBHXZBBHFqKAIQIgJGGyAAIAcbIQAgAUEBdCEBIAINAAsLIAAgBHJFBEBBACEEQQIgBXQiAEEAIABrciAJcSIARQ0DIABBACAAa3FBAWsiACAAQQx2QRBxIgJ2IgFBBXZBCHEiACACciABIAB2IgFBAnZBBHEiAHIgASAAdiIBQQF2QQJxIgByIAEgAHYiAUEBdkEBcSIAciABIAB2akECdEG4CmooAgAhAAsgAEUNAQsDQCAAKAIEQXhxIAhrIgEgA0khAiABIAMgAhshAyAAIAQgAhshBCAAKAIQIgEEfyABBSAAKAIUCyIADQALCyAERQ0AIANBkAgoAgAgCGtPDQAgBCAIaiIGIARNDQEgBCgCGCEFIAQgBCgCDCIBRwRAIAQoAggiAEGYCCgCAEkaIAAgATYCDCABIAA2AggMCgsgBEEUaiICKAIAIgBFBEAgBCgCECIARQ0EIARBEGohAgsDQCACIQcgACIBQRRqIgIoAgAiAA0AIAFBEGohAiABKAIQIgANAAsgB0EANgIADAkLIAhBkAgoAgAiAk0EQEGcCCgCACEDAkAgAiAIayIBQRBPBEBBkAggATYCAEGcCCADIAhqIgA2AgAgACABQQFyNgIEIAIgA2ogATYCACADIAhBA3I2AgQMAQtBnAhBADYCAEGQCEEANgIAIAMgAkEDcjYCBCACIANqIgAgACgCBEEBcjYCBAsgA0EIaiEADAsLIAhBlAgoAgAiBkkEQEGUCCAGIAhrIgE2AgBBoAhBoAgoAgAiAiAIaiIANgIAIAAgAUEBcjYCBCACIAhBA3I2AgQgAkEIaiEADAsLQQAhACAIQS9qIgkCf0HgCygCAARAQegLKAIADAELQewLQn83AgBB5AtCgKCAgICABDcCAEHgCyAMQQxqQXBxQdiq1aoFczYCAEH0C0EANgIAQcQLQQA2AgBBgCALIgFqIgVBACABayIHcSICIAhNDQpBwAsoAgAiBARAQbgLKAIAIgMgAmoiASADTQ0LIAEgBEsNCwtBxAstAABBBHENBQJAAkBBoAgoAgAiAwRAQcgLIQADQCADIAAoAgAiAU8EQCABIAAoAgRqIANLDQMLIAAoAggiAA0ACwtBABABIgFBf0YNBiACIQVB5AsoAgAiA0EBayIAIAFxBEAgAiABayAAIAFqQQAgA2txaiEFCyAFIAhNDQYgBUH+////B0sNBkHACygCACIEBEBBuAsoAgAiAyAFaiIAIANNDQcgACAESw0HCyAFEAEiACABRw0BDAgLIAUgBmsgB3EiBUH+////B0sNBSAFEAEiASAAKAIAIAAoAgRqRg0EIAEhAAsCQCAAQX9GDQAgCEEwaiAFTQ0AQegLKAIAIgEgCSAFa2pBACABa3EiAUH+////B0sEQCAAIQEMCAsgARABQX9HBEAgASAFaiEFIAAhAQwIC0EAIAVrEAEaDAULIAAiAUF/Rw0GDAQLAAtBACEEDAcLQQAhAQwFCyABQX9HDQILQcQLQcQLKAIAQQRyNgIACyACQf7///8HSw0BIAIQASEBQQAQASEAIAFBf0YNASAAQX9GDQEgACABTQ0BIAAgAWsiBSAIQShqTQ0BC0G4C0G4CygCACAFaiIANgIAQbwLKAIAIABJBEBBvAsgADYCAAsCQAJAAkBBoAgoAgAiBwRAQcgLIQADQCABIAAoAgAiAyAAKAIEIgJqRg0CIAAoAggiAA0ACwwCC0GYCCgCACIAQQAgACABTRtFBEBBmAggATYCAAtBACEAQcwLIAU2AgBByAsgATYCAEGoCEF/NgIAQawIQeALKAIANgIAQdQLQQA2AgADQCAAQQN0IgNBuAhqIANBsAhqIgI2AgAgA0G8CGogAjYCACAAQQFqIgBBIEcNAAtBlAggBUEoayIDQXggAWtBB3FBACABQQhqQQdxGyIAayICNgIAQaAIIAAgAWoiADYCACAAIAJBAXI2AgQgASADakEoNgIEQaQIQfALKAIANgIADAILIAAtAAxBCHENACADIAdLDQAgASAHTQ0AIAAgAiAFajYCBEGgCCAHQXggB2tBB3FBACAHQQhqQQdxGyIAaiICNgIAQZQIQZQIKAIAIAVqIgEgAGsiADYCACACIABBAXI2AgQgASAHakEoNgIEQaQIQfALKAIANgIADAELQZgIKAIAIAFLBEBBmAggATYCAAsgASAFaiECQcgLIQACQAJAAkACQAJAAkADQCACIAAoAgBHBEAgACgCCCIADQEMAgsLIAAtAAxBCHFFDQELQcgLIQADQCAHIAAoAgAiAk8EQCACIAAoAgRqIgQgB0sNAwsgACgCCCEADAALAAsgACABNgIAIAAgACgCBCAFajYCBCABQXggAWtBB3FBACABQQhqQQdxG2oiCSAIQQNyNgIEIAJBeCACa0EHcUEAIAJBCGpBB3EbaiIFIAggCWoiBmshAiAFIAdGBEBBoAggBjYCAEGUCEGUCCgCACACaiIANgIAIAYgAEEBcjYCBAwDCyAFQZwIKAIARgRAQZwIIAY2AgBBkAhBkAgoAgAgAmoiADYCACAGIABBAXI2AgQgACAGaiAANgIADAMLIAUoAgQiAEEDcUEBRgRAIABBeHEhBwJAIABB/wFNBEAgBSgCCCIDIABBA3YiAEEDdEGwCGpGGiADIAUoAgwiAUYEQEGICEGICCgCAEF+IAB3cTYCAAwCCyADIAE2AgwgASADNgIIDAELIAUoAhghCAJAIAUgBSgCDCIBRwRAIAUoAggiACABNgIMIAEgADYCCAwBCwJAIAVBFGoiACgCACIDDQAgBUEQaiIAKAIAIgMNAEEAIQEMAQsDQCAAIQQgAyIBQRRqIgAoAgAiAw0AIAFBEGohACABKAIQIgMNAAsgBEEANgIACyAIRQ0AAkAgBSAFKAIcIgNBAnRBuApqIgAoAgBGBEAgACABNgIAIAENAUGMCEGMCCgCAEF+IAN3cTYCAAwCCyAIQRBBFCAIKAIQIAVGG2ogATYCACABRQ0BCyABIAg2AhggBSgCECIABEAgASAANgIQIAAgATYCGAsgBSgCFCIARQ0AIAEgADYCFCAAIAE2AhgLIAUgB2ohBSACIAdqIQILIAUgBSgCBEF+cTYCBCAGIAJBAXI2AgQgAiAGaiACNgIAIAJB/wFNBEAgAkEDdiIAQQN0QbAIaiECAn9BiAgoAgAiAUEBIAB0IgBxRQRAQYgIIAAgAXI2AgAgAgwBCyACKAIICyEAIAIgBjYCCCAAIAY2AgwgBiACNgIMIAYgADYCCAwDC0EfIQAgAkH///8HTQRAIAJBCHYiACAAQYD+P2pBEHZBCHEiA3QiACAAQYDgH2pBEHZBBHEiAXQiACAAQYCAD2pBEHZBAnEiAHRBD3YgASADciAAcmsiAEEBdCACIABBFWp2QQFxckEcaiEACyAGIAA2AhwgBkIANwIQIABBAnRBuApqIQQCQEGMCCgCACIDQQEgAHQiAXFFBEBBjAggASADcjYCACAEIAY2AgAgBiAENgIYDAELIAJBAEEZIABBAXZrIABBH0YbdCEAIAQoAgAhAQNAIAEiAygCBEF4cSACRg0DIABBHXYhASAAQQF0IQAgAyABQQRxaiIEKAIQIgENAAsgBCAGNgIQIAYgAzYCGAsgBiAGNgIMIAYgBjYCCAwCC0GUCCAFQShrIgNBeCABa0EHcUEAIAFBCGpBB3EbIgBrIgI2AgBBoAggACABaiIANgIAIAAgAkEBcjYCBCABIANqQSg2AgRBpAhB8AsoAgA2AgAgByAEQScgBGtBB3FBACAEQSdrQQdxG2pBL2siACAAIAdBEGpJGyICQRs2AgQgAkHQCykCADcCECACQcgLKQIANwIIQdALIAJBCGo2AgBBzAsgBTYCAEHICyABNgIAQdQLQQA2AgAgAkEYaiEAA0AgAEEHNgIEIABBCGohASAAQQRqIQAgASAESQ0ACyACIAdGDQMgAiACKAIEQX5xNgIEIAcgAiAHayIEQQFyNgIEIAIgBDYCACAEQf8BTQRAIARBA3YiAEEDdEGwCGohAgJ/QYgIKAIAIgFBASAAdCIAcUUEQEGICCAAIAFyNgIAIAIMAQsgAigCCAshACACIAc2AgggACAHNgIMIAcgAjYCDCAHIAA2AggMBAtBHyEAIAdCADcCECAEQf///wdNBEAgBEEIdiIAIABBgP4/akEQdkEIcSICdCIAIABBgOAfakEQdkEEcSIBdCIAIABBgIAPakEQdkECcSIAdEEPdiABIAJyIAByayIAQQF0IAQgAEEVanZBAXFyQRxqIQALIAcgADYCHCAAQQJ0QbgKaiEDAkBBjAgoAgAiAkEBIAB0IgFxRQRAQYwIIAEgAnI2AgAgAyAHNgIAIAcgAzYCGAwBCyAEQQBBGSAAQQF2ayAAQR9GG3QhACADKAIAIQEDQCABIgIoAgRBeHEgBEYNBCAAQR12IQEgAEEBdCEAIAIgAUEEcWoiAygCECIBDQALIAMgBzYCECAHIAI2AhgLIAcgBzYCDCAHIAc2AggMAwsgAygCCCIAIAY2AgwgAyAGNgIIIAZBADYCGCAGIAM2AgwgBiAANgIICyAJQQhqIQAMBQsgAigCCCIAIAc2AgwgAiAHNgIIIAdBADYCGCAHIAI2AgwgByAANgIIC0GUCCgCACIAIAhNDQBBlAggACAIayIBNgIAQaAIQaAIKAIAIgIgCGoiADYCACAAIAFBAXI2AgQgAiAIQQNyNgIEIAJBCGohAAwDC0GECEEwNgIAQQAhAAwCCwJAIAVFDQACQCAEKAIcIgJBAnRBuApqIgAoAgAgBEYEQCAAIAE2AgAgAQ0BQYwIIAlBfiACd3EiCTYCAAwCCyAFQRBBFCAFKAIQIARGG2ogATYCACABRQ0BCyABIAU2AhggBCgCECIABEAgASAANgIQIAAgATYCGAsgBCgCFCIARQ0AIAEgADYCFCAAIAE2AhgLAkAgA0EPTQRAIAQgAyAIaiIAQQNyNgIEIAAgBGoiACAAKAIEQQFyNgIEDAELIAQgCEEDcjYCBCAGIANBAXI2AgQgAyAGaiADNgIAIANB/wFNBEAgA0EDdiIAQQN0QbAIaiECAn9BiAgoAgAiAUEBIAB0IgBxRQRAQYgIIAAgAXI2AgAgAgwBCyACKAIICyEAIAIgBjYCCCAAIAY2AgwgBiACNgIMIAYgADYCCAwBC0EfIQAgA0H///8HTQRAIANBCHYiACAAQYD+P2pBEHZBCHEiAnQiACAAQYDgH2pBEHZBBHEiAXQiACAAQYCAD2pBEHZBAnEiAHRBD3YgASACciAAcmsiAEEBdCADIABBFWp2QQFxckEcaiEACyAGIAA2AhwgBkIANwIQIABBAnRBuApqIQICQAJAIAlBASAAdCIBcUUEQEGMCCABIAlyNgIAIAIgBjYCACAGIAI2AhgMAQsgA0EAQRkgAEEBdmsgAEEfRht0IQAgAigCACEIA0AgCCIBKAIEQXhxIANGDQIgAEEddiECIABBAXQhACABIAJBBHFqIgIoAhAiCA0ACyACIAY2AhAgBiABNgIYCyAGIAY2AgwgBiAGNgIIDAELIAEoAggiACAGNgIMIAEgBjYCCCAGQQA2AhggBiABNgIMIAYgADYCCAsgBEEIaiEADAELAkAgC0UNAAJAIAEoAhwiAkECdEG4CmoiACgCACABRgRAIAAgBDYCACAEDQFBjAggBkF+IAJ3cTYCAAwCCyALQRBBFCALKAIQIAFGG2ogBDYCACAERQ0BCyAEIAs2AhggASgCECIABEAgBCAANgIQIAAgBDYCGAsgASgCFCIARQ0AIAQgADYCFCAAIAQ2AhgLAkAgA0EPTQRAIAEgAyAIaiIAQQNyNgIEIAAgAWoiACAAKAIEQQFyNgIEDAELIAEgCEEDcjYCBCAJIANBAXI2AgQgAyAJaiADNgIAIAoEQCAKQQN2IgBBA3RBsAhqIQRBnAgoAgAhAgJ/QQEgAHQiACAFcUUEQEGICCAAIAVyNgIAIAQMAQsgBCgCCAshACAEIAI2AgggACACNgIMIAIgBDYCDCACIAA2AggLQZwIIAk2AgBBkAggAzYCAAsgAUEIaiEACyAMQRBqJAAgAAsQACMAIABrQXBxIgAkACAACwYAIAAkAAsEACMAC4AJAgh/BH4jAEGQAWsiBiQAIAYgBS0AA0EYdEGAgIAYcSAFLwAAIAUtAAJBEHRycjYCACAGIAUoAANBAnZBg/7/H3E2AgQgBiAFKAAGQQR2Qf+B/x9xNgIIIAYgBSgACUEGdkH//8AfcTYCDCAFLwANIQggBS0ADyEJIAZCADcCFCAGQgA3AhwgBkEANgIkIAYgCCAJQRB0QYCAPHFyNgIQIAYgBSgAEDYCKCAGIAUoABQ2AiwgBiAFKAAYNgIwIAUoABwhBSAGQQA6AEwgBkEANgI4IAYgBTYCNCAGIAEgAhAEIAQEQCAGIAMgBBAECyAGKAI4IgEEQCAGQTxqIgIgAWpBAToAACABQQFqQQ9NBEAgASAGakE9aiEEAkBBDyABayIDRQ0AIAMgBGoiAUEBa0EAOgAAIARBADoAACADQQNJDQAgAUECa0EAOgAAIARBADoAASABQQNrQQA6AAAgBEEAOgACIANBB0kNACABQQRrQQA6AAAgBEEAOgADIANBCUkNACAEQQAgBGtBA3EiAWoiBEEANgIAIAQgAyABa0F8cSIBaiIDQQRrQQA2AgAgAUEJSQ0AIARBADYCCCAEQQA2AgQgA0EIa0EANgIAIANBDGtBADYCACABQRlJDQAgBEEANgIYIARBADYCFCAEQQA2AhAgBEEANgIMIANBEGtBADYCACADQRRrQQA2AgAgA0EYa0EANgIAIANBHGtBADYCACABIARBBHFBGHIiAWsiA0EgSQ0AIAEgBGohAQNAIAFCADcDGCABQgA3AxAgAUIANwMIIAFCADcDACABQSBqIQEgA0EgayIDQR9LDQALCwsgBkEBOgBMIAYgAkEQEAILIAY1AjQhECAGNQIwIREgBjUCLCEOIAAgBjUCKCAGKAIkIAYoAiAgBigCHCAGKAIYIgNBGnZqIgJBGnZqIgFBGnZqIgtBgICAYHIgAUH///8fcSINIAJB////H3EiCCAGKAIUIAtBGnZBBWxqIgFB////H3EiCUEFaiIFQRp2IANB////H3EgAUEadmoiA2oiAUEadmoiAkEadmoiBEEadmoiDEEfdSIHIANxIAEgDEEfdkEBayIDQf///x9xIgpxciIBQRp0IAUgCnEgByAJcXJyrXwiDzwAACAAIA9CGIg8AAMgACAPQhCIPAACIAAgD0IIiDwAASAAIA4gByAIcSACIApxciICQRR0IAFBBnZyrXwgD0IgiHwiDjwABCAAIA5CGIg8AAcgACAOQhCIPAAGIAAgDkIIiDwABSAAIBEgByANcSAEIApxciIBQQ50IAJBDHZyrXwgDkIgiHwiDjwACCAAIA5CGIg8AAsgACAOQhCIPAAKIAAgDkIIiDwACSAAIBAgAyAMcSAHIAtxckEIdCABQRJ2cq18IA5CIIh8Ig48AAwgACAOQhiIPAAPIAAgDkIQiDwADiAAIA5CCIg8AA0gBkIANwIwIAZCADcCKCAGQgA3AiAgBkIANwIYIAZCADcCECAGQgA3AgggBkIANwIAIAZBkAFqJAALpwwBB38CQCAARQ0AIABBCGsiAyAAQQRrKAIAIgFBeHEiAGohBQJAIAFBAXENACABQQNxRQ0BIAMgAygCACIBayIDQZgIKAIASQ0BIAAgAWohACADQZwIKAIARwRAIAFB/wFNBEAgAygCCCICIAFBA3YiBEEDdEGwCGpGGiACIAMoAgwiAUYEQEGICEGICCgCAEF+IAR3cTYCAAwDCyACIAE2AgwgASACNgIIDAILIAMoAhghBgJAIAMgAygCDCIBRwRAIAMoAggiAiABNgIMIAEgAjYCCAwBCwJAIANBFGoiAigCACIEDQAgA0EQaiICKAIAIgQNAEEAIQEMAQsDQCACIQcgBCIBQRRqIgIoAgAiBA0AIAFBEGohAiABKAIQIgQNAAsgB0EANgIACyAGRQ0BAkAgAyADKAIcIgJBAnRBuApqIgQoAgBGBEAgBCABNgIAIAENAUGMCEGMCCgCAEF+IAJ3cTYCAAwDCyAGQRBBFCAGKAIQIANGG2ogATYCACABRQ0CCyABIAY2AhggAygCECICBEAgASACNgIQIAIgATYCGAsgAygCFCICRQ0BIAEgAjYCFCACIAE2AhgMAQsgBSgCBCIBQQNxQQNHDQBBkAggADYCACAFIAFBfnE2AgQgAyAAQQFyNgIEIAAgA2ogADYCAA8LIAMgBU8NACAFKAIEIgFBAXFFDQACQCABQQJxRQRAIAVBoAgoAgBGBEBBoAggAzYCAEGUCEGUCCgCACAAaiIANgIAIAMgAEEBcjYCBCADQZwIKAIARw0DQZAIQQA2AgBBnAhBADYCAA8LIAVBnAgoAgBGBEBBnAggAzYCAEGQCEGQCCgCACAAaiIANgIAIAMgAEEBcjYCBCAAIANqIAA2AgAPCyABQXhxIABqIQACQCABQf8BTQRAIAUoAggiAiABQQN2IgRBA3RBsAhqRhogAiAFKAIMIgFGBEBBiAhBiAgoAgBBfiAEd3E2AgAMAgsgAiABNgIMIAEgAjYCCAwBCyAFKAIYIQYCQCAFIAUoAgwiAUcEQCAFKAIIIgJBmAgoAgBJGiACIAE2AgwgASACNgIIDAELAkAgBUEUaiICKAIAIgQNACAFQRBqIgIoAgAiBA0AQQAhAQwBCwNAIAIhByAEIgFBFGoiAigCACIEDQAgAUEQaiECIAEoAhAiBA0ACyAHQQA2AgALIAZFDQACQCAFIAUoAhwiAkECdEG4CmoiBCgCAEYEQCAEIAE2AgAgAQ0BQYwIQYwIKAIAQX4gAndxNgIADAILIAZBEEEUIAYoAhAgBUYbaiABNgIAIAFFDQELIAEgBjYCGCAFKAIQIgIEQCABIAI2AhAgAiABNgIYCyAFKAIUIgJFDQAgASACNgIUIAIgATYCGAsgAyAAQQFyNgIEIAAgA2ogADYCACADQZwIKAIARw0BQZAIIAA2AgAPCyAFIAFBfnE2AgQgAyAAQQFyNgIEIAAgA2ogADYCAAsgAEH/AU0EQCAAQQN2IgFBA3RBsAhqIQACf0GICCgCACICQQEgAXQiAXFFBEBBiAggASACcjYCACAADAELIAAoAggLIQIgACADNgIIIAIgAzYCDCADIAA2AgwgAyACNgIIDwtBHyECIANCADcCECAAQf///wdNBEAgAEEIdiIBIAFBgP4/akEQdkEIcSIBdCICIAJBgOAfakEQdkEEcSICdCIEIARBgIAPakEQdkECcSIEdEEPdiABIAJyIARyayIBQQF0IAAgAUEVanZBAXFyQRxqIQILIAMgAjYCHCACQQJ0QbgKaiEBAkACQAJAQYwIKAIAIgRBASACdCIHcUUEQEGMCCAEIAdyNgIAIAEgAzYCACADIAE2AhgMAQsgAEEAQRkgAkEBdmsgAkEfRht0IQIgASgCACEBA0AgASIEKAIEQXhxIABGDQIgAkEddiEBIAJBAXQhAiAEIAFBBHFqIgdBEGooAgAiAQ0ACyAHIAM2AhAgAyAENgIYCyADIAM2AgwgAyADNgIIDAELIAQoAggiACADNgIMIAQgAzYCCCADQQA2AhggAyAENgIMIAMgADYCCAtBqAhBqAgoAgBBAWsiAEF/IAAbNgIACwsLCQEAQYEICwIGUA==";
        if (!W2.startsWith(V)) {
          var na = W2;
          W2 = b.locateFile ? b.locateFile(na, B) : B + na;
        }
        function pa() {
          var a = W2;
          try {
            if (a == W2 && J)
              return new Uint8Array(J);
            var c = H(a);
            if (c)
              return c;
            if (E)
              return E(a);
            throw "both async and sync fetching of the wasm failed";
          } catch (d) {
            K(d);
          }
        }
        function qa() {
          if (!J && (x || y)) {
            if ("function" === typeof fetch && !W2.startsWith("file://"))
              return fetch(W2, { credentials: "same-origin" }).then(function(a) {
                if (!a.ok)
                  throw "failed to load wasm binary file at '" + W2 + "'";
                return a.arrayBuffer();
              }).catch(function() {
                return pa();
              });
            if (D)
              return new Promise(function(a, c) {
                D(W2, function(d) {
                  a(new Uint8Array(d));
                }, c);
              });
          }
          return Promise.resolve().then(function() {
            return pa();
          });
        }
        function X(a) {
          for (; 0 < a.length; ) {
            var c = a.shift();
            if ("function" == typeof c)
              c(b);
            else {
              var d = c.m;
              "number" === typeof d ? void 0 === c.l ? R2.get(d)() : R2.get(d)(c.l) : d(void 0 === c.l ? null : c.l);
            }
          }
        }
        var ba = false, ra = "function" === typeof atob ? atob : function(a) {
          var c = "", d = 0;
          a = a.replace(/[^A-Za-z0-9\+\/=]/g, "");
          do {
            var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(d++));
            var f = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(d++));
            var l = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(d++));
            var A2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(d++));
            e = e << 2 | f >> 4;
            f = (f & 15) << 4 | l >> 2;
            var t = (l & 3) << 6 | A2;
            c += String.fromCharCode(e);
            64 !== l && (c += String.fromCharCode(f));
            64 !== A2 && (c += String.fromCharCode(t));
          } while (d < a.length);
          return c;
        };
        function H(a) {
          if (a.startsWith(V)) {
            a = a.slice(V.length);
            if ("boolean" === typeof z && z) {
              var c = Buffer.from(a, "base64");
              c = new Uint8Array(c.buffer, c.byteOffset, c.byteLength);
            } else
              try {
                var d = ra(a), e = new Uint8Array(d.length);
                for (a = 0; a < d.length; ++a)
                  e[a] = d.charCodeAt(a);
                c = e;
              } catch (f) {
                throw Error("Converting base64 string to bytes failed.");
              }
            return c;
          }
        }
        var sa = { a: function(a) {
          var c = P2.length;
          a >>>= 0;
          if (2147483648 < a)
            return false;
          for (var d = 1; 4 >= d; d *= 2) {
            var e = c * (1 + 0.2 / d);
            e = Math.min(e, a + 100663296);
            e = Math.max(a, e);
            0 < e % 65536 && (e += 65536 - e % 65536);
            a: {
              try {
                L.grow(Math.min(2147483648, e) - ha.byteLength + 65535 >>> 16);
                ia();
                var f = 1;
                break a;
              } catch (l) {
              }
              f = void 0;
            }
            if (f)
              return true;
          }
          return false;
        } };
        (function() {
          function a(f) {
            b.asm = f.exports;
            L = b.asm.b;
            ia();
            R2 = b.asm.j;
            ka.unshift(b.asm.c);
            S--;
            b.monitorRunDependencies && b.monitorRunDependencies(S);
            0 == S && (null !== T && (clearInterval(T), T = null), U && (f = U, U = null, f()));
          }
          function c(f) {
            a(f.instance);
          }
          function d(f) {
            return qa().then(function(l) {
              return WebAssembly.instantiate(l, e);
            }).then(f, function(l) {
              I("failed to asynchronously prepare wasm: " + l);
              K(l);
            });
          }
          var e = { a: sa };
          S++;
          b.monitorRunDependencies && b.monitorRunDependencies(S);
          if (b.instantiateWasm)
            try {
              return b.instantiateWasm(
                e,
                a
              );
            } catch (f) {
              return I("Module.instantiateWasm callback failed with error: " + f), false;
            }
          (function() {
            return J || "function" !== typeof WebAssembly.instantiateStreaming || W2.startsWith(V) || W2.startsWith("file://") || "function" !== typeof fetch ? d(c) : fetch(W2, { credentials: "same-origin" }).then(function(f) {
              return WebAssembly.instantiateStreaming(f, e).then(c, function(l) {
                I("wasm streaming compile failed: " + l);
                I("falling back to ArrayBuffer instantiation");
                return d(c);
              });
            });
          })().catch(r);
          return {};
        })();
        b.___wasm_call_ctors = function() {
          return (b.___wasm_call_ctors = b.asm.c).apply(null, arguments);
        };
        b._poly1305_auth = function() {
          return (b._poly1305_auth = b.asm.d).apply(null, arguments);
        };
        var da = b.stackSave = function() {
          return (da = b.stackSave = b.asm.e).apply(null, arguments);
        }, fa = b.stackRestore = function() {
          return (fa = b.stackRestore = b.asm.f).apply(null, arguments);
        }, O = b.stackAlloc = function() {
          return (O = b.stackAlloc = b.asm.g).apply(null, arguments);
        };
        b._malloc = function() {
          return (b._malloc = b.asm.h).apply(null, arguments);
        };
        b._free = function() {
          return (b._free = b.asm.i).apply(null, arguments);
        };
        b.cwrap = function(a, c, d, e) {
          d = d || [];
          var f = d.every(function(l) {
            return "number" === l;
          });
          return "string" !== c && f && !e ? N(a) : function() {
            return ca(a, c, d, arguments);
          };
        };
        var Y;
        U = function ta() {
          Y || Z();
          Y || (U = ta);
        };
        function Z() {
          function a() {
            if (!Y && (Y = true, b.calledRun = true, !M)) {
              X(ka);
              q(b);
              if (b.onRuntimeInitialized)
                b.onRuntimeInitialized();
              if (b.postRun)
                for ("function" == typeof b.postRun && (b.postRun = [b.postRun]); b.postRun.length; ) {
                  var c = b.postRun.shift();
                  la.unshift(c);
                }
              X(la);
            }
          }
          if (!(0 < S)) {
            if (b.preRun)
              for ("function" == typeof b.preRun && (b.preRun = [b.preRun]); b.preRun.length; )
                ma();
            X(ja);
            0 < S || (b.setStatus ? (b.setStatus("Running..."), setTimeout(function() {
              setTimeout(function() {
                b.setStatus("");
              }, 1);
              a();
            }, 1)) : a());
          }
        }
        b.run = Z;
        if (b.preInit)
          for ("function" == typeof b.preInit && (b.preInit = [b.preInit]); 0 < b.preInit.length; )
            b.preInit.pop()();
        Z();
        return createPoly13052.ready;
      };
    }();
    if (typeof exports === "object" && typeof module === "object")
      module.exports = createPoly1305;
    else if (typeof define === "function" && define["amd"])
      define([], function() {
        return createPoly1305;
      });
    else if (typeof exports === "object")
      exports["createPoly1305"] = createPoly1305;
  }
});

// node_modules/ssh2/lib/protocol/crypto.js
var require_crypto = __commonJS({
  "node_modules/ssh2/lib/protocol/crypto.js"(exports, module) {
    "use strict";
    var {
      createCipheriv,
      createDecipheriv,
      createHmac,
      randomFillSync,
      timingSafeEqual
    } = __require("crypto");
    var { readUInt32BE, writeUInt32BE } = require_utils7();
    var FastBuffer = Buffer[Symbol.species];
    var MAX_SEQNO = 2 ** 32 - 1;
    var EMPTY_BUFFER = Buffer.alloc(0);
    var BUF_INT = Buffer.alloc(4);
    var DISCARD_CACHE = /* @__PURE__ */ new Map();
    var MAX_PACKET_SIZE = 35e3;
    var binding;
    var AESGCMCipher;
    var ChaChaPolyCipher;
    var GenericCipher;
    var AESGCMDecipher;
    var ChaChaPolyDecipher;
    var GenericDecipher;
    try {
      binding = require_sshcrypto();
      ({
        AESGCMCipher,
        ChaChaPolyCipher,
        GenericCipher,
        AESGCMDecipher,
        ChaChaPolyDecipher,
        GenericDecipher
      } = binding);
    } catch {
    }
    var CIPHER_STREAM = 1 << 0;
    var CIPHER_INFO = (() => {
      function info4(sslName, blockLen, keyLen, ivLen, authLen, discardLen, flags) {
        return {
          sslName,
          blockLen,
          keyLen,
          ivLen: ivLen !== 0 || flags & CIPHER_STREAM ? ivLen : blockLen,
          authLen,
          discardLen,
          stream: !!(flags & CIPHER_STREAM)
        };
      }
      return {
        "chacha20-poly1305@openssh.com": info4("chacha20", 8, 64, 0, 16, 0, CIPHER_STREAM),
        "aes128-gcm": info4("aes-128-gcm", 16, 16, 12, 16, 0, CIPHER_STREAM),
        "aes256-gcm": info4("aes-256-gcm", 16, 32, 12, 16, 0, CIPHER_STREAM),
        "aes128-gcm@openssh.com": info4("aes-128-gcm", 16, 16, 12, 16, 0, CIPHER_STREAM),
        "aes256-gcm@openssh.com": info4("aes-256-gcm", 16, 32, 12, 16, 0, CIPHER_STREAM),
        "aes128-cbc": info4("aes-128-cbc", 16, 16, 0, 0, 0, 0),
        "aes192-cbc": info4("aes-192-cbc", 16, 24, 0, 0, 0, 0),
        "aes256-cbc": info4("aes-256-cbc", 16, 32, 0, 0, 0, 0),
        "rijndael-cbc@lysator.liu.se": info4("aes-256-cbc", 16, 32, 0, 0, 0, 0),
        "3des-cbc": info4("des-ede3-cbc", 8, 24, 0, 0, 0, 0),
        "blowfish-cbc": info4("bf-cbc", 8, 16, 0, 0, 0, 0),
        "idea-cbc": info4("idea-cbc", 8, 16, 0, 0, 0, 0),
        "cast128-cbc": info4("cast-cbc", 8, 16, 0, 0, 0, 0),
        "aes128-ctr": info4("aes-128-ctr", 16, 16, 16, 0, 0, CIPHER_STREAM),
        "aes192-ctr": info4("aes-192-ctr", 16, 24, 16, 0, 0, CIPHER_STREAM),
        "aes256-ctr": info4("aes-256-ctr", 16, 32, 16, 0, 0, CIPHER_STREAM),
        "3des-ctr": info4("des-ede3", 8, 24, 8, 0, 0, CIPHER_STREAM),
        "blowfish-ctr": info4("bf-ecb", 8, 16, 8, 0, 0, CIPHER_STREAM),
        "cast128-ctr": info4("cast5-ecb", 8, 16, 8, 0, 0, CIPHER_STREAM),
        /* The "arcfour128" algorithm is the RC4 cipher, as described in
               [SCHNEIER], using a 128-bit key.  The first 1536 bytes of keystream
               generated by the cipher MUST be discarded, and the first byte of the
               first encrypted packet MUST be encrypted using the 1537th byte of
               keystream.
        
               -- http://tools.ietf.org/html/rfc4345#section-4 */
        "arcfour": info4("rc4", 8, 16, 0, 0, 1536, CIPHER_STREAM),
        "arcfour128": info4("rc4", 8, 16, 0, 0, 1536, CIPHER_STREAM),
        "arcfour256": info4("rc4", 8, 32, 0, 0, 1536, CIPHER_STREAM),
        "arcfour512": info4("rc4", 8, 64, 0, 0, 1536, CIPHER_STREAM)
      };
    })();
    var MAC_INFO = (() => {
      function info4(sslName, len, actualLen, isETM) {
        return {
          sslName,
          len,
          actualLen,
          isETM
        };
      }
      return {
        "hmac-md5": info4("md5", 16, 16, false),
        "hmac-md5-96": info4("md5", 16, 12, false),
        "hmac-ripemd160": info4("ripemd160", 20, 20, false),
        "hmac-sha1": info4("sha1", 20, 20, false),
        "hmac-sha1-etm@openssh.com": info4("sha1", 20, 20, true),
        "hmac-sha1-96": info4("sha1", 20, 12, false),
        "hmac-sha2-256": info4("sha256", 32, 32, false),
        "hmac-sha2-256-etm@openssh.com": info4("sha256", 32, 32, true),
        "hmac-sha2-256-96": info4("sha256", 32, 12, false),
        "hmac-sha2-512": info4("sha512", 64, 64, false),
        "hmac-sha2-512-etm@openssh.com": info4("sha512", 64, 64, true),
        "hmac-sha2-512-96": info4("sha512", 64, 12, false)
      };
    })();
    var NullCipher = class {
      constructor(seqno, onWrite) {
        this.outSeqno = seqno;
        this._onWrite = onWrite;
        this._dead = false;
      }
      free() {
        this._dead = true;
      }
      allocPacket(payloadLen) {
        let pktLen = 4 + 1 + payloadLen;
        let padLen = 8 - (pktLen & 8 - 1);
        if (padLen < 4)
          padLen += 8;
        pktLen += padLen;
        const packet = Buffer.allocUnsafe(pktLen);
        writeUInt32BE(packet, pktLen - 4, 0);
        packet[4] = padLen;
        randomFillSync(packet, 5 + payloadLen, padLen);
        return packet;
      }
      encrypt(packet) {
        if (this._dead)
          return;
        this._onWrite(packet);
        this.outSeqno = this.outSeqno + 1 >>> 0;
      }
    };
    var POLY1305_ZEROS = Buffer.alloc(32);
    var POLY1305_OUT_COMPUTE = Buffer.alloc(16);
    var POLY1305_WASM_MODULE;
    var POLY1305_RESULT_MALLOC;
    var poly1305_auth;
    var ChaChaPolyCipherNative = class {
      constructor(config) {
        const enc = config.outbound;
        this.outSeqno = enc.seqno;
        this._onWrite = enc.onWrite;
        this._encKeyMain = enc.cipherKey.slice(0, 32);
        this._encKeyPktLen = enc.cipherKey.slice(32);
        this._dead = false;
      }
      free() {
        this._dead = true;
      }
      allocPacket(payloadLen) {
        let pktLen = 4 + 1 + payloadLen;
        let padLen = 8 - (pktLen - 4 & 8 - 1);
        if (padLen < 4)
          padLen += 8;
        pktLen += padLen;
        const packet = Buffer.allocUnsafe(pktLen);
        writeUInt32BE(packet, pktLen - 4, 0);
        packet[4] = padLen;
        randomFillSync(packet, 5 + payloadLen, padLen);
        return packet;
      }
      encrypt(packet) {
        if (this._dead)
          return;
        POLY1305_OUT_COMPUTE[0] = 0;
        writeUInt32BE(POLY1305_OUT_COMPUTE, this.outSeqno, 12);
        const polyKey = createCipheriv("chacha20", this._encKeyMain, POLY1305_OUT_COMPUTE).update(POLY1305_ZEROS);
        const pktLenEnc = createCipheriv("chacha20", this._encKeyPktLen, POLY1305_OUT_COMPUTE).update(packet.slice(0, 4));
        this._onWrite(pktLenEnc);
        POLY1305_OUT_COMPUTE[0] = 1;
        const payloadEnc = createCipheriv("chacha20", this._encKeyMain, POLY1305_OUT_COMPUTE).update(packet.slice(4));
        this._onWrite(payloadEnc);
        poly1305_auth(
          POLY1305_RESULT_MALLOC,
          pktLenEnc,
          pktLenEnc.length,
          payloadEnc,
          payloadEnc.length,
          polyKey
        );
        const mac = Buffer.allocUnsafe(16);
        mac.set(
          new Uint8Array(
            POLY1305_WASM_MODULE.HEAPU8.buffer,
            POLY1305_RESULT_MALLOC,
            16
          ),
          0
        );
        this._onWrite(mac);
        this.outSeqno = this.outSeqno + 1 >>> 0;
      }
    };
    var ChaChaPolyCipherBinding = class {
      constructor(config) {
        const enc = config.outbound;
        this.outSeqno = enc.seqno;
        this._onWrite = enc.onWrite;
        this._instance = new ChaChaPolyCipher(enc.cipherKey);
        this._dead = false;
      }
      free() {
        this._dead = true;
        this._instance.free();
      }
      allocPacket(payloadLen) {
        let pktLen = 4 + 1 + payloadLen;
        let padLen = 8 - (pktLen - 4 & 8 - 1);
        if (padLen < 4)
          padLen += 8;
        pktLen += padLen;
        const packet = Buffer.allocUnsafe(
          pktLen + 16
          /* MAC */
        );
        writeUInt32BE(packet, pktLen - 4, 0);
        packet[4] = padLen;
        randomFillSync(packet, 5 + payloadLen, padLen);
        return packet;
      }
      encrypt(packet) {
        if (this._dead)
          return;
        this._instance.encrypt(packet, this.outSeqno);
        this._onWrite(packet);
        this.outSeqno = this.outSeqno + 1 >>> 0;
      }
    };
    var AESGCMCipherNative = class {
      constructor(config) {
        const enc = config.outbound;
        this.outSeqno = enc.seqno;
        this._onWrite = enc.onWrite;
        this._encSSLName = enc.cipherInfo.sslName;
        this._encKey = enc.cipherKey;
        this._encIV = enc.cipherIV;
        this._dead = false;
      }
      free() {
        this._dead = true;
      }
      allocPacket(payloadLen) {
        let pktLen = 4 + 1 + payloadLen;
        let padLen = 16 - (pktLen - 4 & 16 - 1);
        if (padLen < 4)
          padLen += 16;
        pktLen += padLen;
        const packet = Buffer.allocUnsafe(pktLen);
        writeUInt32BE(packet, pktLen - 4, 0);
        packet[4] = padLen;
        randomFillSync(packet, 5 + payloadLen, padLen);
        return packet;
      }
      encrypt(packet) {
        if (this._dead)
          return;
        const cipher = createCipheriv(this._encSSLName, this._encKey, this._encIV);
        cipher.setAutoPadding(false);
        const lenData = packet.slice(0, 4);
        cipher.setAAD(lenData);
        this._onWrite(lenData);
        const encrypted = cipher.update(packet.slice(4));
        this._onWrite(encrypted);
        const final = cipher.final();
        if (final.length)
          this._onWrite(final);
        const tag = cipher.getAuthTag();
        this._onWrite(tag);
        ivIncrement(this._encIV);
        this.outSeqno = this.outSeqno + 1 >>> 0;
      }
    };
    var AESGCMCipherBinding = class {
      constructor(config) {
        const enc = config.outbound;
        this.outSeqno = enc.seqno;
        this._onWrite = enc.onWrite;
        this._instance = new AESGCMCipher(
          enc.cipherInfo.sslName,
          enc.cipherKey,
          enc.cipherIV
        );
        this._dead = false;
      }
      free() {
        this._dead = true;
        this._instance.free();
      }
      allocPacket(payloadLen) {
        let pktLen = 4 + 1 + payloadLen;
        let padLen = 16 - (pktLen - 4 & 16 - 1);
        if (padLen < 4)
          padLen += 16;
        pktLen += padLen;
        const packet = Buffer.allocUnsafe(
          pktLen + 16
          /* authTag */
        );
        writeUInt32BE(packet, pktLen - 4, 0);
        packet[4] = padLen;
        randomFillSync(packet, 5 + payloadLen, padLen);
        return packet;
      }
      encrypt(packet) {
        if (this._dead)
          return;
        this._instance.encrypt(packet);
        this._onWrite(packet);
        this.outSeqno = this.outSeqno + 1 >>> 0;
      }
    };
    var GenericCipherNative = class {
      constructor(config) {
        const enc = config.outbound;
        this.outSeqno = enc.seqno;
        this._onWrite = enc.onWrite;
        this._encBlockLen = enc.cipherInfo.blockLen;
        this._cipherInstance = createCipheriv(
          enc.cipherInfo.sslName,
          enc.cipherKey,
          enc.cipherIV
        );
        this._macSSLName = enc.macInfo.sslName;
        this._macKey = enc.macKey;
        this._macActualLen = enc.macInfo.actualLen;
        this._macETM = enc.macInfo.isETM;
        this._aadLen = this._macETM ? 4 : 0;
        this._dead = false;
        const discardLen = enc.cipherInfo.discardLen;
        if (discardLen) {
          let discard39 = DISCARD_CACHE.get(discardLen);
          if (discard39 === void 0) {
            discard39 = Buffer.alloc(discardLen);
            DISCARD_CACHE.set(discardLen, discard39);
          }
          this._cipherInstance.update(discard39);
        }
      }
      free() {
        this._dead = true;
      }
      allocPacket(payloadLen) {
        const blockLen = this._encBlockLen;
        let pktLen = 4 + 1 + payloadLen;
        let padLen = blockLen - (pktLen - this._aadLen & blockLen - 1);
        if (padLen < 4)
          padLen += blockLen;
        pktLen += padLen;
        const packet = Buffer.allocUnsafe(pktLen);
        writeUInt32BE(packet, pktLen - 4, 0);
        packet[4] = padLen;
        randomFillSync(packet, 5 + payloadLen, padLen);
        return packet;
      }
      encrypt(packet) {
        if (this._dead)
          return;
        let mac;
        if (this._macETM) {
          const lenBytes = new Uint8Array(packet.buffer, packet.byteOffset, 4);
          const encrypted = this._cipherInstance.update(
            new Uint8Array(
              packet.buffer,
              packet.byteOffset + 4,
              packet.length - 4
            )
          );
          this._onWrite(lenBytes);
          this._onWrite(encrypted);
          mac = createHmac(this._macSSLName, this._macKey);
          writeUInt32BE(BUF_INT, this.outSeqno, 0);
          mac.update(BUF_INT);
          mac.update(lenBytes);
          mac.update(encrypted);
        } else {
          const encrypted = this._cipherInstance.update(packet);
          this._onWrite(encrypted);
          mac = createHmac(this._macSSLName, this._macKey);
          writeUInt32BE(BUF_INT, this.outSeqno, 0);
          mac.update(BUF_INT);
          mac.update(packet);
        }
        let digest = mac.digest();
        if (digest.length > this._macActualLen)
          digest = digest.slice(0, this._macActualLen);
        this._onWrite(digest);
        this.outSeqno = this.outSeqno + 1 >>> 0;
      }
    };
    var GenericCipherBinding = class {
      constructor(config) {
        const enc = config.outbound;
        this.outSeqno = enc.seqno;
        this._onWrite = enc.onWrite;
        this._encBlockLen = enc.cipherInfo.blockLen;
        this._macLen = enc.macInfo.len;
        this._macActualLen = enc.macInfo.actualLen;
        this._aadLen = enc.macInfo.isETM ? 4 : 0;
        this._instance = new GenericCipher(
          enc.cipherInfo.sslName,
          enc.cipherKey,
          enc.cipherIV,
          enc.macInfo.sslName,
          enc.macKey,
          enc.macInfo.isETM
        );
        this._dead = false;
      }
      free() {
        this._dead = true;
        this._instance.free();
      }
      allocPacket(payloadLen) {
        const blockLen = this._encBlockLen;
        let pktLen = 4 + 1 + payloadLen;
        let padLen = blockLen - (pktLen - this._aadLen & blockLen - 1);
        if (padLen < 4)
          padLen += blockLen;
        pktLen += padLen;
        const packet = Buffer.allocUnsafe(pktLen + this._macLen);
        writeUInt32BE(packet, pktLen - 4, 0);
        packet[4] = padLen;
        randomFillSync(packet, 5 + payloadLen, padLen);
        return packet;
      }
      encrypt(packet) {
        if (this._dead)
          return;
        this._instance.encrypt(packet, this.outSeqno);
        if (this._macActualLen < this._macLen) {
          packet = new FastBuffer(
            packet.buffer,
            packet.byteOffset,
            packet.length - (this._macLen - this._macActualLen)
          );
        }
        this._onWrite(packet);
        this.outSeqno = this.outSeqno + 1 >>> 0;
      }
    };
    var NullDecipher = class {
      constructor(seqno, onPayload) {
        this.inSeqno = seqno;
        this._onPayload = onPayload;
        this._len = 0;
        this._lenBytes = 0;
        this._packet = null;
        this._packetPos = 0;
      }
      free() {
      }
      decrypt(data, p, dataLen) {
        while (p < dataLen) {
          if (this._lenBytes < 4) {
            let nb = Math.min(4 - this._lenBytes, dataLen - p);
            this._lenBytes += nb;
            while (nb--)
              this._len = (this._len << 8) + data[p++];
            if (this._lenBytes < 4)
              return;
            if (this._len > MAX_PACKET_SIZE || this._len < 8 || (4 + this._len & 7) !== 0) {
              throw new Error("Bad packet length");
            }
            if (p >= dataLen)
              return;
          }
          if (this._packetPos < this._len) {
            const nb = Math.min(this._len - this._packetPos, dataLen - p);
            let chunk;
            if (p !== 0 || nb !== dataLen)
              chunk = new Uint8Array(data.buffer, data.byteOffset + p, nb);
            else
              chunk = data;
            if (nb === this._len) {
              this._packet = chunk;
            } else {
              if (!this._packet)
                this._packet = Buffer.allocUnsafe(this._len);
              this._packet.set(chunk, this._packetPos);
            }
            p += nb;
            this._packetPos += nb;
            if (this._packetPos < this._len)
              return;
          }
          const payload = !this._packet ? EMPTY_BUFFER : new FastBuffer(
            this._packet.buffer,
            this._packet.byteOffset + 1,
            this._packet.length - this._packet[0] - 1
          );
          this.inSeqno = this.inSeqno + 1 >>> 0;
          this._len = 0;
          this._lenBytes = 0;
          this._packet = null;
          this._packetPos = 0;
          {
            const ret = this._onPayload(payload);
            if (ret !== void 0)
              return ret === false ? p : ret;
          }
        }
      }
    };
    var ChaChaPolyDecipherNative = class {
      constructor(config) {
        const dec = config.inbound;
        this.inSeqno = dec.seqno;
        this._onPayload = dec.onPayload;
        this._decKeyMain = dec.decipherKey.slice(0, 32);
        this._decKeyPktLen = dec.decipherKey.slice(32);
        this._len = 0;
        this._lenBuf = Buffer.alloc(4);
        this._lenPos = 0;
        this._packet = null;
        this._pktLen = 0;
        this._mac = Buffer.allocUnsafe(16);
        this._calcMac = Buffer.allocUnsafe(16);
        this._macPos = 0;
      }
      free() {
      }
      decrypt(data, p, dataLen) {
        while (p < dataLen) {
          if (this._lenPos < 4) {
            let nb = Math.min(4 - this._lenPos, dataLen - p);
            while (nb--)
              this._lenBuf[this._lenPos++] = data[p++];
            if (this._lenPos < 4)
              return;
            POLY1305_OUT_COMPUTE[0] = 0;
            writeUInt32BE(POLY1305_OUT_COMPUTE, this.inSeqno, 12);
            const decLenBytes = createDecipheriv("chacha20", this._decKeyPktLen, POLY1305_OUT_COMPUTE).update(this._lenBuf);
            this._len = readUInt32BE(decLenBytes, 0);
            if (this._len > MAX_PACKET_SIZE || this._len < 8 || (this._len & 7) !== 0) {
              throw new Error("Bad packet length");
            }
          }
          if (this._pktLen < this._len) {
            if (p >= dataLen)
              return;
            const nb = Math.min(this._len - this._pktLen, dataLen - p);
            let encrypted;
            if (p !== 0 || nb !== dataLen)
              encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);
            else
              encrypted = data;
            if (nb === this._len) {
              this._packet = encrypted;
            } else {
              if (!this._packet)
                this._packet = Buffer.allocUnsafe(this._len);
              this._packet.set(encrypted, this._pktLen);
            }
            p += nb;
            this._pktLen += nb;
            if (this._pktLen < this._len || p >= dataLen)
              return;
          }
          {
            const nb = Math.min(16 - this._macPos, dataLen - p);
            if (p !== 0 || nb !== dataLen) {
              this._mac.set(
                new Uint8Array(data.buffer, data.byteOffset + p, nb),
                this._macPos
              );
            } else {
              this._mac.set(data, this._macPos);
            }
            p += nb;
            this._macPos += nb;
            if (this._macPos < 16)
              return;
          }
          POLY1305_OUT_COMPUTE[0] = 0;
          writeUInt32BE(POLY1305_OUT_COMPUTE, this.inSeqno, 12);
          const polyKey = createCipheriv("chacha20", this._decKeyMain, POLY1305_OUT_COMPUTE).update(POLY1305_ZEROS);
          poly1305_auth(
            POLY1305_RESULT_MALLOC,
            this._lenBuf,
            4,
            this._packet,
            this._packet.length,
            polyKey
          );
          this._calcMac.set(
            new Uint8Array(
              POLY1305_WASM_MODULE.HEAPU8.buffer,
              POLY1305_RESULT_MALLOC,
              16
            ),
            0
          );
          if (!timingSafeEqual(this._calcMac, this._mac))
            throw new Error("Invalid MAC");
          POLY1305_OUT_COMPUTE[0] = 1;
          const packet = createDecipheriv("chacha20", this._decKeyMain, POLY1305_OUT_COMPUTE).update(this._packet);
          const payload = new FastBuffer(
            packet.buffer,
            packet.byteOffset + 1,
            packet.length - packet[0] - 1
          );
          this.inSeqno = this.inSeqno + 1 >>> 0;
          this._len = 0;
          this._lenPos = 0;
          this._packet = null;
          this._pktLen = 0;
          this._macPos = 0;
          {
            const ret = this._onPayload(payload);
            if (ret !== void 0)
              return ret === false ? p : ret;
          }
        }
      }
    };
    var ChaChaPolyDecipherBinding = class {
      constructor(config) {
        const dec = config.inbound;
        this.inSeqno = dec.seqno;
        this._onPayload = dec.onPayload;
        this._instance = new ChaChaPolyDecipher(dec.decipherKey);
        this._len = 0;
        this._lenBuf = Buffer.alloc(4);
        this._lenPos = 0;
        this._packet = null;
        this._pktLen = 0;
        this._mac = Buffer.allocUnsafe(16);
        this._macPos = 0;
      }
      free() {
        this._instance.free();
      }
      decrypt(data, p, dataLen) {
        while (p < dataLen) {
          if (this._lenPos < 4) {
            let nb = Math.min(4 - this._lenPos, dataLen - p);
            while (nb--)
              this._lenBuf[this._lenPos++] = data[p++];
            if (this._lenPos < 4)
              return;
            this._len = this._instance.decryptLen(this._lenBuf, this.inSeqno);
            if (this._len > MAX_PACKET_SIZE || this._len < 8 || (this._len & 7) !== 0) {
              throw new Error("Bad packet length");
            }
            if (p >= dataLen)
              return;
          }
          if (this._pktLen < this._len) {
            const nb = Math.min(this._len - this._pktLen, dataLen - p);
            let encrypted;
            if (p !== 0 || nb !== dataLen)
              encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);
            else
              encrypted = data;
            if (nb === this._len) {
              this._packet = encrypted;
            } else {
              if (!this._packet)
                this._packet = Buffer.allocUnsafe(this._len);
              this._packet.set(encrypted, this._pktLen);
            }
            p += nb;
            this._pktLen += nb;
            if (this._pktLen < this._len || p >= dataLen)
              return;
          }
          {
            const nb = Math.min(16 - this._macPos, dataLen - p);
            if (p !== 0 || nb !== dataLen) {
              this._mac.set(
                new Uint8Array(data.buffer, data.byteOffset + p, nb),
                this._macPos
              );
            } else {
              this._mac.set(data, this._macPos);
            }
            p += nb;
            this._macPos += nb;
            if (this._macPos < 16)
              return;
          }
          this._instance.decrypt(this._packet, this._mac, this.inSeqno);
          const payload = new FastBuffer(
            this._packet.buffer,
            this._packet.byteOffset + 1,
            this._packet.length - this._packet[0] - 1
          );
          this.inSeqno = this.inSeqno + 1 >>> 0;
          this._len = 0;
          this._lenPos = 0;
          this._packet = null;
          this._pktLen = 0;
          this._macPos = 0;
          {
            const ret = this._onPayload(payload);
            if (ret !== void 0)
              return ret === false ? p : ret;
          }
        }
      }
    };
    var AESGCMDecipherNative = class {
      constructor(config) {
        const dec = config.inbound;
        this.inSeqno = dec.seqno;
        this._onPayload = dec.onPayload;
        this._decipherInstance = null;
        this._decipherSSLName = dec.decipherInfo.sslName;
        this._decipherKey = dec.decipherKey;
        this._decipherIV = dec.decipherIV;
        this._len = 0;
        this._lenBytes = 0;
        this._packet = null;
        this._packetPos = 0;
        this._pktLen = 0;
        this._tag = Buffer.allocUnsafe(16);
        this._tagPos = 0;
      }
      free() {
      }
      decrypt(data, p, dataLen) {
        while (p < dataLen) {
          if (this._lenBytes < 4) {
            let nb = Math.min(4 - this._lenBytes, dataLen - p);
            this._lenBytes += nb;
            while (nb--)
              this._len = (this._len << 8) + data[p++];
            if (this._lenBytes < 4)
              return;
            if (this._len + 20 > MAX_PACKET_SIZE || this._len < 16 || (this._len & 15) !== 0) {
              throw new Error("Bad packet length");
            }
            this._decipherInstance = createDecipheriv(
              this._decipherSSLName,
              this._decipherKey,
              this._decipherIV
            );
            this._decipherInstance.setAutoPadding(false);
            this._decipherInstance.setAAD(intToBytes(this._len));
          }
          if (this._pktLen < this._len) {
            if (p >= dataLen)
              return;
            const nb = Math.min(this._len - this._pktLen, dataLen - p);
            let decrypted;
            if (p !== 0 || nb !== dataLen) {
              decrypted = this._decipherInstance.update(
                new Uint8Array(data.buffer, data.byteOffset + p, nb)
              );
            } else {
              decrypted = this._decipherInstance.update(data);
            }
            if (decrypted.length) {
              if (nb === this._len) {
                this._packet = decrypted;
              } else {
                if (!this._packet)
                  this._packet = Buffer.allocUnsafe(this._len);
                this._packet.set(decrypted, this._packetPos);
              }
              this._packetPos += decrypted.length;
            }
            p += nb;
            this._pktLen += nb;
            if (this._pktLen < this._len || p >= dataLen)
              return;
          }
          {
            const nb = Math.min(16 - this._tagPos, dataLen - p);
            if (p !== 0 || nb !== dataLen) {
              this._tag.set(
                new Uint8Array(data.buffer, data.byteOffset + p, nb),
                this._tagPos
              );
            } else {
              this._tag.set(data, this._tagPos);
            }
            p += nb;
            this._tagPos += nb;
            if (this._tagPos < 16)
              return;
          }
          {
            this._decipherInstance.setAuthTag(this._tag);
            const decrypted = this._decipherInstance.final();
            if (decrypted.length) {
              if (this._packet)
                this._packet.set(decrypted, this._packetPos);
              else
                this._packet = decrypted;
            }
          }
          const payload = !this._packet ? EMPTY_BUFFER : new FastBuffer(
            this._packet.buffer,
            this._packet.byteOffset + 1,
            this._packet.length - this._packet[0] - 1
          );
          this.inSeqno = this.inSeqno + 1 >>> 0;
          ivIncrement(this._decipherIV);
          this._len = 0;
          this._lenBytes = 0;
          this._packet = null;
          this._packetPos = 0;
          this._pktLen = 0;
          this._tagPos = 0;
          {
            const ret = this._onPayload(payload);
            if (ret !== void 0)
              return ret === false ? p : ret;
          }
        }
      }
    };
    var AESGCMDecipherBinding = class {
      constructor(config) {
        const dec = config.inbound;
        this.inSeqno = dec.seqno;
        this._onPayload = dec.onPayload;
        this._instance = new AESGCMDecipher(
          dec.decipherInfo.sslName,
          dec.decipherKey,
          dec.decipherIV
        );
        this._len = 0;
        this._lenBytes = 0;
        this._packet = null;
        this._pktLen = 0;
        this._tag = Buffer.allocUnsafe(16);
        this._tagPos = 0;
      }
      free() {
      }
      decrypt(data, p, dataLen) {
        while (p < dataLen) {
          if (this._lenBytes < 4) {
            let nb = Math.min(4 - this._lenBytes, dataLen - p);
            this._lenBytes += nb;
            while (nb--)
              this._len = (this._len << 8) + data[p++];
            if (this._lenBytes < 4)
              return;
            if (this._len + 20 > MAX_PACKET_SIZE || this._len < 16 || (this._len & 15) !== 0) {
              throw new Error(`Bad packet length: ${this._len}`);
            }
          }
          if (this._pktLen < this._len) {
            if (p >= dataLen)
              return;
            const nb = Math.min(this._len - this._pktLen, dataLen - p);
            let encrypted;
            if (p !== 0 || nb !== dataLen)
              encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);
            else
              encrypted = data;
            if (nb === this._len) {
              this._packet = encrypted;
            } else {
              if (!this._packet)
                this._packet = Buffer.allocUnsafe(this._len);
              this._packet.set(encrypted, this._pktLen);
            }
            p += nb;
            this._pktLen += nb;
            if (this._pktLen < this._len || p >= dataLen)
              return;
          }
          {
            const nb = Math.min(16 - this._tagPos, dataLen - p);
            if (p !== 0 || nb !== dataLen) {
              this._tag.set(
                new Uint8Array(data.buffer, data.byteOffset + p, nb),
                this._tagPos
              );
            } else {
              this._tag.set(data, this._tagPos);
            }
            p += nb;
            this._tagPos += nb;
            if (this._tagPos < 16)
              return;
          }
          this._instance.decrypt(this._packet, this._len, this._tag);
          const payload = new FastBuffer(
            this._packet.buffer,
            this._packet.byteOffset + 1,
            this._packet.length - this._packet[0] - 1
          );
          this.inSeqno = this.inSeqno + 1 >>> 0;
          this._len = 0;
          this._lenBytes = 0;
          this._packet = null;
          this._pktLen = 0;
          this._tagPos = 0;
          {
            const ret = this._onPayload(payload);
            if (ret !== void 0)
              return ret === false ? p : ret;
          }
        }
      }
    };
    var GenericDecipherNative = class {
      constructor(config) {
        const dec = config.inbound;
        this.inSeqno = dec.seqno;
        this._onPayload = dec.onPayload;
        this._decipherInstance = createDecipheriv(
          dec.decipherInfo.sslName,
          dec.decipherKey,
          dec.decipherIV
        );
        this._decipherInstance.setAutoPadding(false);
        this._block = Buffer.allocUnsafe(
          dec.macInfo.isETM ? 4 : dec.decipherInfo.blockLen
        );
        this._blockSize = dec.decipherInfo.blockLen;
        this._blockPos = 0;
        this._len = 0;
        this._packet = null;
        this._packetPos = 0;
        this._pktLen = 0;
        this._mac = Buffer.allocUnsafe(dec.macInfo.actualLen);
        this._macPos = 0;
        this._macSSLName = dec.macInfo.sslName;
        this._macKey = dec.macKey;
        this._macActualLen = dec.macInfo.actualLen;
        this._macETM = dec.macInfo.isETM;
        this._macInstance = null;
        const discardLen = dec.decipherInfo.discardLen;
        if (discardLen) {
          let discard39 = DISCARD_CACHE.get(discardLen);
          if (discard39 === void 0) {
            discard39 = Buffer.alloc(discardLen);
            DISCARD_CACHE.set(discardLen, discard39);
          }
          this._decipherInstance.update(discard39);
        }
      }
      free() {
      }
      decrypt(data, p, dataLen) {
        while (p < dataLen) {
          if (this._blockPos < this._block.length) {
            const nb = Math.min(this._block.length - this._blockPos, dataLen - p);
            if (p !== 0 || nb !== dataLen || nb < data.length) {
              this._block.set(
                new Uint8Array(data.buffer, data.byteOffset + p, nb),
                this._blockPos
              );
            } else {
              this._block.set(data, this._blockPos);
            }
            p += nb;
            this._blockPos += nb;
            if (this._blockPos < this._block.length)
              return;
            let decrypted;
            let need;
            if (this._macETM) {
              this._len = need = readUInt32BE(this._block, 0);
            } else {
              decrypted = this._decipherInstance.update(this._block);
              this._len = readUInt32BE(decrypted, 0);
              need = 4 + this._len - this._blockSize;
            }
            if (this._len > MAX_PACKET_SIZE || this._len < 5 || (need & this._blockSize - 1) !== 0) {
              throw new Error("Bad packet length");
            }
            this._macInstance = createHmac(this._macSSLName, this._macKey);
            writeUInt32BE(BUF_INT, this.inSeqno, 0);
            this._macInstance.update(BUF_INT);
            if (this._macETM) {
              this._macInstance.update(this._block);
            } else {
              this._macInstance.update(new Uint8Array(
                decrypted.buffer,
                decrypted.byteOffset,
                4
              ));
              this._pktLen = decrypted.length - 4;
              this._packetPos = this._pktLen;
              this._packet = Buffer.allocUnsafe(this._len);
              this._packet.set(
                new Uint8Array(
                  decrypted.buffer,
                  decrypted.byteOffset + 4,
                  this._packetPos
                ),
                0
              );
            }
            if (p >= dataLen)
              return;
          }
          if (this._pktLen < this._len) {
            const nb = Math.min(this._len - this._pktLen, dataLen - p);
            let encrypted;
            if (p !== 0 || nb !== dataLen)
              encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);
            else
              encrypted = data;
            if (this._macETM)
              this._macInstance.update(encrypted);
            const decrypted = this._decipherInstance.update(encrypted);
            if (decrypted.length) {
              if (nb === this._len) {
                this._packet = decrypted;
              } else {
                if (!this._packet)
                  this._packet = Buffer.allocUnsafe(this._len);
                this._packet.set(decrypted, this._packetPos);
              }
              this._packetPos += decrypted.length;
            }
            p += nb;
            this._pktLen += nb;
            if (this._pktLen < this._len || p >= dataLen)
              return;
          }
          {
            const nb = Math.min(this._macActualLen - this._macPos, dataLen - p);
            if (p !== 0 || nb !== dataLen) {
              this._mac.set(
                new Uint8Array(data.buffer, data.byteOffset + p, nb),
                this._macPos
              );
            } else {
              this._mac.set(data, this._macPos);
            }
            p += nb;
            this._macPos += nb;
            if (this._macPos < this._macActualLen)
              return;
          }
          if (!this._macETM)
            this._macInstance.update(this._packet);
          let calculated = this._macInstance.digest();
          if (this._macActualLen < calculated.length) {
            calculated = new Uint8Array(
              calculated.buffer,
              calculated.byteOffset,
              this._macActualLen
            );
          }
          if (!timingSafeEquals(calculated, this._mac))
            throw new Error("Invalid MAC");
          const payload = new FastBuffer(
            this._packet.buffer,
            this._packet.byteOffset + 1,
            this._packet.length - this._packet[0] - 1
          );
          this.inSeqno = this.inSeqno + 1 >>> 0;
          this._blockPos = 0;
          this._len = 0;
          this._packet = null;
          this._packetPos = 0;
          this._pktLen = 0;
          this._macPos = 0;
          this._macInstance = null;
          {
            const ret = this._onPayload(payload);
            if (ret !== void 0)
              return ret === false ? p : ret;
          }
        }
      }
    };
    var GenericDecipherBinding = class {
      constructor(config) {
        const dec = config.inbound;
        this.inSeqno = dec.seqno;
        this._onPayload = dec.onPayload;
        this._instance = new GenericDecipher(
          dec.decipherInfo.sslName,
          dec.decipherKey,
          dec.decipherIV,
          dec.macInfo.sslName,
          dec.macKey,
          dec.macInfo.isETM,
          dec.macInfo.actualLen
        );
        this._block = Buffer.allocUnsafe(
          dec.macInfo.isETM || dec.decipherInfo.stream ? 4 : dec.decipherInfo.blockLen
        );
        this._blockPos = 0;
        this._len = 0;
        this._packet = null;
        this._pktLen = 0;
        this._mac = Buffer.allocUnsafe(dec.macInfo.actualLen);
        this._macPos = 0;
        this._macActualLen = dec.macInfo.actualLen;
        this._macETM = dec.macInfo.isETM;
      }
      free() {
        this._instance.free();
      }
      decrypt(data, p, dataLen) {
        while (p < dataLen) {
          if (this._blockPos < this._block.length) {
            const nb = Math.min(this._block.length - this._blockPos, dataLen - p);
            if (p !== 0 || nb !== dataLen || nb < data.length) {
              this._block.set(
                new Uint8Array(data.buffer, data.byteOffset + p, nb),
                this._blockPos
              );
            } else {
              this._block.set(data, this._blockPos);
            }
            p += nb;
            this._blockPos += nb;
            if (this._blockPos < this._block.length)
              return;
            let need;
            if (this._macETM) {
              this._len = need = readUInt32BE(this._block, 0);
            } else {
              this._instance.decryptBlock(this._block);
              this._len = readUInt32BE(this._block, 0);
              need = 4 + this._len - this._block.length;
            }
            if (this._len > MAX_PACKET_SIZE || this._len < 5 || (need & this._block.length - 1) !== 0) {
              throw new Error("Bad packet length");
            }
            if (!this._macETM) {
              this._pktLen = this._block.length - 4;
              if (this._pktLen) {
                this._packet = Buffer.allocUnsafe(this._len);
                this._packet.set(
                  new Uint8Array(
                    this._block.buffer,
                    this._block.byteOffset + 4,
                    this._pktLen
                  ),
                  0
                );
              }
            }
            if (p >= dataLen)
              return;
          }
          if (this._pktLen < this._len) {
            const nb = Math.min(this._len - this._pktLen, dataLen - p);
            let encrypted;
            if (p !== 0 || nb !== dataLen)
              encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);
            else
              encrypted = data;
            if (nb === this._len) {
              this._packet = encrypted;
            } else {
              if (!this._packet)
                this._packet = Buffer.allocUnsafe(this._len);
              this._packet.set(encrypted, this._pktLen);
            }
            p += nb;
            this._pktLen += nb;
            if (this._pktLen < this._len || p >= dataLen)
              return;
          }
          {
            const nb = Math.min(this._macActualLen - this._macPos, dataLen - p);
            if (p !== 0 || nb !== dataLen) {
              this._mac.set(
                new Uint8Array(data.buffer, data.byteOffset + p, nb),
                this._macPos
              );
            } else {
              this._mac.set(data, this._macPos);
            }
            p += nb;
            this._macPos += nb;
            if (this._macPos < this._macActualLen)
              return;
          }
          this._instance.decrypt(
            this._packet,
            this.inSeqno,
            this._block,
            this._mac
          );
          const payload = new FastBuffer(
            this._packet.buffer,
            this._packet.byteOffset + 1,
            this._packet.length - this._packet[0] - 1
          );
          this.inSeqno = this.inSeqno + 1 >>> 0;
          this._blockPos = 0;
          this._len = 0;
          this._packet = null;
          this._pktLen = 0;
          this._macPos = 0;
          this._macInstance = null;
          {
            const ret = this._onPayload(payload);
            if (ret !== void 0)
              return ret === false ? p : ret;
          }
        }
      }
    };
    function ivIncrement(iv) {
      ++iv[11] >>> 8 && ++iv[10] >>> 8 && ++iv[9] >>> 8 && ++iv[8] >>> 8 && ++iv[7] >>> 8 && ++iv[6] >>> 8 && ++iv[5] >>> 8 && ++iv[4] >>> 8;
    }
    var intToBytes = (() => {
      const ret = Buffer.alloc(4);
      return (n) => {
        ret[0] = n >>> 24;
        ret[1] = n >>> 16;
        ret[2] = n >>> 8;
        ret[3] = n;
        return ret;
      };
    })();
    function timingSafeEquals(a, b) {
      if (a.length !== b.length) {
        timingSafeEqual(a, a);
        return false;
      }
      return timingSafeEqual(a, b);
    }
    function createCipher(config) {
      if (typeof config !== "object" || config === null)
        throw new Error("Invalid config");
      if (typeof config.outbound !== "object" || config.outbound === null)
        throw new Error("Invalid outbound");
      const outbound = config.outbound;
      if (typeof outbound.onWrite !== "function")
        throw new Error("Invalid outbound.onWrite");
      if (typeof outbound.cipherInfo !== "object" || outbound.cipherInfo === null)
        throw new Error("Invalid outbound.cipherInfo");
      if (!Buffer.isBuffer(outbound.cipherKey) || outbound.cipherKey.length !== outbound.cipherInfo.keyLen) {
        throw new Error("Invalid outbound.cipherKey");
      }
      if (outbound.cipherInfo.ivLen && (!Buffer.isBuffer(outbound.cipherIV) || outbound.cipherIV.length !== outbound.cipherInfo.ivLen)) {
        throw new Error("Invalid outbound.cipherIV");
      }
      if (typeof outbound.seqno !== "number" || outbound.seqno < 0 || outbound.seqno > MAX_SEQNO) {
        throw new Error("Invalid outbound.seqno");
      }
      const forceNative = !!outbound.forceNative;
      switch (outbound.cipherInfo.sslName) {
        case "aes-128-gcm":
        case "aes-256-gcm":
          return AESGCMCipher && !forceNative ? new AESGCMCipherBinding(config) : new AESGCMCipherNative(config);
        case "chacha20":
          return ChaChaPolyCipher && !forceNative ? new ChaChaPolyCipherBinding(config) : new ChaChaPolyCipherNative(config);
        default: {
          if (typeof outbound.macInfo !== "object" || outbound.macInfo === null)
            throw new Error("Invalid outbound.macInfo");
          if (!Buffer.isBuffer(outbound.macKey) || outbound.macKey.length !== outbound.macInfo.len) {
            throw new Error("Invalid outbound.macKey");
          }
          return GenericCipher && !forceNative ? new GenericCipherBinding(config) : new GenericCipherNative(config);
        }
      }
    }
    function createDecipher(config) {
      if (typeof config !== "object" || config === null)
        throw new Error("Invalid config");
      if (typeof config.inbound !== "object" || config.inbound === null)
        throw new Error("Invalid inbound");
      const inbound = config.inbound;
      if (typeof inbound.onPayload !== "function")
        throw new Error("Invalid inbound.onPayload");
      if (typeof inbound.decipherInfo !== "object" || inbound.decipherInfo === null) {
        throw new Error("Invalid inbound.decipherInfo");
      }
      if (!Buffer.isBuffer(inbound.decipherKey) || inbound.decipherKey.length !== inbound.decipherInfo.keyLen) {
        throw new Error("Invalid inbound.decipherKey");
      }
      if (inbound.decipherInfo.ivLen && (!Buffer.isBuffer(inbound.decipherIV) || inbound.decipherIV.length !== inbound.decipherInfo.ivLen)) {
        throw new Error("Invalid inbound.decipherIV");
      }
      if (typeof inbound.seqno !== "number" || inbound.seqno < 0 || inbound.seqno > MAX_SEQNO) {
        throw new Error("Invalid inbound.seqno");
      }
      const forceNative = !!inbound.forceNative;
      switch (inbound.decipherInfo.sslName) {
        case "aes-128-gcm":
        case "aes-256-gcm":
          return AESGCMDecipher && !forceNative ? new AESGCMDecipherBinding(config) : new AESGCMDecipherNative(config);
        case "chacha20":
          return ChaChaPolyDecipher && !forceNative ? new ChaChaPolyDecipherBinding(config) : new ChaChaPolyDecipherNative(config);
        default: {
          if (typeof inbound.macInfo !== "object" || inbound.macInfo === null)
            throw new Error("Invalid inbound.macInfo");
          if (!Buffer.isBuffer(inbound.macKey) || inbound.macKey.length !== inbound.macInfo.len) {
            throw new Error("Invalid inbound.macKey");
          }
          return GenericDecipher && !forceNative ? new GenericDecipherBinding(config) : new GenericDecipherNative(config);
        }
      }
    }
    module.exports = {
      CIPHER_INFO,
      MAC_INFO,
      bindingAvailable: !!binding,
      init: (() => {
        return new Promise(async (resolve2, reject) => {
          try {
            POLY1305_WASM_MODULE = await require_poly1305()();
            POLY1305_RESULT_MALLOC = POLY1305_WASM_MODULE._malloc(16);
            poly1305_auth = POLY1305_WASM_MODULE.cwrap(
              "poly1305_auth",
              null,
              ["number", "array", "number", "array", "number", "array"]
            );
          } catch (ex) {
            return reject(ex);
          }
          resolve2();
        });
      })(),
      NullCipher,
      createCipher,
      NullDecipher,
      createDecipher
    };
  }
});

// node_modules/ssh2/lib/protocol/keyParser.js
var require_keyParser = __commonJS({
  "node_modules/ssh2/lib/protocol/keyParser.js"(exports, module) {
    "use strict";
    var {
      createDecipheriv,
      createECDH,
      createHash: createHash2,
      createHmac,
      createSign,
      createVerify,
      getCiphers,
      sign: sign_,
      verify: verify_
    } = __require("crypto");
    var supportedOpenSSLCiphers = getCiphers();
    var { Ber } = require_lib2();
    var bcrypt_pbkdf = require_bcrypt_pbkdf().pbkdf;
    var { CIPHER_INFO } = require_crypto();
    var { eddsaSupported, SUPPORTED_CIPHER } = require_constants5();
    var {
      bufferSlice,
      makeBufferParser,
      readString: readString7,
      readUInt32BE,
      writeUInt32BE
    } = require_utils7();
    var SYM_HASH_ALGO = Symbol("Hash Algorithm");
    var SYM_PRIV_PEM = Symbol("Private key PEM");
    var SYM_PUB_PEM = Symbol("Public key PEM");
    var SYM_PUB_SSH = Symbol("Public key SSH");
    var SYM_DECRYPTED = Symbol("Decrypted Key");
    var CIPHER_INFO_OPENSSL = /* @__PURE__ */ Object.create(null);
    {
      const keys4 = Object.keys(CIPHER_INFO);
      for (let i = 0; i < keys4.length; ++i) {
        const cipherName = CIPHER_INFO[keys4[i]].sslName;
        if (!cipherName || CIPHER_INFO_OPENSSL[cipherName])
          continue;
        CIPHER_INFO_OPENSSL[cipherName] = CIPHER_INFO[keys4[i]];
      }
    }
    var binaryKeyParser = makeBufferParser();
    function makePEM(type, data) {
      data = data.base64Slice(0, data.length);
      let formatted = data.replace(/.{64}/g, "$&\n");
      if (data.length & 63)
        formatted += "\n";
      return `-----BEGIN ${type} KEY-----
${formatted}-----END ${type} KEY-----`;
    }
    function combineBuffers(buf1, buf2) {
      const result = Buffer.allocUnsafe(buf1.length + buf2.length);
      result.set(buf1, 0);
      result.set(buf2, buf1.length);
      return result;
    }
    function skipFields(buf, nfields) {
      const bufLen = buf.length;
      let pos = buf._pos || 0;
      for (let i = 0; i < nfields; ++i) {
        const left2 = bufLen - pos;
        if (pos >= bufLen || left2 < 4)
          return false;
        const len = readUInt32BE(buf, pos);
        if (left2 < 4 + len)
          return false;
        pos += 4 + len;
      }
      buf._pos = pos;
      return true;
    }
    function genOpenSSLRSAPub(n, e) {
      const asnWriter = new Ber.Writer();
      asnWriter.startSequence();
      asnWriter.startSequence();
      asnWriter.writeOID("1.2.840.113549.1.1.1");
      asnWriter.writeNull();
      asnWriter.endSequence();
      asnWriter.startSequence(Ber.BitString);
      asnWriter.writeByte(0);
      asnWriter.startSequence();
      asnWriter.writeBuffer(n, Ber.Integer);
      asnWriter.writeBuffer(e, Ber.Integer);
      asnWriter.endSequence();
      asnWriter.endSequence();
      asnWriter.endSequence();
      return makePEM("PUBLIC", asnWriter.buffer);
    }
    function genOpenSSHRSAPub(n, e) {
      const publicKey = Buffer.allocUnsafe(4 + 7 + 4 + e.length + 4 + n.length);
      writeUInt32BE(publicKey, 7, 0);
      publicKey.utf8Write("ssh-rsa", 4, 7);
      let i = 4 + 7;
      writeUInt32BE(publicKey, e.length, i);
      publicKey.set(e, i += 4);
      writeUInt32BE(publicKey, n.length, i += e.length);
      publicKey.set(n, i + 4);
      return publicKey;
    }
    var genOpenSSLRSAPriv = (() => {
      function genRSAASN1Buf(n, e, d, p, q, dmp1, dmq1, iqmp) {
        const asnWriter = new Ber.Writer();
        asnWriter.startSequence();
        asnWriter.writeInt(0, Ber.Integer);
        asnWriter.writeBuffer(n, Ber.Integer);
        asnWriter.writeBuffer(e, Ber.Integer);
        asnWriter.writeBuffer(d, Ber.Integer);
        asnWriter.writeBuffer(p, Ber.Integer);
        asnWriter.writeBuffer(q, Ber.Integer);
        asnWriter.writeBuffer(dmp1, Ber.Integer);
        asnWriter.writeBuffer(dmq1, Ber.Integer);
        asnWriter.writeBuffer(iqmp, Ber.Integer);
        asnWriter.endSequence();
        return asnWriter.buffer;
      }
      function bigIntFromBuffer(buf) {
        return BigInt(`0x${buf.hexSlice(0, buf.length)}`);
      }
      function bigIntToBuffer(bn) {
        let hex = bn.toString(16);
        if ((hex.length & 1) !== 0) {
          hex = `0${hex}`;
        } else {
          const sigbit = hex.charCodeAt(0);
          if (sigbit === 56 || sigbit === 57 || sigbit >= 97 && sigbit <= 102) {
            hex = `00${hex}`;
          }
        }
        return Buffer.from(hex, "hex");
      }
      return function genOpenSSLRSAPriv2(n, e, d, iqmp, p, q) {
        const bn_d = bigIntFromBuffer(d);
        const dmp1 = bigIntToBuffer(bn_d % (bigIntFromBuffer(p) - 1n));
        const dmq1 = bigIntToBuffer(bn_d % (bigIntFromBuffer(q) - 1n));
        return makePEM(
          "RSA PRIVATE",
          genRSAASN1Buf(n, e, d, p, q, dmp1, dmq1, iqmp)
        );
      };
    })();
    function genOpenSSLDSAPub(p, q, g, y) {
      const asnWriter = new Ber.Writer();
      asnWriter.startSequence();
      asnWriter.startSequence();
      asnWriter.writeOID("1.2.840.10040.4.1");
      asnWriter.startSequence();
      asnWriter.writeBuffer(p, Ber.Integer);
      asnWriter.writeBuffer(q, Ber.Integer);
      asnWriter.writeBuffer(g, Ber.Integer);
      asnWriter.endSequence();
      asnWriter.endSequence();
      asnWriter.startSequence(Ber.BitString);
      asnWriter.writeByte(0);
      asnWriter.writeBuffer(y, Ber.Integer);
      asnWriter.endSequence();
      asnWriter.endSequence();
      return makePEM("PUBLIC", asnWriter.buffer);
    }
    function genOpenSSHDSAPub(p, q, g, y) {
      const publicKey = Buffer.allocUnsafe(
        4 + 7 + 4 + p.length + 4 + q.length + 4 + g.length + 4 + y.length
      );
      writeUInt32BE(publicKey, 7, 0);
      publicKey.utf8Write("ssh-dss", 4, 7);
      let i = 4 + 7;
      writeUInt32BE(publicKey, p.length, i);
      publicKey.set(p, i += 4);
      writeUInt32BE(publicKey, q.length, i += p.length);
      publicKey.set(q, i += 4);
      writeUInt32BE(publicKey, g.length, i += q.length);
      publicKey.set(g, i += 4);
      writeUInt32BE(publicKey, y.length, i += g.length);
      publicKey.set(y, i + 4);
      return publicKey;
    }
    function genOpenSSLDSAPriv(p, q, g, y, x) {
      const asnWriter = new Ber.Writer();
      asnWriter.startSequence();
      asnWriter.writeInt(0, Ber.Integer);
      asnWriter.writeBuffer(p, Ber.Integer);
      asnWriter.writeBuffer(q, Ber.Integer);
      asnWriter.writeBuffer(g, Ber.Integer);
      asnWriter.writeBuffer(y, Ber.Integer);
      asnWriter.writeBuffer(x, Ber.Integer);
      asnWriter.endSequence();
      return makePEM("DSA PRIVATE", asnWriter.buffer);
    }
    function genOpenSSLEdPub(pub) {
      const asnWriter = new Ber.Writer();
      asnWriter.startSequence();
      asnWriter.startSequence();
      asnWriter.writeOID("1.3.101.112");
      asnWriter.endSequence();
      asnWriter.startSequence(Ber.BitString);
      asnWriter.writeByte(0);
      asnWriter._ensure(pub.length);
      asnWriter._buf.set(pub, asnWriter._offset);
      asnWriter._offset += pub.length;
      asnWriter.endSequence();
      asnWriter.endSequence();
      return makePEM("PUBLIC", asnWriter.buffer);
    }
    function genOpenSSHEdPub(pub) {
      const publicKey = Buffer.allocUnsafe(4 + 11 + 4 + pub.length);
      writeUInt32BE(publicKey, 11, 0);
      publicKey.utf8Write("ssh-ed25519", 4, 11);
      writeUInt32BE(publicKey, pub.length, 15);
      publicKey.set(pub, 19);
      return publicKey;
    }
    function genOpenSSLEdPriv(priv) {
      const asnWriter = new Ber.Writer();
      asnWriter.startSequence();
      asnWriter.writeInt(0, Ber.Integer);
      asnWriter.startSequence();
      asnWriter.writeOID("1.3.101.112");
      asnWriter.endSequence();
      asnWriter.startSequence(Ber.OctetString);
      asnWriter.writeBuffer(priv, Ber.OctetString);
      asnWriter.endSequence();
      asnWriter.endSequence();
      return makePEM("PRIVATE", asnWriter.buffer);
    }
    function genOpenSSLECDSAPub(oid, Q) {
      const asnWriter = new Ber.Writer();
      asnWriter.startSequence();
      asnWriter.startSequence();
      asnWriter.writeOID("1.2.840.10045.2.1");
      asnWriter.writeOID(oid);
      asnWriter.endSequence();
      asnWriter.startSequence(Ber.BitString);
      asnWriter.writeByte(0);
      asnWriter._ensure(Q.length);
      asnWriter._buf.set(Q, asnWriter._offset);
      asnWriter._offset += Q.length;
      asnWriter.endSequence();
      asnWriter.endSequence();
      return makePEM("PUBLIC", asnWriter.buffer);
    }
    function genOpenSSHECDSAPub(oid, Q) {
      let curveName;
      switch (oid) {
        case "1.2.840.10045.3.1.7":
          curveName = "nistp256";
          break;
        case "1.3.132.0.34":
          curveName = "nistp384";
          break;
        case "1.3.132.0.35":
          curveName = "nistp521";
          break;
        default:
          return;
      }
      const publicKey = Buffer.allocUnsafe(4 + 19 + 4 + 8 + 4 + Q.length);
      writeUInt32BE(publicKey, 19, 0);
      publicKey.utf8Write(`ecdsa-sha2-${curveName}`, 4, 19);
      writeUInt32BE(publicKey, 8, 23);
      publicKey.utf8Write(curveName, 27, 8);
      writeUInt32BE(publicKey, Q.length, 35);
      publicKey.set(Q, 39);
      return publicKey;
    }
    function genOpenSSLECDSAPriv(oid, pub, priv) {
      const asnWriter = new Ber.Writer();
      asnWriter.startSequence();
      asnWriter.writeInt(1, Ber.Integer);
      asnWriter.writeBuffer(priv, Ber.OctetString);
      asnWriter.startSequence(160);
      asnWriter.writeOID(oid);
      asnWriter.endSequence();
      asnWriter.startSequence(161);
      asnWriter.startSequence(Ber.BitString);
      asnWriter.writeByte(0);
      asnWriter._ensure(pub.length);
      asnWriter._buf.set(pub, asnWriter._offset);
      asnWriter._offset += pub.length;
      asnWriter.endSequence();
      asnWriter.endSequence();
      asnWriter.endSequence();
      return makePEM("EC PRIVATE", asnWriter.buffer);
    }
    function genOpenSSLECDSAPubFromPriv(curveName, priv) {
      const tempECDH = createECDH(curveName);
      tempECDH.setPrivateKey(priv);
      return tempECDH.getPublicKey();
    }
    var BaseKey = {
      sign: (() => {
        if (typeof sign_ === "function") {
          return function sign2(data, algo) {
            const pem = this[SYM_PRIV_PEM];
            if (pem === null)
              return new Error("No private key available");
            if (!algo || typeof algo !== "string")
              algo = this[SYM_HASH_ALGO];
            try {
              return sign_(algo, data, pem);
            } catch (ex) {
              return ex;
            }
          };
        }
        return function sign2(data, algo) {
          const pem = this[SYM_PRIV_PEM];
          if (pem === null)
            return new Error("No private key available");
          if (!algo || typeof algo !== "string")
            algo = this[SYM_HASH_ALGO];
          const signature = createSign(algo);
          signature.update(data);
          try {
            return signature.sign(pem);
          } catch (ex) {
            return ex;
          }
        };
      })(),
      verify: (() => {
        if (typeof verify_ === "function") {
          return function verify(data, signature, algo) {
            const pem = this[SYM_PUB_PEM];
            if (pem === null)
              return new Error("No public key available");
            if (!algo || typeof algo !== "string")
              algo = this[SYM_HASH_ALGO];
            try {
              return verify_(algo, data, pem, signature);
            } catch (ex) {
              return ex;
            }
          };
        }
        return function verify(data, signature, algo) {
          const pem = this[SYM_PUB_PEM];
          if (pem === null)
            return new Error("No public key available");
          if (!algo || typeof algo !== "string")
            algo = this[SYM_HASH_ALGO];
          const verifier = createVerify(algo);
          verifier.update(data);
          try {
            return verifier.verify(pem, signature);
          } catch (ex) {
            return ex;
          }
        };
      })(),
      isPrivateKey: function isPrivateKey() {
        return this[SYM_PRIV_PEM] !== null;
      },
      getPrivatePEM: function getPrivatePEM() {
        return this[SYM_PRIV_PEM];
      },
      getPublicPEM: function getPublicPEM() {
        return this[SYM_PUB_PEM];
      },
      getPublicSSH: function getPublicSSH() {
        return this[SYM_PUB_SSH];
      },
      equals: function equals(key) {
        const parsed = parseKey(key);
        if (parsed instanceof Error)
          return false;
        return this.type === parsed.type && this[SYM_PRIV_PEM] === parsed[SYM_PRIV_PEM] && this[SYM_PUB_PEM] === parsed[SYM_PUB_PEM] && this[SYM_PUB_SSH] === parsed[SYM_PUB_SSH];
      }
    };
    function OpenSSH_Private(type, comment2, privPEM, pubPEM, pubSSH, algo, decrypted) {
      this.type = type;
      this.comment = comment2;
      this[SYM_PRIV_PEM] = privPEM;
      this[SYM_PUB_PEM] = pubPEM;
      this[SYM_PUB_SSH] = pubSSH;
      this[SYM_HASH_ALGO] = algo;
      this[SYM_DECRYPTED] = decrypted;
    }
    OpenSSH_Private.prototype = BaseKey;
    {
      let parseOpenSSHPrivKeys = function(data, nkeys, decrypted) {
        const keys4 = [];
        if (data.length < 8)
          return new Error("Malformed OpenSSH private key");
        const check1 = readUInt32BE(data, 0);
        const check2 = readUInt32BE(data, 4);
        if (check1 !== check2) {
          if (decrypted) {
            return new Error(
              "OpenSSH key integrity check failed -- bad passphrase?"
            );
          }
          return new Error("OpenSSH key integrity check failed");
        }
        data._pos = 8;
        let i;
        let oid;
        for (i = 0; i < nkeys; ++i) {
          let algo;
          let privPEM;
          let pubPEM;
          let pubSSH;
          const type = readString7(data, data._pos, true);
          if (type === void 0)
            return new Error("Malformed OpenSSH private key");
          switch (type) {
            case "ssh-rsa": {
              const n = readString7(data, data._pos);
              if (n === void 0)
                return new Error("Malformed OpenSSH private key");
              const e = readString7(data, data._pos);
              if (e === void 0)
                return new Error("Malformed OpenSSH private key");
              const d = readString7(data, data._pos);
              if (d === void 0)
                return new Error("Malformed OpenSSH private key");
              const iqmp = readString7(data, data._pos);
              if (iqmp === void 0)
                return new Error("Malformed OpenSSH private key");
              const p = readString7(data, data._pos);
              if (p === void 0)
                return new Error("Malformed OpenSSH private key");
              const q = readString7(data, data._pos);
              if (q === void 0)
                return new Error("Malformed OpenSSH private key");
              pubPEM = genOpenSSLRSAPub(n, e);
              pubSSH = genOpenSSHRSAPub(n, e);
              privPEM = genOpenSSLRSAPriv(n, e, d, iqmp, p, q);
              algo = "sha1";
              break;
            }
            case "ssh-dss": {
              const p = readString7(data, data._pos);
              if (p === void 0)
                return new Error("Malformed OpenSSH private key");
              const q = readString7(data, data._pos);
              if (q === void 0)
                return new Error("Malformed OpenSSH private key");
              const g = readString7(data, data._pos);
              if (g === void 0)
                return new Error("Malformed OpenSSH private key");
              const y = readString7(data, data._pos);
              if (y === void 0)
                return new Error("Malformed OpenSSH private key");
              const x = readString7(data, data._pos);
              if (x === void 0)
                return new Error("Malformed OpenSSH private key");
              pubPEM = genOpenSSLDSAPub(p, q, g, y);
              pubSSH = genOpenSSHDSAPub(p, q, g, y);
              privPEM = genOpenSSLDSAPriv(p, q, g, y, x);
              algo = "sha1";
              break;
            }
            case "ssh-ed25519": {
              if (!eddsaSupported)
                return new Error(`Unsupported OpenSSH private key type: ${type}`);
              const edpub = readString7(data, data._pos);
              if (edpub === void 0 || edpub.length !== 32)
                return new Error("Malformed OpenSSH private key");
              const edpriv = readString7(data, data._pos);
              if (edpriv === void 0 || edpriv.length !== 64)
                return new Error("Malformed OpenSSH private key");
              pubPEM = genOpenSSLEdPub(edpub);
              pubSSH = genOpenSSHEdPub(edpub);
              privPEM = genOpenSSLEdPriv(bufferSlice(edpriv, 0, 32));
              algo = null;
              break;
            }
            case "ecdsa-sha2-nistp256":
              algo = "sha256";
              oid = "1.2.840.10045.3.1.7";
            case "ecdsa-sha2-nistp384":
              if (algo === void 0) {
                algo = "sha384";
                oid = "1.3.132.0.34";
              }
            case "ecdsa-sha2-nistp521": {
              if (algo === void 0) {
                algo = "sha512";
                oid = "1.3.132.0.35";
              }
              if (!skipFields(data, 1))
                return new Error("Malformed OpenSSH private key");
              const ecpub = readString7(data, data._pos);
              if (ecpub === void 0)
                return new Error("Malformed OpenSSH private key");
              const ecpriv = readString7(data, data._pos);
              if (ecpriv === void 0)
                return new Error("Malformed OpenSSH private key");
              pubPEM = genOpenSSLECDSAPub(oid, ecpub);
              pubSSH = genOpenSSHECDSAPub(oid, ecpub);
              privPEM = genOpenSSLECDSAPriv(oid, ecpub, ecpriv);
              break;
            }
            default:
              return new Error(`Unsupported OpenSSH private key type: ${type}`);
          }
          const privComment = readString7(data, data._pos, true);
          if (privComment === void 0)
            return new Error("Malformed OpenSSH private key");
          keys4.push(
            new OpenSSH_Private(
              type,
              privComment,
              privPEM,
              pubPEM,
              pubSSH,
              algo,
              decrypted
            )
          );
        }
        let cnt = 0;
        for (i = data._pos; i < data.length; ++i) {
          if (data[i] !== ++cnt % 255)
            return new Error("Malformed OpenSSH private key");
        }
        return keys4;
      };
      const regexp = /^-----BEGIN OPENSSH PRIVATE KEY-----(?:\r\n|\n)([\s\S]+)(?:\r\n|\n)-----END OPENSSH PRIVATE KEY-----$/;
      OpenSSH_Private.parse = (str2, passphrase) => {
        const m = regexp.exec(str2);
        if (m === null)
          return null;
        let ret;
        const data = Buffer.from(m[1], "base64");
        if (data.length < 31)
          return new Error("Malformed OpenSSH private key");
        const magic = data.utf8Slice(0, 15);
        if (magic !== "openssh-key-v1\0")
          return new Error(`Unsupported OpenSSH key magic: ${magic}`);
        const cipherName = readString7(data, 15, true);
        if (cipherName === void 0)
          return new Error("Malformed OpenSSH private key");
        if (cipherName !== "none" && SUPPORTED_CIPHER.indexOf(cipherName) === -1)
          return new Error(`Unsupported cipher for OpenSSH key: ${cipherName}`);
        const kdfName = readString7(data, data._pos, true);
        if (kdfName === void 0)
          return new Error("Malformed OpenSSH private key");
        if (kdfName !== "none") {
          if (cipherName === "none")
            return new Error("Malformed OpenSSH private key");
          if (kdfName !== "bcrypt")
            return new Error(`Unsupported kdf name for OpenSSH key: ${kdfName}`);
          if (!passphrase) {
            return new Error(
              "Encrypted private OpenSSH key detected, but no passphrase given"
            );
          }
        } else if (cipherName !== "none") {
          return new Error("Malformed OpenSSH private key");
        }
        let encInfo;
        let cipherKey;
        let cipherIV;
        if (cipherName !== "none")
          encInfo = CIPHER_INFO[cipherName];
        const kdfOptions = readString7(data, data._pos);
        if (kdfOptions === void 0)
          return new Error("Malformed OpenSSH private key");
        if (kdfOptions.length) {
          switch (kdfName) {
            case "none":
              return new Error("Malformed OpenSSH private key");
            case "bcrypt": {
              const salt = readString7(kdfOptions, 0);
              if (salt === void 0 || kdfOptions._pos + 4 > kdfOptions.length)
                return new Error("Malformed OpenSSH private key");
              const rounds = readUInt32BE(kdfOptions, kdfOptions._pos);
              const gen = Buffer.allocUnsafe(encInfo.keyLen + encInfo.ivLen);
              const r = bcrypt_pbkdf(
                passphrase,
                passphrase.length,
                salt,
                salt.length,
                gen,
                gen.length,
                rounds
              );
              if (r !== 0)
                return new Error("Failed to generate information to decrypt key");
              cipherKey = bufferSlice(gen, 0, encInfo.keyLen);
              cipherIV = bufferSlice(gen, encInfo.keyLen, gen.length);
              break;
            }
          }
        } else if (kdfName !== "none") {
          return new Error("Malformed OpenSSH private key");
        }
        if (data._pos + 3 >= data.length)
          return new Error("Malformed OpenSSH private key");
        const keyCount = readUInt32BE(data, data._pos);
        data._pos += 4;
        if (keyCount > 0) {
          for (let i = 0; i < keyCount; ++i) {
            const pubData = readString7(data, data._pos);
            if (pubData === void 0)
              return new Error("Malformed OpenSSH private key");
            const type = readString7(pubData, 0, true);
            if (type === void 0)
              return new Error("Malformed OpenSSH private key");
          }
          let privBlob = readString7(data, data._pos);
          if (privBlob === void 0)
            return new Error("Malformed OpenSSH private key");
          if (cipherKey !== void 0) {
            if (privBlob.length < encInfo.blockLen || privBlob.length % encInfo.blockLen !== 0) {
              return new Error("Malformed OpenSSH private key");
            }
            try {
              const options = { authTagLength: encInfo.authLen };
              const decipher = createDecipheriv(
                encInfo.sslName,
                cipherKey,
                cipherIV,
                options
              );
              decipher.setAutoPadding(false);
              if (encInfo.authLen > 0) {
                if (data.length - data._pos < encInfo.authLen)
                  return new Error("Malformed OpenSSH private key");
                decipher.setAuthTag(
                  bufferSlice(data, data._pos, data._pos += encInfo.authLen)
                );
              }
              privBlob = combineBuffers(
                decipher.update(privBlob),
                decipher.final()
              );
            } catch (ex) {
              return ex;
            }
          }
          if (data._pos !== data.length)
            return new Error("Malformed OpenSSH private key");
          ret = parseOpenSSHPrivKeys(privBlob, keyCount, cipherKey !== void 0);
        } else {
          ret = [];
        }
        if (ret instanceof Error)
          return ret;
        return ret[0];
      };
    }
    function OpenSSH_Old_Private(type, comment2, privPEM, pubPEM, pubSSH, algo, decrypted) {
      this.type = type;
      this.comment = comment2;
      this[SYM_PRIV_PEM] = privPEM;
      this[SYM_PUB_PEM] = pubPEM;
      this[SYM_PUB_SSH] = pubSSH;
      this[SYM_HASH_ALGO] = algo;
      this[SYM_DECRYPTED] = decrypted;
    }
    OpenSSH_Old_Private.prototype = BaseKey;
    {
      const regexp = /^-----BEGIN (RSA|DSA|EC) PRIVATE KEY-----(?:\r\n|\n)((?:[^:]+:\s*[\S].*(?:\r\n|\n))*)([\s\S]+)(?:\r\n|\n)-----END (RSA|DSA|EC) PRIVATE KEY-----$/;
      OpenSSH_Old_Private.parse = (str2, passphrase) => {
        const m = regexp.exec(str2);
        if (m === null)
          return null;
        let privBlob = Buffer.from(m[3], "base64");
        let headers = m[2];
        let decrypted = false;
        if (headers !== void 0) {
          headers = headers.split(/\r\n|\n/g);
          for (let i = 0; i < headers.length; ++i) {
            const header = headers[i];
            let sepIdx = header.indexOf(":");
            if (header.slice(0, sepIdx) === "DEK-Info") {
              const val = header.slice(sepIdx + 2);
              sepIdx = val.indexOf(",");
              if (sepIdx === -1)
                continue;
              const cipherName = val.slice(0, sepIdx).toLowerCase();
              if (supportedOpenSSLCiphers.indexOf(cipherName) === -1) {
                return new Error(
                  `Cipher (${cipherName}) not supported for encrypted OpenSSH private key`
                );
              }
              const encInfo = CIPHER_INFO_OPENSSL[cipherName];
              if (!encInfo) {
                return new Error(
                  `Cipher (${cipherName}) not supported for encrypted OpenSSH private key`
                );
              }
              const cipherIV = Buffer.from(val.slice(sepIdx + 1), "hex");
              if (cipherIV.length !== encInfo.ivLen)
                return new Error("Malformed encrypted OpenSSH private key");
              if (!passphrase) {
                return new Error(
                  "Encrypted OpenSSH private key detected, but no passphrase given"
                );
              }
              const ivSlice = bufferSlice(cipherIV, 0, 8);
              let cipherKey = createHash2("md5").update(passphrase).update(ivSlice).digest();
              while (cipherKey.length < encInfo.keyLen) {
                cipherKey = combineBuffers(
                  cipherKey,
                  createHash2("md5").update(cipherKey).update(passphrase).update(ivSlice).digest()
                );
              }
              if (cipherKey.length > encInfo.keyLen)
                cipherKey = bufferSlice(cipherKey, 0, encInfo.keyLen);
              try {
                const decipher = createDecipheriv(cipherName, cipherKey, cipherIV);
                decipher.setAutoPadding(false);
                privBlob = combineBuffers(
                  decipher.update(privBlob),
                  decipher.final()
                );
                decrypted = true;
              } catch (ex) {
                return ex;
              }
            }
          }
        }
        let type;
        let privPEM;
        let pubPEM;
        let pubSSH;
        let algo;
        let reader;
        let errMsg = "Malformed OpenSSH private key";
        if (decrypted)
          errMsg += ". Bad passphrase?";
        switch (m[1]) {
          case "RSA":
            type = "ssh-rsa";
            privPEM = makePEM("RSA PRIVATE", privBlob);
            try {
              reader = new Ber.Reader(privBlob);
              reader.readSequence();
              reader.readInt();
              const n = reader.readString(Ber.Integer, true);
              if (n === null)
                return new Error(errMsg);
              const e = reader.readString(Ber.Integer, true);
              if (e === null)
                return new Error(errMsg);
              pubPEM = genOpenSSLRSAPub(n, e);
              pubSSH = genOpenSSHRSAPub(n, e);
            } catch {
              return new Error(errMsg);
            }
            algo = "sha1";
            break;
          case "DSA":
            type = "ssh-dss";
            privPEM = makePEM("DSA PRIVATE", privBlob);
            try {
              reader = new Ber.Reader(privBlob);
              reader.readSequence();
              reader.readInt();
              const p = reader.readString(Ber.Integer, true);
              if (p === null)
                return new Error(errMsg);
              const q = reader.readString(Ber.Integer, true);
              if (q === null)
                return new Error(errMsg);
              const g = reader.readString(Ber.Integer, true);
              if (g === null)
                return new Error(errMsg);
              const y = reader.readString(Ber.Integer, true);
              if (y === null)
                return new Error(errMsg);
              pubPEM = genOpenSSLDSAPub(p, q, g, y);
              pubSSH = genOpenSSHDSAPub(p, q, g, y);
            } catch {
              return new Error(errMsg);
            }
            algo = "sha1";
            break;
          case "EC": {
            let ecSSLName;
            let ecPriv;
            let ecOID;
            try {
              reader = new Ber.Reader(privBlob);
              reader.readSequence();
              reader.readInt();
              ecPriv = reader.readString(Ber.OctetString, true);
              reader.readByte();
              const offset = reader.readLength();
              if (offset !== null) {
                reader._offset = offset;
                ecOID = reader.readOID();
                if (ecOID === null)
                  return new Error(errMsg);
                switch (ecOID) {
                  case "1.2.840.10045.3.1.7":
                    ecSSLName = "prime256v1";
                    type = "ecdsa-sha2-nistp256";
                    algo = "sha256";
                    break;
                  case "1.3.132.0.34":
                    ecSSLName = "secp384r1";
                    type = "ecdsa-sha2-nistp384";
                    algo = "sha384";
                    break;
                  case "1.3.132.0.35":
                    ecSSLName = "secp521r1";
                    type = "ecdsa-sha2-nistp521";
                    algo = "sha512";
                    break;
                  default:
                    return new Error(`Unsupported private key EC OID: ${ecOID}`);
                }
              } else {
                return new Error(errMsg);
              }
            } catch {
              return new Error(errMsg);
            }
            privPEM = makePEM("EC PRIVATE", privBlob);
            const pubBlob = genOpenSSLECDSAPubFromPriv(ecSSLName, ecPriv);
            pubPEM = genOpenSSLECDSAPub(ecOID, pubBlob);
            pubSSH = genOpenSSHECDSAPub(ecOID, pubBlob);
            break;
          }
        }
        return new OpenSSH_Old_Private(
          type,
          "",
          privPEM,
          pubPEM,
          pubSSH,
          algo,
          decrypted
        );
      };
    }
    function PPK_Private(type, comment2, privPEM, pubPEM, pubSSH, algo, decrypted) {
      this.type = type;
      this.comment = comment2;
      this[SYM_PRIV_PEM] = privPEM;
      this[SYM_PUB_PEM] = pubPEM;
      this[SYM_PUB_SSH] = pubSSH;
      this[SYM_HASH_ALGO] = algo;
      this[SYM_DECRYPTED] = decrypted;
    }
    PPK_Private.prototype = BaseKey;
    {
      const EMPTY_PASSPHRASE = Buffer.alloc(0);
      const PPK_IV = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
      const PPK_PP1 = Buffer.from([0, 0, 0, 0]);
      const PPK_PP2 = Buffer.from([0, 0, 0, 1]);
      const regexp = /^PuTTY-User-Key-File-2: (ssh-(?:rsa|dss))\r?\nEncryption: (aes256-cbc|none)\r?\nComment: ([^\r\n]*)\r?\nPublic-Lines: \d+\r?\n([\s\S]+?)\r?\nPrivate-Lines: \d+\r?\n([\s\S]+?)\r?\nPrivate-MAC: ([^\r\n]+)/;
      PPK_Private.parse = (str2, passphrase) => {
        const m = regexp.exec(str2);
        if (m === null)
          return null;
        const cipherName = m[2];
        const encrypted = cipherName !== "none";
        if (encrypted && !passphrase) {
          return new Error(
            "Encrypted PPK private key detected, but no passphrase given"
          );
        }
        let privBlob = Buffer.from(m[5], "base64");
        if (encrypted) {
          const encInfo = CIPHER_INFO[cipherName];
          let cipherKey = combineBuffers(
            createHash2("sha1").update(PPK_PP1).update(passphrase).digest(),
            createHash2("sha1").update(PPK_PP2).update(passphrase).digest()
          );
          if (cipherKey.length > encInfo.keyLen)
            cipherKey = bufferSlice(cipherKey, 0, encInfo.keyLen);
          try {
            const decipher = createDecipheriv(encInfo.sslName, cipherKey, PPK_IV);
            decipher.setAutoPadding(false);
            privBlob = combineBuffers(
              decipher.update(privBlob),
              decipher.final()
            );
          } catch (ex) {
            return ex;
          }
        }
        const type = m[1];
        const comment2 = m[3];
        const pubBlob = Buffer.from(m[4], "base64");
        const mac = m[6];
        const typeLen = type.length;
        const cipherNameLen = cipherName.length;
        const commentLen = Buffer.byteLength(comment2);
        const pubLen = pubBlob.length;
        const privLen = privBlob.length;
        const macData = Buffer.allocUnsafe(4 + typeLen + 4 + cipherNameLen + 4 + commentLen + 4 + pubLen + 4 + privLen);
        let p = 0;
        writeUInt32BE(macData, typeLen, p);
        macData.utf8Write(type, p += 4, typeLen);
        writeUInt32BE(macData, cipherNameLen, p += typeLen);
        macData.utf8Write(cipherName, p += 4, cipherNameLen);
        writeUInt32BE(macData, commentLen, p += cipherNameLen);
        macData.utf8Write(comment2, p += 4, commentLen);
        writeUInt32BE(macData, pubLen, p += commentLen);
        macData.set(pubBlob, p += 4);
        writeUInt32BE(macData, privLen, p += pubLen);
        macData.set(privBlob, p + 4);
        if (!passphrase)
          passphrase = EMPTY_PASSPHRASE;
        const calcMAC = createHmac(
          "sha1",
          createHash2("sha1").update("putty-private-key-file-mac-key").update(passphrase).digest()
        ).update(macData).digest("hex");
        if (calcMAC !== mac) {
          if (encrypted) {
            return new Error(
              "PPK private key integrity check failed -- bad passphrase?"
            );
          }
          return new Error("PPK private key integrity check failed");
        }
        let pubPEM;
        let pubSSH;
        let privPEM;
        pubBlob._pos = 0;
        skipFields(pubBlob, 1);
        switch (type) {
          case "ssh-rsa": {
            const e = readString7(pubBlob, pubBlob._pos);
            if (e === void 0)
              return new Error("Malformed PPK public key");
            const n = readString7(pubBlob, pubBlob._pos);
            if (n === void 0)
              return new Error("Malformed PPK public key");
            const d = readString7(privBlob, 0);
            if (d === void 0)
              return new Error("Malformed PPK private key");
            const p2 = readString7(privBlob, privBlob._pos);
            if (p2 === void 0)
              return new Error("Malformed PPK private key");
            const q = readString7(privBlob, privBlob._pos);
            if (q === void 0)
              return new Error("Malformed PPK private key");
            const iqmp = readString7(privBlob, privBlob._pos);
            if (iqmp === void 0)
              return new Error("Malformed PPK private key");
            pubPEM = genOpenSSLRSAPub(n, e);
            pubSSH = genOpenSSHRSAPub(n, e);
            privPEM = genOpenSSLRSAPriv(n, e, d, iqmp, p2, q);
            break;
          }
          case "ssh-dss": {
            const p2 = readString7(pubBlob, pubBlob._pos);
            if (p2 === void 0)
              return new Error("Malformed PPK public key");
            const q = readString7(pubBlob, pubBlob._pos);
            if (q === void 0)
              return new Error("Malformed PPK public key");
            const g = readString7(pubBlob, pubBlob._pos);
            if (g === void 0)
              return new Error("Malformed PPK public key");
            const y = readString7(pubBlob, pubBlob._pos);
            if (y === void 0)
              return new Error("Malformed PPK public key");
            const x = readString7(privBlob, 0);
            if (x === void 0)
              return new Error("Malformed PPK private key");
            pubPEM = genOpenSSLDSAPub(p2, q, g, y);
            pubSSH = genOpenSSHDSAPub(p2, q, g, y);
            privPEM = genOpenSSLDSAPriv(p2, q, g, y, x);
            break;
          }
        }
        return new PPK_Private(
          type,
          comment2,
          privPEM,
          pubPEM,
          pubSSH,
          "sha1",
          encrypted
        );
      };
    }
    function OpenSSH_Public(type, comment2, pubPEM, pubSSH, algo) {
      this.type = type;
      this.comment = comment2;
      this[SYM_PRIV_PEM] = null;
      this[SYM_PUB_PEM] = pubPEM;
      this[SYM_PUB_SSH] = pubSSH;
      this[SYM_HASH_ALGO] = algo;
      this[SYM_DECRYPTED] = false;
    }
    OpenSSH_Public.prototype = BaseKey;
    {
      let regexp;
      if (eddsaSupported)
        regexp = /^(((?:ssh-(?:rsa|dss|ed25519))|ecdsa-sha2-nistp(?:256|384|521))(?:-cert-v0[01]@openssh.com)?) ([A-Z0-9a-z/+=]+)(?:$|\s+([\S].*)?)$/;
      else
        regexp = /^(((?:ssh-(?:rsa|dss))|ecdsa-sha2-nistp(?:256|384|521))(?:-cert-v0[01]@openssh.com)?) ([A-Z0-9a-z/+=]+)(?:$|\s+([\S].*)?)$/;
      OpenSSH_Public.parse = (str2) => {
        const m = regexp.exec(str2);
        if (m === null)
          return null;
        const fullType = m[1];
        const baseType = m[2];
        const data = Buffer.from(m[3], "base64");
        const comment2 = m[4] || "";
        const type = readString7(data, data._pos, true);
        if (type === void 0 || type.indexOf(baseType) !== 0)
          return new Error("Malformed OpenSSH public key");
        return parseDER(data, baseType, comment2, fullType);
      };
    }
    function RFC4716_Public(type, comment2, pubPEM, pubSSH, algo) {
      this.type = type;
      this.comment = comment2;
      this[SYM_PRIV_PEM] = null;
      this[SYM_PUB_PEM] = pubPEM;
      this[SYM_PUB_SSH] = pubSSH;
      this[SYM_HASH_ALGO] = algo;
      this[SYM_DECRYPTED] = false;
    }
    RFC4716_Public.prototype = BaseKey;
    {
      const regexp = /^---- BEGIN SSH2 PUBLIC KEY ----(?:\r?\n)((?:.{0,72}\r?\n)+)---- END SSH2 PUBLIC KEY ----$/;
      const RE_DATA = /^[A-Z0-9a-z/+=\r\n]+$/;
      const RE_HEADER = /^([\x21-\x39\x3B-\x7E]{1,64}): ((?:[^\\]*\\\r?\n)*[^\r\n]+)\r?\n/gm;
      const RE_HEADER_ENDS = /\\\r?\n/g;
      RFC4716_Public.parse = (str2) => {
        let m = regexp.exec(str2);
        if (m === null)
          return null;
        const body = m[1];
        let dataStart = 0;
        let comment2 = "";
        while (m = RE_HEADER.exec(body)) {
          const headerName = m[1];
          const headerValue = m[2].replace(RE_HEADER_ENDS, "");
          if (headerValue.length > 1024) {
            RE_HEADER.lastIndex = 0;
            return new Error("Malformed RFC4716 public key");
          }
          dataStart = RE_HEADER.lastIndex;
          if (headerName.toLowerCase() === "comment") {
            comment2 = headerValue;
            if (comment2.length > 1 && comment2.charCodeAt(0) === 34 && comment2.charCodeAt(comment2.length - 1) === 34) {
              comment2 = comment2.slice(1, -1);
            }
          }
        }
        let data = body.slice(dataStart);
        if (!RE_DATA.test(data))
          return new Error("Malformed RFC4716 public key");
        data = Buffer.from(data, "base64");
        const type = readString7(data, 0, true);
        if (type === void 0)
          return new Error("Malformed RFC4716 public key");
        let pubPEM = null;
        let pubSSH = null;
        switch (type) {
          case "ssh-rsa": {
            const e = readString7(data, data._pos);
            if (e === void 0)
              return new Error("Malformed RFC4716 public key");
            const n = readString7(data, data._pos);
            if (n === void 0)
              return new Error("Malformed RFC4716 public key");
            pubPEM = genOpenSSLRSAPub(n, e);
            pubSSH = genOpenSSHRSAPub(n, e);
            break;
          }
          case "ssh-dss": {
            const p = readString7(data, data._pos);
            if (p === void 0)
              return new Error("Malformed RFC4716 public key");
            const q = readString7(data, data._pos);
            if (q === void 0)
              return new Error("Malformed RFC4716 public key");
            const g = readString7(data, data._pos);
            if (g === void 0)
              return new Error("Malformed RFC4716 public key");
            const y = readString7(data, data._pos);
            if (y === void 0)
              return new Error("Malformed RFC4716 public key");
            pubPEM = genOpenSSLDSAPub(p, q, g, y);
            pubSSH = genOpenSSHDSAPub(p, q, g, y);
            break;
          }
          default:
            return new Error("Malformed RFC4716 public key");
        }
        return new RFC4716_Public(type, comment2, pubPEM, pubSSH, "sha1");
      };
    }
    function parseDER(data, baseType, comment2, fullType) {
      if (!isSupportedKeyType(baseType))
        return new Error(`Unsupported OpenSSH public key type: ${baseType}`);
      let algo;
      let oid;
      let pubPEM = null;
      let pubSSH = null;
      switch (baseType) {
        case "ssh-rsa": {
          const e = readString7(data, data._pos || 0);
          if (e === void 0)
            return new Error("Malformed OpenSSH public key");
          const n = readString7(data, data._pos);
          if (n === void 0)
            return new Error("Malformed OpenSSH public key");
          pubPEM = genOpenSSLRSAPub(n, e);
          pubSSH = genOpenSSHRSAPub(n, e);
          algo = "sha1";
          break;
        }
        case "ssh-dss": {
          const p = readString7(data, data._pos || 0);
          if (p === void 0)
            return new Error("Malformed OpenSSH public key");
          const q = readString7(data, data._pos);
          if (q === void 0)
            return new Error("Malformed OpenSSH public key");
          const g = readString7(data, data._pos);
          if (g === void 0)
            return new Error("Malformed OpenSSH public key");
          const y = readString7(data, data._pos);
          if (y === void 0)
            return new Error("Malformed OpenSSH public key");
          pubPEM = genOpenSSLDSAPub(p, q, g, y);
          pubSSH = genOpenSSHDSAPub(p, q, g, y);
          algo = "sha1";
          break;
        }
        case "ssh-ed25519": {
          const edpub = readString7(data, data._pos || 0);
          if (edpub === void 0 || edpub.length !== 32)
            return new Error("Malformed OpenSSH public key");
          pubPEM = genOpenSSLEdPub(edpub);
          pubSSH = genOpenSSHEdPub(edpub);
          algo = null;
          break;
        }
        case "ecdsa-sha2-nistp256":
          algo = "sha256";
          oid = "1.2.840.10045.3.1.7";
        case "ecdsa-sha2-nistp384":
          if (algo === void 0) {
            algo = "sha384";
            oid = "1.3.132.0.34";
          }
        case "ecdsa-sha2-nistp521": {
          if (algo === void 0) {
            algo = "sha512";
            oid = "1.3.132.0.35";
          }
          if (!skipFields(data, 1))
            return new Error("Malformed OpenSSH public key");
          const ecpub = readString7(data, data._pos || 0);
          if (ecpub === void 0)
            return new Error("Malformed OpenSSH public key");
          pubPEM = genOpenSSLECDSAPub(oid, ecpub);
          pubSSH = genOpenSSHECDSAPub(oid, ecpub);
          break;
        }
        default:
          return new Error(`Unsupported OpenSSH public key type: ${baseType}`);
      }
      return new OpenSSH_Public(fullType, comment2, pubPEM, pubSSH, algo);
    }
    function isSupportedKeyType(type) {
      switch (type) {
        case "ssh-rsa":
        case "ssh-dss":
        case "ecdsa-sha2-nistp256":
        case "ecdsa-sha2-nistp384":
        case "ecdsa-sha2-nistp521":
          return true;
        case "ssh-ed25519":
          if (eddsaSupported)
            return true;
        default:
          return false;
      }
    }
    function isParsedKey(val) {
      if (!val)
        return false;
      return typeof val[SYM_DECRYPTED] === "boolean";
    }
    function parseKey(data, passphrase) {
      if (isParsedKey(data))
        return data;
      let origBuffer;
      if (Buffer.isBuffer(data)) {
        origBuffer = data;
        data = data.utf8Slice(0, data.length).trim();
      } else if (typeof data === "string") {
        data = data.trim();
      } else {
        return new Error("Key data must be a Buffer or string");
      }
      if (passphrase != void 0) {
        if (typeof passphrase === "string")
          passphrase = Buffer.from(passphrase);
        else if (!Buffer.isBuffer(passphrase))
          return new Error("Passphrase must be a string or Buffer when supplied");
      }
      let ret;
      if ((ret = OpenSSH_Private.parse(data, passphrase)) !== null)
        return ret;
      if ((ret = OpenSSH_Old_Private.parse(data, passphrase)) !== null)
        return ret;
      if ((ret = PPK_Private.parse(data, passphrase)) !== null)
        return ret;
      if ((ret = OpenSSH_Public.parse(data)) !== null)
        return ret;
      if ((ret = RFC4716_Public.parse(data)) !== null)
        return ret;
      if (origBuffer) {
        binaryKeyParser.init(origBuffer, 0);
        const type = binaryKeyParser.readString(true);
        if (type !== void 0) {
          data = binaryKeyParser.readRaw();
          if (data !== void 0) {
            ret = parseDER(data, type, "", type);
            if (ret instanceof Error)
              ret = null;
          }
        }
        binaryKeyParser.clear();
      }
      if (ret)
        return ret;
      return new Error("Unsupported key format");
    }
    module.exports = {
      isParsedKey,
      isSupportedKeyType,
      parseDERKey: (data, type) => parseDER(data, type, "", type),
      parseKey
    };
  }
});

// node_modules/ssh2/lib/agent.js
var require_agent = __commonJS({
  "node_modules/ssh2/lib/agent.js"(exports, module) {
    "use strict";
    var { Socket } = __require("net");
    var { Duplex } = __require("stream");
    var { resolve: resolve2 } = __require("path");
    var { readFile: readFile4 } = __require("fs");
    var { execFile, spawn: spawn4 } = __require("child_process");
    var { isParsedKey, parseKey } = require_keyParser();
    var {
      makeBufferParser,
      readUInt32BE,
      writeUInt32BE,
      writeUInt32LE
    } = require_utils7();
    function once(cb) {
      let called = false;
      return (...args) => {
        if (called)
          return;
        called = true;
        cb(...args);
      };
    }
    function concat6(buf1, buf2) {
      const combined = Buffer.allocUnsafe(buf1.length + buf2.length);
      buf1.copy(combined, 0);
      buf2.copy(combined, buf1.length);
      return combined;
    }
    function noop() {
    }
    var EMPTY_BUF = Buffer.alloc(0);
    var binaryParser = makeBufferParser();
    var BaseAgent = class {
      getIdentities(cb) {
        cb(new Error("Missing getIdentities() implementation"));
      }
      sign(pubKey, data, options, cb) {
        if (typeof options === "function")
          cb = options;
        cb(new Error("Missing sign() implementation"));
      }
    };
    var OpenSSHAgent = class extends BaseAgent {
      constructor(socketPath) {
        super();
        this.socketPath = socketPath;
      }
      getStream(cb) {
        cb = once(cb);
        const sock = new Socket();
        sock.on("connect", () => {
          cb(null, sock);
        });
        sock.on("close", onFail).on("end", onFail).on("error", onFail);
        sock.connect(this.socketPath);
        function onFail() {
          try {
            sock.destroy();
          } catch {
          }
          cb(new Error("Failed to connect to agent"));
        }
      }
      getIdentities(cb) {
        cb = once(cb);
        this.getStream((err, stream3) => {
          function onFail(err2) {
            if (stream3) {
              try {
                stream3.destroy();
              } catch {
              }
            }
            if (!err2)
              err2 = new Error("Failed to retrieve identities from agent");
            cb(err2);
          }
          if (err)
            return onFail(err);
          const protocol = new AgentProtocol(true);
          protocol.on("error", onFail);
          protocol.pipe(stream3).pipe(protocol);
          stream3.on("close", onFail).on("end", onFail).on("error", onFail);
          protocol.getIdentities((err2, keys4) => {
            if (err2)
              return onFail(err2);
            try {
              stream3.destroy();
            } catch {
            }
            cb(null, keys4);
          });
        });
      }
      sign(pubKey, data, options, cb) {
        if (typeof options === "function") {
          cb = options;
          options = void 0;
        } else if (typeof options !== "object" || options === null) {
          options = void 0;
        }
        cb = once(cb);
        this.getStream((err, stream3) => {
          function onFail(err2) {
            if (stream3) {
              try {
                stream3.destroy();
              } catch {
              }
            }
            if (!err2)
              err2 = new Error("Failed to sign data with agent");
            cb(err2);
          }
          if (err)
            return onFail(err);
          const protocol = new AgentProtocol(true);
          protocol.on("error", onFail);
          protocol.pipe(stream3).pipe(protocol);
          stream3.on("close", onFail).on("end", onFail).on("error", onFail);
          protocol.sign(pubKey, data, options, (err2, sig) => {
            if (err2)
              return onFail(err2);
            try {
              stream3.destroy();
            } catch {
            }
            cb(null, sig);
          });
        });
      }
    };
    var PageantAgent = (() => {
      const RET_ERR_BADARGS = 10;
      const RET_ERR_UNAVAILABLE = 11;
      const RET_ERR_NOMAP = 12;
      const RET_ERR_BINSTDIN = 13;
      const RET_ERR_BINSTDOUT = 14;
      const RET_ERR_BADLEN = 15;
      const EXEPATH = resolve2(__dirname, "..", "util/pagent.exe");
      const ERROR = {
        [RET_ERR_BADARGS]: new Error("Invalid pagent.exe arguments"),
        [RET_ERR_UNAVAILABLE]: new Error("Pageant is not running"),
        [RET_ERR_NOMAP]: new Error("pagent.exe could not create an mmap"),
        [RET_ERR_BINSTDIN]: new Error("pagent.exe could not set mode for stdin"),
        [RET_ERR_BINSTDOUT]: new Error("pagent.exe could not set mode for stdout"),
        [RET_ERR_BADLEN]: new Error("pagent.exe did not get expected input payload")
      };
      function destroy2(stream3) {
        stream3.buffer = null;
        if (stream3.proc) {
          stream3.proc.kill();
          stream3.proc = void 0;
        }
      }
      class PageantSocket extends Duplex {
        constructor() {
          super();
          this.proc = void 0;
          this.buffer = null;
        }
        _read(n) {
        }
        _write(data, encoding, cb) {
          if (this.buffer === null) {
            this.buffer = data;
          } else {
            const newBuffer = Buffer.allocUnsafe(this.buffer.length + data.length);
            this.buffer.copy(newBuffer, 0);
            data.copy(newBuffer, this.buffer.length);
            this.buffer = newBuffer;
          }
          if (this.buffer.length < 4)
            return cb();
          const len = readUInt32BE(this.buffer, 0);
          if (this.buffer.length - 4 < len)
            return cb();
          data = this.buffer.slice(0, 4 + len);
          if (this.buffer.length > 4 + len)
            return cb(new Error("Unexpected multiple agent requests"));
          this.buffer = null;
          let error4;
          const proc = this.proc = spawn4(EXEPATH, [data.length]);
          proc.stdout.on("data", (data2) => {
            this.push(data2);
          });
          proc.on("error", (err) => {
            error4 = err;
            cb(error4);
          });
          proc.on("close", (code) => {
            this.proc = void 0;
            if (!error4) {
              if (error4 = ERROR[code])
                return cb(error4);
              cb();
            }
          });
          proc.stdin.end(data);
        }
        _final(cb) {
          destroy2(this);
          cb();
        }
        _destroy(err, cb) {
          destroy2(this);
          cb();
        }
      }
      return class PageantAgent extends OpenSSHAgent {
        getStream(cb) {
          cb(null, new PageantSocket());
        }
      };
    })();
    var CygwinAgent = (() => {
      const RE_CYGWIN_SOCK = /^!<socket >(\d+) s ([A-Z0-9]{8}-[A-Z0-9]{8}-[A-Z0-9]{8}-[A-Z0-9]{8})/;
      return class CygwinAgent extends OpenSSHAgent {
        getStream(cb) {
          cb = once(cb);
          let socketPath = this.socketPath;
          let triedCygpath = false;
          readFile4(socketPath, function readCygsocket(err, data) {
            if (err) {
              if (triedCygpath)
                return cb(new Error("Invalid cygwin unix socket path"));
              execFile("cygpath", ["-w", socketPath], (err2, stdout3, stderr3) => {
                if (err2 || stdout3.length === 0)
                  return cb(new Error("Invalid cygwin unix socket path"));
                triedCygpath = true;
                socketPath = stdout3.toString().replace(/[\r\n]/g, "");
                readFile4(socketPath, readCygsocket);
              });
              return;
            }
            const m = RE_CYGWIN_SOCK.exec(data.toString("ascii"));
            if (!m)
              return cb(new Error("Malformed cygwin unix socket file"));
            let state2;
            let bc = 0;
            let isRetrying = false;
            const inBuf = [];
            let sock;
            let credsBuf = Buffer.alloc(12);
            const port = parseInt(m[1], 10);
            const secret = m[2].replace(/-/g, "");
            const secretBuf = Buffer.allocUnsafe(16);
            for (let i = 0, j = 0; j < 32; ++i, j += 2)
              secretBuf[i] = parseInt(secret.substring(j, j + 2), 16);
            for (let i = 0; i < 16; i += 4)
              writeUInt32LE(secretBuf, readUInt32BE(secretBuf, i), i);
            tryConnect();
            function _onconnect() {
              bc = 0;
              state2 = "secret";
              sock.write(secretBuf);
            }
            function _ondata(data2) {
              bc += data2.length;
              if (state2 === "secret") {
                if (bc === 16) {
                  bc = 0;
                  state2 = "creds";
                  sock.write(credsBuf);
                }
                return;
              }
              if (state2 === "creds") {
                if (!isRetrying)
                  inBuf.push(data2);
                if (bc === 12) {
                  sock.removeListener("connect", _onconnect);
                  sock.removeListener("data", _ondata);
                  sock.removeListener("error", onFail);
                  sock.removeListener("end", onFail);
                  sock.removeListener("close", onFail);
                  if (isRetrying)
                    return cb(null, sock);
                  isRetrying = true;
                  credsBuf = Buffer.concat(inBuf);
                  writeUInt32LE(credsBuf, process.pid, 0);
                  sock.on("error", () => {
                  });
                  sock.destroy();
                  tryConnect();
                }
              }
            }
            function onFail() {
              cb(new Error("Problem negotiating cygwin unix socket security"));
            }
            function tryConnect() {
              sock = new Socket();
              sock.on("connect", _onconnect);
              sock.on("data", _ondata);
              sock.on("error", onFail);
              sock.on("end", onFail);
              sock.on("close", onFail);
              sock.connect(port);
            }
          });
        }
      };
    })();
    var WINDOWS_PIPE_REGEX = /^[/\\][/\\]\.[/\\]pipe[/\\].+/;
    function createAgent(path5) {
      if (process.platform === "win32" && !WINDOWS_PIPE_REGEX.test(path5)) {
        return path5 === "pageant" ? new PageantAgent() : new CygwinAgent(path5);
      }
      return new OpenSSHAgent(path5);
    }
    var AgentProtocol = (() => {
      const SSH_AGENTC_REQUEST_IDENTITIES = 11;
      const SSH_AGENTC_SIGN_REQUEST = 13;
      const SSH_AGENT_FAILURE = 5;
      const SSH_AGENT_IDENTITIES_ANSWER = 12;
      const SSH_AGENT_SIGN_RESPONSE = 14;
      const SSH_AGENT_RSA_SHA2_256 = 1 << 1;
      const SSH_AGENT_RSA_SHA2_512 = 1 << 2;
      const ROLE_CLIENT = 0;
      const ROLE_SERVER = 1;
      function processResponses(protocol) {
        let ret;
        while (protocol[SYM_REQS].length) {
          const nextResponse = protocol[SYM_REQS][0][SYM_RESP];
          if (nextResponse === void 0)
            break;
          protocol[SYM_REQS].shift();
          ret = protocol.push(nextResponse);
        }
        return ret;
      }
      const SYM_TYPE = Symbol("Inbound Request Type");
      const SYM_RESP = Symbol("Inbound Request Response");
      const SYM_CTX = Symbol("Inbound Request Context");
      class AgentInboundRequest {
        constructor(type, ctx) {
          this[SYM_TYPE] = type;
          this[SYM_RESP] = void 0;
          this[SYM_CTX] = ctx;
        }
        hasResponded() {
          return this[SYM_RESP] !== void 0;
        }
        getType() {
          return this[SYM_TYPE];
        }
        getContext() {
          return this[SYM_CTX];
        }
      }
      function respond(protocol, req, data) {
        req[SYM_RESP] = data;
        return processResponses(protocol);
      }
      function cleanup(protocol) {
        protocol[SYM_BUFFER] = null;
        if (protocol[SYM_MODE] === ROLE_CLIENT) {
          const reqs = protocol[SYM_REQS];
          if (reqs && reqs.length) {
            protocol[SYM_REQS] = [];
            for (const req of reqs)
              req.cb(new Error("No reply from server"));
          }
        }
        try {
          protocol.end();
        } catch {
        }
        setImmediate(() => {
          if (!protocol[SYM_ENDED])
            protocol.emit("end");
          if (!protocol[SYM_CLOSED])
            protocol.emit("close");
        });
      }
      function onClose3() {
        this[SYM_CLOSED] = true;
      }
      function onEnd2() {
        this[SYM_ENDED] = true;
      }
      const SYM_REQS = Symbol("Requests");
      const SYM_MODE = Symbol("Agent Protocol Role");
      const SYM_BUFFER = Symbol("Agent Protocol Buffer");
      const SYM_MSGLEN = Symbol("Agent Protocol Current Message Length");
      const SYM_CLOSED = Symbol("Agent Protocol Closed");
      const SYM_ENDED = Symbol("Agent Protocol Ended");
      return class AgentProtocol extends Duplex {
        /*
            Notes:
              - `constraint` type consists of:
                   byte                    constraint_type
                   byte[]                  constraint_data
                where `constraint_type` is one of:
                  * SSH_AGENT_CONSTRAIN_LIFETIME
                    - `constraint_data` consists of:
                         uint32                  seconds
                  * SSH_AGENT_CONSTRAIN_CONFIRM
                    - `constraint_data` N/A
                  * SSH_AGENT_CONSTRAIN_EXTENSION
                    - `constraint_data` consists of:
                         string                  extension name
                         byte[]                  extension-specific details
        */
        constructor(isClient) {
          super({ autoDestroy: true, emitClose: false });
          this[SYM_MODE] = isClient ? ROLE_CLIENT : ROLE_SERVER;
          this[SYM_REQS] = [];
          this[SYM_BUFFER] = null;
          this[SYM_MSGLEN] = -1;
          this.once("end", onEnd2);
          this.once("close", onClose3);
        }
        _read(n) {
        }
        _write(data, encoding, cb) {
          if (this[SYM_BUFFER] === null)
            this[SYM_BUFFER] = data;
          else
            this[SYM_BUFFER] = concat6(this[SYM_BUFFER], data);
          let buffer = this[SYM_BUFFER];
          let bufferLen = buffer.length;
          let p = 0;
          while (p < bufferLen) {
            if (bufferLen < 5)
              break;
            if (this[SYM_MSGLEN] === -1)
              this[SYM_MSGLEN] = readUInt32BE(buffer, p);
            if (bufferLen < 4 + this[SYM_MSGLEN])
              break;
            const msgType = buffer[p += 4];
            ++p;
            if (this[SYM_MODE] === ROLE_CLIENT) {
              if (this[SYM_REQS].length === 0)
                return cb(new Error("Received unexpected message from server"));
              const req = this[SYM_REQS].shift();
              switch (msgType) {
                case SSH_AGENT_FAILURE:
                  req.cb(new Error("Agent responded with failure"));
                  break;
                case SSH_AGENT_IDENTITIES_ANSWER: {
                  if (req.type !== SSH_AGENTC_REQUEST_IDENTITIES)
                    return cb(new Error("Agent responded with wrong message type"));
                  binaryParser.init(buffer, p);
                  const numKeys = binaryParser.readUInt32BE();
                  if (numKeys === void 0) {
                    binaryParser.clear();
                    return cb(new Error("Malformed agent response"));
                  }
                  const keys4 = [];
                  for (let i = 0; i < numKeys; ++i) {
                    let pubKey = binaryParser.readString();
                    if (pubKey === void 0) {
                      binaryParser.clear();
                      return cb(new Error("Malformed agent response"));
                    }
                    const comment2 = binaryParser.readString(true);
                    if (comment2 === void 0) {
                      binaryParser.clear();
                      return cb(new Error("Malformed agent response"));
                    }
                    pubKey = parseKey(pubKey);
                    if (pubKey instanceof Error)
                      continue;
                    pubKey.comment = pubKey.comment || comment2;
                    keys4.push(pubKey);
                  }
                  p = binaryParser.pos();
                  binaryParser.clear();
                  req.cb(null, keys4);
                  break;
                }
                case SSH_AGENT_SIGN_RESPONSE: {
                  if (req.type !== SSH_AGENTC_SIGN_REQUEST)
                    return cb(new Error("Agent responded with wrong message type"));
                  binaryParser.init(buffer, p);
                  let signature = binaryParser.readString();
                  p = binaryParser.pos();
                  binaryParser.clear();
                  if (signature === void 0)
                    return cb(new Error("Malformed agent response"));
                  binaryParser.init(signature, 0);
                  binaryParser.readString(true);
                  signature = binaryParser.readString();
                  binaryParser.clear();
                  if (signature === void 0)
                    return cb(new Error("Malformed OpenSSH signature format"));
                  req.cb(null, signature);
                  break;
                }
                default:
                  return cb(
                    new Error("Agent responded with unsupported message type")
                  );
              }
            } else {
              switch (msgType) {
                case SSH_AGENTC_REQUEST_IDENTITIES: {
                  const req = new AgentInboundRequest(msgType);
                  this[SYM_REQS].push(req);
                  this.emit("identities", req);
                  break;
                }
                case SSH_AGENTC_SIGN_REQUEST: {
                  binaryParser.init(buffer, p);
                  let pubKey = binaryParser.readString();
                  const data2 = binaryParser.readString();
                  const flagsVal = binaryParser.readUInt32BE();
                  p = binaryParser.pos();
                  binaryParser.clear();
                  if (flagsVal === void 0) {
                    const req2 = new AgentInboundRequest(msgType);
                    this[SYM_REQS].push(req2);
                    return this.failureReply(req2);
                  }
                  pubKey = parseKey(pubKey);
                  if (pubKey instanceof Error) {
                    const req2 = new AgentInboundRequest(msgType);
                    this[SYM_REQS].push(req2);
                    return this.failureReply(req2);
                  }
                  const flags = {
                    hash: void 0
                  };
                  let ctx;
                  if (pubKey.type === "ssh-rsa") {
                    if (flagsVal & SSH_AGENT_RSA_SHA2_256) {
                      ctx = "rsa-sha2-256";
                      flags.hash = "sha256";
                    } else if (flagsVal & SSH_AGENT_RSA_SHA2_512) {
                      ctx = "rsa-sha2-512";
                      flags.hash = "sha512";
                    }
                  }
                  if (ctx === void 0)
                    ctx = pubKey.type;
                  const req = new AgentInboundRequest(msgType, ctx);
                  this[SYM_REQS].push(req);
                  this.emit("sign", req, pubKey, data2, flags);
                  break;
                }
                default: {
                  const req = new AgentInboundRequest(msgType);
                  this[SYM_REQS].push(req);
                  this.failureReply(req);
                }
              }
            }
            this[SYM_MSGLEN] = -1;
            if (p === bufferLen) {
              this[SYM_BUFFER] = null;
              break;
            } else {
              this[SYM_BUFFER] = buffer = buffer.slice(p);
              bufferLen = buffer.length;
              p = 0;
            }
          }
          cb();
        }
        _destroy(err, cb) {
          cleanup(this);
          cb();
        }
        _final(cb) {
          cleanup(this);
          cb();
        }
        // Client->Server messages =================================================
        sign(pubKey, data, options, cb) {
          if (this[SYM_MODE] !== ROLE_CLIENT)
            throw new Error("Client-only method called with server role");
          if (typeof options === "function") {
            cb = options;
            options = void 0;
          } else if (typeof options !== "object" || options === null) {
            options = void 0;
          }
          let flags = 0;
          pubKey = parseKey(pubKey);
          if (pubKey instanceof Error)
            throw new Error("Invalid public key argument");
          if (pubKey.type === "ssh-rsa" && options) {
            switch (options.hash) {
              case "sha256":
                flags = SSH_AGENT_RSA_SHA2_256;
                break;
              case "sha512":
                flags = SSH_AGENT_RSA_SHA2_512;
                break;
            }
          }
          pubKey = pubKey.getPublicSSH();
          const type = SSH_AGENTC_SIGN_REQUEST;
          const keyLen = pubKey.length;
          const dataLen = data.length;
          let p = 0;
          const buf = Buffer.allocUnsafe(4 + 1 + 4 + keyLen + 4 + dataLen + 4);
          writeUInt32BE(buf, buf.length - 4, p);
          buf[p += 4] = type;
          writeUInt32BE(buf, keyLen, ++p);
          pubKey.copy(buf, p += 4);
          writeUInt32BE(buf, dataLen, p += keyLen);
          data.copy(buf, p += 4);
          writeUInt32BE(buf, flags, p += dataLen);
          if (typeof cb !== "function")
            cb = noop;
          this[SYM_REQS].push({ type, cb });
          return this.push(buf);
        }
        getIdentities(cb) {
          if (this[SYM_MODE] !== ROLE_CLIENT)
            throw new Error("Client-only method called with server role");
          const type = SSH_AGENTC_REQUEST_IDENTITIES;
          let p = 0;
          const buf = Buffer.allocUnsafe(4 + 1);
          writeUInt32BE(buf, buf.length - 4, p);
          buf[p += 4] = type;
          if (typeof cb !== "function")
            cb = noop;
          this[SYM_REQS].push({ type, cb });
          return this.push(buf);
        }
        // Server->Client messages =================================================
        failureReply(req) {
          if (this[SYM_MODE] !== ROLE_SERVER)
            throw new Error("Server-only method called with client role");
          if (!(req instanceof AgentInboundRequest))
            throw new Error("Wrong request argument");
          if (req.hasResponded())
            return true;
          let p = 0;
          const buf = Buffer.allocUnsafe(4 + 1);
          writeUInt32BE(buf, buf.length - 4, p);
          buf[p += 4] = SSH_AGENT_FAILURE;
          return respond(this, req, buf);
        }
        getIdentitiesReply(req, keys4) {
          if (this[SYM_MODE] !== ROLE_SERVER)
            throw new Error("Server-only method called with client role");
          if (!(req instanceof AgentInboundRequest))
            throw new Error("Wrong request argument");
          if (req.hasResponded())
            return true;
          if (req.getType() !== SSH_AGENTC_REQUEST_IDENTITIES)
            throw new Error("Invalid response to request");
          if (!Array.isArray(keys4))
            throw new Error("Keys argument must be an array");
          let totalKeysLen = 4;
          const newKeys = [];
          for (let i = 0; i < keys4.length; ++i) {
            const entry = keys4[i];
            if (typeof entry !== "object" || entry === null)
              throw new Error(`Invalid key entry: ${entry}`);
            let pubKey;
            let comment2;
            if (isParsedKey(entry)) {
              pubKey = entry;
            } else if (isParsedKey(entry.pubKey)) {
              pubKey = entry.pubKey;
            } else {
              if (typeof entry.pubKey !== "object" || entry.pubKey === null)
                continue;
              ({ pubKey, comment: comment2 } = entry.pubKey);
              pubKey = parseKey(pubKey);
              if (pubKey instanceof Error)
                continue;
            }
            comment2 = pubKey.comment || comment2;
            pubKey = pubKey.getPublicSSH();
            totalKeysLen += 4 + pubKey.length;
            if (comment2 && typeof comment2 === "string")
              comment2 = Buffer.from(comment2);
            else if (!Buffer.isBuffer(comment2))
              comment2 = EMPTY_BUF;
            totalKeysLen += 4 + comment2.length;
            newKeys.push({ pubKey, comment: comment2 });
          }
          let p = 0;
          const buf = Buffer.allocUnsafe(4 + 1 + totalKeysLen);
          writeUInt32BE(buf, buf.length - 4, p);
          buf[p += 4] = SSH_AGENT_IDENTITIES_ANSWER;
          writeUInt32BE(buf, newKeys.length, ++p);
          p += 4;
          for (let i = 0; i < newKeys.length; ++i) {
            const { pubKey, comment: comment2 } = newKeys[i];
            writeUInt32BE(buf, pubKey.length, p);
            pubKey.copy(buf, p += 4);
            writeUInt32BE(buf, comment2.length, p += pubKey.length);
            p += 4;
            if (comment2.length) {
              comment2.copy(buf, p);
              p += comment2.length;
            }
          }
          return respond(this, req, buf);
        }
        signReply(req, signature) {
          if (this[SYM_MODE] !== ROLE_SERVER)
            throw new Error("Server-only method called with client role");
          if (!(req instanceof AgentInboundRequest))
            throw new Error("Wrong request argument");
          if (req.hasResponded())
            return true;
          if (req.getType() !== SSH_AGENTC_SIGN_REQUEST)
            throw new Error("Invalid response to request");
          if (!Buffer.isBuffer(signature))
            throw new Error("Signature argument must be a Buffer");
          if (signature.length === 0)
            throw new Error("Signature argument must be non-empty");
          let p = 0;
          const sigFormat = req.getContext();
          const sigFormatLen = Buffer.byteLength(sigFormat);
          const buf = Buffer.allocUnsafe(
            4 + 1 + 4 + 4 + sigFormatLen + 4 + signature.length
          );
          writeUInt32BE(buf, buf.length - 4, p);
          buf[p += 4] = SSH_AGENT_SIGN_RESPONSE;
          writeUInt32BE(buf, 4 + sigFormatLen + 4 + signature.length, ++p);
          writeUInt32BE(buf, sigFormatLen, p += 4);
          buf.utf8Write(sigFormat, p += 4, sigFormatLen);
          writeUInt32BE(buf, signature.length, p += sigFormatLen);
          signature.copy(buf, p += 4);
          return respond(this, req, buf);
        }
      };
    })();
    var SYM_AGENT = Symbol("Agent");
    var SYM_AGENT_KEYS = Symbol("Agent Keys");
    var SYM_AGENT_KEYS_IDX = Symbol("Agent Keys Index");
    var SYM_AGENT_CBS = Symbol("Agent Init Callbacks");
    var AgentContext = class {
      constructor(agent) {
        if (typeof agent === "string")
          agent = createAgent(agent);
        else if (!isAgent(agent))
          throw new Error("Invalid agent argument");
        this[SYM_AGENT] = agent;
        this[SYM_AGENT_KEYS] = null;
        this[SYM_AGENT_KEYS_IDX] = -1;
        this[SYM_AGENT_CBS] = null;
      }
      init(cb) {
        if (typeof cb !== "function")
          cb = noop;
        if (this[SYM_AGENT_KEYS] === null) {
          if (this[SYM_AGENT_CBS] === null) {
            this[SYM_AGENT_CBS] = [cb];
            const doCbs = (...args) => {
              process.nextTick(() => {
                const cbs = this[SYM_AGENT_CBS];
                this[SYM_AGENT_CBS] = null;
                for (const cb2 of cbs)
                  cb2(...args);
              });
            };
            this[SYM_AGENT].getIdentities(once((err, keys4) => {
              if (err)
                return doCbs(err);
              if (!Array.isArray(keys4)) {
                return doCbs(new Error(
                  "Agent implementation failed to provide keys"
                ));
              }
              const newKeys = [];
              for (let key of keys4) {
                key = parseKey(key);
                if (key instanceof Error) {
                  continue;
                }
                newKeys.push(key);
              }
              this[SYM_AGENT_KEYS] = newKeys;
              this[SYM_AGENT_KEYS_IDX] = -1;
              doCbs();
            }));
          } else {
            this[SYM_AGENT_CBS].push(cb);
          }
        } else {
          process.nextTick(cb);
        }
      }
      nextKey() {
        if (this[SYM_AGENT_KEYS] === null || ++this[SYM_AGENT_KEYS_IDX] >= this[SYM_AGENT_KEYS].length) {
          return false;
        }
        return this[SYM_AGENT_KEYS][this[SYM_AGENT_KEYS_IDX]];
      }
      currentKey() {
        if (this[SYM_AGENT_KEYS] === null || this[SYM_AGENT_KEYS_IDX] >= this[SYM_AGENT_KEYS].length) {
          return null;
        }
        return this[SYM_AGENT_KEYS][this[SYM_AGENT_KEYS_IDX]];
      }
      pos() {
        if (this[SYM_AGENT_KEYS] === null || this[SYM_AGENT_KEYS_IDX] >= this[SYM_AGENT_KEYS].length) {
          return -1;
        }
        return this[SYM_AGENT_KEYS_IDX];
      }
      reset() {
        this[SYM_AGENT_KEYS_IDX] = -1;
      }
      sign(...args) {
        this[SYM_AGENT].sign(...args);
      }
    };
    function isAgent(val) {
      return val instanceof BaseAgent;
    }
    module.exports = {
      AgentContext,
      AgentProtocol,
      BaseAgent,
      createAgent,
      CygwinAgent,
      isAgent,
      OpenSSHAgent,
      PageantAgent
    };
  }
});

// node_modules/ssh2/lib/protocol/zlib.js
var require_zlib = __commonJS({
  "node_modules/ssh2/lib/protocol/zlib.js"(exports, module) {
    "use strict";
    var { kMaxLength } = __require("buffer");
    var {
      createInflate,
      constants: {
        DEFLATE,
        INFLATE,
        Z_DEFAULT_CHUNK,
        Z_DEFAULT_COMPRESSION,
        Z_DEFAULT_MEMLEVEL,
        Z_DEFAULT_STRATEGY,
        Z_DEFAULT_WINDOWBITS,
        Z_PARTIAL_FLUSH
      }
    } = __require("zlib");
    var ZlibHandle = createInflate()._handle.constructor;
    function processCallback() {
      throw new Error("Should not get here");
    }
    function zlibOnError(message2, errno, code) {
      const self2 = this._owner;
      const error4 = new Error(message2);
      error4.errno = errno;
      error4.code = code;
      self2._err = error4;
    }
    function _close(engine) {
      if (!engine._handle)
        return;
      engine._handle.close();
      engine._handle = null;
    }
    var Zlib = class {
      constructor(mode) {
        const windowBits = Z_DEFAULT_WINDOWBITS;
        const level = Z_DEFAULT_COMPRESSION;
        const memLevel = Z_DEFAULT_MEMLEVEL;
        const strategy = Z_DEFAULT_STRATEGY;
        const dictionary = void 0;
        this._err = void 0;
        this._writeState = new Uint32Array(2);
        this._chunkSize = Z_DEFAULT_CHUNK;
        this._maxOutputLength = kMaxLength;
        this._outBuffer = Buffer.allocUnsafe(this._chunkSize);
        this._outOffset = 0;
        this._handle = new ZlibHandle(mode);
        this._handle._owner = this;
        this._handle.onerror = zlibOnError;
        this._handle.init(
          windowBits,
          level,
          memLevel,
          strategy,
          this._writeState,
          processCallback,
          dictionary
        );
      }
      writeSync(chunk, retChunks) {
        const handle = this._handle;
        if (!handle)
          throw new Error("Invalid Zlib instance");
        let availInBefore = chunk.length;
        let availOutBefore = this._chunkSize - this._outOffset;
        let inOff = 0;
        let availOutAfter;
        let availInAfter;
        let buffers;
        let nread = 0;
        const state2 = this._writeState;
        let buffer = this._outBuffer;
        let offset = this._outOffset;
        const chunkSize = this._chunkSize;
        while (true) {
          handle.writeSync(
            Z_PARTIAL_FLUSH,
            chunk,
            // in
            inOff,
            // in_off
            availInBefore,
            // in_len
            buffer,
            // out
            offset,
            // out_off
            availOutBefore
          );
          if (this._err)
            throw this._err;
          availOutAfter = state2[0];
          availInAfter = state2[1];
          const inDelta = availInBefore - availInAfter;
          const have = availOutBefore - availOutAfter;
          if (have > 0) {
            const out = offset === 0 && have === buffer.length ? buffer : buffer.slice(offset, offset + have);
            offset += have;
            if (!buffers)
              buffers = out;
            else if (buffers.push === void 0)
              buffers = [buffers, out];
            else
              buffers.push(out);
            nread += out.byteLength;
            if (nread > this._maxOutputLength) {
              _close(this);
              throw new Error(
                `Output length exceeded maximum of ${this._maxOutputLength}`
              );
            }
          } else if (have !== 0) {
            throw new Error("have should not go down");
          }
          if (availOutAfter === 0 || offset >= chunkSize) {
            availOutBefore = chunkSize;
            offset = 0;
            buffer = Buffer.allocUnsafe(chunkSize);
          }
          if (availOutAfter === 0) {
            inOff += inDelta;
            availInBefore = availInAfter;
          } else {
            break;
          }
        }
        this._outBuffer = buffer;
        this._outOffset = offset;
        if (nread === 0)
          buffers = Buffer.alloc(0);
        if (retChunks) {
          buffers.totalLen = nread;
          return buffers;
        }
        if (buffers.push === void 0)
          return buffers;
        const output5 = Buffer.allocUnsafe(nread);
        for (let i = 0, p = 0; i < buffers.length; ++i) {
          const buf = buffers[i];
          output5.set(buf, p);
          p += buf.length;
        }
        return output5;
      }
    };
    var ZlibPacketWriter = class {
      constructor(protocol) {
        this.allocStart = 0;
        this.allocStartKEX = 0;
        this._protocol = protocol;
        this._zlib = new Zlib(DEFLATE);
      }
      cleanup() {
        if (this._zlib)
          _close(this._zlib);
      }
      alloc(payloadSize, force2) {
        return Buffer.allocUnsafe(payloadSize);
      }
      finalize(payload, force2) {
        if (this._protocol._kexinit === void 0 || force2) {
          const output5 = this._zlib.writeSync(payload, true);
          const packet = this._protocol._cipher.allocPacket(output5.totalLen);
          if (output5.push === void 0) {
            packet.set(output5, 5);
          } else {
            for (let i = 0, p = 5; i < output5.length; ++i) {
              const chunk = output5[i];
              packet.set(chunk, p);
              p += chunk.length;
            }
          }
          return packet;
        }
        return payload;
      }
    };
    var PacketWriter = class {
      constructor(protocol) {
        this.allocStart = 5;
        this.allocStartKEX = 5;
        this._protocol = protocol;
      }
      cleanup() {
      }
      alloc(payloadSize, force2) {
        if (this._protocol._kexinit === void 0 || force2)
          return this._protocol._cipher.allocPacket(payloadSize);
        return Buffer.allocUnsafe(payloadSize);
      }
      finalize(packet, force2) {
        return packet;
      }
    };
    var ZlibPacketReader = class {
      constructor() {
        this._zlib = new Zlib(INFLATE);
      }
      cleanup() {
        if (this._zlib)
          _close(this._zlib);
      }
      read(data) {
        return this._zlib.writeSync(data, false);
      }
    };
    var PacketReader = class {
      cleanup() {
      }
      read(data) {
        return data;
      }
    };
    module.exports = {
      PacketReader,
      PacketWriter,
      ZlibPacketReader,
      ZlibPacketWriter
    };
  }
});

// node_modules/ssh2/lib/protocol/handlers.misc.js
var require_handlers_misc = __commonJS({
  "node_modules/ssh2/lib/protocol/handlers.misc.js"(exports, module) {
    "use strict";
    var {
      bufferSlice,
      bufferParser,
      doFatalError,
      sigSSHToASN1,
      writeUInt32BE
    } = require_utils7();
    var {
      CHANNEL_OPEN_FAILURE,
      COMPAT,
      MESSAGE,
      TERMINAL_MODE
    } = require_constants5();
    var {
      parseKey
    } = require_keyParser();
    var TERMINAL_MODE_BY_VALUE = Array.from(Object.entries(TERMINAL_MODE)).reduce((obj, [key, value4]) => ({ ...obj, [key]: value4 }), {});
    module.exports = {
      // Transport layer protocol ==================================================
      [MESSAGE.DISCONNECT]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const reason = bufferParser.readUInt32BE();
        const desc = bufferParser.readString(true);
        const lang = bufferParser.readString();
        bufferParser.clear();
        if (lang === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed DISCONNECT packet"
          );
        }
        self2._debug && self2._debug(
          `Inbound: Received DISCONNECT (${reason}, "${desc}")`
        );
        const handler = self2._handlers.DISCONNECT;
        handler && handler(self2, reason, desc);
      },
      [MESSAGE.IGNORE]: (self2, payload) => {
        self2._debug && self2._debug("Inbound: Received IGNORE");
      },
      [MESSAGE.UNIMPLEMENTED]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const seqno = bufferParser.readUInt32BE();
        bufferParser.clear();
        if (seqno === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed UNIMPLEMENTED packet"
          );
        }
        self2._debug && self2._debug(`Inbound: Received UNIMPLEMENTED (seqno ${seqno})`);
      },
      [MESSAGE.DEBUG]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const display = bufferParser.readBool();
        const msg = bufferParser.readString(true);
        const lang = bufferParser.readString();
        bufferParser.clear();
        if (lang === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed DEBUG packet"
          );
        }
        self2._debug && self2._debug("Inbound: Received DEBUG");
        const handler = self2._handlers.DEBUG;
        handler && handler(self2, display, msg);
      },
      [MESSAGE.SERVICE_REQUEST]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const name4 = bufferParser.readString(true);
        bufferParser.clear();
        if (name4 === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed SERVICE_REQUEST packet"
          );
        }
        self2._debug && self2._debug(`Inbound: Received SERVICE_REQUEST (${name4})`);
        const handler = self2._handlers.SERVICE_REQUEST;
        handler && handler(self2, name4);
      },
      [MESSAGE.SERVICE_ACCEPT]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const name4 = bufferParser.readString(true);
        bufferParser.clear();
        if (name4 === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed SERVICE_ACCEPT packet"
          );
        }
        self2._debug && self2._debug(`Inbound: Received SERVICE_ACCEPT (${name4})`);
        const handler = self2._handlers.SERVICE_ACCEPT;
        handler && handler(self2, name4);
      },
      [MESSAGE.EXT_INFO]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const numExts = bufferParser.readUInt32BE();
        let exts;
        if (numExts !== void 0) {
          exts = [];
          for (let i = 0; i < numExts; ++i) {
            const name4 = bufferParser.readString(true);
            const data = bufferParser.readString();
            if (data !== void 0) {
              switch (name4) {
                case "server-sig-algs": {
                  const algs = data.latin1Slice(0, data.length).split(",");
                  exts.push({ name: name4, algs });
                  continue;
                }
                default:
                  continue;
              }
            }
            exts = void 0;
            break;
          }
        }
        bufferParser.clear();
        if (exts === void 0)
          return doFatalError(self2, "Inbound: Malformed EXT_INFO packet");
        self2._debug && self2._debug("Inbound: Received EXT_INFO");
        const handler = self2._handlers.EXT_INFO;
        handler && handler(self2, exts);
      },
      // User auth protocol -- generic =============================================
      [MESSAGE.USERAUTH_REQUEST]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const user = bufferParser.readString(true);
        const service = bufferParser.readString(true);
        const method = bufferParser.readString(true);
        let methodData;
        let methodDesc;
        switch (method) {
          case "none":
            methodData = null;
            break;
          case "password": {
            const isChange = bufferParser.readBool();
            if (isChange !== void 0) {
              methodData = bufferParser.readString(true);
              if (methodData !== void 0 && isChange) {
                const newPassword = bufferParser.readString(true);
                if (newPassword !== void 0)
                  methodData = { oldPassword: methodData, newPassword };
                else
                  methodData = void 0;
              }
            }
            break;
          }
          case "publickey": {
            const hasSig = bufferParser.readBool();
            if (hasSig !== void 0) {
              const keyAlgo = bufferParser.readString(true);
              let realKeyAlgo = keyAlgo;
              const key = bufferParser.readString();
              let hashAlgo;
              switch (keyAlgo) {
                case "rsa-sha2-256":
                  realKeyAlgo = "ssh-rsa";
                  hashAlgo = "sha256";
                  break;
                case "rsa-sha2-512":
                  realKeyAlgo = "ssh-rsa";
                  hashAlgo = "sha512";
                  break;
              }
              if (hasSig) {
                const blobEnd = bufferParser.pos();
                let signature = bufferParser.readString();
                if (signature !== void 0) {
                  if (signature.length > 4 + keyAlgo.length + 4 && signature.utf8Slice(4, 4 + keyAlgo.length) === keyAlgo) {
                    signature = bufferSlice(signature, 4 + keyAlgo.length + 4);
                  }
                  signature = sigSSHToASN1(signature, realKeyAlgo);
                  if (signature) {
                    const sessionID = self2._kex.sessionID;
                    const blob = Buffer.allocUnsafe(4 + sessionID.length + blobEnd);
                    writeUInt32BE(blob, sessionID.length, 0);
                    blob.set(sessionID, 4);
                    blob.set(
                      new Uint8Array(payload.buffer, payload.byteOffset, blobEnd),
                      4 + sessionID.length
                    );
                    methodData = {
                      keyAlgo: realKeyAlgo,
                      key,
                      signature,
                      blob,
                      hashAlgo
                    };
                  }
                }
              } else {
                methodData = { keyAlgo: realKeyAlgo, key, hashAlgo };
                methodDesc = "publickey -- check";
              }
            }
            break;
          }
          case "hostbased": {
            const keyAlgo = bufferParser.readString(true);
            let realKeyAlgo = keyAlgo;
            const key = bufferParser.readString();
            const localHostname = bufferParser.readString(true);
            const localUsername = bufferParser.readString(true);
            let hashAlgo;
            switch (keyAlgo) {
              case "rsa-sha2-256":
                realKeyAlgo = "ssh-rsa";
                hashAlgo = "sha256";
                break;
              case "rsa-sha2-512":
                realKeyAlgo = "ssh-rsa";
                hashAlgo = "sha512";
                break;
            }
            const blobEnd = bufferParser.pos();
            let signature = bufferParser.readString();
            if (signature !== void 0) {
              if (signature.length > 4 + keyAlgo.length + 4 && signature.utf8Slice(4, 4 + keyAlgo.length) === keyAlgo) {
                signature = bufferSlice(signature, 4 + keyAlgo.length + 4);
              }
              signature = sigSSHToASN1(signature, realKeyAlgo);
              if (signature !== void 0) {
                const sessionID = self2._kex.sessionID;
                const blob = Buffer.allocUnsafe(4 + sessionID.length + blobEnd);
                writeUInt32BE(blob, sessionID.length, 0);
                blob.set(sessionID, 4);
                blob.set(
                  new Uint8Array(payload.buffer, payload.byteOffset, blobEnd),
                  4 + sessionID.length
                );
                methodData = {
                  keyAlgo: realKeyAlgo,
                  key,
                  signature,
                  blob,
                  localHostname,
                  localUsername,
                  hashAlgo
                };
              }
            }
            break;
          }
          case "keyboard-interactive":
            bufferParser.skipString();
            methodData = bufferParser.readList();
            break;
          default:
            if (method !== void 0)
              methodData = bufferParser.readRaw();
        }
        bufferParser.clear();
        if (methodData === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed USERAUTH_REQUEST packet"
          );
        }
        if (methodDesc === void 0)
          methodDesc = method;
        self2._authsQueue.push(method);
        self2._debug && self2._debug(`Inbound: Received USERAUTH_REQUEST (${methodDesc})`);
        const handler = self2._handlers.USERAUTH_REQUEST;
        handler && handler(self2, user, service, method, methodData);
      },
      [MESSAGE.USERAUTH_FAILURE]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const authMethods = bufferParser.readList();
        const partialSuccess = bufferParser.readBool();
        bufferParser.clear();
        if (partialSuccess === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed USERAUTH_FAILURE packet"
          );
        }
        self2._debug && self2._debug(`Inbound: Received USERAUTH_FAILURE (${authMethods})`);
        self2._authsQueue.shift();
        const handler = self2._handlers.USERAUTH_FAILURE;
        handler && handler(self2, authMethods, partialSuccess);
      },
      [MESSAGE.USERAUTH_SUCCESS]: (self2, payload) => {
        self2._debug && self2._debug("Inbound: Received USERAUTH_SUCCESS");
        self2._authsQueue.shift();
        const handler = self2._handlers.USERAUTH_SUCCESS;
        handler && handler(self2);
      },
      [MESSAGE.USERAUTH_BANNER]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const msg = bufferParser.readString(true);
        const lang = bufferParser.readString();
        bufferParser.clear();
        if (lang === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed USERAUTH_BANNER packet"
          );
        }
        self2._debug && self2._debug("Inbound: Received USERAUTH_BANNER");
        const handler = self2._handlers.USERAUTH_BANNER;
        handler && handler(self2, msg);
      },
      // User auth protocol -- method-specific =====================================
      60: (self2, payload) => {
        if (!self2._authsQueue.length) {
          self2._debug && self2._debug("Inbound: Received payload type 60 without auth");
          return;
        }
        switch (self2._authsQueue[0]) {
          case "password": {
            bufferParser.init(payload, 1);
            const prompt = bufferParser.readString(true);
            const lang = bufferParser.readString();
            bufferParser.clear();
            if (lang === void 0) {
              return doFatalError(
                self2,
                "Inbound: Malformed USERAUTH_PASSWD_CHANGEREQ packet"
              );
            }
            self2._debug && self2._debug("Inbound: Received USERAUTH_PASSWD_CHANGEREQ");
            const handler = self2._handlers.USERAUTH_PASSWD_CHANGEREQ;
            handler && handler(self2, prompt);
            break;
          }
          case "publickey": {
            bufferParser.init(payload, 1);
            const keyAlgo = bufferParser.readString(true);
            const key = bufferParser.readString();
            bufferParser.clear();
            if (key === void 0) {
              return doFatalError(
                self2,
                "Inbound: Malformed USERAUTH_PK_OK packet"
              );
            }
            self2._debug && self2._debug("Inbound: Received USERAUTH_PK_OK");
            self2._authsQueue.shift();
            const handler = self2._handlers.USERAUTH_PK_OK;
            handler && handler(self2, keyAlgo, key);
            break;
          }
          case "keyboard-interactive": {
            bufferParser.init(payload, 1);
            const name4 = bufferParser.readString(true);
            const instructions = bufferParser.readString(true);
            bufferParser.readString();
            const numPrompts = bufferParser.readUInt32BE();
            let prompts;
            if (numPrompts !== void 0) {
              prompts = new Array(numPrompts);
              let i;
              for (i = 0; i < numPrompts; ++i) {
                const prompt = bufferParser.readString(true);
                const echo = bufferParser.readBool();
                if (echo === void 0)
                  break;
                prompts[i] = { prompt, echo };
              }
              if (i !== numPrompts)
                prompts = void 0;
            }
            bufferParser.clear();
            if (prompts === void 0) {
              return doFatalError(
                self2,
                "Inbound: Malformed USERAUTH_INFO_REQUEST packet"
              );
            }
            self2._debug && self2._debug("Inbound: Received USERAUTH_INFO_REQUEST");
            const handler = self2._handlers.USERAUTH_INFO_REQUEST;
            handler && handler(self2, name4, instructions, prompts);
            break;
          }
          default:
            self2._debug && self2._debug("Inbound: Received unexpected payload type 60");
        }
      },
      61: (self2, payload) => {
        if (!self2._authsQueue.length) {
          self2._debug && self2._debug("Inbound: Received payload type 61 without auth");
          return;
        }
        if (self2._authsQueue[0] !== "keyboard-interactive") {
          return doFatalError(
            self2,
            "Inbound: Received unexpected payload type 61"
          );
        }
        bufferParser.init(payload, 1);
        const numResponses = bufferParser.readUInt32BE();
        let responses;
        if (numResponses !== void 0) {
          responses = new Array(numResponses);
          let i;
          for (i = 0; i < numResponses; ++i) {
            const response = bufferParser.readString(true);
            if (response === void 0)
              break;
            responses[i] = response;
          }
          if (i !== numResponses)
            responses = void 0;
        }
        bufferParser.clear();
        if (responses === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed USERAUTH_INFO_RESPONSE packet"
          );
        }
        self2._debug && self2._debug("Inbound: Received USERAUTH_INFO_RESPONSE");
        const handler = self2._handlers.USERAUTH_INFO_RESPONSE;
        handler && handler(self2, responses);
      },
      // Connection protocol -- generic ============================================
      [MESSAGE.GLOBAL_REQUEST]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const name4 = bufferParser.readString(true);
        const wantReply = bufferParser.readBool();
        let data;
        if (wantReply !== void 0) {
          switch (name4) {
            case "tcpip-forward":
            case "cancel-tcpip-forward": {
              const bindAddr = bufferParser.readString(true);
              const bindPort = bufferParser.readUInt32BE();
              if (bindPort !== void 0)
                data = { bindAddr, bindPort };
              break;
            }
            case "streamlocal-forward@openssh.com":
            case "cancel-streamlocal-forward@openssh.com": {
              const socketPath = bufferParser.readString(true);
              if (socketPath !== void 0)
                data = { socketPath };
              break;
            }
            case "no-more-sessions@openssh.com":
              data = null;
              break;
            case "hostkeys-00@openssh.com": {
              data = [];
              while (bufferParser.avail() > 0) {
                const keyRaw = bufferParser.readString();
                if (keyRaw === void 0) {
                  data = void 0;
                  break;
                }
                const key = parseKey(keyRaw);
                if (!(key instanceof Error))
                  data.push(key);
              }
              break;
            }
            default:
              data = bufferParser.readRaw();
          }
        }
        bufferParser.clear();
        if (data === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed GLOBAL_REQUEST packet"
          );
        }
        self2._debug && self2._debug(`Inbound: GLOBAL_REQUEST (${name4})`);
        const handler = self2._handlers.GLOBAL_REQUEST;
        if (handler)
          handler(self2, name4, wantReply, data);
        else
          self2.requestFailure();
      },
      [MESSAGE.REQUEST_SUCCESS]: (self2, payload) => {
        const data = payload.length > 1 ? bufferSlice(payload, 1) : null;
        self2._debug && self2._debug("Inbound: REQUEST_SUCCESS");
        const handler = self2._handlers.REQUEST_SUCCESS;
        handler && handler(self2, data);
      },
      [MESSAGE.REQUEST_FAILURE]: (self2, payload) => {
        self2._debug && self2._debug("Inbound: Received REQUEST_FAILURE");
        const handler = self2._handlers.REQUEST_FAILURE;
        handler && handler(self2);
      },
      // Connection protocol -- channel-related ====================================
      [MESSAGE.CHANNEL_OPEN]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const type = bufferParser.readString(true);
        const sender = bufferParser.readUInt32BE();
        const window2 = bufferParser.readUInt32BE();
        const packetSize = bufferParser.readUInt32BE();
        let channelInfo;
        switch (type) {
          case "forwarded-tcpip":
          case "direct-tcpip": {
            const destIP = bufferParser.readString(true);
            const destPort = bufferParser.readUInt32BE();
            const srcIP = bufferParser.readString(true);
            const srcPort = bufferParser.readUInt32BE();
            if (srcPort !== void 0) {
              channelInfo = {
                type,
                sender,
                window: window2,
                packetSize,
                data: { destIP, destPort, srcIP, srcPort }
              };
            }
            break;
          }
          case "forwarded-streamlocal@openssh.com":
          case "direct-streamlocal@openssh.com": {
            const socketPath = bufferParser.readString(true);
            if (socketPath !== void 0) {
              channelInfo = {
                type,
                sender,
                window: window2,
                packetSize,
                data: { socketPath }
              };
            }
            break;
          }
          case "x11": {
            const srcIP = bufferParser.readString(true);
            const srcPort = bufferParser.readUInt32BE();
            if (srcPort !== void 0) {
              channelInfo = {
                type,
                sender,
                window: window2,
                packetSize,
                data: { srcIP, srcPort }
              };
            }
            break;
          }
          default:
            channelInfo = {
              type,
              sender,
              window: window2,
              packetSize,
              data: {}
            };
        }
        bufferParser.clear();
        if (channelInfo === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_OPEN packet"
          );
        }
        self2._debug && self2._debug(`Inbound: CHANNEL_OPEN (s:${sender}, ${type})`);
        const handler = self2._handlers.CHANNEL_OPEN;
        if (handler) {
          handler(self2, channelInfo);
        } else {
          self2.channelOpenFail(
            channelInfo.sender,
            CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED,
            "",
            ""
          );
        }
      },
      [MESSAGE.CHANNEL_OPEN_CONFIRMATION]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const recipient = bufferParser.readUInt32BE();
        const sender = bufferParser.readUInt32BE();
        const window2 = bufferParser.readUInt32BE();
        const packetSize = bufferParser.readUInt32BE();
        const data = bufferParser.avail() ? bufferParser.readRaw() : void 0;
        bufferParser.clear();
        if (packetSize === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_OPEN_CONFIRMATION packet"
          );
        }
        self2._debug && self2._debug(
          `Inbound: CHANNEL_OPEN_CONFIRMATION (r:${recipient}, s:${sender})`
        );
        const handler = self2._handlers.CHANNEL_OPEN_CONFIRMATION;
        if (handler)
          handler(self2, { recipient, sender, window: window2, packetSize, data });
      },
      [MESSAGE.CHANNEL_OPEN_FAILURE]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const recipient = bufferParser.readUInt32BE();
        const reason = bufferParser.readUInt32BE();
        const description = bufferParser.readString(true);
        const lang = bufferParser.readString();
        bufferParser.clear();
        if (lang === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_OPEN_FAILURE packet"
          );
        }
        self2._debug && self2._debug(`Inbound: CHANNEL_OPEN_FAILURE (r:${recipient})`);
        const handler = self2._handlers.CHANNEL_OPEN_FAILURE;
        handler && handler(self2, recipient, reason, description);
      },
      [MESSAGE.CHANNEL_WINDOW_ADJUST]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const recipient = bufferParser.readUInt32BE();
        const bytesToAdd = bufferParser.readUInt32BE();
        bufferParser.clear();
        if (bytesToAdd === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_WINDOW_ADJUST packet"
          );
        }
        self2._debug && self2._debug(
          `Inbound: CHANNEL_WINDOW_ADJUST (r:${recipient}, ${bytesToAdd})`
        );
        const handler = self2._handlers.CHANNEL_WINDOW_ADJUST;
        handler && handler(self2, recipient, bytesToAdd);
      },
      [MESSAGE.CHANNEL_DATA]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const recipient = bufferParser.readUInt32BE();
        const data = bufferParser.readString();
        bufferParser.clear();
        if (data === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_DATA packet"
          );
        }
        self2._debug && self2._debug(`Inbound: CHANNEL_DATA (r:${recipient}, ${data.length})`);
        const handler = self2._handlers.CHANNEL_DATA;
        handler && handler(self2, recipient, data);
      },
      [MESSAGE.CHANNEL_EXTENDED_DATA]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const recipient = bufferParser.readUInt32BE();
        const type = bufferParser.readUInt32BE();
        const data = bufferParser.readString();
        bufferParser.clear();
        if (data === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_EXTENDED_DATA packet"
          );
        }
        self2._debug && self2._debug(
          `Inbound: CHANNEL_EXTENDED_DATA (r:${recipient}, ${data.length})`
        );
        const handler = self2._handlers.CHANNEL_EXTENDED_DATA;
        handler && handler(self2, recipient, data, type);
      },
      [MESSAGE.CHANNEL_EOF]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const recipient = bufferParser.readUInt32BE();
        bufferParser.clear();
        if (recipient === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_EOF packet"
          );
        }
        self2._debug && self2._debug(`Inbound: CHANNEL_EOF (r:${recipient})`);
        const handler = self2._handlers.CHANNEL_EOF;
        handler && handler(self2, recipient);
      },
      [MESSAGE.CHANNEL_CLOSE]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const recipient = bufferParser.readUInt32BE();
        bufferParser.clear();
        if (recipient === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_CLOSE packet"
          );
        }
        self2._debug && self2._debug(`Inbound: CHANNEL_CLOSE (r:${recipient})`);
        const handler = self2._handlers.CHANNEL_CLOSE;
        handler && handler(self2, recipient);
      },
      [MESSAGE.CHANNEL_REQUEST]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const recipient = bufferParser.readUInt32BE();
        const type = bufferParser.readString(true);
        const wantReply = bufferParser.readBool();
        let data;
        if (wantReply !== void 0) {
          switch (type) {
            case "exit-status":
              data = bufferParser.readUInt32BE();
              self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`
              );
              break;
            case "exit-signal": {
              let signal;
              let coreDumped;
              if (self2._compatFlags & COMPAT.OLD_EXIT) {
                const num = bufferParser.readUInt32BE();
                switch (num) {
                  case 1:
                    signal = "HUP";
                    break;
                  case 2:
                    signal = "INT";
                    break;
                  case 3:
                    signal = "QUIT";
                    break;
                  case 6:
                    signal = "ABRT";
                    break;
                  case 9:
                    signal = "KILL";
                    break;
                  case 14:
                    signal = "ALRM";
                    break;
                  case 15:
                    signal = "TERM";
                    break;
                  default:
                    if (num !== void 0) {
                      signal = `UNKNOWN (${num})`;
                    }
                }
                coreDumped = false;
              } else {
                signal = bufferParser.readString(true);
                coreDumped = bufferParser.readBool();
                if (coreDumped === void 0)
                  signal = void 0;
              }
              const errorMessage = bufferParser.readString(true);
              if (bufferParser.skipString() !== void 0)
                data = { signal, coreDumped, errorMessage };
              self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${signal})`
              );
              break;
            }
            case "pty-req": {
              const term = bufferParser.readString(true);
              const cols = bufferParser.readUInt32BE();
              const rows = bufferParser.readUInt32BE();
              const width2 = bufferParser.readUInt32BE();
              const height = bufferParser.readUInt32BE();
              const modesBinary = bufferParser.readString();
              if (modesBinary !== void 0) {
                bufferParser.init(modesBinary, 1);
                let modes = {};
                while (bufferParser.avail()) {
                  const opcode = bufferParser.readByte();
                  if (opcode === TERMINAL_MODE.TTY_OP_END)
                    break;
                  const name4 = TERMINAL_MODE_BY_VALUE[opcode];
                  const value4 = bufferParser.readUInt32BE();
                  if (opcode === void 0 || name4 === void 0 || value4 === void 0) {
                    modes = void 0;
                    break;
                  }
                  modes[name4] = value4;
                }
                if (modes !== void 0)
                  data = { term, cols, rows, width: width2, height, modes };
              }
              self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`
              );
              break;
            }
            case "window-change": {
              const cols = bufferParser.readUInt32BE();
              const rows = bufferParser.readUInt32BE();
              const width2 = bufferParser.readUInt32BE();
              const height = bufferParser.readUInt32BE();
              if (height !== void 0)
                data = { cols, rows, width: width2, height };
              self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`
              );
              break;
            }
            case "x11-req": {
              const single = bufferParser.readBool();
              const protocol = bufferParser.readString(true);
              const cookie = bufferParser.readString();
              const screen = bufferParser.readUInt32BE();
              if (screen !== void 0)
                data = { single, protocol, cookie, screen };
              self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`
              );
              break;
            }
            case "env": {
              const name4 = bufferParser.readString(true);
              const value4 = bufferParser.readString(true);
              if (value4 !== void 0)
                data = { name: name4, value: value4 };
              if (self2._debug) {
                self2._debug(
                  `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${name4}=${value4})`
                );
              }
              break;
            }
            case "shell":
              data = null;
              self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`
              );
              break;
            case "exec":
              data = bufferParser.readString(true);
              self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`
              );
              break;
            case "subsystem":
              data = bufferParser.readString(true);
              self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`
              );
              break;
            case "signal":
              data = bufferParser.readString(true);
              self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`
              );
              break;
            case "xon-xoff":
              data = bufferParser.readBool();
              self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`
              );
              break;
            case "auth-agent-req@openssh.com":
              data = null;
              self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`
              );
              break;
            default:
              data = bufferParser.avail() ? bufferParser.readRaw() : null;
              self2._debug && self2._debug(
                `Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`
              );
          }
        }
        bufferParser.clear();
        if (data === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_REQUEST packet"
          );
        }
        const handler = self2._handlers.CHANNEL_REQUEST;
        handler && handler(self2, recipient, type, wantReply, data);
      },
      [MESSAGE.CHANNEL_SUCCESS]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const recipient = bufferParser.readUInt32BE();
        bufferParser.clear();
        if (recipient === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_SUCCESS packet"
          );
        }
        self2._debug && self2._debug(`Inbound: CHANNEL_SUCCESS (r:${recipient})`);
        const handler = self2._handlers.CHANNEL_SUCCESS;
        handler && handler(self2, recipient);
      },
      [MESSAGE.CHANNEL_FAILURE]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const recipient = bufferParser.readUInt32BE();
        bufferParser.clear();
        if (recipient === void 0) {
          return doFatalError(
            self2,
            "Inbound: Malformed CHANNEL_FAILURE packet"
          );
        }
        self2._debug && self2._debug(`Inbound: CHANNEL_FAILURE (r:${recipient})`);
        const handler = self2._handlers.CHANNEL_FAILURE;
        handler && handler(self2, recipient);
      }
    };
  }
});

// node_modules/ssh2/lib/protocol/handlers.js
var require_handlers = __commonJS({
  "node_modules/ssh2/lib/protocol/handlers.js"(exports, module) {
    "use strict";
    var MESSAGE_HANDLERS = new Array(256);
    [
      require_kex().HANDLERS,
      require_handlers_misc()
    ].forEach((handlers) => {
      for (let [type, handler] of Object.entries(handlers)) {
        type = +type;
        if (isFinite(type) && type >= 0 && type < MESSAGE_HANDLERS.length)
          MESSAGE_HANDLERS[type] = handler;
      }
    });
    module.exports = MESSAGE_HANDLERS;
  }
});

// node_modules/ssh2/lib/protocol/kex.js
var require_kex = __commonJS({
  "node_modules/ssh2/lib/protocol/kex.js"(exports, module) {
    "use strict";
    var {
      createDiffieHellman,
      createDiffieHellmanGroup,
      createECDH,
      createHash: createHash2,
      createPublicKey,
      diffieHellman,
      generateKeyPairSync,
      randomFillSync
    } = __require("crypto");
    var { Ber } = require_lib2();
    var {
      COMPAT,
      curve25519Supported,
      DEFAULT_KEX,
      DEFAULT_SERVER_HOST_KEY,
      DEFAULT_CIPHER,
      DEFAULT_MAC,
      DEFAULT_COMPRESSION,
      DISCONNECT_REASON,
      MESSAGE
    } = require_constants5();
    var {
      CIPHER_INFO,
      createCipher,
      createDecipher,
      MAC_INFO
    } = require_crypto();
    var { parseDERKey } = require_keyParser();
    var {
      bufferFill,
      bufferParser,
      convertSignature,
      doFatalError,
      FastBuffer,
      sigSSHToASN1,
      writeUInt32BE
    } = require_utils7();
    var {
      PacketReader,
      PacketWriter,
      ZlibPacketReader,
      ZlibPacketWriter
    } = require_zlib();
    var MESSAGE_HANDLERS;
    var GEX_MIN_BITS = 2048;
    var GEX_MAX_BITS = 8192;
    var EMPTY_BUFFER = Buffer.alloc(0);
    function kexinit(self2) {
      let payload;
      if (self2._compatFlags & COMPAT.BAD_DHGEX) {
        const entry = self2._offer.lists.kex;
        let kex = entry.array;
        let found = false;
        for (let i = 0; i < kex.length; ++i) {
          if (kex[i].includes("group-exchange")) {
            if (!found) {
              found = true;
              kex = kex.slice();
            }
            kex.splice(i--, 1);
          }
        }
        if (found) {
          let len = 1 + 16 + self2._offer.totalSize + 1 + 4;
          const newKexBuf = Buffer.from(kex.join(","));
          len -= entry.buffer.length - newKexBuf.length;
          const all5 = self2._offer.lists.all;
          const rest2 = new Uint8Array(
            all5.buffer,
            all5.byteOffset + 4 + entry.buffer.length,
            all5.length - (4 + entry.buffer.length)
          );
          payload = Buffer.allocUnsafe(len);
          writeUInt32BE(payload, newKexBuf.length, 17);
          payload.set(newKexBuf, 17 + 4);
          payload.set(rest2, 17 + 4 + newKexBuf.length);
        }
      }
      if (payload === void 0) {
        payload = Buffer.allocUnsafe(1 + 16 + self2._offer.totalSize + 1 + 4);
        self2._offer.copyAllTo(payload, 17);
      }
      self2._debug && self2._debug("Outbound: Sending KEXINIT");
      payload[0] = MESSAGE.KEXINIT;
      randomFillSync(payload, 1, 16);
      bufferFill(payload, 0, payload.length - 5);
      self2._kexinit = payload;
      self2._packetRW.write.allocStart = 0;
      {
        const p = self2._packetRW.write.allocStartKEX;
        const packet = self2._packetRW.write.alloc(payload.length, true);
        packet.set(payload, p);
        self2._cipher.encrypt(self2._packetRW.write.finalize(packet, true));
      }
    }
    function handleKexInit(self2, payload) {
      const init4 = {
        kex: void 0,
        serverHostKey: void 0,
        cs: {
          cipher: void 0,
          mac: void 0,
          compress: void 0,
          lang: void 0
        },
        sc: {
          cipher: void 0,
          mac: void 0,
          compress: void 0,
          lang: void 0
        }
      };
      bufferParser.init(payload, 17);
      if ((init4.kex = bufferParser.readList()) === void 0 || (init4.serverHostKey = bufferParser.readList()) === void 0 || (init4.cs.cipher = bufferParser.readList()) === void 0 || (init4.sc.cipher = bufferParser.readList()) === void 0 || (init4.cs.mac = bufferParser.readList()) === void 0 || (init4.sc.mac = bufferParser.readList()) === void 0 || (init4.cs.compress = bufferParser.readList()) === void 0 || (init4.sc.compress = bufferParser.readList()) === void 0 || (init4.cs.lang = bufferParser.readList()) === void 0 || (init4.sc.lang = bufferParser.readList()) === void 0) {
        bufferParser.clear();
        return doFatalError(
          self2,
          "Received malformed KEXINIT",
          "handshake",
          DISCONNECT_REASON.KEY_EXCHANGE_FAILED
        );
      }
      const pos = bufferParser.pos();
      const firstFollows = pos < payload.length && payload[pos] === 1;
      bufferParser.clear();
      const local2 = self2._offer;
      const remote = init4;
      let localKex = local2.lists.kex.array;
      if (self2._compatFlags & COMPAT.BAD_DHGEX) {
        let found = false;
        for (let i2 = 0; i2 < localKex.length; ++i2) {
          if (localKex[i2].indexOf("group-exchange") !== -1) {
            if (!found) {
              found = true;
              localKex = localKex.slice();
            }
            localKex.splice(i2--, 1);
          }
        }
      }
      let clientList;
      let serverList;
      let i;
      const debug2 = self2._debug;
      debug2 && debug2("Inbound: Handshake in progress");
      debug2 && debug2(`Handshake: (local) KEX method: ${localKex}`);
      debug2 && debug2(`Handshake: (remote) KEX method: ${remote.kex}`);
      let remoteExtInfoEnabled;
      if (self2._server) {
        serverList = localKex;
        clientList = remote.kex;
        remoteExtInfoEnabled = clientList.indexOf("ext-info-c") !== -1;
      } else {
        serverList = remote.kex;
        clientList = localKex;
        remoteExtInfoEnabled = serverList.indexOf("ext-info-s") !== -1;
      }
      for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i)
        ;
      if (i === clientList.length) {
        debug2 && debug2("Handshake: No matching key exchange algorithm");
        return doFatalError(
          self2,
          "Handshake failed: no matching key exchange algorithm",
          "handshake",
          DISCONNECT_REASON.KEY_EXCHANGE_FAILED
        );
      }
      init4.kex = clientList[i];
      debug2 && debug2(`Handshake: KEX algorithm: ${clientList[i]}`);
      if (firstFollows && (!remote.kex.length || clientList[i] !== remote.kex[0])) {
        self2._skipNextInboundPacket = true;
      }
      const localSrvHostKey = local2.lists.serverHostKey.array;
      debug2 && debug2(`Handshake: (local) Host key format: ${localSrvHostKey}`);
      debug2 && debug2(
        `Handshake: (remote) Host key format: ${remote.serverHostKey}`
      );
      if (self2._server) {
        serverList = localSrvHostKey;
        clientList = remote.serverHostKey;
      } else {
        serverList = remote.serverHostKey;
        clientList = localSrvHostKey;
      }
      for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i)
        ;
      if (i === clientList.length) {
        debug2 && debug2("Handshake: No matching host key format");
        return doFatalError(
          self2,
          "Handshake failed: no matching host key format",
          "handshake",
          DISCONNECT_REASON.KEY_EXCHANGE_FAILED
        );
      }
      init4.serverHostKey = clientList[i];
      debug2 && debug2(`Handshake: Host key format: ${clientList[i]}`);
      const localCSCipher = local2.lists.cs.cipher.array;
      debug2 && debug2(`Handshake: (local) C->S cipher: ${localCSCipher}`);
      debug2 && debug2(`Handshake: (remote) C->S cipher: ${remote.cs.cipher}`);
      if (self2._server) {
        serverList = localCSCipher;
        clientList = remote.cs.cipher;
      } else {
        serverList = remote.cs.cipher;
        clientList = localCSCipher;
      }
      for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i)
        ;
      if (i === clientList.length) {
        debug2 && debug2("Handshake: No matching C->S cipher");
        return doFatalError(
          self2,
          "Handshake failed: no matching C->S cipher",
          "handshake",
          DISCONNECT_REASON.KEY_EXCHANGE_FAILED
        );
      }
      init4.cs.cipher = clientList[i];
      debug2 && debug2(`Handshake: C->S Cipher: ${clientList[i]}`);
      const localSCCipher = local2.lists.sc.cipher.array;
      debug2 && debug2(`Handshake: (local) S->C cipher: ${localSCCipher}`);
      debug2 && debug2(`Handshake: (remote) S->C cipher: ${remote.sc.cipher}`);
      if (self2._server) {
        serverList = localSCCipher;
        clientList = remote.sc.cipher;
      } else {
        serverList = remote.sc.cipher;
        clientList = localSCCipher;
      }
      for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i)
        ;
      if (i === clientList.length) {
        debug2 && debug2("Handshake: No matching S->C cipher");
        return doFatalError(
          self2,
          "Handshake failed: no matching S->C cipher",
          "handshake",
          DISCONNECT_REASON.KEY_EXCHANGE_FAILED
        );
      }
      init4.sc.cipher = clientList[i];
      debug2 && debug2(`Handshake: S->C cipher: ${clientList[i]}`);
      const localCSMAC = local2.lists.cs.mac.array;
      debug2 && debug2(`Handshake: (local) C->S MAC: ${localCSMAC}`);
      debug2 && debug2(`Handshake: (remote) C->S MAC: ${remote.cs.mac}`);
      if (CIPHER_INFO[init4.cs.cipher].authLen > 0) {
        init4.cs.mac = "";
        debug2 && debug2("Handshake: C->S MAC: <implicit>");
      } else {
        if (self2._server) {
          serverList = localCSMAC;
          clientList = remote.cs.mac;
        } else {
          serverList = remote.cs.mac;
          clientList = localCSMAC;
        }
        for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i)
          ;
        if (i === clientList.length) {
          debug2 && debug2("Handshake: No matching C->S MAC");
          return doFatalError(
            self2,
            "Handshake failed: no matching C->S MAC",
            "handshake",
            DISCONNECT_REASON.KEY_EXCHANGE_FAILED
          );
        }
        init4.cs.mac = clientList[i];
        debug2 && debug2(`Handshake: C->S MAC: ${clientList[i]}`);
      }
      const localSCMAC = local2.lists.sc.mac.array;
      debug2 && debug2(`Handshake: (local) S->C MAC: ${localSCMAC}`);
      debug2 && debug2(`Handshake: (remote) S->C MAC: ${remote.sc.mac}`);
      if (CIPHER_INFO[init4.sc.cipher].authLen > 0) {
        init4.sc.mac = "";
        debug2 && debug2("Handshake: S->C MAC: <implicit>");
      } else {
        if (self2._server) {
          serverList = localSCMAC;
          clientList = remote.sc.mac;
        } else {
          serverList = remote.sc.mac;
          clientList = localSCMAC;
        }
        for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i)
          ;
        if (i === clientList.length) {
          debug2 && debug2("Handshake: No matching S->C MAC");
          return doFatalError(
            self2,
            "Handshake failed: no matching S->C MAC",
            "handshake",
            DISCONNECT_REASON.KEY_EXCHANGE_FAILED
          );
        }
        init4.sc.mac = clientList[i];
        debug2 && debug2(`Handshake: S->C MAC: ${clientList[i]}`);
      }
      const localCSCompress = local2.lists.cs.compress.array;
      debug2 && debug2(`Handshake: (local) C->S compression: ${localCSCompress}`);
      debug2 && debug2(`Handshake: (remote) C->S compression: ${remote.cs.compress}`);
      if (self2._server) {
        serverList = localCSCompress;
        clientList = remote.cs.compress;
      } else {
        serverList = remote.cs.compress;
        clientList = localCSCompress;
      }
      for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i)
        ;
      if (i === clientList.length) {
        debug2 && debug2("Handshake: No matching C->S compression");
        return doFatalError(
          self2,
          "Handshake failed: no matching C->S compression",
          "handshake",
          DISCONNECT_REASON.KEY_EXCHANGE_FAILED
        );
      }
      init4.cs.compress = clientList[i];
      debug2 && debug2(`Handshake: C->S compression: ${clientList[i]}`);
      const localSCCompress = local2.lists.sc.compress.array;
      debug2 && debug2(`Handshake: (local) S->C compression: ${localSCCompress}`);
      debug2 && debug2(`Handshake: (remote) S->C compression: ${remote.sc.compress}`);
      if (self2._server) {
        serverList = localSCCompress;
        clientList = remote.sc.compress;
      } else {
        serverList = remote.sc.compress;
        clientList = localSCCompress;
      }
      for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i)
        ;
      if (i === clientList.length) {
        debug2 && debug2("Handshake: No matching S->C compression");
        return doFatalError(
          self2,
          "Handshake failed: no matching S->C compression",
          "handshake",
          DISCONNECT_REASON.KEY_EXCHANGE_FAILED
        );
      }
      init4.sc.compress = clientList[i];
      debug2 && debug2(`Handshake: S->C compression: ${clientList[i]}`);
      init4.cs.lang = "";
      init4.sc.lang = "";
      if (self2._kex) {
        if (!self2._kexinit) {
          kexinit(self2);
        }
        self2._decipher._onPayload = onKEXPayload.bind(self2, { firstPacket: false });
      }
      self2._kex = createKeyExchange(init4, self2, payload);
      self2._kex.remoteExtInfoEnabled = remoteExtInfoEnabled;
      self2._kex.start();
    }
    var createKeyExchange = (() => {
      function convertToMpint(buf) {
        let idx = 0;
        let length7 = buf.length;
        while (buf[idx] === 0) {
          ++idx;
          --length7;
        }
        let newBuf;
        if (buf[idx] & 128) {
          newBuf = Buffer.allocUnsafe(1 + length7);
          newBuf[0] = 0;
          buf.copy(newBuf, 1, idx);
          buf = newBuf;
        } else if (length7 !== buf.length) {
          newBuf = Buffer.allocUnsafe(length7);
          buf.copy(newBuf, 0, idx);
          buf = newBuf;
        }
        return buf;
      }
      class KeyExchange {
        constructor(negotiated, protocol, remoteKexinit) {
          this._protocol = protocol;
          this.sessionID = protocol._kex ? protocol._kex.sessionID : void 0;
          this.negotiated = negotiated;
          this.remoteExtInfoEnabled = false;
          this._step = 1;
          this._public = null;
          this._dh = null;
          this._sentNEWKEYS = false;
          this._receivedNEWKEYS = false;
          this._finished = false;
          this._hostVerified = false;
          this._kexinit = protocol._kexinit;
          this._remoteKexinit = remoteKexinit;
          this._identRaw = protocol._identRaw;
          this._remoteIdentRaw = protocol._remoteIdentRaw;
          this._hostKey = void 0;
          this._dhData = void 0;
          this._sig = void 0;
        }
        finish(scOnly) {
          if (this._finished)
            return false;
          this._finished = true;
          const isServer = this._protocol._server;
          const negotiated = this.negotiated;
          const pubKey = this.convertPublicKey(this._dhData);
          let secret = this.computeSecret(this._dhData);
          if (secret instanceof Error) {
            secret.message = `Error while computing DH secret (${this.type}): ${secret.message}`;
            secret.level = "handshake";
            return doFatalError(
              this._protocol,
              secret,
              DISCONNECT_REASON.KEY_EXCHANGE_FAILED
            );
          }
          const hash3 = createHash2(this.hashName);
          hashString4(hash3, isServer ? this._remoteIdentRaw : this._identRaw);
          hashString4(hash3, isServer ? this._identRaw : this._remoteIdentRaw);
          hashString4(hash3, isServer ? this._remoteKexinit : this._kexinit);
          hashString4(hash3, isServer ? this._kexinit : this._remoteKexinit);
          const serverPublicHostKey = isServer ? this._hostKey.getPublicSSH() : this._hostKey;
          hashString4(hash3, serverPublicHostKey);
          if (this.type === "groupex") {
            const params2 = this.getDHParams();
            const num = Buffer.allocUnsafe(4);
            writeUInt32BE(num, this._minBits, 0);
            hash3.update(num);
            writeUInt32BE(num, this._prefBits, 0);
            hash3.update(num);
            writeUInt32BE(num, this._maxBits, 0);
            hash3.update(num);
            hashString4(hash3, params2.prime);
            hashString4(hash3, params2.generator);
          }
          hashString4(hash3, isServer ? pubKey : this.getPublicKey());
          const serverPublicKey = isServer ? this.getPublicKey() : pubKey;
          hashString4(hash3, serverPublicKey);
          hashString4(hash3, secret);
          const exchangeHash = hash3.digest();
          if (!isServer) {
            bufferParser.init(this._sig, 0);
            const sigType = bufferParser.readString(true);
            if (!sigType) {
              return doFatalError(
                this._protocol,
                "Malformed packet while reading signature",
                "handshake",
                DISCONNECT_REASON.KEY_EXCHANGE_FAILED
              );
            }
            if (sigType !== negotiated.serverHostKey) {
              return doFatalError(
                this._protocol,
                `Wrong signature type: ${sigType}, expected: ${negotiated.serverHostKey}`,
                "handshake",
                DISCONNECT_REASON.KEY_EXCHANGE_FAILED
              );
            }
            let sigValue = bufferParser.readString();
            bufferParser.clear();
            if (sigValue === void 0) {
              return doFatalError(
                this._protocol,
                "Malformed packet while reading signature",
                "handshake",
                DISCONNECT_REASON.KEY_EXCHANGE_FAILED
              );
            }
            if (!(sigValue = sigSSHToASN1(sigValue, sigType))) {
              return doFatalError(
                this._protocol,
                "Malformed signature",
                "handshake",
                DISCONNECT_REASON.KEY_EXCHANGE_FAILED
              );
            }
            let parsedHostKey;
            {
              bufferParser.init(this._hostKey, 0);
              const name4 = bufferParser.readString(true);
              const hostKey = this._hostKey.slice(bufferParser.pos());
              bufferParser.clear();
              parsedHostKey = parseDERKey(hostKey, name4);
              if (parsedHostKey instanceof Error) {
                parsedHostKey.level = "handshake";
                return doFatalError(
                  this._protocol,
                  parsedHostKey,
                  DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                );
              }
            }
            let hashAlgo;
            switch (this.negotiated.serverHostKey) {
              case "rsa-sha2-256":
                hashAlgo = "sha256";
                break;
              case "rsa-sha2-512":
                hashAlgo = "sha512";
                break;
            }
            this._protocol._debug && this._protocol._debug("Verifying signature ...");
            const verified = parsedHostKey.verify(exchangeHash, sigValue, hashAlgo);
            if (verified !== true) {
              if (verified instanceof Error) {
                this._protocol._debug && this._protocol._debug(
                  `Signature verification failed: ${verified.stack}`
                );
              } else {
                this._protocol._debug && this._protocol._debug(
                  "Signature verification failed"
                );
              }
              return doFatalError(
                this._protocol,
                "Handshake failed: signature verification failed",
                "handshake",
                DISCONNECT_REASON.KEY_EXCHANGE_FAILED
              );
            }
            this._protocol._debug && this._protocol._debug("Verified signature");
          } else {
            let hashAlgo;
            switch (this.negotiated.serverHostKey) {
              case "rsa-sha2-256":
                hashAlgo = "sha256";
                break;
              case "rsa-sha2-512":
                hashAlgo = "sha512";
                break;
            }
            this._protocol._debug && this._protocol._debug(
              "Generating signature ..."
            );
            let signature = this._hostKey.sign(exchangeHash, hashAlgo);
            if (signature instanceof Error) {
              return doFatalError(
                this._protocol,
                `Handshake failed: signature generation failed for ${this._hostKey.type} host key: ${signature.message}`,
                "handshake",
                DISCONNECT_REASON.KEY_EXCHANGE_FAILED
              );
            }
            signature = convertSignature(signature, this._hostKey.type);
            if (signature === false) {
              return doFatalError(
                this._protocol,
                `Handshake failed: signature conversion failed for ${this._hostKey.type} host key`,
                "handshake",
                DISCONNECT_REASON.KEY_EXCHANGE_FAILED
              );
            }
            const sigType = this.negotiated.serverHostKey;
            const sigTypeLen = Buffer.byteLength(sigType);
            const sigLen = 4 + sigTypeLen + 4 + signature.length;
            let p = this._protocol._packetRW.write.allocStartKEX;
            const packet = this._protocol._packetRW.write.alloc(
              1 + 4 + serverPublicHostKey.length + 4 + serverPublicKey.length + 4 + sigLen,
              true
            );
            packet[p] = MESSAGE.KEXDH_REPLY;
            writeUInt32BE(packet, serverPublicHostKey.length, ++p);
            packet.set(serverPublicHostKey, p += 4);
            writeUInt32BE(
              packet,
              serverPublicKey.length,
              p += serverPublicHostKey.length
            );
            packet.set(serverPublicKey, p += 4);
            writeUInt32BE(packet, sigLen, p += serverPublicKey.length);
            writeUInt32BE(packet, sigTypeLen, p += 4);
            packet.utf8Write(sigType, p += 4, sigTypeLen);
            writeUInt32BE(packet, signature.length, p += sigTypeLen);
            packet.set(signature, p += 4);
            if (this._protocol._debug) {
              let type;
              switch (this.type) {
                case "group":
                  type = "KEXDH_REPLY";
                  break;
                case "groupex":
                  type = "KEXDH_GEX_REPLY";
                  break;
                default:
                  type = "KEXECDH_REPLY";
              }
              this._protocol._debug(`Outbound: Sending ${type}`);
            }
            this._protocol._cipher.encrypt(
              this._protocol._packetRW.write.finalize(packet, true)
            );
          }
          if (isServer || !scOnly)
            trySendNEWKEYS(this);
          let hsCipherConfig;
          let hsWrite;
          const completeHandshake = (partial) => {
            if (hsCipherConfig) {
              trySendNEWKEYS(this);
              hsCipherConfig.outbound.seqno = this._protocol._cipher.outSeqno;
              this._protocol._cipher.free();
              this._protocol._cipher = createCipher(hsCipherConfig);
              this._protocol._packetRW.write = hsWrite;
              hsCipherConfig = void 0;
              hsWrite = void 0;
              this._protocol._onHandshakeComplete(negotiated);
              return false;
            }
            if (!this.sessionID)
              this.sessionID = exchangeHash;
            {
              const newSecret = Buffer.allocUnsafe(4 + secret.length);
              writeUInt32BE(newSecret, secret.length, 0);
              newSecret.set(secret, 4);
              secret = newSecret;
            }
            const csCipherInfo = CIPHER_INFO[negotiated.cs.cipher];
            const scCipherInfo = CIPHER_INFO[negotiated.sc.cipher];
            const csIV = generateKEXVal(
              csCipherInfo.ivLen,
              this.hashName,
              secret,
              exchangeHash,
              this.sessionID,
              "A"
            );
            const scIV = generateKEXVal(
              scCipherInfo.ivLen,
              this.hashName,
              secret,
              exchangeHash,
              this.sessionID,
              "B"
            );
            const csKey = generateKEXVal(
              csCipherInfo.keyLen,
              this.hashName,
              secret,
              exchangeHash,
              this.sessionID,
              "C"
            );
            const scKey = generateKEXVal(
              scCipherInfo.keyLen,
              this.hashName,
              secret,
              exchangeHash,
              this.sessionID,
              "D"
            );
            let csMacInfo;
            let csMacKey;
            if (!csCipherInfo.authLen) {
              csMacInfo = MAC_INFO[negotiated.cs.mac];
              csMacKey = generateKEXVal(
                csMacInfo.len,
                this.hashName,
                secret,
                exchangeHash,
                this.sessionID,
                "E"
              );
            }
            let scMacInfo;
            let scMacKey;
            if (!scCipherInfo.authLen) {
              scMacInfo = MAC_INFO[negotiated.sc.mac];
              scMacKey = generateKEXVal(
                scMacInfo.len,
                this.hashName,
                secret,
                exchangeHash,
                this.sessionID,
                "F"
              );
            }
            const config = {
              inbound: {
                onPayload: this._protocol._onPayload,
                seqno: this._protocol._decipher.inSeqno,
                decipherInfo: !isServer ? scCipherInfo : csCipherInfo,
                decipherIV: !isServer ? scIV : csIV,
                decipherKey: !isServer ? scKey : csKey,
                macInfo: !isServer ? scMacInfo : csMacInfo,
                macKey: !isServer ? scMacKey : csMacKey
              },
              outbound: {
                onWrite: this._protocol._onWrite,
                seqno: this._protocol._cipher.outSeqno,
                cipherInfo: isServer ? scCipherInfo : csCipherInfo,
                cipherIV: isServer ? scIV : csIV,
                cipherKey: isServer ? scKey : csKey,
                macInfo: isServer ? scMacInfo : csMacInfo,
                macKey: isServer ? scMacKey : csMacKey
              }
            };
            this._protocol._decipher.free();
            hsCipherConfig = config;
            this._protocol._decipher = createDecipher(config);
            const rw = {
              read: void 0,
              write: void 0
            };
            switch (negotiated.cs.compress) {
              case "zlib":
                if (isServer)
                  rw.read = new ZlibPacketReader();
                else
                  rw.write = new ZlibPacketWriter(this._protocol);
                break;
              case "zlib@openssh.com":
                if (this._protocol._authenticated) {
                  if (isServer)
                    rw.read = new ZlibPacketReader();
                  else
                    rw.write = new ZlibPacketWriter(this._protocol);
                  break;
                }
              default:
                if (isServer)
                  rw.read = new PacketReader();
                else
                  rw.write = new PacketWriter(this._protocol);
            }
            switch (negotiated.sc.compress) {
              case "zlib":
                if (isServer)
                  rw.write = new ZlibPacketWriter(this._protocol);
                else
                  rw.read = new ZlibPacketReader();
                break;
              case "zlib@openssh.com":
                if (this._protocol._authenticated) {
                  if (isServer)
                    rw.write = new ZlibPacketWriter(this._protocol);
                  else
                    rw.read = new ZlibPacketReader();
                  break;
                }
              default:
                if (isServer)
                  rw.write = new PacketWriter(this._protocol);
                else
                  rw.read = new PacketReader();
            }
            this._protocol._packetRW.read.cleanup();
            this._protocol._packetRW.write.cleanup();
            this._protocol._packetRW.read = rw.read;
            hsWrite = rw.write;
            this._public = null;
            this._dh = null;
            this._kexinit = this._protocol._kexinit = void 0;
            this._remoteKexinit = void 0;
            this._identRaw = void 0;
            this._remoteIdentRaw = void 0;
            this._hostKey = void 0;
            this._dhData = void 0;
            this._sig = void 0;
            if (!partial)
              return completeHandshake();
            return false;
          };
          if (isServer || scOnly)
            this.finish = completeHandshake;
          if (!isServer)
            return completeHandshake(scOnly);
        }
        start() {
          if (!this._protocol._server) {
            if (this._protocol._debug) {
              let type;
              switch (this.type) {
                case "group":
                  type = "KEXDH_INIT";
                  break;
                default:
                  type = "KEXECDH_INIT";
              }
              this._protocol._debug(`Outbound: Sending ${type}`);
            }
            const pubKey = this.getPublicKey();
            let p = this._protocol._packetRW.write.allocStartKEX;
            const packet = this._protocol._packetRW.write.alloc(
              1 + 4 + pubKey.length,
              true
            );
            packet[p] = MESSAGE.KEXDH_INIT;
            writeUInt32BE(packet, pubKey.length, ++p);
            packet.set(pubKey, p += 4);
            this._protocol._cipher.encrypt(
              this._protocol._packetRW.write.finalize(packet, true)
            );
          }
        }
        getPublicKey() {
          this.generateKeys();
          const key = this._public;
          if (key)
            return this.convertPublicKey(key);
        }
        convertPublicKey(key) {
          let newKey;
          let idx = 0;
          let len = key.length;
          while (key[idx] === 0) {
            ++idx;
            --len;
          }
          if (key[idx] & 128) {
            newKey = Buffer.allocUnsafe(1 + len);
            newKey[0] = 0;
            key.copy(newKey, 1, idx);
            return newKey;
          }
          if (len !== key.length) {
            newKey = Buffer.allocUnsafe(len);
            key.copy(newKey, 0, idx);
            key = newKey;
          }
          return key;
        }
        computeSecret(otherPublicKey) {
          this.generateKeys();
          try {
            return convertToMpint(this._dh.computeSecret(otherPublicKey));
          } catch (ex) {
            return ex;
          }
        }
        parse(payload) {
          const type = payload[0];
          switch (this._step) {
            case 1:
              if (this._protocol._server) {
                if (type !== MESSAGE.KEXDH_INIT) {
                  return doFatalError(
                    this._protocol,
                    `Received packet ${type} instead of ${MESSAGE.KEXDH_INIT}`,
                    "handshake",
                    DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                  );
                }
                this._protocol._debug && this._protocol._debug(
                  "Received DH Init"
                );
                bufferParser.init(payload, 1);
                const dhData = bufferParser.readString();
                bufferParser.clear();
                if (dhData === void 0) {
                  return doFatalError(
                    this._protocol,
                    "Received malformed KEX*_INIT",
                    "handshake",
                    DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                  );
                }
                this._dhData = dhData;
                let hostKey = this._protocol._hostKeys[this.negotiated.serverHostKey];
                if (Array.isArray(hostKey))
                  hostKey = hostKey[0];
                this._hostKey = hostKey;
                this.finish();
              } else {
                if (type !== MESSAGE.KEXDH_REPLY) {
                  return doFatalError(
                    this._protocol,
                    `Received packet ${type} instead of ${MESSAGE.KEXDH_REPLY}`,
                    "handshake",
                    DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                  );
                }
                this._protocol._debug && this._protocol._debug(
                  "Received DH Reply"
                );
                bufferParser.init(payload, 1);
                let hostPubKey;
                let dhData;
                let sig;
                if ((hostPubKey = bufferParser.readString()) === void 0 || (dhData = bufferParser.readString()) === void 0 || (sig = bufferParser.readString()) === void 0) {
                  bufferParser.clear();
                  return doFatalError(
                    this._protocol,
                    "Received malformed KEX*_REPLY",
                    "handshake",
                    DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                  );
                }
                bufferParser.clear();
                bufferParser.init(hostPubKey, 0);
                const hostPubKeyType = bufferParser.readString(true);
                bufferParser.clear();
                if (hostPubKeyType === void 0) {
                  return doFatalError(
                    this._protocol,
                    "Received malformed host public key",
                    "handshake",
                    DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                  );
                }
                if (hostPubKeyType !== this.negotiated.serverHostKey) {
                  switch (this.negotiated.serverHostKey) {
                    case "rsa-sha2-256":
                    case "rsa-sha2-512":
                      if (hostPubKeyType === "ssh-rsa")
                        break;
                    default:
                      return doFatalError(
                        this._protocol,
                        "Host key does not match negotiated type",
                        "handshake",
                        DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                      );
                  }
                }
                this._hostKey = hostPubKey;
                this._dhData = dhData;
                this._sig = sig;
                let checked = false;
                let ret;
                if (this._protocol._hostVerifier === void 0) {
                  ret = true;
                  this._protocol._debug && this._protocol._debug(
                    "Host accepted by default (no verification)"
                  );
                } else {
                  ret = this._protocol._hostVerifier(hostPubKey, (permitted) => {
                    if (checked)
                      return;
                    checked = true;
                    if (permitted === false) {
                      this._protocol._debug && this._protocol._debug(
                        "Host denied (verification failed)"
                      );
                      return doFatalError(
                        this._protocol,
                        "Host denied (verification failed)",
                        "handshake",
                        DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                      );
                    }
                    this._protocol._debug && this._protocol._debug(
                      "Host accepted (verified)"
                    );
                    this._hostVerified = true;
                    if (this._receivedNEWKEYS)
                      this.finish();
                    else
                      trySendNEWKEYS(this);
                  });
                }
                if (ret === void 0) {
                  ++this._step;
                  return;
                }
                checked = true;
                if (ret === false) {
                  this._protocol._debug && this._protocol._debug(
                    "Host denied (verification failed)"
                  );
                  return doFatalError(
                    this._protocol,
                    "Host denied (verification failed)",
                    "handshake",
                    DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                  );
                }
                this._protocol._debug && this._protocol._debug(
                  "Host accepted (verified)"
                );
                this._hostVerified = true;
                trySendNEWKEYS(this);
              }
              ++this._step;
              break;
            case 2:
              if (type !== MESSAGE.NEWKEYS) {
                return doFatalError(
                  this._protocol,
                  `Received packet ${type} instead of ${MESSAGE.NEWKEYS}`,
                  "handshake",
                  DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                );
              }
              this._protocol._debug && this._protocol._debug(
                "Inbound: NEWKEYS"
              );
              this._receivedNEWKEYS = true;
              ++this._step;
              return this.finish(!this._protocol._server && !this._hostVerified);
            default:
              return doFatalError(
                this._protocol,
                `Received unexpected packet ${type} after NEWKEYS`,
                "handshake",
                DISCONNECT_REASON.KEY_EXCHANGE_FAILED
              );
          }
        }
      }
      class Curve25519Exchange extends KeyExchange {
        constructor(hashName, ...args) {
          super(...args);
          this.type = "25519";
          this.hashName = hashName;
          this._keys = null;
        }
        generateKeys() {
          if (!this._keys)
            this._keys = generateKeyPairSync("x25519");
        }
        getPublicKey() {
          this.generateKeys();
          const key = this._keys.publicKey.export({ type: "spki", format: "der" });
          return key.slice(-32);
        }
        convertPublicKey(key) {
          let newKey;
          let idx = 0;
          let len = key.length;
          while (key[idx] === 0) {
            ++idx;
            --len;
          }
          if (key.length === 32)
            return key;
          if (len !== key.length) {
            newKey = Buffer.allocUnsafe(len);
            key.copy(newKey, 0, idx);
            key = newKey;
          }
          return key;
        }
        computeSecret(otherPublicKey) {
          this.generateKeys();
          try {
            const asnWriter = new Ber.Writer();
            asnWriter.startSequence();
            asnWriter.startSequence();
            asnWriter.writeOID("1.3.101.110");
            asnWriter.endSequence();
            asnWriter.startSequence(Ber.BitString);
            asnWriter.writeByte(0);
            asnWriter._ensure(otherPublicKey.length);
            otherPublicKey.copy(
              asnWriter._buf,
              asnWriter._offset,
              0,
              otherPublicKey.length
            );
            asnWriter._offset += otherPublicKey.length;
            asnWriter.endSequence();
            asnWriter.endSequence();
            return convertToMpint(diffieHellman({
              privateKey: this._keys.privateKey,
              publicKey: createPublicKey({
                key: asnWriter.buffer,
                type: "spki",
                format: "der"
              })
            }));
          } catch (ex) {
            return ex;
          }
        }
      }
      class ECDHExchange extends KeyExchange {
        constructor(curveName, hashName, ...args) {
          super(...args);
          this.type = "ecdh";
          this.curveName = curveName;
          this.hashName = hashName;
        }
        generateKeys() {
          if (!this._dh) {
            this._dh = createECDH(this.curveName);
            this._public = this._dh.generateKeys();
          }
        }
      }
      class DHGroupExchange extends KeyExchange {
        constructor(hashName, ...args) {
          super(...args);
          this.type = "groupex";
          this.hashName = hashName;
          this._prime = null;
          this._generator = null;
          this._minBits = GEX_MIN_BITS;
          this._prefBits = dhEstimate(this.negotiated);
          if (this._protocol._compatFlags & COMPAT.BUG_DHGEX_LARGE)
            this._prefBits = Math.min(this._prefBits, 4096);
          this._maxBits = GEX_MAX_BITS;
        }
        start() {
          if (this._protocol._server)
            return;
          this._protocol._debug && this._protocol._debug(
            "Outbound: Sending KEXDH_GEX_REQUEST"
          );
          let p = this._protocol._packetRW.write.allocStartKEX;
          const packet = this._protocol._packetRW.write.alloc(
            1 + 4 + 4 + 4,
            true
          );
          packet[p] = MESSAGE.KEXDH_GEX_REQUEST;
          writeUInt32BE(packet, this._minBits, ++p);
          writeUInt32BE(packet, this._prefBits, p += 4);
          writeUInt32BE(packet, this._maxBits, p += 4);
          this._protocol._cipher.encrypt(
            this._protocol._packetRW.write.finalize(packet, true)
          );
        }
        generateKeys() {
          if (!this._dh && this._prime && this._generator) {
            this._dh = createDiffieHellman(this._prime, this._generator);
            this._public = this._dh.generateKeys();
          }
        }
        setDHParams(prime, generator) {
          if (!Buffer.isBuffer(prime))
            throw new Error("Invalid prime value");
          if (!Buffer.isBuffer(generator))
            throw new Error("Invalid generator value");
          this._prime = prime;
          this._generator = generator;
        }
        getDHParams() {
          if (this._dh) {
            return {
              prime: convertToMpint(this._dh.getPrime()),
              generator: convertToMpint(this._dh.getGenerator())
            };
          }
        }
        parse(payload) {
          const type = payload[0];
          switch (this._step) {
            case 1: {
              if (this._protocol._server) {
                if (type !== MESSAGE.KEXDH_GEX_REQUEST) {
                  return doFatalError(
                    this._protocol,
                    `Received packet ${type} instead of ` + MESSAGE.KEXDH_GEX_REQUEST,
                    "handshake",
                    DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                  );
                }
                return doFatalError(
                  this._protocol,
                  "Group exchange not implemented for server",
                  "handshake",
                  DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                );
              }
              if (type !== MESSAGE.KEXDH_GEX_GROUP) {
                return doFatalError(
                  this._protocol,
                  `Received packet ${type} instead of ${MESSAGE.KEXDH_GEX_GROUP}`,
                  "handshake",
                  DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                );
              }
              this._protocol._debug && this._protocol._debug(
                "Received DH GEX Group"
              );
              bufferParser.init(payload, 1);
              let prime;
              let gen;
              if ((prime = bufferParser.readString()) === void 0 || (gen = bufferParser.readString()) === void 0) {
                bufferParser.clear();
                return doFatalError(
                  this._protocol,
                  "Received malformed KEXDH_GEX_GROUP",
                  "handshake",
                  DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                );
              }
              bufferParser.clear();
              this.setDHParams(prime, gen);
              this.generateKeys();
              const pubkey = this.getPublicKey();
              this._protocol._debug && this._protocol._debug(
                "Outbound: Sending KEXDH_GEX_INIT"
              );
              let p = this._protocol._packetRW.write.allocStartKEX;
              const packet = this._protocol._packetRW.write.alloc(1 + 4 + pubkey.length, true);
              packet[p] = MESSAGE.KEXDH_GEX_INIT;
              writeUInt32BE(packet, pubkey.length, ++p);
              packet.set(pubkey, p += 4);
              this._protocol._cipher.encrypt(
                this._protocol._packetRW.write.finalize(packet, true)
              );
              ++this._step;
              break;
            }
            case 2:
              if (this._protocol._server) {
                if (type !== MESSAGE.KEXDH_GEX_INIT) {
                  return doFatalError(
                    this._protocol,
                    `Received packet ${type} instead of ${MESSAGE.KEXDH_GEX_INIT}`,
                    "handshake",
                    DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                  );
                }
                this._protocol._debug && this._protocol._debug(
                  "Received DH GEX Init"
                );
                return doFatalError(
                  this._protocol,
                  "Group exchange not implemented for server",
                  "handshake",
                  DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                );
              } else if (type !== MESSAGE.KEXDH_GEX_REPLY) {
                return doFatalError(
                  this._protocol,
                  `Received packet ${type} instead of ${MESSAGE.KEXDH_GEX_REPLY}`,
                  "handshake",
                  DISCONNECT_REASON.KEY_EXCHANGE_FAILED
                );
              }
              this._protocol._debug && this._protocol._debug(
                "Received DH GEX Reply"
              );
              this._step = 1;
              payload[0] = MESSAGE.KEXDH_REPLY;
              this.parse = KeyExchange.prototype.parse;
              this.parse(payload);
          }
        }
      }
      class DHExchange extends KeyExchange {
        constructor(groupName, hashName, ...args) {
          super(...args);
          this.type = "group";
          this.groupName = groupName;
          this.hashName = hashName;
        }
        start() {
          if (!this._protocol._server) {
            this._protocol._debug && this._protocol._debug(
              "Outbound: Sending KEXDH_INIT"
            );
            const pubKey = this.getPublicKey();
            let p = this._protocol._packetRW.write.allocStartKEX;
            const packet = this._protocol._packetRW.write.alloc(1 + 4 + pubKey.length, true);
            packet[p] = MESSAGE.KEXDH_INIT;
            writeUInt32BE(packet, pubKey.length, ++p);
            packet.set(pubKey, p += 4);
            this._protocol._cipher.encrypt(
              this._protocol._packetRW.write.finalize(packet, true)
            );
          }
        }
        generateKeys() {
          if (!this._dh) {
            this._dh = createDiffieHellmanGroup(this.groupName);
            this._public = this._dh.generateKeys();
          }
        }
        getDHParams() {
          if (this._dh) {
            return {
              prime: convertToMpint(this._dh.getPrime()),
              generator: convertToMpint(this._dh.getGenerator())
            };
          }
        }
      }
      return (negotiated, ...args) => {
        if (typeof negotiated !== "object" || negotiated === null)
          throw new Error("Invalid negotiated argument");
        const kexType = negotiated.kex;
        if (typeof kexType === "string") {
          args = [negotiated, ...args];
          switch (kexType) {
            case "curve25519-sha256":
            case "curve25519-sha256@libssh.org":
              if (!curve25519Supported)
                break;
              return new Curve25519Exchange("sha256", ...args);
            case "ecdh-sha2-nistp256":
              return new ECDHExchange("prime256v1", "sha256", ...args);
            case "ecdh-sha2-nistp384":
              return new ECDHExchange("secp384r1", "sha384", ...args);
            case "ecdh-sha2-nistp521":
              return new ECDHExchange("secp521r1", "sha512", ...args);
            case "diffie-hellman-group1-sha1":
              return new DHExchange("modp2", "sha1", ...args);
            case "diffie-hellman-group14-sha1":
              return new DHExchange("modp14", "sha1", ...args);
            case "diffie-hellman-group14-sha256":
              return new DHExchange("modp14", "sha256", ...args);
            case "diffie-hellman-group15-sha512":
              return new DHExchange("modp15", "sha512", ...args);
            case "diffie-hellman-group16-sha512":
              return new DHExchange("modp16", "sha512", ...args);
            case "diffie-hellman-group17-sha512":
              return new DHExchange("modp17", "sha512", ...args);
            case "diffie-hellman-group18-sha512":
              return new DHExchange("modp18", "sha512", ...args);
            case "diffie-hellman-group-exchange-sha1":
              return new DHGroupExchange("sha1", ...args);
            case "diffie-hellman-group-exchange-sha256":
              return new DHGroupExchange("sha256", ...args);
          }
          throw new Error(`Unsupported key exchange algorithm: ${kexType}`);
        }
        throw new Error(`Invalid key exchange type: ${kexType}`);
      };
    })();
    var KexInit = (() => {
      const KEX_PROPERTY_NAMES = [
        "kex",
        "serverHostKey",
        ["cs", "cipher"],
        ["sc", "cipher"],
        ["cs", "mac"],
        ["sc", "mac"],
        ["cs", "compress"],
        ["sc", "compress"],
        ["cs", "lang"],
        ["sc", "lang"]
      ];
      return class KexInit {
        constructor(obj) {
          if (typeof obj !== "object" || obj === null)
            throw new TypeError("Argument must be an object");
          const lists = {
            kex: void 0,
            serverHostKey: void 0,
            cs: {
              cipher: void 0,
              mac: void 0,
              compress: void 0,
              lang: void 0
            },
            sc: {
              cipher: void 0,
              mac: void 0,
              compress: void 0,
              lang: void 0
            },
            all: void 0
          };
          let totalSize = 0;
          for (const prop3 of KEX_PROPERTY_NAMES) {
            let base;
            let val;
            let desc;
            let key;
            if (typeof prop3 === "string") {
              base = lists;
              val = obj[prop3];
              desc = key = prop3;
            } else {
              const parent = prop3[0];
              base = lists[parent];
              key = prop3[1];
              val = obj[parent][key];
              desc = `${parent}.${key}`;
            }
            const entry = { array: void 0, buffer: void 0 };
            if (Buffer.isBuffer(val)) {
              entry.array = ("" + val).split(",");
              entry.buffer = val;
              totalSize += 4 + val.length;
            } else {
              if (typeof val === "string")
                val = val.split(",");
              if (Array.isArray(val)) {
                entry.array = val;
                entry.buffer = Buffer.from(val.join(","));
              } else {
                throw new TypeError(`Invalid \`${desc}\` type: ${typeof val}`);
              }
              totalSize += 4 + entry.buffer.length;
            }
            base[key] = entry;
          }
          const all5 = Buffer.allocUnsafe(totalSize);
          lists.all = all5;
          let allPos = 0;
          for (const prop3 of KEX_PROPERTY_NAMES) {
            let data;
            if (typeof prop3 === "string")
              data = lists[prop3].buffer;
            else
              data = lists[prop3[0]][prop3[1]].buffer;
            allPos = writeUInt32BE(all5, data.length, allPos);
            all5.set(data, allPos);
            allPos += data.length;
          }
          this.totalSize = totalSize;
          this.lists = lists;
        }
        copyAllTo(buf, offset) {
          const src = this.lists.all;
          if (typeof offset !== "number")
            throw new TypeError(`Invalid offset value: ${typeof offset}`);
          if (buf.length - offset < src.length)
            throw new Error("Insufficient space to copy list");
          buf.set(src, offset);
          return src.length;
        }
      };
    })();
    var hashString4 = (() => {
      const LEN = Buffer.allocUnsafe(4);
      return (hash3, buf) => {
        writeUInt32BE(LEN, buf.length, 0);
        hash3.update(LEN);
        hash3.update(buf);
      };
    })();
    function generateKEXVal(len, hashName, secret, exchangeHash, sessionID, char2) {
      let ret;
      if (len) {
        let digest = createHash2(hashName).update(secret).update(exchangeHash).update(char2).update(sessionID).digest();
        while (digest.length < len) {
          const chunk = createHash2(hashName).update(secret).update(exchangeHash).update(digest).digest();
          const extended = Buffer.allocUnsafe(digest.length + chunk.length);
          extended.set(digest, 0);
          extended.set(chunk, digest.length);
          digest = extended;
        }
        if (digest.length === len)
          ret = digest;
        else
          ret = new FastBuffer(digest.buffer, digest.byteOffset, len);
      } else {
        ret = EMPTY_BUFFER;
      }
      return ret;
    }
    function onKEXPayload(state2, payload) {
      if (payload.length === 0) {
        this._debug && this._debug("Inbound: Skipping empty packet payload");
        return;
      }
      if (this._skipNextInboundPacket) {
        this._skipNextInboundPacket = false;
        return;
      }
      payload = this._packetRW.read.read(payload);
      const type = payload[0];
      switch (type) {
        case MESSAGE.DISCONNECT:
        case MESSAGE.IGNORE:
        case MESSAGE.UNIMPLEMENTED:
        case MESSAGE.DEBUG:
          if (!MESSAGE_HANDLERS)
            MESSAGE_HANDLERS = require_handlers();
          return MESSAGE_HANDLERS[type](this, payload);
        case MESSAGE.KEXINIT:
          if (!state2.firstPacket) {
            return doFatalError(
              this,
              "Received extra KEXINIT during handshake",
              "handshake",
              DISCONNECT_REASON.KEY_EXCHANGE_FAILED
            );
          }
          state2.firstPacket = false;
          return handleKexInit(this, payload);
        default:
          if (type < 20 || type > 49) {
            return doFatalError(
              this,
              `Received unexpected packet type ${type}`,
              "handshake",
              DISCONNECT_REASON.KEY_EXCHANGE_FAILED
            );
          }
      }
      return this._kex.parse(payload);
    }
    function dhEstimate(neg) {
      const csCipher = CIPHER_INFO[neg.cs.cipher];
      const scCipher = CIPHER_INFO[neg.sc.cipher];
      const bits = Math.max(
        0,
        csCipher.sslName === "des-ede3-cbc" ? 14 : csCipher.keyLen,
        csCipher.blockLen,
        csCipher.ivLen,
        scCipher.sslName === "des-ede3-cbc" ? 14 : scCipher.keyLen,
        scCipher.blockLen,
        scCipher.ivLen
      ) * 8;
      if (bits <= 112)
        return 2048;
      if (bits <= 128)
        return 3072;
      if (bits <= 192)
        return 7680;
      return 8192;
    }
    function trySendNEWKEYS(kex) {
      if (!kex._sentNEWKEYS) {
        kex._protocol._debug && kex._protocol._debug(
          "Outbound: Sending NEWKEYS"
        );
        const p = kex._protocol._packetRW.write.allocStartKEX;
        const packet = kex._protocol._packetRW.write.alloc(1, true);
        packet[p] = MESSAGE.NEWKEYS;
        kex._protocol._cipher.encrypt(
          kex._protocol._packetRW.write.finalize(packet, true)
        );
        kex._sentNEWKEYS = true;
      }
    }
    module.exports = {
      KexInit,
      kexinit,
      onKEXPayload,
      DEFAULT_KEXINIT_CLIENT: new KexInit({
        kex: DEFAULT_KEX.concat(["ext-info-c"]),
        serverHostKey: DEFAULT_SERVER_HOST_KEY,
        cs: {
          cipher: DEFAULT_CIPHER,
          mac: DEFAULT_MAC,
          compress: DEFAULT_COMPRESSION,
          lang: []
        },
        sc: {
          cipher: DEFAULT_CIPHER,
          mac: DEFAULT_MAC,
          compress: DEFAULT_COMPRESSION,
          lang: []
        }
      }),
      DEFAULT_KEXINIT_SERVER: new KexInit({
        kex: DEFAULT_KEX,
        serverHostKey: DEFAULT_SERVER_HOST_KEY,
        cs: {
          cipher: DEFAULT_CIPHER,
          mac: DEFAULT_MAC,
          compress: DEFAULT_COMPRESSION,
          lang: []
        },
        sc: {
          cipher: DEFAULT_CIPHER,
          mac: DEFAULT_MAC,
          compress: DEFAULT_COMPRESSION,
          lang: []
        }
      }),
      HANDLERS: {
        [MESSAGE.KEXINIT]: handleKexInit
      }
    };
  }
});

// node_modules/ssh2/package.json
var require_package = __commonJS({
  "node_modules/ssh2/package.json"(exports, module) {
    module.exports = {
      name: "ssh2",
      version: "1.14.0",
      author: "Brian White <mscdex@mscdex.net>",
      description: "SSH2 client and server modules written in pure JavaScript for node.js",
      main: "./lib/index.js",
      engines: {
        node: ">=10.16.0"
      },
      dependencies: {
        asn1: "^0.2.6",
        "bcrypt-pbkdf": "^1.0.2"
      },
      devDependencies: {
        "@mscdex/eslint-config": "^1.1.0",
        eslint: "^7.32.0"
      },
      optionalDependencies: {
        "cpu-features": "~0.0.8",
        nan: "^2.17.0"
      },
      scripts: {
        install: "node install.js",
        rebuild: "node install.js",
        test: "node test/test.js",
        lint: "eslint --cache --report-unused-disable-directives --ext=.js .eslintrc.js examples lib test",
        "lint:fix": "npm run lint -- --fix"
      },
      keywords: [
        "ssh",
        "ssh2",
        "sftp",
        "secure",
        "shell",
        "exec",
        "remote",
        "client"
      ],
      licenses: [
        {
          type: "MIT",
          url: "http://github.com/mscdex/ssh2/raw/master/LICENSE"
        }
      ],
      repository: {
        type: "git",
        url: "http://github.com/mscdex/ssh2.git"
      }
    };
  }
});

// node_modules/ssh2/lib/protocol/Protocol.js
var require_Protocol = __commonJS({
  "node_modules/ssh2/lib/protocol/Protocol.js"(exports, module) {
    "use strict";
    var { inspect: inspect2 } = __require("util");
    var { bindingAvailable, NullCipher, NullDecipher } = require_crypto();
    var {
      COMPAT_CHECKS,
      DISCONNECT_REASON,
      eddsaSupported,
      MESSAGE,
      SIGNALS,
      TERMINAL_MODE
    } = require_constants5();
    var {
      DEFAULT_KEXINIT_CLIENT,
      DEFAULT_KEXINIT_SERVER,
      KexInit,
      kexinit,
      onKEXPayload
    } = require_kex();
    var {
      parseKey
    } = require_keyParser();
    var MESSAGE_HANDLERS = require_handlers();
    var {
      bufferCopy,
      bufferFill,
      bufferSlice,
      convertSignature,
      sendPacket,
      writeUInt32BE
    } = require_utils7();
    var {
      PacketReader,
      PacketWriter,
      ZlibPacketReader,
      ZlibPacketWriter
    } = require_zlib();
    var MODULE_VER = require_package().version;
    var VALID_DISCONNECT_REASONS = new Map(
      Object.values(DISCONNECT_REASON).map((n) => [n, 1])
    );
    var IDENT_RAW = Buffer.from(`SSH-2.0-ssh2js${MODULE_VER}`);
    var IDENT = Buffer.from(`${IDENT_RAW}\r
`);
    var MAX_LINE_LEN = 8192;
    var MAX_LINES = 1024;
    var PING_PAYLOAD = Buffer.from([
      MESSAGE.GLOBAL_REQUEST,
      // "keepalive@openssh.com"
      0,
      0,
      0,
      21,
      107,
      101,
      101,
      112,
      97,
      108,
      105,
      118,
      101,
      64,
      111,
      112,
      101,
      110,
      115,
      115,
      104,
      46,
      99,
      111,
      109,
      // Request a reply
      1
    ]);
    var NO_TERMINAL_MODES_BUFFER = Buffer.from([TERMINAL_MODE.TTY_OP_END]);
    function noop() {
    }
    var Protocol = class {
      constructor(config) {
        const onWrite = config.onWrite;
        if (typeof onWrite !== "function")
          throw new Error("Missing onWrite function");
        this._onWrite = (data) => {
          onWrite(data);
        };
        const onError3 = config.onError;
        if (typeof onError3 !== "function")
          throw new Error("Missing onError function");
        this._onError = (err) => {
          onError3(err);
        };
        const debug2 = config.debug;
        this._debug = typeof debug2 === "function" ? (msg) => {
          debug2(msg);
        } : void 0;
        const onHeader = config.onHeader;
        this._onHeader = typeof onHeader === "function" ? (...args) => {
          onHeader(...args);
        } : noop;
        const onPacket = config.onPacket;
        this._onPacket = typeof onPacket === "function" ? () => {
          onPacket();
        } : noop;
        let onHandshakeComplete = config.onHandshakeComplete;
        if (typeof onHandshakeComplete !== "function")
          onHandshakeComplete = noop;
        let firstHandshake;
        this._onHandshakeComplete = (...args) => {
          this._debug && this._debug("Handshake completed");
          if (firstHandshake === void 0)
            firstHandshake = true;
          else
            firstHandshake = false;
          const oldQueue = this._queue;
          if (oldQueue) {
            this._queue = void 0;
            this._debug && this._debug(
              `Draining outbound queue (${oldQueue.length}) ...`
            );
            for (let i = 0; i < oldQueue.length; ++i) {
              const data = oldQueue[i];
              let finalized = this._packetRW.write.finalize(data);
              if (finalized === data) {
                const packet = this._cipher.allocPacket(data.length);
                packet.set(data, 5);
                finalized = packet;
              }
              sendPacket(this, finalized);
            }
            this._debug && this._debug("... finished draining outbound queue");
          }
          if (firstHandshake && this._server && this._kex.remoteExtInfoEnabled)
            sendExtInfo(this);
          onHandshakeComplete(...args);
        };
        this._queue = void 0;
        const messageHandlers = config.messageHandlers;
        if (typeof messageHandlers === "object" && messageHandlers !== null)
          this._handlers = messageHandlers;
        else
          this._handlers = {};
        this._onPayload = onPayload.bind(this);
        this._server = !!config.server;
        this._banner = void 0;
        let greeting;
        if (this._server) {
          if (typeof config.hostKeys !== "object" || config.hostKeys === null)
            throw new Error("Missing server host key(s)");
          this._hostKeys = config.hostKeys;
          if (typeof config.greeting === "string" && config.greeting.length) {
            greeting = config.greeting.slice(-2) === "\r\n" ? config.greeting : `${config.greeting}\r
`;
          }
          if (typeof config.banner === "string" && config.banner.length) {
            this._banner = config.banner.slice(-2) === "\r\n" ? config.banner : `${config.banner}\r
`;
          }
        } else {
          this._hostKeys = void 0;
        }
        let offer = config.offer;
        if (typeof offer !== "object" || offer === null) {
          offer = this._server ? DEFAULT_KEXINIT_SERVER : DEFAULT_KEXINIT_CLIENT;
        } else if (offer.constructor !== KexInit) {
          if (!this._server)
            offer.kex = offer.kex.concat(["ext-info-c"]);
          offer = new KexInit(offer);
        }
        this._kex = void 0;
        this._kexinit = void 0;
        this._offer = offer;
        this._cipher = new NullCipher(0, this._onWrite);
        this._decipher = void 0;
        this._skipNextInboundPacket = false;
        this._packetRW = {
          read: new PacketReader(),
          write: new PacketWriter(this)
        };
        this._hostVerifier = !this._server && typeof config.hostVerifier === "function" ? config.hostVerifier : void 0;
        this._parse = parseHeader;
        this._buffer = void 0;
        this._authsQueue = [];
        this._authenticated = false;
        this._remoteIdentRaw = void 0;
        let sentIdent;
        if (typeof config.ident === "string") {
          this._identRaw = Buffer.from(`SSH-2.0-${config.ident}`);
          sentIdent = Buffer.allocUnsafe(this._identRaw.length + 2);
          sentIdent.set(this._identRaw, 0);
          sentIdent[sentIdent.length - 2] = 13;
          sentIdent[sentIdent.length - 1] = 10;
        } else if (Buffer.isBuffer(config.ident)) {
          const fullIdent = Buffer.allocUnsafe(8 + config.ident.length);
          fullIdent.latin1Write("SSH-2.0-", 0, 8);
          fullIdent.set(config.ident, 8);
          this._identRaw = fullIdent;
          sentIdent = Buffer.allocUnsafe(fullIdent.length + 2);
          sentIdent.set(fullIdent, 0);
          sentIdent[sentIdent.length - 2] = 13;
          sentIdent[sentIdent.length - 1] = 10;
        } else {
          this._identRaw = IDENT_RAW;
          sentIdent = IDENT;
        }
        this._compatFlags = 0;
        if (this._debug) {
          if (bindingAvailable)
            this._debug("Custom crypto binding available");
          else
            this._debug("Custom crypto binding not available");
        }
        this._debug && this._debug(
          `Local ident: ${inspect2(this._identRaw.toString())}`
        );
        this.start = () => {
          this.start = void 0;
          if (greeting)
            this._onWrite(greeting);
          this._onWrite(sentIdent);
        };
      }
      _destruct(reason) {
        this._packetRW.read.cleanup();
        this._packetRW.write.cleanup();
        this._cipher && this._cipher.free();
        this._decipher && this._decipher.free();
        if (typeof reason !== "string" || reason.length === 0)
          reason = "fatal error";
        this.parse = () => {
          throw new Error(`Instance unusable after ${reason}`);
        };
        this._onWrite = () => {
          throw new Error(`Instance unusable after ${reason}`);
        };
        this._destruct = void 0;
      }
      cleanup() {
        this._destruct && this._destruct();
      }
      parse(chunk, i, len) {
        while (i < len)
          i = this._parse(chunk, i, len);
      }
      // Protocol message API
      // ===========================================================================
      // Common/Shared =============================================================
      // ===========================================================================
      // Global
      // ------
      disconnect(reason) {
        const pktLen = 1 + 4 + 4 + 4;
        let p = this._packetRW.write.allocStartKEX;
        const packet = this._packetRW.write.alloc(pktLen, true);
        const end4 = p + pktLen;
        if (!VALID_DISCONNECT_REASONS.has(reason))
          reason = DISCONNECT_REASON.PROTOCOL_ERROR;
        packet[p] = MESSAGE.DISCONNECT;
        writeUInt32BE(packet, reason, ++p);
        packet.fill(0, p += 4, end4);
        this._debug && this._debug(`Outbound: Sending DISCONNECT (${reason})`);
        sendPacket(this, this._packetRW.write.finalize(packet, true), true);
      }
      ping() {
        const p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(PING_PAYLOAD.length);
        packet.set(PING_PAYLOAD, p);
        this._debug && this._debug(
          "Outbound: Sending ping (GLOBAL_REQUEST: keepalive@openssh.com)"
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      rekey() {
        if (this._kexinit === void 0) {
          this._debug && this._debug("Outbound: Initiated explicit rekey");
          this._queue = [];
          kexinit(this);
        } else {
          this._debug && this._debug("Outbound: Ignoring rekey during handshake");
        }
      }
      // 'ssh-connection' service-specific
      // ---------------------------------
      requestSuccess(data) {
        let p = this._packetRW.write.allocStart;
        let packet;
        if (Buffer.isBuffer(data)) {
          packet = this._packetRW.write.alloc(1 + data.length);
          packet[p] = MESSAGE.REQUEST_SUCCESS;
          packet.set(data, ++p);
        } else {
          packet = this._packetRW.write.alloc(1);
          packet[p] = MESSAGE.REQUEST_SUCCESS;
        }
        this._debug && this._debug("Outbound: Sending REQUEST_SUCCESS");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      requestFailure() {
        const p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1);
        packet[p] = MESSAGE.REQUEST_FAILURE;
        this._debug && this._debug("Outbound: Sending REQUEST_FAILURE");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelSuccess(chan) {
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4);
        packet[p] = MESSAGE.CHANNEL_SUCCESS;
        writeUInt32BE(packet, chan, ++p);
        this._debug && this._debug(`Outbound: Sending CHANNEL_SUCCESS (r:${chan})`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelFailure(chan) {
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4);
        packet[p] = MESSAGE.CHANNEL_FAILURE;
        writeUInt32BE(packet, chan, ++p);
        this._debug && this._debug(`Outbound: Sending CHANNEL_FAILURE (r:${chan})`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelEOF(chan) {
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4);
        packet[p] = MESSAGE.CHANNEL_EOF;
        writeUInt32BE(packet, chan, ++p);
        this._debug && this._debug(`Outbound: Sending CHANNEL_EOF (r:${chan})`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelClose(chan) {
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4);
        packet[p] = MESSAGE.CHANNEL_CLOSE;
        writeUInt32BE(packet, chan, ++p);
        this._debug && this._debug(`Outbound: Sending CHANNEL_CLOSE (r:${chan})`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelWindowAdjust(chan, amount) {
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4);
        packet[p] = MESSAGE.CHANNEL_WINDOW_ADJUST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, amount, p += 4);
        this._debug && this._debug(
          `Outbound: Sending CHANNEL_WINDOW_ADJUST (r:${chan}, ${amount})`
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelData(chan, data) {
        const isBuffer = Buffer.isBuffer(data);
        const dataLen = isBuffer ? data.length : Buffer.byteLength(data);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4 + dataLen);
        packet[p] = MESSAGE.CHANNEL_DATA;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, dataLen, p += 4);
        if (isBuffer)
          packet.set(data, p += 4);
        else
          packet.utf8Write(data, p += 4, dataLen);
        this._debug && this._debug(
          `Outbound: Sending CHANNEL_DATA (r:${chan}, ${dataLen})`
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelExtData(chan, data, type) {
        const isBuffer = Buffer.isBuffer(data);
        const dataLen = isBuffer ? data.length : Buffer.byteLength(data);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + dataLen);
        packet[p] = MESSAGE.CHANNEL_EXTENDED_DATA;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, type, p += 4);
        writeUInt32BE(packet, dataLen, p += 4);
        if (isBuffer)
          packet.set(data, p += 4);
        else
          packet.utf8Write(data, p += 4, dataLen);
        this._debug && this._debug(`Outbound: Sending CHANNEL_EXTENDED_DATA (r:${chan})`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelOpenConfirm(remote, local2, initWindow, maxPacket) {
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + 4);
        packet[p] = MESSAGE.CHANNEL_OPEN_CONFIRMATION;
        writeUInt32BE(packet, remote, ++p);
        writeUInt32BE(packet, local2, p += 4);
        writeUInt32BE(packet, initWindow, p += 4);
        writeUInt32BE(packet, maxPacket, p += 4);
        this._debug && this._debug(
          `Outbound: Sending CHANNEL_OPEN_CONFIRMATION (r:${remote}, l:${local2})`
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelOpenFail(remote, reason, desc) {
        if (typeof desc !== "string")
          desc = "";
        const descLen = Buffer.byteLength(desc);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + descLen + 4);
        packet[p] = MESSAGE.CHANNEL_OPEN_FAILURE;
        writeUInt32BE(packet, remote, ++p);
        writeUInt32BE(packet, reason, p += 4);
        writeUInt32BE(packet, descLen, p += 4);
        p += 4;
        if (descLen) {
          packet.utf8Write(desc, p, descLen);
          p += descLen;
        }
        writeUInt32BE(packet, 0, p);
        this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN_FAILURE (r:${remote})`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      // ===========================================================================
      // Client-specific ===========================================================
      // ===========================================================================
      // Global
      // ------
      service(name4) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const nameLen = Buffer.byteLength(name4);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + nameLen);
        packet[p] = MESSAGE.SERVICE_REQUEST;
        writeUInt32BE(packet, nameLen, ++p);
        packet.utf8Write(name4, p += 4, nameLen);
        this._debug && this._debug(`Outbound: Sending SERVICE_REQUEST (${name4})`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      // 'ssh-userauth' service-specific
      // -------------------------------
      authPassword(username, password, newPassword) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const userLen = Buffer.byteLength(username);
        const passLen = Buffer.byteLength(password);
        const newPassLen = newPassword ? Buffer.byteLength(newPassword) : 0;
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + userLen + 4 + 14 + 4 + 8 + 1 + 4 + passLen + (newPassword ? 4 + newPassLen : 0)
        );
        packet[p] = MESSAGE.USERAUTH_REQUEST;
        writeUInt32BE(packet, userLen, ++p);
        packet.utf8Write(username, p += 4, userLen);
        writeUInt32BE(packet, 14, p += userLen);
        packet.utf8Write("ssh-connection", p += 4, 14);
        writeUInt32BE(packet, 8, p += 14);
        packet.utf8Write("password", p += 4, 8);
        packet[p += 8] = newPassword ? 1 : 0;
        writeUInt32BE(packet, passLen, ++p);
        if (Buffer.isBuffer(password))
          bufferCopy(password, packet, 0, passLen, p += 4);
        else
          packet.utf8Write(password, p += 4, passLen);
        if (newPassword) {
          writeUInt32BE(packet, newPassLen, p += passLen);
          if (Buffer.isBuffer(newPassword))
            bufferCopy(newPassword, packet, 0, newPassLen, p += 4);
          else
            packet.utf8Write(newPassword, p += 4, newPassLen);
          this._debug && this._debug(
            "Outbound: Sending USERAUTH_REQUEST (changed password)"
          );
        } else {
          this._debug && this._debug(
            "Outbound: Sending USERAUTH_REQUEST (password)"
          );
        }
        this._authsQueue.push("password");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      authPK(username, pubKey, keyAlgo, cbSign) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        pubKey = parseKey(pubKey);
        if (pubKey instanceof Error)
          throw new Error("Invalid key");
        const keyType = pubKey.type;
        pubKey = pubKey.getPublicSSH();
        if (typeof keyAlgo === "function") {
          cbSign = keyAlgo;
          keyAlgo = void 0;
        }
        if (!keyAlgo)
          keyAlgo = keyType;
        const userLen = Buffer.byteLength(username);
        const algoLen = Buffer.byteLength(keyAlgo);
        const pubKeyLen = pubKey.length;
        const sessionID = this._kex.sessionID;
        const sesLen = sessionID.length;
        const payloadLen = (cbSign ? 4 + sesLen : 0) + 1 + 4 + userLen + 4 + 14 + 4 + 9 + 1 + 4 + algoLen + 4 + pubKeyLen;
        let packet;
        let p;
        if (cbSign) {
          packet = Buffer.allocUnsafe(payloadLen);
          p = 0;
          writeUInt32BE(packet, sesLen, p);
          packet.set(sessionID, p += 4);
          p += sesLen;
        } else {
          packet = this._packetRW.write.alloc(payloadLen);
          p = this._packetRW.write.allocStart;
        }
        packet[p] = MESSAGE.USERAUTH_REQUEST;
        writeUInt32BE(packet, userLen, ++p);
        packet.utf8Write(username, p += 4, userLen);
        writeUInt32BE(packet, 14, p += userLen);
        packet.utf8Write("ssh-connection", p += 4, 14);
        writeUInt32BE(packet, 9, p += 14);
        packet.utf8Write("publickey", p += 4, 9);
        packet[p += 9] = cbSign ? 1 : 0;
        writeUInt32BE(packet, algoLen, ++p);
        packet.utf8Write(keyAlgo, p += 4, algoLen);
        writeUInt32BE(packet, pubKeyLen, p += algoLen);
        packet.set(pubKey, p += 4);
        if (!cbSign) {
          this._authsQueue.push("publickey");
          this._debug && this._debug(
            "Outbound: Sending USERAUTH_REQUEST (publickey -- check)"
          );
          sendPacket(this, this._packetRW.write.finalize(packet));
          return;
        }
        cbSign(packet, (signature) => {
          signature = convertSignature(signature, keyType);
          if (signature === false)
            throw new Error("Error while converting handshake signature");
          const sigLen = signature.length;
          p = this._packetRW.write.allocStart;
          packet = this._packetRW.write.alloc(
            1 + 4 + userLen + 4 + 14 + 4 + 9 + 1 + 4 + algoLen + 4 + pubKeyLen + 4 + 4 + algoLen + 4 + sigLen
          );
          packet[p] = MESSAGE.USERAUTH_REQUEST;
          writeUInt32BE(packet, userLen, ++p);
          packet.utf8Write(username, p += 4, userLen);
          writeUInt32BE(packet, 14, p += userLen);
          packet.utf8Write("ssh-connection", p += 4, 14);
          writeUInt32BE(packet, 9, p += 14);
          packet.utf8Write("publickey", p += 4, 9);
          packet[p += 9] = 1;
          writeUInt32BE(packet, algoLen, ++p);
          packet.utf8Write(keyAlgo, p += 4, algoLen);
          writeUInt32BE(packet, pubKeyLen, p += algoLen);
          packet.set(pubKey, p += 4);
          writeUInt32BE(packet, 4 + algoLen + 4 + sigLen, p += pubKeyLen);
          writeUInt32BE(packet, algoLen, p += 4);
          packet.utf8Write(keyAlgo, p += 4, algoLen);
          writeUInt32BE(packet, sigLen, p += algoLen);
          packet.set(signature, p += 4);
          this._authsQueue.push("publickey");
          this._debug && this._debug(
            "Outbound: Sending USERAUTH_REQUEST (publickey)"
          );
          sendPacket(this, this._packetRW.write.finalize(packet));
        });
      }
      authHostbased(username, pubKey, hostname, userlocal, keyAlgo, cbSign) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        pubKey = parseKey(pubKey);
        if (pubKey instanceof Error)
          throw new Error("Invalid key");
        const keyType = pubKey.type;
        pubKey = pubKey.getPublicSSH();
        if (typeof keyAlgo === "function") {
          cbSign = keyAlgo;
          keyAlgo = void 0;
        }
        if (!keyAlgo)
          keyAlgo = keyType;
        const userLen = Buffer.byteLength(username);
        const algoLen = Buffer.byteLength(keyAlgo);
        const pubKeyLen = pubKey.length;
        const sessionID = this._kex.sessionID;
        const sesLen = sessionID.length;
        const hostnameLen = Buffer.byteLength(hostname);
        const userlocalLen = Buffer.byteLength(userlocal);
        const data = Buffer.allocUnsafe(
          4 + sesLen + 1 + 4 + userLen + 4 + 14 + 4 + 9 + 4 + algoLen + 4 + pubKeyLen + 4 + hostnameLen + 4 + userlocalLen
        );
        let p = 0;
        writeUInt32BE(data, sesLen, p);
        data.set(sessionID, p += 4);
        data[p += sesLen] = MESSAGE.USERAUTH_REQUEST;
        writeUInt32BE(data, userLen, ++p);
        data.utf8Write(username, p += 4, userLen);
        writeUInt32BE(data, 14, p += userLen);
        data.utf8Write("ssh-connection", p += 4, 14);
        writeUInt32BE(data, 9, p += 14);
        data.utf8Write("hostbased", p += 4, 9);
        writeUInt32BE(data, algoLen, p += 9);
        data.utf8Write(keyAlgo, p += 4, algoLen);
        writeUInt32BE(data, pubKeyLen, p += algoLen);
        data.set(pubKey, p += 4);
        writeUInt32BE(data, hostnameLen, p += pubKeyLen);
        data.utf8Write(hostname, p += 4, hostnameLen);
        writeUInt32BE(data, userlocalLen, p += hostnameLen);
        data.utf8Write(userlocal, p += 4, userlocalLen);
        cbSign(data, (signature) => {
          signature = convertSignature(signature, keyType);
          if (!signature)
            throw new Error("Error while converting handshake signature");
          const sigLen = signature.length;
          const reqDataLen = data.length - sesLen - 4;
          p = this._packetRW.write.allocStart;
          const packet = this._packetRW.write.alloc(
            reqDataLen + 4 + 4 + algoLen + 4 + sigLen
          );
          bufferCopy(data, packet, 4 + sesLen, data.length, p);
          writeUInt32BE(packet, 4 + algoLen + 4 + sigLen, p += reqDataLen);
          writeUInt32BE(packet, algoLen, p += 4);
          packet.utf8Write(keyAlgo, p += 4, algoLen);
          writeUInt32BE(packet, sigLen, p += algoLen);
          packet.set(signature, p += 4);
          this._authsQueue.push("hostbased");
          this._debug && this._debug(
            "Outbound: Sending USERAUTH_REQUEST (hostbased)"
          );
          sendPacket(this, this._packetRW.write.finalize(packet));
        });
      }
      authKeyboard(username) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const userLen = Buffer.byteLength(username);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + userLen + 4 + 14 + 4 + 20 + 4 + 4
        );
        packet[p] = MESSAGE.USERAUTH_REQUEST;
        writeUInt32BE(packet, userLen, ++p);
        packet.utf8Write(username, p += 4, userLen);
        writeUInt32BE(packet, 14, p += userLen);
        packet.utf8Write("ssh-connection", p += 4, 14);
        writeUInt32BE(packet, 20, p += 14);
        packet.utf8Write("keyboard-interactive", p += 4, 20);
        writeUInt32BE(packet, 0, p += 20);
        writeUInt32BE(packet, 0, p += 4);
        this._authsQueue.push("keyboard-interactive");
        this._debug && this._debug(
          "Outbound: Sending USERAUTH_REQUEST (keyboard-interactive)"
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      authNone(username) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const userLen = Buffer.byteLength(username);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + userLen + 4 + 14 + 4 + 4);
        packet[p] = MESSAGE.USERAUTH_REQUEST;
        writeUInt32BE(packet, userLen, ++p);
        packet.utf8Write(username, p += 4, userLen);
        writeUInt32BE(packet, 14, p += userLen);
        packet.utf8Write("ssh-connection", p += 4, 14);
        writeUInt32BE(packet, 4, p += 14);
        packet.utf8Write("none", p += 4, 4);
        this._authsQueue.push("none");
        this._debug && this._debug("Outbound: Sending USERAUTH_REQUEST (none)");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      authInfoRes(responses) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let responsesTotalLen = 0;
        let responseLens;
        if (responses) {
          responseLens = new Array(responses.length);
          for (let i = 0; i < responses.length; ++i) {
            const len = Buffer.byteLength(responses[i]);
            responseLens[i] = len;
            responsesTotalLen += 4 + len;
          }
        }
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + responsesTotalLen);
        packet[p] = MESSAGE.USERAUTH_INFO_RESPONSE;
        if (responses) {
          writeUInt32BE(packet, responses.length, ++p);
          p += 4;
          for (let i = 0; i < responses.length; ++i) {
            const len = responseLens[i];
            writeUInt32BE(packet, len, p);
            p += 4;
            if (len) {
              packet.utf8Write(responses[i], p, len);
              p += len;
            }
          }
        } else {
          writeUInt32BE(packet, 0, ++p);
        }
        this._debug && this._debug("Outbound: Sending USERAUTH_INFO_RESPONSE");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      // 'ssh-connection' service-specific
      // ---------------------------------
      tcpipForward(bindAddr, bindPort, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const addrLen = Buffer.byteLength(bindAddr);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 13 + 1 + 4 + addrLen + 4);
        packet[p] = MESSAGE.GLOBAL_REQUEST;
        writeUInt32BE(packet, 13, ++p);
        packet.utf8Write("tcpip-forward", p += 4, 13);
        packet[p += 13] = wantReply === void 0 || wantReply === true ? 1 : 0;
        writeUInt32BE(packet, addrLen, ++p);
        packet.utf8Write(bindAddr, p += 4, addrLen);
        writeUInt32BE(packet, bindPort, p += addrLen);
        this._debug && this._debug("Outbound: Sending GLOBAL_REQUEST (tcpip-forward)");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      cancelTcpipForward(bindAddr, bindPort, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const addrLen = Buffer.byteLength(bindAddr);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 20 + 1 + 4 + addrLen + 4);
        packet[p] = MESSAGE.GLOBAL_REQUEST;
        writeUInt32BE(packet, 20, ++p);
        packet.utf8Write("cancel-tcpip-forward", p += 4, 20);
        packet[p += 20] = wantReply === void 0 || wantReply === true ? 1 : 0;
        writeUInt32BE(packet, addrLen, ++p);
        packet.utf8Write(bindAddr, p += 4, addrLen);
        writeUInt32BE(packet, bindPort, p += addrLen);
        this._debug && this._debug("Outbound: Sending GLOBAL_REQUEST (cancel-tcpip-forward)");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      openssh_streamLocalForward(socketPath, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const socketPathLen = Buffer.byteLength(socketPath);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + 31 + 1 + 4 + socketPathLen
        );
        packet[p] = MESSAGE.GLOBAL_REQUEST;
        writeUInt32BE(packet, 31, ++p);
        packet.utf8Write("streamlocal-forward@openssh.com", p += 4, 31);
        packet[p += 31] = wantReply === void 0 || wantReply === true ? 1 : 0;
        writeUInt32BE(packet, socketPathLen, ++p);
        packet.utf8Write(socketPath, p += 4, socketPathLen);
        this._debug && this._debug(
          "Outbound: Sending GLOBAL_REQUEST (streamlocal-forward@openssh.com)"
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      openssh_cancelStreamLocalForward(socketPath, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const socketPathLen = Buffer.byteLength(socketPath);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + 38 + 1 + 4 + socketPathLen
        );
        packet[p] = MESSAGE.GLOBAL_REQUEST;
        writeUInt32BE(packet, 38, ++p);
        packet.utf8Write("cancel-streamlocal-forward@openssh.com", p += 4, 38);
        packet[p += 38] = wantReply === void 0 || wantReply === true ? 1 : 0;
        writeUInt32BE(packet, socketPathLen, ++p);
        packet.utf8Write(socketPath, p += 4, socketPathLen);
        if (this._debug) {
          this._debug(
            "Outbound: Sending GLOBAL_REQUEST (cancel-streamlocal-forward@openssh.com)"
          );
        }
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      directTcpip(chan, initWindow, maxPacket, cfg) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const srcLen = Buffer.byteLength(cfg.srcIP);
        const dstLen = Buffer.byteLength(cfg.dstIP);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + 12 + 4 + 4 + 4 + 4 + srcLen + 4 + 4 + dstLen + 4
        );
        packet[p] = MESSAGE.CHANNEL_OPEN;
        writeUInt32BE(packet, 12, ++p);
        packet.utf8Write("direct-tcpip", p += 4, 12);
        writeUInt32BE(packet, chan, p += 12);
        writeUInt32BE(packet, initWindow, p += 4);
        writeUInt32BE(packet, maxPacket, p += 4);
        writeUInt32BE(packet, dstLen, p += 4);
        packet.utf8Write(cfg.dstIP, p += 4, dstLen);
        writeUInt32BE(packet, cfg.dstPort, p += dstLen);
        writeUInt32BE(packet, srcLen, p += 4);
        packet.utf8Write(cfg.srcIP, p += 4, srcLen);
        writeUInt32BE(packet, cfg.srcPort, p += srcLen);
        this._debug && this._debug(
          `Outbound: Sending CHANNEL_OPEN (r:${chan}, direct-tcpip)`
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      openssh_directStreamLocal(chan, initWindow, maxPacket, cfg) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const pathLen = Buffer.byteLength(cfg.socketPath);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + 30 + 4 + 4 + 4 + 4 + pathLen + 4 + 4
        );
        packet[p] = MESSAGE.CHANNEL_OPEN;
        writeUInt32BE(packet, 30, ++p);
        packet.utf8Write("direct-streamlocal@openssh.com", p += 4, 30);
        writeUInt32BE(packet, chan, p += 30);
        writeUInt32BE(packet, initWindow, p += 4);
        writeUInt32BE(packet, maxPacket, p += 4);
        writeUInt32BE(packet, pathLen, p += 4);
        packet.utf8Write(cfg.socketPath, p += 4, pathLen);
        bufferFill(packet, 0, p += pathLen, p + 8);
        if (this._debug) {
          this._debug(
            `Outbound: Sending CHANNEL_OPEN (r:${chan}, direct-streamlocal@openssh.com)`
          );
        }
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      openssh_noMoreSessions(wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 28 + 1);
        packet[p] = MESSAGE.GLOBAL_REQUEST;
        writeUInt32BE(packet, 28, ++p);
        packet.utf8Write("no-more-sessions@openssh.com", p += 4, 28);
        packet[p += 28] = wantReply === void 0 || wantReply === true ? 1 : 0;
        this._debug && this._debug(
          "Outbound: Sending GLOBAL_REQUEST (no-more-sessions@openssh.com)"
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      session(chan, initWindow, maxPacket) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 7 + 4 + 4 + 4);
        packet[p] = MESSAGE.CHANNEL_OPEN;
        writeUInt32BE(packet, 7, ++p);
        packet.utf8Write("session", p += 4, 7);
        writeUInt32BE(packet, chan, p += 7);
        writeUInt32BE(packet, initWindow, p += 4);
        writeUInt32BE(packet, maxPacket, p += 4);
        this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN (r:${chan}, session)`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      windowChange(chan, rows, cols, height, width2) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + 4 + 13 + 1 + 4 + 4 + 4 + 4
        );
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 13, p += 4);
        packet.utf8Write("window-change", p += 4, 13);
        packet[p += 13] = 0;
        writeUInt32BE(packet, cols, ++p);
        writeUInt32BE(packet, rows, p += 4);
        writeUInt32BE(packet, width2, p += 4);
        writeUInt32BE(packet, height, p += 4);
        this._debug && this._debug(
          `Outbound: Sending CHANNEL_REQUEST (r:${chan}, window-change)`
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      pty(chan, rows, cols, height, width2, term, modes, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        if (!term || !term.length)
          term = "vt100";
        if (modes && !Buffer.isBuffer(modes) && !Array.isArray(modes) && typeof modes === "object" && modes !== null) {
          modes = modesToBytes(modes);
        }
        if (!modes || !modes.length)
          modes = NO_TERMINAL_MODES_BUFFER;
        const termLen = term.length;
        const modesLen = modes.length;
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + 4 + 7 + 1 + 4 + termLen + 4 + 4 + 4 + 4 + 4 + modesLen
        );
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 7, p += 4);
        packet.utf8Write("pty-req", p += 4, 7);
        packet[p += 7] = wantReply === void 0 || wantReply === true ? 1 : 0;
        writeUInt32BE(packet, termLen, ++p);
        packet.utf8Write(term, p += 4, termLen);
        writeUInt32BE(packet, cols, p += termLen);
        writeUInt32BE(packet, rows, p += 4);
        writeUInt32BE(packet, width2, p += 4);
        writeUInt32BE(packet, height, p += 4);
        writeUInt32BE(packet, modesLen, p += 4);
        p += 4;
        if (Array.isArray(modes)) {
          for (let i = 0; i < modesLen; ++i)
            packet[p++] = modes[i];
        } else if (Buffer.isBuffer(modes)) {
          packet.set(modes, p);
        }
        this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, pty-req)`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      shell(chan, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4 + 5 + 1);
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 5, p += 4);
        packet.utf8Write("shell", p += 4, 5);
        packet[p += 5] = wantReply === void 0 || wantReply === true ? 1 : 0;
        this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, shell)`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      exec(chan, cmd, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const isBuf = Buffer.isBuffer(cmd);
        const cmdLen = isBuf ? cmd.length : Buffer.byteLength(cmd);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + 1 + 4 + cmdLen);
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 4, p += 4);
        packet.utf8Write("exec", p += 4, 4);
        packet[p += 4] = wantReply === void 0 || wantReply === true ? 1 : 0;
        writeUInt32BE(packet, cmdLen, ++p);
        if (isBuf)
          packet.set(cmd, p += 4);
        else
          packet.utf8Write(cmd, p += 4, cmdLen);
        this._debug && this._debug(
          `Outbound: Sending CHANNEL_REQUEST (r:${chan}, exec: ${cmd})`
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      signal(chan, signal) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const origSignal = signal;
        signal = signal.toUpperCase();
        if (signal.slice(0, 3) === "SIG")
          signal = signal.slice(3);
        if (SIGNALS[signal] !== 1)
          throw new Error(`Invalid signal: ${origSignal}`);
        const signalLen = signal.length;
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + 4 + 6 + 1 + 4 + signalLen
        );
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 6, p += 4);
        packet.utf8Write("signal", p += 4, 6);
        packet[p += 6] = 0;
        writeUInt32BE(packet, signalLen, ++p);
        packet.utf8Write(signal, p += 4, signalLen);
        this._debug && this._debug(
          `Outbound: Sending CHANNEL_REQUEST (r:${chan}, signal: ${signal})`
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      env(chan, key, val, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const keyLen = Buffer.byteLength(key);
        const isBuf = Buffer.isBuffer(val);
        const valLen = isBuf ? val.length : Buffer.byteLength(val);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + 4 + 3 + 1 + 4 + keyLen + 4 + valLen
        );
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 3, p += 4);
        packet.utf8Write("env", p += 4, 3);
        packet[p += 3] = wantReply === void 0 || wantReply === true ? 1 : 0;
        writeUInt32BE(packet, keyLen, ++p);
        packet.utf8Write(key, p += 4, keyLen);
        writeUInt32BE(packet, valLen, p += keyLen);
        if (isBuf)
          packet.set(val, p += 4);
        else
          packet.utf8Write(val, p += 4, valLen);
        this._debug && this._debug(
          `Outbound: Sending CHANNEL_REQUEST (r:${chan}, env: ${key}=${val})`
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      x11Forward(chan, cfg, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const protocol = cfg.protocol;
        const cookie = cfg.cookie;
        const isBufProto = Buffer.isBuffer(protocol);
        const protoLen = isBufProto ? protocol.length : Buffer.byteLength(protocol);
        const isBufCookie = Buffer.isBuffer(cookie);
        const cookieLen = isBufCookie ? cookie.length : Buffer.byteLength(cookie);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + 4 + 7 + 1 + 1 + 4 + protoLen + 4 + cookieLen + 4
        );
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 7, p += 4);
        packet.utf8Write("x11-req", p += 4, 7);
        packet[p += 7] = wantReply === void 0 || wantReply === true ? 1 : 0;
        packet[++p] = cfg.single ? 1 : 0;
        writeUInt32BE(packet, protoLen, ++p);
        if (isBufProto)
          packet.set(protocol, p += 4);
        else
          packet.utf8Write(protocol, p += 4, protoLen);
        writeUInt32BE(packet, cookieLen, p += protoLen);
        if (isBufCookie)
          packet.set(cookie, p += 4);
        else
          packet.latin1Write(cookie, p += 4, cookieLen);
        writeUInt32BE(packet, cfg.screen || 0, p += cookieLen);
        this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, x11-req)`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      subsystem(chan, name4, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        const nameLen = Buffer.byteLength(name4);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4 + 9 + 1 + 4 + nameLen);
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 9, p += 4);
        packet.utf8Write("subsystem", p += 4, 9);
        packet[p += 9] = wantReply === void 0 || wantReply === true ? 1 : 0;
        writeUInt32BE(packet, nameLen, ++p);
        packet.utf8Write(name4, p += 4, nameLen);
        this._debug && this._debug(
          `Outbound: Sending CHANNEL_REQUEST (r:${chan}, subsystem: ${name4})`
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      openssh_agentForward(chan, wantReply) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4 + 26 + 1);
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 26, p += 4);
        packet.utf8Write("auth-agent-req@openssh.com", p += 4, 26);
        packet[p += 26] = wantReply === void 0 || wantReply === true ? 1 : 0;
        if (this._debug) {
          this._debug(
            `Outbound: Sending CHANNEL_REQUEST (r:${chan}, auth-agent-req@openssh.com)`
          );
        }
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      openssh_hostKeysProve(keys4) {
        if (this._server)
          throw new Error("Client-only method called in server mode");
        let keysTotal = 0;
        const publicKeys = [];
        for (const key of keys4) {
          const publicKey = key.getPublicSSH();
          keysTotal += 4 + publicKey.length;
          publicKeys.push(publicKey);
        }
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 29 + 1 + keysTotal);
        packet[p] = MESSAGE.GLOBAL_REQUEST;
        writeUInt32BE(packet, 29, ++p);
        packet.utf8Write("hostkeys-prove-00@openssh.com", p += 4, 29);
        packet[p += 29] = 1;
        ++p;
        for (const buf of publicKeys) {
          writeUInt32BE(packet, buf.length, p);
          bufferCopy(buf, packet, 0, buf.length, p += 4);
          p += buf.length;
        }
        if (this._debug) {
          this._debug(
            "Outbound: Sending GLOBAL_REQUEST (hostkeys-prove-00@openssh.com)"
          );
        }
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      // ===========================================================================
      // Server-specific ===========================================================
      // ===========================================================================
      // Global
      // ------
      serviceAccept(svcName) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        const svcNameLen = Buffer.byteLength(svcName);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + svcNameLen);
        packet[p] = MESSAGE.SERVICE_ACCEPT;
        writeUInt32BE(packet, svcNameLen, ++p);
        packet.utf8Write(svcName, p += 4, svcNameLen);
        this._debug && this._debug(`Outbound: Sending SERVICE_ACCEPT (${svcName})`);
        sendPacket(this, this._packetRW.write.finalize(packet));
        if (this._server && this._banner && svcName === "ssh-userauth") {
          const banner = this._banner;
          this._banner = void 0;
          const bannerLen = Buffer.byteLength(banner);
          p = this._packetRW.write.allocStart;
          const packet2 = this._packetRW.write.alloc(1 + 4 + bannerLen + 4);
          packet2[p] = MESSAGE.USERAUTH_BANNER;
          writeUInt32BE(packet2, bannerLen, ++p);
          packet2.utf8Write(banner, p += 4, bannerLen);
          writeUInt32BE(packet2, 0, p += bannerLen);
          this._debug && this._debug("Outbound: Sending USERAUTH_BANNER");
          sendPacket(this, this._packetRW.write.finalize(packet2));
        }
      }
      // 'ssh-connection' service-specific
      forwardedTcpip(chan, initWindow, maxPacket, cfg) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        const boundAddrLen = Buffer.byteLength(cfg.boundAddr);
        const remoteAddrLen = Buffer.byteLength(cfg.remoteAddr);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + 15 + 4 + 4 + 4 + 4 + boundAddrLen + 4 + 4 + remoteAddrLen + 4
        );
        packet[p] = MESSAGE.CHANNEL_OPEN;
        writeUInt32BE(packet, 15, ++p);
        packet.utf8Write("forwarded-tcpip", p += 4, 15);
        writeUInt32BE(packet, chan, p += 15);
        writeUInt32BE(packet, initWindow, p += 4);
        writeUInt32BE(packet, maxPacket, p += 4);
        writeUInt32BE(packet, boundAddrLen, p += 4);
        packet.utf8Write(cfg.boundAddr, p += 4, boundAddrLen);
        writeUInt32BE(packet, cfg.boundPort, p += boundAddrLen);
        writeUInt32BE(packet, remoteAddrLen, p += 4);
        packet.utf8Write(cfg.remoteAddr, p += 4, remoteAddrLen);
        writeUInt32BE(packet, cfg.remotePort, p += remoteAddrLen);
        this._debug && this._debug(
          `Outbound: Sending CHANNEL_OPEN (r:${chan}, forwarded-tcpip)`
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      x11(chan, initWindow, maxPacket, cfg) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        const addrLen = Buffer.byteLength(cfg.originAddr);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + 3 + 4 + 4 + 4 + 4 + addrLen + 4
        );
        packet[p] = MESSAGE.CHANNEL_OPEN;
        writeUInt32BE(packet, 3, ++p);
        packet.utf8Write("x11", p += 4, 3);
        writeUInt32BE(packet, chan, p += 3);
        writeUInt32BE(packet, initWindow, p += 4);
        writeUInt32BE(packet, maxPacket, p += 4);
        writeUInt32BE(packet, addrLen, p += 4);
        packet.utf8Write(cfg.originAddr, p += 4, addrLen);
        writeUInt32BE(packet, cfg.originPort, p += addrLen);
        this._debug && this._debug(
          `Outbound: Sending CHANNEL_OPEN (r:${chan}, x11)`
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      openssh_authAgent(chan, initWindow, maxPacket) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 22 + 4 + 4 + 4);
        packet[p] = MESSAGE.CHANNEL_OPEN;
        writeUInt32BE(packet, 22, ++p);
        packet.utf8Write("auth-agent@openssh.com", p += 4, 22);
        writeUInt32BE(packet, chan, p += 22);
        writeUInt32BE(packet, initWindow, p += 4);
        writeUInt32BE(packet, maxPacket, p += 4);
        this._debug && this._debug(
          `Outbound: Sending CHANNEL_OPEN (r:${chan}, auth-agent@openssh.com)`
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      openssh_forwardedStreamLocal(chan, initWindow, maxPacket, cfg) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        const pathLen = Buffer.byteLength(cfg.socketPath);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + 33 + 4 + 4 + 4 + 4 + pathLen + 4
        );
        packet[p] = MESSAGE.CHANNEL_OPEN;
        writeUInt32BE(packet, 33, ++p);
        packet.utf8Write("forwarded-streamlocal@openssh.com", p += 4, 33);
        writeUInt32BE(packet, chan, p += 33);
        writeUInt32BE(packet, initWindow, p += 4);
        writeUInt32BE(packet, maxPacket, p += 4);
        writeUInt32BE(packet, pathLen, p += 4);
        packet.utf8Write(cfg.socketPath, p += 4, pathLen);
        writeUInt32BE(packet, 0, p += pathLen);
        if (this._debug) {
          this._debug(
            `Outbound: Sending CHANNEL_OPEN (r:${chan}, forwarded-streamlocal@openssh.com)`
          );
        }
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      exitStatus(chan, status) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4 + 11 + 1 + 4);
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 11, p += 4);
        packet.utf8Write("exit-status", p += 4, 11);
        packet[p += 11] = 0;
        writeUInt32BE(packet, status, ++p);
        this._debug && this._debug(
          `Outbound: Sending CHANNEL_REQUEST (r:${chan}, exit-status: ${status})`
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      exitSignal(chan, name4, coreDumped, msg) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        const origSignal = name4;
        if (typeof origSignal !== "string" || !origSignal)
          throw new Error(`Invalid signal: ${origSignal}`);
        let signal = name4.toUpperCase();
        if (signal.slice(0, 3) === "SIG")
          signal = signal.slice(3);
        if (SIGNALS[signal] !== 1)
          throw new Error(`Invalid signal: ${origSignal}`);
        const nameLen = Buffer.byteLength(signal);
        const msgLen = msg ? Buffer.byteLength(msg) : 0;
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + 4 + 11 + 1 + 4 + nameLen + 1 + 4 + msgLen + 4
        );
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 11, p += 4);
        packet.utf8Write("exit-signal", p += 4, 11);
        packet[p += 11] = 0;
        writeUInt32BE(packet, nameLen, ++p);
        packet.utf8Write(signal, p += 4, nameLen);
        packet[p += nameLen] = coreDumped ? 1 : 0;
        writeUInt32BE(packet, msgLen, ++p);
        p += 4;
        if (msgLen) {
          packet.utf8Write(msg, p, msgLen);
          p += msgLen;
        }
        writeUInt32BE(packet, 0, p);
        this._debug && this._debug(
          `Outbound: Sending CHANNEL_REQUEST (r:${chan}, exit-signal: ${name4})`
        );
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      // 'ssh-userauth' service-specific
      authFailure(authMethods, isPartial) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        if (this._authsQueue.length === 0)
          throw new Error("No auth in progress");
        let methods;
        if (typeof authMethods === "boolean") {
          isPartial = authMethods;
          authMethods = void 0;
        }
        if (authMethods) {
          methods = [];
          for (let i = 0; i < authMethods.length; ++i) {
            if (authMethods[i].toLowerCase() === "none")
              continue;
            methods.push(authMethods[i]);
          }
          methods = methods.join(",");
        } else {
          methods = "";
        }
        const methodsLen = methods.length;
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + methodsLen + 1);
        packet[p] = MESSAGE.USERAUTH_FAILURE;
        writeUInt32BE(packet, methodsLen, ++p);
        packet.utf8Write(methods, p += 4, methodsLen);
        packet[p += methodsLen] = isPartial === true ? 1 : 0;
        this._authsQueue.shift();
        this._debug && this._debug("Outbound: Sending USERAUTH_FAILURE");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      authSuccess() {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        if (this._authsQueue.length === 0)
          throw new Error("No auth in progress");
        const p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1);
        packet[p] = MESSAGE.USERAUTH_SUCCESS;
        this._authsQueue.shift();
        this._authenticated = true;
        this._debug && this._debug("Outbound: Sending USERAUTH_SUCCESS");
        sendPacket(this, this._packetRW.write.finalize(packet));
        if (this._kex.negotiated.cs.compress === "zlib@openssh.com")
          this._packetRW.read = new ZlibPacketReader();
        if (this._kex.negotiated.sc.compress === "zlib@openssh.com")
          this._packetRW.write = new ZlibPacketWriter(this);
      }
      authPKOK(keyAlgo, key) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        if (this._authsQueue.length === 0 || this._authsQueue[0] !== "publickey")
          throw new Error('"publickey" auth not in progress');
        const keyAlgoLen = Buffer.byteLength(keyAlgo);
        const keyLen = key.length;
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + keyAlgoLen + 4 + keyLen);
        packet[p] = MESSAGE.USERAUTH_PK_OK;
        writeUInt32BE(packet, keyAlgoLen, ++p);
        packet.utf8Write(keyAlgo, p += 4, keyAlgoLen);
        writeUInt32BE(packet, keyLen, p += keyAlgoLen);
        packet.set(key, p += 4);
        this._authsQueue.shift();
        this._debug && this._debug("Outbound: Sending USERAUTH_PK_OK");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      authPasswdChg(prompt) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        const promptLen = Buffer.byteLength(prompt);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + promptLen + 4);
        packet[p] = MESSAGE.USERAUTH_PASSWD_CHANGEREQ;
        writeUInt32BE(packet, promptLen, ++p);
        packet.utf8Write(prompt, p += 4, promptLen);
        writeUInt32BE(packet, 0, p += promptLen);
        this._debug && this._debug("Outbound: Sending USERAUTH_PASSWD_CHANGEREQ");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      authInfoReq(name4, instructions, prompts) {
        if (!this._server)
          throw new Error("Server-only method called in client mode");
        let promptsLen = 0;
        const nameLen = name4 ? Buffer.byteLength(name4) : 0;
        const instrLen = instructions ? Buffer.byteLength(instructions) : 0;
        for (let i = 0; i < prompts.length; ++i)
          promptsLen += 4 + Buffer.byteLength(prompts[i].prompt) + 1;
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(
          1 + 4 + nameLen + 4 + instrLen + 4 + 4 + promptsLen
        );
        packet[p] = MESSAGE.USERAUTH_INFO_REQUEST;
        writeUInt32BE(packet, nameLen, ++p);
        p += 4;
        if (name4) {
          packet.utf8Write(name4, p, nameLen);
          p += nameLen;
        }
        writeUInt32BE(packet, instrLen, p);
        p += 4;
        if (instructions) {
          packet.utf8Write(instructions, p, instrLen);
          p += instrLen;
        }
        writeUInt32BE(packet, 0, p);
        writeUInt32BE(packet, prompts.length, p += 4);
        p += 4;
        for (let i = 0; i < prompts.length; ++i) {
          const prompt = prompts[i];
          const promptLen = Buffer.byteLength(prompt.prompt);
          writeUInt32BE(packet, promptLen, p);
          p += 4;
          if (promptLen) {
            packet.utf8Write(prompt.prompt, p, promptLen);
            p += promptLen;
          }
          packet[p++] = prompt.echo ? 1 : 0;
        }
        this._debug && this._debug("Outbound: Sending USERAUTH_INFO_REQUEST");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
    };
    var RE_IDENT = /^SSH-(2\.0|1\.99)-([^ ]+)(?: (.*))?$/;
    function parseHeader(chunk, p, len) {
      let data;
      let chunkOffset;
      if (this._buffer) {
        data = Buffer.allocUnsafe(this._buffer.length + (len - p));
        data.set(this._buffer, 0);
        if (p === 0) {
          data.set(chunk, this._buffer.length);
        } else {
          data.set(
            new Uint8Array(
              chunk.buffer,
              chunk.byteOffset + p,
              len - p
            ),
            this._buffer.length
          );
        }
        chunkOffset = this._buffer.length;
        p = 0;
      } else {
        data = chunk;
        chunkOffset = 0;
      }
      const op = p;
      let start = p;
      let end4 = p;
      let needNL = false;
      let lineLen = 0;
      let lines6 = 0;
      for (; p < data.length; ++p) {
        const ch = data[p];
        if (ch === 13) {
          needNL = true;
          continue;
        }
        if (ch === 10) {
          if (end4 > start && end4 - start > 4 && data[start] === 83 && data[start + 1] === 83 && data[start + 2] === 72 && data[start + 3] === 45) {
            const full = data.latin1Slice(op, end4 + 1);
            const identRaw = start === op ? full : full.slice(start - op);
            const m = RE_IDENT.exec(identRaw);
            if (!m)
              throw new Error("Invalid identification string");
            const header = {
              greeting: start === op ? "" : full.slice(0, start - op),
              identRaw,
              versions: {
                protocol: m[1],
                software: m[2]
              },
              comments: m[3]
            };
            this._remoteIdentRaw = Buffer.from(identRaw);
            this._debug && this._debug(`Remote ident: ${inspect2(identRaw)}`);
            this._compatFlags = getCompatFlags(header);
            this._buffer = void 0;
            this._decipher = new NullDecipher(0, onKEXPayload.bind(this, { firstPacket: true }));
            this._parse = parsePacket;
            this._onHeader(header);
            if (!this._destruct) {
              return len;
            }
            kexinit(this);
            return p + 1 - chunkOffset;
          }
          if (this._server)
            throw new Error("Greetings from clients not permitted");
          if (++lines6 > MAX_LINES)
            throw new Error("Max greeting lines exceeded");
          needNL = false;
          start = p + 1;
          lineLen = 0;
        } else if (needNL) {
          throw new Error("Invalid header: expected newline");
        } else if (++lineLen >= MAX_LINE_LEN) {
          throw new Error("Header line too long");
        }
        end4 = p;
      }
      if (!this._buffer)
        this._buffer = bufferSlice(data, op);
      return p - chunkOffset;
    }
    function parsePacket(chunk, p, len) {
      return this._decipher.decrypt(chunk, p, len);
    }
    function onPayload(payload) {
      this._onPacket();
      if (payload.length === 0) {
        this._debug && this._debug("Inbound: Skipping empty packet payload");
        return;
      }
      payload = this._packetRW.read.read(payload);
      const type = payload[0];
      if (type === MESSAGE.USERAUTH_SUCCESS && !this._server && !this._authenticated) {
        this._authenticated = true;
        if (this._kex.negotiated.cs.compress === "zlib@openssh.com")
          this._packetRW.write = new ZlibPacketWriter(this);
        if (this._kex.negotiated.sc.compress === "zlib@openssh.com")
          this._packetRW.read = new ZlibPacketReader();
      }
      const handler = MESSAGE_HANDLERS[type];
      if (handler === void 0) {
        this._debug && this._debug(`Inbound: Unsupported message type: ${type}`);
        return;
      }
      return handler(this, payload);
    }
    function getCompatFlags(header) {
      const software = header.versions.software;
      let flags = 0;
      for (const rule of COMPAT_CHECKS) {
        if (typeof rule[0] === "string") {
          if (software === rule[0])
            flags |= rule[1];
        } else if (rule[0].test(software)) {
          flags |= rule[1];
        }
      }
      return flags;
    }
    function modesToBytes(modes) {
      const keys4 = Object.keys(modes);
      const bytes = Buffer.allocUnsafe(5 * keys4.length + 1);
      let b = 0;
      for (let i = 0; i < keys4.length; ++i) {
        const key = keys4[i];
        if (key === "TTY_OP_END")
          continue;
        const opcode = TERMINAL_MODE[key];
        if (opcode === void 0)
          continue;
        const val = modes[key];
        if (typeof val === "number" && isFinite(val)) {
          bytes[b++] = opcode;
          bytes[b++] = val >>> 24;
          bytes[b++] = val >>> 16;
          bytes[b++] = val >>> 8;
          bytes[b++] = val;
        }
      }
      bytes[b++] = TERMINAL_MODE.TTY_OP_END;
      if (b < bytes.length)
        return bufferSlice(bytes, 0, b);
      return bytes;
    }
    function sendExtInfo(proto) {
      let serverSigAlgs = "ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521rsa-sha2-512,rsa-sha2-256,ssh-rsa,ssh-dss";
      if (eddsaSupported)
        serverSigAlgs = `ssh-ed25519,${serverSigAlgs}`;
      const algsLen = Buffer.byteLength(serverSigAlgs);
      let p = proto._packetRW.write.allocStart;
      const packet = proto._packetRW.write.alloc(1 + 4 + 4 + 15 + 4 + algsLen);
      packet[p] = MESSAGE.EXT_INFO;
      writeUInt32BE(packet, 1, ++p);
      writeUInt32BE(packet, 15, p += 4);
      packet.utf8Write("server-sig-algs", p += 4, 15);
      writeUInt32BE(packet, algsLen, p += 15);
      packet.utf8Write(serverSigAlgs, p += 4, algsLen);
      proto._debug && proto._debug("Outbound: Sending EXT_INFO");
      sendPacket(proto, proto._packetRW.write.finalize(packet));
    }
    module.exports = Protocol;
  }
});

// node_modules/ssh2/lib/protocol/node-fs-compat.js
var require_node_fs_compat = __commonJS({
  "node_modules/ssh2/lib/protocol/node-fs-compat.js"(exports) {
    "use strict";
    var assert = __require("assert");
    var { inspect: inspect2 } = __require("util");
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3)
        res = `_${val.slice(i - 3, i)}${res}`;
      return `${val.slice(0, i)}${res}`;
    }
    function oneOf5(expected, thing) {
      assert(typeof thing === "string", "`thing` has to be of type string");
      if (Array.isArray(expected)) {
        const len = expected.length;
        assert(len > 0, "At least one expected value needs to be specified");
        expected = expected.map((i) => String(i));
        if (len > 2) {
          return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        } else if (len === 2) {
          return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        }
        return `of ${thing} ${expected[0]}`;
      }
      return `of ${thing} ${String(expected)}`;
    }
    exports.ERR_INTERNAL_ASSERTION = class ERR_INTERNAL_ASSERTION extends Error {
      constructor(message2) {
        super();
        Error.captureStackTrace(this, ERR_INTERNAL_ASSERTION);
        const suffix2 = "This is caused by either a bug in ssh2 or incorrect usage of ssh2 internals.\nPlease open an issue with this stack trace at https://github.com/mscdex/ssh2/issues\n";
        this.message = message2 === void 0 ? suffix2 : `${message2}
${suffix2}`;
      }
    };
    var MAX_32BIT_INT = 2 ** 32;
    var MAX_32BIT_BIGINT = (() => {
      try {
        return new Function("return 2n ** 32n")();
      } catch {
      }
    })();
    exports.ERR_OUT_OF_RANGE = class ERR_OUT_OF_RANGE extends RangeError {
      constructor(str2, range3, input, replaceDefaultBoolean) {
        super();
        Error.captureStackTrace(this, ERR_OUT_OF_RANGE);
        assert(range3, 'Missing "range" argument');
        let msg = replaceDefaultBoolean ? str2 : `The value of "${str2}" is out of range.`;
        let received;
        if (Number.isInteger(input) && Math.abs(input) > MAX_32BIT_INT) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > MAX_32BIT_BIGINT || input < -MAX_32BIT_BIGINT)
            received = addNumericalSeparator(received);
          received += "n";
        } else {
          received = inspect2(input);
        }
        msg += ` It must be ${range3}. Received ${received}`;
        this.message = msg;
      }
    };
    var ERR_INVALID_ARG_TYPE = class _ERR_INVALID_ARG_TYPE extends TypeError {
      constructor(name4, expected, actual) {
        super();
        Error.captureStackTrace(this, _ERR_INVALID_ARG_TYPE);
        assert(typeof name4 === "string", `'name' must be a string`);
        let determiner;
        if (typeof expected === "string" && expected.startsWith("not ")) {
          determiner = "must not be";
          expected = expected.replace(/^not /, "");
        } else {
          determiner = "must be";
        }
        let msg;
        if (name4.endsWith(" argument")) {
          msg = `The ${name4} ${determiner} ${oneOf5(expected, "type")}`;
        } else {
          const type = name4.includes(".") ? "property" : "argument";
          msg = `The "${name4}" ${type} ${determiner} ${oneOf5(expected, "type")}`;
        }
        msg += `. Received type ${typeof actual}`;
        this.message = msg;
      }
    };
    exports.ERR_INVALID_ARG_TYPE = ERR_INVALID_ARG_TYPE;
    exports.validateNumber = function validateNumber(value4, name4) {
      if (typeof value4 !== "number")
        throw new ERR_INVALID_ARG_TYPE(name4, "number", value4);
    };
  }
});

// node_modules/ssh2/lib/protocol/SFTP.js
var require_SFTP = __commonJS({
  "node_modules/ssh2/lib/protocol/SFTP.js"(exports, module) {
    "use strict";
    var EventEmitter = __require("events");
    var fs2 = __require("fs");
    var { constants: constants4 } = fs2;
    var {
      Readable: ReadableStream,
      Writable: WritableStream
    } = __require("stream");
    var { inherits, isDate } = __require("util");
    var FastBuffer = Buffer[Symbol.species];
    var {
      bufferCopy,
      bufferSlice,
      makeBufferParser,
      writeUInt32BE
    } = require_utils7();
    var ATTR = {
      SIZE: 1,
      UIDGID: 2,
      PERMISSIONS: 4,
      ACMODTIME: 8,
      EXTENDED: 2147483648
    };
    var ATTRS_BUF = Buffer.alloc(28);
    var STATUS_CODE = {
      OK: 0,
      EOF: 1,
      NO_SUCH_FILE: 2,
      PERMISSION_DENIED: 3,
      FAILURE: 4,
      BAD_MESSAGE: 5,
      NO_CONNECTION: 6,
      CONNECTION_LOST: 7,
      OP_UNSUPPORTED: 8
    };
    var VALID_STATUS_CODES = new Map(
      Object.values(STATUS_CODE).map((n) => [n, 1])
    );
    var STATUS_CODE_STR = {
      [STATUS_CODE.OK]: "No error",
      [STATUS_CODE.EOF]: "End of file",
      [STATUS_CODE.NO_SUCH_FILE]: "No such file or directory",
      [STATUS_CODE.PERMISSION_DENIED]: "Permission denied",
      [STATUS_CODE.FAILURE]: "Failure",
      [STATUS_CODE.BAD_MESSAGE]: "Bad message",
      [STATUS_CODE.NO_CONNECTION]: "No connection",
      [STATUS_CODE.CONNECTION_LOST]: "Connection lost",
      [STATUS_CODE.OP_UNSUPPORTED]: "Operation unsupported"
    };
    var REQUEST = {
      INIT: 1,
      OPEN: 3,
      CLOSE: 4,
      READ: 5,
      WRITE: 6,
      LSTAT: 7,
      FSTAT: 8,
      SETSTAT: 9,
      FSETSTAT: 10,
      OPENDIR: 11,
      READDIR: 12,
      REMOVE: 13,
      MKDIR: 14,
      RMDIR: 15,
      REALPATH: 16,
      STAT: 17,
      RENAME: 18,
      READLINK: 19,
      SYMLINK: 20,
      EXTENDED: 200
    };
    var RESPONSE = {
      VERSION: 2,
      STATUS: 101,
      HANDLE: 102,
      DATA: 103,
      NAME: 104,
      ATTRS: 105,
      EXTENDED: 201
    };
    var OPEN_MODE = {
      READ: 1,
      WRITE: 2,
      APPEND: 4,
      CREAT: 8,
      TRUNC: 16,
      EXCL: 32
    };
    var PKT_RW_OVERHEAD = 2 * 1024;
    var MAX_REQID = 2 ** 32 - 1;
    var CLIENT_VERSION_BUFFER = Buffer.from([
      0,
      0,
      0,
      5,
      REQUEST.INIT,
      0,
      0,
      0,
      3
      /* version */
    ]);
    var SERVER_VERSION_BUFFER = Buffer.from([
      0,
      0,
      0,
      5,
      RESPONSE.VERSION,
      0,
      0,
      0,
      3
      /* version */
    ]);
    var RE_OPENSSH = /^SSH-2.0-(?:OpenSSH|dropbear)/;
    var OPENSSH_MAX_PKT_LEN = 256 * 1024;
    var bufferParser = makeBufferParser();
    var fakeStderr = {
      readable: false,
      writable: false,
      push: (data) => {
      },
      once: () => {
      },
      on: () => {
      },
      emit: () => {
      },
      end: () => {
      }
    };
    function noop() {
    }
    var SFTP = class extends EventEmitter {
      constructor(client, chanInfo, cfg) {
        super();
        if (typeof cfg !== "object" || !cfg)
          cfg = {};
        const remoteIdentRaw = client._protocol._remoteIdentRaw;
        this.server = !!cfg.server;
        this._debug = typeof cfg.debug === "function" ? cfg.debug : void 0;
        this._isOpenSSH = remoteIdentRaw && RE_OPENSSH.test(remoteIdentRaw);
        this._version = -1;
        this._extensions = {};
        this._biOpt = cfg.biOpt;
        this._pktLenBytes = 0;
        this._pktLen = 0;
        this._pktPos = 0;
        this._pktType = 0;
        this._pktData = void 0;
        this._writeReqid = -1;
        this._requests = {};
        this._maxInPktLen = OPENSSH_MAX_PKT_LEN;
        this._maxOutPktLen = 34e3;
        this._maxReadLen = (this._isOpenSSH ? OPENSSH_MAX_PKT_LEN : 34e3) - PKT_RW_OVERHEAD;
        this._maxWriteLen = (this._isOpenSSH ? OPENSSH_MAX_PKT_LEN : 34e3) - PKT_RW_OVERHEAD;
        this.maxOpenHandles = void 0;
        this._client = client;
        this._protocol = client._protocol;
        this._callbacks = [];
        this._hasX11 = false;
        this._exit = {
          code: void 0,
          signal: void 0,
          dump: void 0,
          desc: void 0
        };
        this._waitWindow = false;
        this._chunkcb = void 0;
        this._buffer = [];
        this.type = chanInfo.type;
        this.subtype = void 0;
        this.incoming = chanInfo.incoming;
        this.outgoing = chanInfo.outgoing;
        this.stderr = fakeStderr;
        this.readable = true;
      }
      // This handles incoming data to parse
      push(data) {
        if (data === null) {
          cleanupRequests(this);
          if (!this.readable)
            return;
          this.readable = false;
          this.emit("end");
          return;
        }
        let p = 0;
        while (p < data.length) {
          if (this._pktLenBytes < 4) {
            let nb = Math.min(4 - this._pktLenBytes, data.length - p);
            this._pktLenBytes += nb;
            while (nb--)
              this._pktLen = (this._pktLen << 8) + data[p++];
            if (this._pktLenBytes < 4)
              return;
            if (this._pktLen === 0)
              return doFatalSFTPError(this, "Invalid packet length");
            if (this._pktLen > this._maxInPktLen) {
              const max8 = this._maxInPktLen;
              return doFatalSFTPError(
                this,
                `Packet length ${this._pktLen} exceeds max length of ${max8}`
              );
            }
            if (p >= data.length)
              return;
          }
          if (this._pktPos < this._pktLen) {
            const nb = Math.min(this._pktLen - this._pktPos, data.length - p);
            if (p !== 0 || nb !== data.length) {
              if (nb === this._pktLen) {
                this._pkt = new FastBuffer(data.buffer, data.byteOffset + p, nb);
              } else {
                if (!this._pkt)
                  this._pkt = Buffer.allocUnsafe(this._pktLen);
                this._pkt.set(
                  new Uint8Array(data.buffer, data.byteOffset + p, nb),
                  this._pktPos
                );
              }
            } else if (nb === this._pktLen) {
              this._pkt = data;
            } else {
              if (!this._pkt)
                this._pkt = Buffer.allocUnsafe(this._pktLen);
              this._pkt.set(data, this._pktPos);
            }
            p += nb;
            this._pktPos += nb;
            if (this._pktPos < this._pktLen)
              return;
          }
          const type = this._pkt[0];
          const payload = this._pkt;
          this._pktLen = 0;
          this._pktLenBytes = 0;
          this._pkt = void 0;
          this._pktPos = 0;
          const handler = this.server ? SERVER_HANDLERS[type] : CLIENT_HANDLERS[type];
          if (!handler)
            return doFatalSFTPError(this, `Unknown packet type ${type}`);
          if (this._version === -1) {
            if (this.server) {
              if (type !== REQUEST.INIT)
                return doFatalSFTPError(this, `Expected INIT packet, got ${type}`);
            } else if (type !== RESPONSE.VERSION) {
              return doFatalSFTPError(this, `Expected VERSION packet, got ${type}`);
            }
          }
          if (handler(this, payload) === false)
            return;
        }
      }
      end() {
        this.destroy();
      }
      destroy() {
        if (this.outgoing.state === "open" || this.outgoing.state === "eof") {
          this.outgoing.state = "closing";
          this._protocol.channelClose(this.outgoing.id);
        }
      }
      _init() {
        this._init = noop;
        if (!this.server)
          sendOrBuffer(this, CLIENT_VERSION_BUFFER);
      }
      // ===========================================================================
      // Client-specific ===========================================================
      // ===========================================================================
      createReadStream(path5, options) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        return new ReadStream(this, path5, options);
      }
      createWriteStream(path5, options) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        return new WriteStream(this, path5, options);
      }
      open(path5, flags_, attrs, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        if (typeof attrs === "function") {
          cb = attrs;
          attrs = void 0;
        }
        const flags = typeof flags_ === "number" ? flags_ : stringToFlags(flags_);
        if (flags === null)
          throw new Error(`Unknown flags string: ${flags_}`);
        let attrsFlags = 0;
        let attrsLen = 0;
        if (typeof attrs === "string" || typeof attrs === "number")
          attrs = { mode: attrs };
        if (typeof attrs === "object" && attrs !== null) {
          attrs = attrsToBytes(attrs);
          attrsFlags = attrs.flags;
          attrsLen = attrs.nb;
        }
        const pathLen = Buffer.byteLength(path5);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen + 4 + 4 + attrsLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.OPEN;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, pathLen, p);
        buf.utf8Write(path5, p += 4, pathLen);
        writeUInt32BE(buf, flags, p += pathLen);
        writeUInt32BE(buf, attrsFlags, p += 4);
        if (attrsLen) {
          p += 4;
          if (attrsLen === ATTRS_BUF.length)
            buf.set(ATTRS_BUF, p);
          else
            bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);
          p += attrsLen;
        }
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} OPEN`
        );
      }
      close(handle, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        if (!Buffer.isBuffer(handle))
          throw new Error("handle is not a Buffer");
        const handleLen = handle.length;
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.CLOSE;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, handleLen, p);
        buf.set(handle, p += 4);
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} CLOSE`
        );
      }
      read(handle, buf, off, len, position2, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        if (!Buffer.isBuffer(handle))
          throw new Error("handle is not a Buffer");
        if (!Buffer.isBuffer(buf))
          throw new Error("buffer is not a Buffer");
        if (off >= buf.length)
          throw new Error("offset is out of bounds");
        if (off + len > buf.length)
          throw new Error("length extends beyond buffer");
        if (position2 === null)
          throw new Error("null position currently unsupported");
        read_(this, handle, buf, off, len, position2, cb);
      }
      readData(handle, buf, off, len, position2, cb) {
        this.read(handle, buf, off, len, position2, cb);
      }
      write(handle, buf, off, len, position2, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        if (!Buffer.isBuffer(handle))
          throw new Error("handle is not a Buffer");
        if (!Buffer.isBuffer(buf))
          throw new Error("buffer is not a Buffer");
        if (off > buf.length)
          throw new Error("offset is out of bounds");
        if (off + len > buf.length)
          throw new Error("length extends beyond buffer");
        if (position2 === null)
          throw new Error("null position currently unsupported");
        if (!len) {
          cb && process.nextTick(cb, void 0, 0);
          return;
        }
        const maxDataLen = this._maxWriteLen;
        const overflow = Math.max(len - maxDataLen, 0);
        const origPosition = position2;
        if (overflow)
          len = maxDataLen;
        const handleLen = handle.length;
        let p = 9;
        const out = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen + 8 + 4 + len);
        writeUInt32BE(out, out.length - 4, 0);
        out[4] = REQUEST.WRITE;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(out, reqid, 5);
        writeUInt32BE(out, handleLen, p);
        out.set(handle, p += 4);
        p += handleLen;
        for (let i = 7; i >= 0; --i) {
          out[p + i] = position2 & 255;
          position2 /= 256;
        }
        writeUInt32BE(out, len, p += 8);
        bufferCopy(buf, out, off, off + len, p += 4);
        this._requests[reqid] = {
          cb: (err) => {
            if (err) {
              if (typeof cb === "function")
                cb(err);
            } else if (overflow) {
              this.write(
                handle,
                buf,
                off + len,
                overflow,
                origPosition + len,
                cb
              );
            } else if (typeof cb === "function") {
              cb(void 0, off + len);
            }
          }
        };
        const isSent = sendOrBuffer(this, out);
        if (this._debug) {
          const how = isSent ? "Sent" : "Buffered";
          this._debug(`SFTP: Outbound: ${how} WRITE (id:${reqid})`);
        }
      }
      writeData(handle, buf, off, len, position2, cb) {
        this.write(handle, buf, off, len, position2, cb);
      }
      fastGet(remotePath, localPath, opts, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        fastXfer(this, fs2, remotePath, localPath, opts, cb);
      }
      fastPut(localPath, remotePath, opts, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        fastXfer(fs2, this, localPath, remotePath, opts, cb);
      }
      readFile(path5, options, callback_) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        let callback;
        if (typeof callback_ === "function") {
          callback = callback_;
        } else if (typeof options === "function") {
          callback = options;
          options = void 0;
        }
        if (typeof options === "string")
          options = { encoding: options, flag: "r" };
        else if (!options)
          options = { encoding: null, flag: "r" };
        else if (typeof options !== "object")
          throw new TypeError("Bad arguments");
        const encoding = options.encoding;
        if (encoding && !Buffer.isEncoding(encoding))
          throw new Error(`Unknown encoding: ${encoding}`);
        let size10;
        let buffer;
        let buffers;
        let pos = 0;
        let handle;
        let bytesRead = 0;
        const flag2 = options.flag || "r";
        const read7 = () => {
          if (size10 === 0) {
            buffer = Buffer.allocUnsafe(8192);
            this.read(handle, buffer, 0, 8192, bytesRead, afterRead);
          } else {
            this.read(handle, buffer, pos, size10 - pos, bytesRead, afterRead);
          }
        };
        const afterRead = (er, nbytes) => {
          let eof3;
          if (er) {
            eof3 = er.code === STATUS_CODE.EOF;
            if (!eof3) {
              return this.close(handle, () => {
                return callback && callback(er);
              });
            }
          } else {
            eof3 = false;
          }
          if (eof3 || size10 === 0 && nbytes === 0)
            return close2();
          bytesRead += nbytes;
          pos += nbytes;
          if (size10 !== 0) {
            if (pos === size10)
              close2();
            else
              read7();
          } else {
            buffers.push(bufferSlice(buffer, 0, nbytes));
            read7();
          }
        };
        afterRead._wantEOFError = true;
        const close2 = () => {
          this.close(handle, (er) => {
            if (size10 === 0) {
              buffer = Buffer.concat(buffers, pos);
            } else if (pos < size10) {
              buffer = bufferSlice(buffer, 0, pos);
            }
            if (encoding)
              buffer = buffer.toString(encoding);
            return callback && callback(er, buffer);
          });
        };
        this.open(path5, flag2, 438, (er, handle_) => {
          if (er)
            return callback && callback(er);
          handle = handle_;
          const tryStat = (er2, st) => {
            if (er2) {
              this.stat(path5, (er_, st_) => {
                if (er_) {
                  return this.close(handle, () => {
                    callback && callback(er2);
                  });
                }
                tryStat(null, st_);
              });
              return;
            }
            size10 = st.size || 0;
            if (size10 === 0) {
              buffers = [];
              return read7();
            }
            buffer = Buffer.allocUnsafe(size10);
            read7();
          };
          this.fstat(handle, tryStat);
        });
      }
      writeFile(path5, data, options, callback_) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        let callback;
        if (typeof callback_ === "function") {
          callback = callback_;
        } else if (typeof options === "function") {
          callback = options;
          options = void 0;
        }
        if (typeof options === "string")
          options = { encoding: options, mode: 438, flag: "w" };
        else if (!options)
          options = { encoding: "utf8", mode: 438, flag: "w" };
        else if (typeof options !== "object")
          throw new TypeError("Bad arguments");
        if (options.encoding && !Buffer.isEncoding(options.encoding))
          throw new Error(`Unknown encoding: ${options.encoding}`);
        const flag2 = options.flag || "w";
        this.open(path5, flag2, options.mode, (openErr, handle) => {
          if (openErr) {
            callback && callback(openErr);
          } else {
            const buffer = Buffer.isBuffer(data) ? data : Buffer.from("" + data, options.encoding || "utf8");
            const position2 = /a/.test(flag2) ? null : 0;
            if (position2 === null) {
              const tryStat = (er, st) => {
                if (er) {
                  this.stat(path5, (er_, st_) => {
                    if (er_) {
                      return this.close(handle, () => {
                        callback && callback(er);
                      });
                    }
                    tryStat(null, st_);
                  });
                  return;
                }
                writeAll(this, handle, buffer, 0, buffer.length, st.size, callback);
              };
              this.fstat(handle, tryStat);
              return;
            }
            writeAll(this, handle, buffer, 0, buffer.length, position2, callback);
          }
        });
      }
      appendFile(path5, data, options, callback_) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        let callback;
        if (typeof callback_ === "function") {
          callback = callback_;
        } else if (typeof options === "function") {
          callback = options;
          options = void 0;
        }
        if (typeof options === "string")
          options = { encoding: options, mode: 438, flag: "a" };
        else if (!options)
          options = { encoding: "utf8", mode: 438, flag: "a" };
        else if (typeof options !== "object")
          throw new TypeError("Bad arguments");
        if (!options.flag)
          options = Object.assign({ flag: "a" }, options);
        this.writeFile(path5, data, options, callback);
      }
      exists(path5, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        this.stat(path5, (err) => {
          cb && cb(err ? false : true);
        });
      }
      unlink(filename, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const fnameLen = Buffer.byteLength(filename);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + fnameLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.REMOVE;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, fnameLen, p);
        buf.utf8Write(filename, p += 4, fnameLen);
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} REMOVE`
        );
      }
      rename(oldPath, newPath, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const oldLen = Buffer.byteLength(oldPath);
        const newLen = Buffer.byteLength(newPath);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + oldLen + 4 + newLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.RENAME;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, oldLen, p);
        buf.utf8Write(oldPath, p += 4, oldLen);
        writeUInt32BE(buf, newLen, p += oldLen);
        buf.utf8Write(newPath, p += 4, newLen);
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} RENAME`
        );
      }
      mkdir(path5, attrs, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        let flags = 0;
        let attrsLen = 0;
        if (typeof attrs === "function") {
          cb = attrs;
          attrs = void 0;
        }
        if (typeof attrs === "object" && attrs !== null) {
          attrs = attrsToBytes(attrs);
          flags = attrs.flags;
          attrsLen = attrs.nb;
        }
        const pathLen = Buffer.byteLength(path5);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen + 4 + attrsLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.MKDIR;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, pathLen, p);
        buf.utf8Write(path5, p += 4, pathLen);
        writeUInt32BE(buf, flags, p += pathLen);
        if (attrsLen) {
          p += 4;
          if (attrsLen === ATTRS_BUF.length)
            buf.set(ATTRS_BUF, p);
          else
            bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);
          p += attrsLen;
        }
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} MKDIR`
        );
      }
      rmdir(path5, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const pathLen = Buffer.byteLength(path5);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.RMDIR;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, pathLen, p);
        buf.utf8Write(path5, p += 4, pathLen);
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} RMDIR`
        );
      }
      readdir(where, opts, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        if (typeof opts === "function") {
          cb = opts;
          opts = {};
        }
        if (typeof opts !== "object" || opts === null)
          opts = {};
        const doFilter = opts && opts.full ? false : true;
        if (!Buffer.isBuffer(where) && typeof where !== "string")
          throw new Error("missing directory handle or path");
        if (typeof where === "string") {
          const entries = [];
          let e = 0;
          const reread = (err, handle) => {
            if (err)
              return cb(err);
            this.readdir(handle, opts, (err2, list2) => {
              const eof3 = err2 && err2.code === STATUS_CODE.EOF;
              if (err2 && !eof3)
                return this.close(handle, () => cb(err2));
              if (eof3) {
                return this.close(handle, (err3) => {
                  if (err3)
                    return cb(err3);
                  cb(void 0, entries);
                });
              }
              for (let i = 0; i < list2.length; ++i, ++e)
                entries[e] = list2[i];
              reread(void 0, handle);
            });
          };
          return this.opendir(where, reread);
        }
        const handleLen = where.length;
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.READDIR;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, handleLen, p);
        buf.set(where, p += 4);
        this._requests[reqid] = {
          cb: doFilter ? (err, list2) => {
            if (typeof cb !== "function")
              return;
            if (err)
              return cb(err);
            for (let i = list2.length - 1; i >= 0; --i) {
              if (list2[i].filename === "." || list2[i].filename === "..")
                list2.splice(i, 1);
            }
            cb(void 0, list2);
          } : cb
        };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} READDIR`
        );
      }
      fstat(handle, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        if (!Buffer.isBuffer(handle))
          throw new Error("handle is not a Buffer");
        const handleLen = handle.length;
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.FSTAT;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, handleLen, p);
        buf.set(handle, p += 4);
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} FSTAT`
        );
      }
      stat(path5, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const pathLen = Buffer.byteLength(path5);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.STAT;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, pathLen, p);
        buf.utf8Write(path5, p += 4, pathLen);
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} STAT`
        );
      }
      lstat(path5, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const pathLen = Buffer.byteLength(path5);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.LSTAT;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, pathLen, p);
        buf.utf8Write(path5, p += 4, pathLen);
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} LSTAT`
        );
      }
      opendir(path5, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const pathLen = Buffer.byteLength(path5);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.OPENDIR;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, pathLen, p);
        buf.utf8Write(path5, p += 4, pathLen);
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} OPENDIR`
        );
      }
      setstat(path5, attrs, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        let flags = 0;
        let attrsLen = 0;
        if (typeof attrs === "object" && attrs !== null) {
          attrs = attrsToBytes(attrs);
          flags = attrs.flags;
          attrsLen = attrs.nb;
        } else if (typeof attrs === "function") {
          cb = attrs;
        }
        const pathLen = Buffer.byteLength(path5);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen + 4 + attrsLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.SETSTAT;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, pathLen, p);
        buf.utf8Write(path5, p += 4, pathLen);
        writeUInt32BE(buf, flags, p += pathLen);
        if (attrsLen) {
          p += 4;
          if (attrsLen === ATTRS_BUF.length)
            buf.set(ATTRS_BUF, p);
          else
            bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);
          p += attrsLen;
        }
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} SETSTAT`
        );
      }
      fsetstat(handle, attrs, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        if (!Buffer.isBuffer(handle))
          throw new Error("handle is not a Buffer");
        let flags = 0;
        let attrsLen = 0;
        if (typeof attrs === "object" && attrs !== null) {
          attrs = attrsToBytes(attrs);
          flags = attrs.flags;
          attrsLen = attrs.nb;
        } else if (typeof attrs === "function") {
          cb = attrs;
        }
        const handleLen = handle.length;
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen + 4 + attrsLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.FSETSTAT;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, handleLen, p);
        buf.set(handle, p += 4);
        writeUInt32BE(buf, flags, p += handleLen);
        if (attrsLen) {
          p += 4;
          if (attrsLen === ATTRS_BUF.length)
            buf.set(ATTRS_BUF, p);
          else
            bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);
          p += attrsLen;
        }
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} FSETSTAT`
        );
      }
      futimes(handle, atime, mtime, cb) {
        return this.fsetstat(handle, {
          atime: toUnixTimestamp(atime),
          mtime: toUnixTimestamp(mtime)
        }, cb);
      }
      utimes(path5, atime, mtime, cb) {
        return this.setstat(path5, {
          atime: toUnixTimestamp(atime),
          mtime: toUnixTimestamp(mtime)
        }, cb);
      }
      fchown(handle, uid, gid, cb) {
        return this.fsetstat(handle, {
          uid,
          gid
        }, cb);
      }
      chown(path5, uid, gid, cb) {
        return this.setstat(path5, {
          uid,
          gid
        }, cb);
      }
      fchmod(handle, mode, cb) {
        return this.fsetstat(handle, {
          mode
        }, cb);
      }
      chmod(path5, mode, cb) {
        return this.setstat(path5, {
          mode
        }, cb);
      }
      readlink(path5, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const pathLen = Buffer.byteLength(path5);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.READLINK;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, pathLen, p);
        buf.utf8Write(path5, p += 4, pathLen);
        this._requests[reqid] = {
          cb: (err, names) => {
            if (typeof cb !== "function")
              return;
            if (err)
              return cb(err);
            if (!names || !names.length)
              return cb(new Error("Response missing link info"));
            cb(void 0, names[0].filename);
          }
        };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} READLINK`
        );
      }
      symlink(targetPath, linkPath, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const linkLen = Buffer.byteLength(linkPath);
        const targetLen = Buffer.byteLength(targetPath);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + linkLen + 4 + targetLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.SYMLINK;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        if (this._isOpenSSH) {
          writeUInt32BE(buf, targetLen, p);
          buf.utf8Write(targetPath, p += 4, targetLen);
          writeUInt32BE(buf, linkLen, p += targetLen);
          buf.utf8Write(linkPath, p += 4, linkLen);
        } else {
          writeUInt32BE(buf, linkLen, p);
          buf.utf8Write(linkPath, p += 4, linkLen);
          writeUInt32BE(buf, targetLen, p += linkLen);
          buf.utf8Write(targetPath, p += 4, targetLen);
        }
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} SYMLINK`
        );
      }
      realpath(path5, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const pathLen = Buffer.byteLength(path5);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.REALPATH;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, pathLen, p);
        buf.utf8Write(path5, p += 4, pathLen);
        this._requests[reqid] = {
          cb: (err, names) => {
            if (typeof cb !== "function")
              return;
            if (err)
              return cb(err);
            if (!names || !names.length)
              return cb(new Error("Response missing path info"));
            cb(void 0, names[0].filename);
          }
        };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} REALPATH`
        );
      }
      // extended requests
      ext_openssh_rename(oldPath, newPath, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const ext = this._extensions["posix-rename@openssh.com"];
        if (!ext || ext !== "1")
          throw new Error("Server does not support this extended request");
        const oldLen = Buffer.byteLength(oldPath);
        const newLen = Buffer.byteLength(newPath);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 24 + 4 + oldLen + 4 + newLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.EXTENDED;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, 24, p);
        buf.utf8Write("posix-rename@openssh.com", p += 4, 24);
        writeUInt32BE(buf, oldLen, p += 24);
        buf.utf8Write(oldPath, p += 4, oldLen);
        writeUInt32BE(buf, newLen, p += oldLen);
        buf.utf8Write(newPath, p += 4, newLen);
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          const which = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${which} posix-rename@openssh.com`);
        }
      }
      ext_openssh_statvfs(path5, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const ext = this._extensions["statvfs@openssh.com"];
        if (!ext || ext !== "2")
          throw new Error("Server does not support this extended request");
        const pathLen = Buffer.byteLength(path5);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 19 + 4 + pathLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.EXTENDED;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, 19, p);
        buf.utf8Write("statvfs@openssh.com", p += 4, 19);
        writeUInt32BE(buf, pathLen, p += 19);
        buf.utf8Write(path5, p += 4, pathLen);
        this._requests[reqid] = { extended: "statvfs@openssh.com", cb };
        const isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          const which = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${which} statvfs@openssh.com`);
        }
      }
      ext_openssh_fstatvfs(handle, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const ext = this._extensions["fstatvfs@openssh.com"];
        if (!ext || ext !== "2")
          throw new Error("Server does not support this extended request");
        if (!Buffer.isBuffer(handle))
          throw new Error("handle is not a Buffer");
        const handleLen = handle.length;
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 20 + 4 + handleLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.EXTENDED;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, 20, p);
        buf.utf8Write("fstatvfs@openssh.com", p += 4, 20);
        writeUInt32BE(buf, handleLen, p += 20);
        buf.set(handle, p += 4);
        this._requests[reqid] = { extended: "fstatvfs@openssh.com", cb };
        const isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          const which = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${which} fstatvfs@openssh.com`);
        }
      }
      ext_openssh_hardlink(oldPath, newPath, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const ext = this._extensions["hardlink@openssh.com"];
        if (ext !== "1")
          throw new Error("Server does not support this extended request");
        const oldLen = Buffer.byteLength(oldPath);
        const newLen = Buffer.byteLength(newPath);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 20 + 4 + oldLen + 4 + newLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.EXTENDED;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, 20, p);
        buf.utf8Write("hardlink@openssh.com", p += 4, 20);
        writeUInt32BE(buf, oldLen, p += 20);
        buf.utf8Write(oldPath, p += 4, oldLen);
        writeUInt32BE(buf, newLen, p += oldLen);
        buf.utf8Write(newPath, p += 4, newLen);
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          const which = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${which} hardlink@openssh.com`);
        }
      }
      ext_openssh_fsync(handle, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const ext = this._extensions["fsync@openssh.com"];
        if (ext !== "1")
          throw new Error("Server does not support this extended request");
        if (!Buffer.isBuffer(handle))
          throw new Error("handle is not a Buffer");
        const handleLen = handle.length;
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 17 + 4 + handleLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.EXTENDED;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, 17, p);
        buf.utf8Write("fsync@openssh.com", p += 4, 17);
        writeUInt32BE(buf, handleLen, p += 17);
        buf.set(handle, p += 4);
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} fsync@openssh.com`
        );
      }
      ext_openssh_lsetstat(path5, attrs, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const ext = this._extensions["lsetstat@openssh.com"];
        if (ext !== "1")
          throw new Error("Server does not support this extended request");
        let flags = 0;
        let attrsLen = 0;
        if (typeof attrs === "object" && attrs !== null) {
          attrs = attrsToBytes(attrs);
          flags = attrs.flags;
          attrsLen = attrs.nb;
        } else if (typeof attrs === "function") {
          cb = attrs;
        }
        const pathLen = Buffer.byteLength(path5);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 20 + 4 + pathLen + 4 + attrsLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.EXTENDED;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, 20, p);
        buf.utf8Write("lsetstat@openssh.com", p += 4, 20);
        writeUInt32BE(buf, pathLen, p += 20);
        buf.utf8Write(path5, p += 4, pathLen);
        writeUInt32BE(buf, flags, p += pathLen);
        if (attrsLen) {
          p += 4;
          if (attrsLen === ATTRS_BUF.length)
            buf.set(ATTRS_BUF, p);
          else
            bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);
          p += attrsLen;
        }
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          const status = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${status} lsetstat@openssh.com`);
        }
      }
      ext_openssh_expandPath(path5, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const ext = this._extensions["expand-path@openssh.com"];
        if (ext !== "1")
          throw new Error("Server does not support this extended request");
        const pathLen = Buffer.byteLength(path5);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 23 + 4 + pathLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.EXTENDED;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, 23, p);
        buf.utf8Write("expand-path@openssh.com", p += 4, 23);
        writeUInt32BE(buf, pathLen, p += 20);
        buf.utf8Write(path5, p += 4, pathLen);
        this._requests[reqid] = {
          cb: (err, names) => {
            if (typeof cb !== "function")
              return;
            if (err)
              return cb(err);
            if (!names || !names.length)
              return cb(new Error("Response missing expanded path"));
            cb(void 0, names[0].filename);
          }
        };
        const isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          const status = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${status} expand-path@openssh.com`);
        }
      }
      ext_copy_data(srcHandle, srcOffset, len, dstHandle, dstOffset, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const ext = this._extensions["copy-data"];
        if (ext !== "1")
          throw new Error("Server does not support this extended request");
        if (!Buffer.isBuffer(srcHandle))
          throw new Error("Source handle is not a Buffer");
        if (!Buffer.isBuffer(dstHandle))
          throw new Error("Destination handle is not a Buffer");
        let p = 0;
        const buf = Buffer.allocUnsafe(
          4 + 1 + 4 + 4 + 9 + 4 + srcHandle.length + 8 + 8 + 4 + dstHandle.length + 8
        );
        writeUInt32BE(buf, buf.length - 4, p);
        p += 4;
        buf[p] = REQUEST.EXTENDED;
        ++p;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, p);
        p += 4;
        writeUInt32BE(buf, 9, p);
        p += 4;
        buf.utf8Write("copy-data", p, 9);
        p += 9;
        writeUInt32BE(buf, srcHandle.length, p);
        p += 4;
        buf.set(srcHandle, p);
        p += srcHandle.length;
        for (let i = 7; i >= 0; --i) {
          buf[p + i] = srcOffset & 255;
          srcOffset /= 256;
        }
        p += 8;
        for (let i = 7; i >= 0; --i) {
          buf[p + i] = len & 255;
          len /= 256;
        }
        p += 8;
        writeUInt32BE(buf, dstHandle.length, p);
        p += 4;
        buf.set(dstHandle, p);
        p += dstHandle.length;
        for (let i = 7; i >= 0; --i) {
          buf[p + i] = dstOffset & 255;
          dstOffset /= 256;
        }
        this._requests[reqid] = { cb };
        const isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          const status = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${status} copy-data`);
        }
      }
      ext_home_dir(username, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const ext = this._extensions["home-directory"];
        if (ext !== "1")
          throw new Error("Server does not support this extended request");
        if (typeof username !== "string")
          throw new TypeError("username is not a string");
        let p = 0;
        const usernameLen = Buffer.byteLength(username);
        const buf = Buffer.allocUnsafe(
          4 + 1 + 4 + 4 + 14 + 4 + usernameLen
        );
        writeUInt32BE(buf, buf.length - 4, p);
        p += 4;
        buf[p] = REQUEST.EXTENDED;
        ++p;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, p);
        p += 4;
        writeUInt32BE(buf, 14, p);
        p += 4;
        buf.utf8Write("home-directory", p, 14);
        p += 14;
        writeUInt32BE(buf, usernameLen, p);
        p += 4;
        buf.utf8Write(username, p, usernameLen);
        p += usernameLen;
        this._requests[reqid] = {
          cb: (err, names) => {
            if (typeof cb !== "function")
              return;
            if (err)
              return cb(err);
            if (!names || !names.length)
              return cb(new Error("Response missing home directory"));
            cb(void 0, names[0].filename);
          }
        };
        const isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          const status = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${status} home-directory`);
        }
      }
      ext_users_groups(uids, gids, cb) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        const ext = this._extensions["users-groups-by-id@openssh.com"];
        if (ext !== "1")
          throw new Error("Server does not support this extended request");
        if (!Array.isArray(uids))
          throw new TypeError("uids is not an array");
        for (const val of uids) {
          if (!Number.isInteger(val) || val < 0 || val > 2 ** 32 - 1)
            throw new Error("uid values must all be 32-bit unsigned integers");
        }
        if (!Array.isArray(gids))
          throw new TypeError("gids is not an array");
        for (const val of gids) {
          if (!Number.isInteger(val) || val < 0 || val > 2 ** 32 - 1)
            throw new Error("gid values must all be 32-bit unsigned integers");
        }
        let p = 0;
        const buf = Buffer.allocUnsafe(
          4 + 1 + 4 + 4 + 30 + 4 + 4 * uids.length + 4 + 4 * gids.length
        );
        writeUInt32BE(buf, buf.length - 4, p);
        p += 4;
        buf[p] = REQUEST.EXTENDED;
        ++p;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, p);
        p += 4;
        writeUInt32BE(buf, 30, p);
        p += 4;
        buf.utf8Write("users-groups-by-id@openssh.com", p, 30);
        p += 30;
        writeUInt32BE(buf, 4 * uids.length, p);
        p += 4;
        for (const val of uids) {
          writeUInt32BE(buf, val, p);
          p += 4;
        }
        writeUInt32BE(buf, 4 * gids.length, p);
        p += 4;
        for (const val of gids) {
          writeUInt32BE(buf, val, p);
          p += 4;
        }
        this._requests[reqid] = { extended: "users-groups-by-id@openssh.com", cb };
        const isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          const status = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${status} users-groups-by-id@openssh.com`);
        }
      }
      // ===========================================================================
      // Server-specific ===========================================================
      // ===========================================================================
      handle(reqid, handle) {
        if (!this.server)
          throw new Error("Server-only method called in client mode");
        if (!Buffer.isBuffer(handle))
          throw new Error("handle is not a Buffer");
        const handleLen = handle.length;
        if (handleLen > 256)
          throw new Error("handle too large (> 256 bytes)");
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = RESPONSE.HANDLE;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, handleLen, p);
        if (handleLen)
          buf.set(handle, p += 4);
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} HANDLE`
        );
      }
      status(reqid, code, message2) {
        if (!this.server)
          throw new Error("Server-only method called in client mode");
        if (!VALID_STATUS_CODES.has(code))
          throw new Error(`Bad status code: ${code}`);
        message2 || (message2 = "");
        const msgLen = Buffer.byteLength(message2);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 4 + msgLen + 4);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = RESPONSE.STATUS;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, code, p);
        writeUInt32BE(buf, msgLen, p += 4);
        p += 4;
        if (msgLen) {
          buf.utf8Write(message2, p, msgLen);
          p += msgLen;
        }
        writeUInt32BE(buf, 0, p);
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} STATUS`
        );
      }
      data(reqid, data, encoding) {
        if (!this.server)
          throw new Error("Server-only method called in client mode");
        const isBuffer = Buffer.isBuffer(data);
        if (!isBuffer && typeof data !== "string")
          throw new Error("data is not a Buffer or string");
        let isUTF8;
        if (!isBuffer && !encoding) {
          encoding = void 0;
          isUTF8 = true;
        }
        const dataLen = isBuffer ? data.length : Buffer.byteLength(data, encoding);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + dataLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = RESPONSE.DATA;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, dataLen, p);
        if (dataLen) {
          if (isBuffer)
            buf.set(data, p += 4);
          else if (isUTF8)
            buf.utf8Write(data, p += 4, dataLen);
          else
            buf.write(data, p += 4, dataLen, encoding);
        }
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} DATA`
        );
      }
      name(reqid, names) {
        if (!this.server)
          throw new Error("Server-only method called in client mode");
        if (!Array.isArray(names)) {
          if (typeof names !== "object" || names === null)
            throw new Error("names is not an object or array");
          names = [names];
        }
        const count = names.length;
        let namesLen = 0;
        let nameAttrs;
        const attrs = [];
        for (let i = 0; i < count; ++i) {
          const name4 = names[i];
          const filename = !name4 || !name4.filename || typeof name4.filename !== "string" ? "" : name4.filename;
          namesLen += 4 + Buffer.byteLength(filename);
          const longname = !name4 || !name4.longname || typeof name4.longname !== "string" ? "" : name4.longname;
          namesLen += 4 + Buffer.byteLength(longname);
          if (typeof name4.attrs === "object" && name4.attrs !== null) {
            nameAttrs = attrsToBytes(name4.attrs);
            namesLen += 4 + nameAttrs.nb;
            if (nameAttrs.nb) {
              let bytes;
              if (nameAttrs.nb === ATTRS_BUF.length) {
                bytes = new Uint8Array(ATTRS_BUF);
              } else {
                bytes = new Uint8Array(nameAttrs.nb);
                bufferCopy(ATTRS_BUF, bytes, 0, nameAttrs.nb, 0);
              }
              nameAttrs.bytes = bytes;
            }
            attrs.push(nameAttrs);
          } else {
            namesLen += 4;
            attrs.push(null);
          }
        }
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + namesLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = RESPONSE.NAME;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, count, p);
        p += 4;
        for (let i = 0; i < count; ++i) {
          const name4 = names[i];
          {
            const filename = !name4 || !name4.filename || typeof name4.filename !== "string" ? "" : name4.filename;
            const len = Buffer.byteLength(filename);
            writeUInt32BE(buf, len, p);
            p += 4;
            if (len) {
              buf.utf8Write(filename, p, len);
              p += len;
            }
          }
          {
            const longname = !name4 || !name4.longname || typeof name4.longname !== "string" ? "" : name4.longname;
            const len = Buffer.byteLength(longname);
            writeUInt32BE(buf, len, p);
            p += 4;
            if (len) {
              buf.utf8Write(longname, p, len);
              p += len;
            }
          }
          const attr = attrs[i];
          if (attr) {
            writeUInt32BE(buf, attr.flags, p);
            p += 4;
            if (attr.flags && attr.bytes) {
              buf.set(attr.bytes, p);
              p += attr.nb;
            }
          } else {
            writeUInt32BE(buf, 0, p);
            p += 4;
          }
        }
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} NAME`
        );
      }
      attrs(reqid, attrs) {
        if (!this.server)
          throw new Error("Server-only method called in client mode");
        if (typeof attrs !== "object" || attrs === null)
          throw new Error("attrs is not an object");
        attrs = attrsToBytes(attrs);
        const flags = attrs.flags;
        const attrsLen = attrs.nb;
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + attrsLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = RESPONSE.ATTRS;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, flags, p);
        if (attrsLen) {
          p += 4;
          if (attrsLen === ATTRS_BUF.length)
            buf.set(ATTRS_BUF, p);
          else
            bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);
          p += attrsLen;
        }
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(
          `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} ATTRS`
        );
      }
    };
    function tryCreateBuffer(size10) {
      try {
        return Buffer.allocUnsafe(size10);
      } catch (ex) {
        return ex;
      }
    }
    function read_(self2, handle, buf, off, len, position2, cb, req_) {
      const maxDataLen = self2._maxReadLen;
      const overflow = Math.max(len - maxDataLen, 0);
      if (overflow)
        len = maxDataLen;
      const handleLen = handle.length;
      let p = 9;
      let pos = position2;
      const out = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen + 8 + 4);
      writeUInt32BE(out, out.length - 4, 0);
      out[4] = REQUEST.READ;
      const reqid = self2._writeReqid = self2._writeReqid + 1 & MAX_REQID;
      writeUInt32BE(out, reqid, 5);
      writeUInt32BE(out, handleLen, p);
      out.set(handle, p += 4);
      p += handleLen;
      for (let i = 7; i >= 0; --i) {
        out[p + i] = pos & 255;
        pos /= 256;
      }
      writeUInt32BE(out, len, p += 8);
      if (typeof cb !== "function")
        cb = noop;
      const req = req_ || {
        nb: 0,
        position: position2,
        off,
        origOff: off,
        len: void 0,
        overflow: void 0,
        cb: (err, data, nb) => {
          const len2 = req.len;
          const overflow2 = req.overflow;
          if (err) {
            if (cb._wantEOFError || err.code !== STATUS_CODE.EOF)
              return cb(err);
          } else if (nb > len2) {
            return cb(new Error("Received more data than requested"));
          } else if (nb === len2 && overflow2) {
            req.nb += nb;
            req.position += nb;
            req.off += nb;
            read_(self2, handle, buf, req.off, overflow2, req.position, cb, req);
            return;
          }
          nb = nb || 0;
          if (req.origOff === 0 && buf.length === req.nb)
            data = buf;
          else
            data = bufferSlice(buf, req.origOff, req.origOff + req.nb + nb);
          cb(void 0, req.nb + nb, data, req.position);
        },
        buffer: void 0
      };
      req.len = len;
      req.overflow = overflow;
      req.buffer = bufferSlice(buf, off, off + len);
      self2._requests[reqid] = req;
      const isBuffered = sendOrBuffer(self2, out);
      self2._debug && self2._debug(
        `SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} READ`
      );
    }
    function fastXfer(src, dst, srcPath, dstPath, opts, cb) {
      let concurrency = 64;
      let chunkSize = 32768;
      let onstep;
      let mode;
      let fileSize;
      if (typeof opts === "function") {
        cb = opts;
      } else if (typeof opts === "object" && opts !== null) {
        if (typeof opts.concurrency === "number" && opts.concurrency > 0 && !isNaN(opts.concurrency)) {
          concurrency = opts.concurrency;
        }
        if (typeof opts.chunkSize === "number" && opts.chunkSize > 0 && !isNaN(opts.chunkSize)) {
          chunkSize = opts.chunkSize;
        }
        if (typeof opts.fileSize === "number" && opts.fileSize > 0 && !isNaN(opts.fileSize)) {
          fileSize = opts.fileSize;
        }
        if (typeof opts.step === "function")
          onstep = opts.step;
        if (typeof opts.mode === "string" || typeof opts.mode === "number")
          mode = modeNum(opts.mode);
      }
      let fsize;
      let pdst = 0;
      let total = 0;
      let hadError = false;
      let srcHandle;
      let dstHandle;
      let readbuf;
      let bufsize = chunkSize * concurrency;
      function onerror(err) {
        if (hadError)
          return;
        hadError = true;
        let left2 = 0;
        let cbfinal;
        if (srcHandle || dstHandle) {
          cbfinal = () => {
            if (--left2 === 0)
              cb(err);
          };
          if (srcHandle && (src === fs2 || src.outgoing.state === "open"))
            ++left2;
          if (dstHandle && (dst === fs2 || dst.outgoing.state === "open"))
            ++left2;
          if (srcHandle && (src === fs2 || src.outgoing.state === "open"))
            src.close(srcHandle, cbfinal);
          if (dstHandle && (dst === fs2 || dst.outgoing.state === "open"))
            dst.close(dstHandle, cbfinal);
        } else {
          cb(err);
        }
      }
      src.open(srcPath, "r", (err, sourceHandle) => {
        if (err)
          return onerror(err);
        srcHandle = sourceHandle;
        if (fileSize === void 0)
          src.fstat(srcHandle, tryStat);
        else
          tryStat(null, { size: fileSize });
        function tryStat(err2, attrs) {
          if (err2) {
            if (src !== fs2) {
              src.stat(srcPath, (err_, attrs_) => {
                if (err_)
                  return onerror(err2);
                tryStat(null, attrs_);
              });
              return;
            }
            return onerror(err2);
          }
          fsize = attrs.size;
          dst.open(dstPath, "w", (err3, destHandle) => {
            if (err3)
              return onerror(err3);
            dstHandle = destHandle;
            if (fsize <= 0)
              return onerror();
            while (bufsize > fsize) {
              if (concurrency === 1) {
                bufsize = fsize;
                break;
              }
              bufsize -= chunkSize;
              --concurrency;
            }
            readbuf = tryCreateBuffer(bufsize);
            if (readbuf instanceof Error)
              return onerror(readbuf);
            if (mode !== void 0) {
              dst.fchmod(dstHandle, mode, function tryAgain(err4) {
                if (err4) {
                  dst.chmod(dstPath, mode, (err_) => tryAgain());
                  return;
                }
                startReads();
              });
            } else {
              startReads();
            }
            function onread(err4, nb, data, dstpos, datapos, origChunkLen) {
              if (err4)
                return onerror(err4);
              datapos = datapos || 0;
              dst.write(dstHandle, readbuf, datapos, nb, dstpos, writeCb);
              function writeCb(err5) {
                if (err5)
                  return onerror(err5);
                total += nb;
                onstep && onstep(total, nb, fsize);
                if (nb < origChunkLen)
                  return singleRead(datapos, dstpos + nb, origChunkLen - nb);
                if (total === fsize) {
                  dst.close(dstHandle, (err6) => {
                    dstHandle = void 0;
                    if (err6)
                      return onerror(err6);
                    src.close(srcHandle, (err7) => {
                      srcHandle = void 0;
                      if (err7)
                        return onerror(err7);
                      cb();
                    });
                  });
                  return;
                }
                if (pdst >= fsize)
                  return;
                const chunk = pdst + chunkSize > fsize ? fsize - pdst : chunkSize;
                singleRead(datapos, pdst, chunk);
                pdst += chunk;
              }
            }
            function makeCb(psrc, pdst2, chunk) {
              return (err4, nb, data) => {
                onread(err4, nb, data, pdst2, psrc, chunk);
              };
            }
            function singleRead(psrc, pdst2, chunk) {
              src.read(
                srcHandle,
                readbuf,
                psrc,
                chunk,
                pdst2,
                makeCb(psrc, pdst2, chunk)
              );
            }
            function startReads() {
              let reads = 0;
              let psrc = 0;
              while (pdst < fsize && reads < concurrency) {
                const chunk = pdst + chunkSize > fsize ? fsize - pdst : chunkSize;
                singleRead(psrc, pdst, chunk);
                psrc += chunk;
                pdst += chunk;
                ++reads;
              }
            }
          });
        }
      });
    }
    function writeAll(sftp, handle, buffer, offset, length7, position2, callback_) {
      const callback = typeof callback_ === "function" ? callback_ : void 0;
      sftp.write(
        handle,
        buffer,
        offset,
        length7,
        position2,
        (writeErr, written) => {
          if (writeErr) {
            return sftp.close(handle, () => {
              callback && callback(writeErr);
            });
          }
          if (written === length7) {
            sftp.close(handle, callback);
          } else {
            offset += written;
            length7 -= written;
            position2 += written;
            writeAll(sftp, handle, buffer, offset, length7, position2, callback);
          }
        }
      );
    }
    var Stats2 = class {
      constructor(initial) {
        this.mode = initial && initial.mode;
        this.uid = initial && initial.uid;
        this.gid = initial && initial.gid;
        this.size = initial && initial.size;
        this.atime = initial && initial.atime;
        this.mtime = initial && initial.mtime;
        this.extended = initial && initial.extended;
      }
      isDirectory() {
        return (this.mode & constants4.S_IFMT) === constants4.S_IFDIR;
      }
      isFile() {
        return (this.mode & constants4.S_IFMT) === constants4.S_IFREG;
      }
      isBlockDevice() {
        return (this.mode & constants4.S_IFMT) === constants4.S_IFBLK;
      }
      isCharacterDevice() {
        return (this.mode & constants4.S_IFMT) === constants4.S_IFCHR;
      }
      isSymbolicLink() {
        return (this.mode & constants4.S_IFMT) === constants4.S_IFLNK;
      }
      isFIFO() {
        return (this.mode & constants4.S_IFMT) === constants4.S_IFIFO;
      }
      isSocket() {
        return (this.mode & constants4.S_IFMT) === constants4.S_IFSOCK;
      }
    };
    function attrsToBytes(attrs) {
      let flags = 0;
      let nb = 0;
      if (typeof attrs === "object" && attrs !== null) {
        if (typeof attrs.size === "number") {
          flags |= ATTR.SIZE;
          const val = attrs.size;
          ATTRS_BUF[nb++] = val / 72057594037927940;
          ATTRS_BUF[nb++] = val / 281474976710656;
          ATTRS_BUF[nb++] = val / 1099511627776;
          ATTRS_BUF[nb++] = val / 4294967296;
          ATTRS_BUF[nb++] = val / 16777216;
          ATTRS_BUF[nb++] = val / 65536;
          ATTRS_BUF[nb++] = val / 256;
          ATTRS_BUF[nb++] = val;
        }
        if (typeof attrs.uid === "number" && typeof attrs.gid === "number") {
          flags |= ATTR.UIDGID;
          const uid = attrs.uid;
          const gid = attrs.gid;
          ATTRS_BUF[nb++] = uid >>> 24;
          ATTRS_BUF[nb++] = uid >>> 16;
          ATTRS_BUF[nb++] = uid >>> 8;
          ATTRS_BUF[nb++] = uid;
          ATTRS_BUF[nb++] = gid >>> 24;
          ATTRS_BUF[nb++] = gid >>> 16;
          ATTRS_BUF[nb++] = gid >>> 8;
          ATTRS_BUF[nb++] = gid;
        }
        if (typeof attrs.mode === "number" || typeof attrs.mode === "string") {
          const mode = modeNum(attrs.mode);
          flags |= ATTR.PERMISSIONS;
          ATTRS_BUF[nb++] = mode >>> 24;
          ATTRS_BUF[nb++] = mode >>> 16;
          ATTRS_BUF[nb++] = mode >>> 8;
          ATTRS_BUF[nb++] = mode;
        }
        if ((typeof attrs.atime === "number" || isDate(attrs.atime)) && (typeof attrs.mtime === "number" || isDate(attrs.mtime))) {
          const atime = toUnixTimestamp(attrs.atime);
          const mtime = toUnixTimestamp(attrs.mtime);
          flags |= ATTR.ACMODTIME;
          ATTRS_BUF[nb++] = atime >>> 24;
          ATTRS_BUF[nb++] = atime >>> 16;
          ATTRS_BUF[nb++] = atime >>> 8;
          ATTRS_BUF[nb++] = atime;
          ATTRS_BUF[nb++] = mtime >>> 24;
          ATTRS_BUF[nb++] = mtime >>> 16;
          ATTRS_BUF[nb++] = mtime >>> 8;
          ATTRS_BUF[nb++] = mtime;
        }
      }
      return { flags, nb };
    }
    function toUnixTimestamp(time3) {
      if (typeof time3 === "number" && time3 === time3)
        return time3;
      if (isDate(time3))
        return parseInt(time3.getTime() / 1e3, 10);
      throw new Error(`Cannot parse time: ${time3}`);
    }
    function modeNum(mode) {
      if (typeof mode === "number" && mode === mode)
        return mode;
      if (typeof mode === "string")
        return modeNum(parseInt(mode, 8));
      throw new Error(`Cannot parse mode: ${mode}`);
    }
    var stringFlagMap = {
      "r": OPEN_MODE.READ,
      "r+": OPEN_MODE.READ | OPEN_MODE.WRITE,
      "w": OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE,
      "wx": OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,
      "xw": OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,
      "w+": OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE,
      "wx+": OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE | OPEN_MODE.EXCL,
      "xw+": OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE | OPEN_MODE.EXCL,
      "a": OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE,
      "ax": OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,
      "xa": OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,
      "a+": OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE,
      "ax+": OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE | OPEN_MODE.EXCL,
      "xa+": OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE | OPEN_MODE.EXCL
    };
    function stringToFlags(str2) {
      const flags = stringFlagMap[str2];
      return flags !== void 0 ? flags : null;
    }
    var flagsToString = (() => {
      const stringFlagMapKeys = Object.keys(stringFlagMap);
      return (flags) => {
        for (let i = 0; i < stringFlagMapKeys.length; ++i) {
          const key = stringFlagMapKeys[i];
          if (stringFlagMap[key] === flags)
            return key;
        }
        return null;
      };
    })();
    function readAttrs(biOpt) {
      const flags = bufferParser.readUInt32BE();
      if (flags === void 0)
        return;
      const attrs = new Stats2();
      if (flags & ATTR.SIZE) {
        const size10 = bufferParser.readUInt64BE(biOpt);
        if (size10 === void 0)
          return;
        attrs.size = size10;
      }
      if (flags & ATTR.UIDGID) {
        const uid = bufferParser.readUInt32BE();
        const gid = bufferParser.readUInt32BE();
        if (gid === void 0)
          return;
        attrs.uid = uid;
        attrs.gid = gid;
      }
      if (flags & ATTR.PERMISSIONS) {
        const mode = bufferParser.readUInt32BE();
        if (mode === void 0)
          return;
        attrs.mode = mode;
      }
      if (flags & ATTR.ACMODTIME) {
        const atime = bufferParser.readUInt32BE();
        const mtime = bufferParser.readUInt32BE();
        if (mtime === void 0)
          return;
        attrs.atime = atime;
        attrs.mtime = mtime;
      }
      if (flags & ATTR.EXTENDED) {
        const count = bufferParser.readUInt32BE();
        if (count === void 0)
          return;
        const extended = {};
        for (let i = 0; i < count; ++i) {
          const type = bufferParser.readString(true);
          const data = bufferParser.readString();
          if (data === void 0)
            return;
          extended[type] = data;
        }
        attrs.extended = extended;
      }
      return attrs;
    }
    function sendOrBuffer(sftp, payload) {
      const ret = tryWritePayload(sftp, payload);
      if (ret !== void 0) {
        sftp._buffer.push(ret);
        return false;
      }
      return true;
    }
    function tryWritePayload(sftp, payload) {
      const outgoing = sftp.outgoing;
      if (outgoing.state !== "open")
        return;
      if (outgoing.window === 0) {
        sftp._waitWindow = true;
        sftp._chunkcb = drainBuffer;
        return payload;
      }
      let ret;
      const len = payload.length;
      let p = 0;
      while (len - p > 0 && outgoing.window > 0) {
        const actualLen = Math.min(len - p, outgoing.window, outgoing.packetSize);
        outgoing.window -= actualLen;
        if (outgoing.window === 0) {
          sftp._waitWindow = true;
          sftp._chunkcb = drainBuffer;
        }
        if (p === 0 && actualLen === len) {
          sftp._protocol.channelData(sftp.outgoing.id, payload);
        } else {
          sftp._protocol.channelData(
            sftp.outgoing.id,
            bufferSlice(payload, p, p + actualLen)
          );
        }
        p += actualLen;
      }
      if (len - p > 0) {
        if (p > 0)
          ret = bufferSlice(payload, p, len);
        else
          ret = payload;
      }
      return ret;
    }
    function drainBuffer() {
      this._chunkcb = void 0;
      const buffer = this._buffer;
      let i = 0;
      while (i < buffer.length) {
        const payload = buffer[i];
        const ret = tryWritePayload(this, payload);
        if (ret !== void 0) {
          if (ret !== payload)
            buffer[i] = ret;
          if (i > 0)
            this._buffer = buffer.slice(i);
          return;
        }
        ++i;
      }
      if (i > 0)
        this._buffer = [];
    }
    function doFatalSFTPError(sftp, msg, noDebug) {
      const err = new Error(msg);
      err.level = "sftp-protocol";
      if (!noDebug && sftp._debug)
        sftp._debug(`SFTP: Inbound: ${msg}`);
      sftp.emit("error", err);
      sftp.destroy();
      cleanupRequests(sftp);
      return false;
    }
    function cleanupRequests(sftp) {
      const keys4 = Object.keys(sftp._requests);
      if (keys4.length === 0)
        return;
      const reqs = sftp._requests;
      sftp._requests = {};
      const err = new Error("No response from server");
      for (let i = 0; i < keys4.length; ++i) {
        const req = reqs[keys4[i]];
        if (typeof req.cb === "function")
          req.cb(err);
      }
    }
    function requestLimits(sftp, cb) {
      let p = 9;
      const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 18);
      writeUInt32BE(buf, buf.length - 4, 0);
      buf[4] = REQUEST.EXTENDED;
      const reqid = sftp._writeReqid = sftp._writeReqid + 1 & MAX_REQID;
      writeUInt32BE(buf, reqid, 5);
      writeUInt32BE(buf, 18, p);
      buf.utf8Write("limits@openssh.com", p += 4, 18);
      sftp._requests[reqid] = { extended: "limits@openssh.com", cb };
      const isBuffered = sendOrBuffer(sftp, buf);
      if (sftp._debug) {
        const which = isBuffered ? "Buffered" : "Sending";
        sftp._debug(`SFTP: Outbound: ${which} limits@openssh.com`);
      }
    }
    var CLIENT_HANDLERS = {
      [RESPONSE.VERSION]: (sftp, payload) => {
        if (sftp._version !== -1)
          return doFatalSFTPError(sftp, "Duplicate VERSION packet");
        const extensions = {};
        bufferParser.init(payload, 1);
        let version = bufferParser.readUInt32BE();
        while (bufferParser.avail()) {
          const extName = bufferParser.readString(true);
          const extData = bufferParser.readString(true);
          if (extData === void 0) {
            version = void 0;
            break;
          }
          extensions[extName] = extData;
        }
        bufferParser.clear();
        if (version === void 0)
          return doFatalSFTPError(sftp, "Malformed VERSION packet");
        if (sftp._debug) {
          const names = Object.keys(extensions);
          if (names.length) {
            sftp._debug(
              `SFTP: Inbound: Received VERSION (v${version}, exts:${names})`
            );
          } else {
            sftp._debug(`SFTP: Inbound: Received VERSION (v${version})`);
          }
        }
        sftp._version = version;
        sftp._extensions = extensions;
        if (extensions["limits@openssh.com"] === "1") {
          return requestLimits(sftp, (err, limits) => {
            if (!err) {
              if (limits.maxPktLen > 0)
                sftp._maxOutPktLen = limits.maxPktLen;
              if (limits.maxReadLen > 0)
                sftp._maxReadLen = limits.maxReadLen;
              if (limits.maxWriteLen > 0)
                sftp._maxWriteLen = limits.maxWriteLen;
              sftp.maxOpenHandles = limits.maxOpenHandles > 0 ? limits.maxOpenHandles : Infinity;
            }
            sftp.emit("ready");
          });
        }
        sftp.emit("ready");
      },
      [RESPONSE.STATUS]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const errorCode = bufferParser.readUInt32BE();
        const errorMsg = bufferParser.readString(true);
        bufferParser.clear();
        if (sftp._debug) {
          const jsonMsg = JSON.stringify(errorMsg);
          sftp._debug(
            `SFTP: Inbound: Received STATUS (id:${reqID}, ${errorCode}, ${jsonMsg})`
          );
        }
        const req = sftp._requests[reqID];
        delete sftp._requests[reqID];
        if (req && typeof req.cb === "function") {
          if (errorCode === STATUS_CODE.OK) {
            req.cb();
            return;
          }
          const err = new Error(errorMsg || STATUS_CODE_STR[errorCode] || "Unknown status");
          err.code = errorCode;
          req.cb(err);
        }
      },
      [RESPONSE.HANDLE]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const handle = bufferParser.readString();
        bufferParser.clear();
        if (handle === void 0) {
          if (reqID !== void 0)
            delete sftp._requests[reqID];
          return doFatalSFTPError(sftp, "Malformed HANDLE packet");
        }
        sftp._debug && sftp._debug(`SFTP: Inbound: Received HANDLE (id:${reqID})`);
        const req = sftp._requests[reqID];
        delete sftp._requests[reqID];
        if (req && typeof req.cb === "function")
          req.cb(void 0, handle);
      },
      [RESPONSE.DATA]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        let req;
        if (reqID !== void 0) {
          req = sftp._requests[reqID];
          delete sftp._requests[reqID];
        }
        if (req && typeof req.cb === "function") {
          if (req.buffer) {
            const nb = bufferParser.readString(req.buffer);
            bufferParser.clear();
            if (nb !== void 0) {
              sftp._debug && sftp._debug(
                `SFTP: Inbound: Received DATA (id:${reqID}, ${nb})`
              );
              req.cb(void 0, req.buffer, nb);
              return;
            }
          } else {
            const data = bufferParser.readString();
            bufferParser.clear();
            if (data !== void 0) {
              sftp._debug && sftp._debug(
                `SFTP: Inbound: Received DATA (id:${reqID}, ${data.length})`
              );
              req.cb(void 0, data);
              return;
            }
          }
        } else {
          const nb = bufferParser.skipString();
          bufferParser.clear();
          if (nb !== void 0) {
            sftp._debug && sftp._debug(
              `SFTP: Inbound: Received DATA (id:${reqID}, ${nb})`
            );
            return;
          }
        }
        return doFatalSFTPError(sftp, "Malformed DATA packet");
      },
      [RESPONSE.NAME]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        let req;
        if (reqID !== void 0) {
          req = sftp._requests[reqID];
          delete sftp._requests[reqID];
        }
        const count = bufferParser.readUInt32BE();
        if (count !== void 0) {
          let names = [];
          for (let i = 0; i < count; ++i) {
            const filename = bufferParser.readString(true);
            const longname = bufferParser.readString(true);
            const attrs = readAttrs(sftp._biOpt);
            if (attrs === void 0) {
              names = void 0;
              break;
            }
            names.push({ filename, longname, attrs });
          }
          if (names !== void 0) {
            sftp._debug && sftp._debug(
              `SFTP: Inbound: Received NAME (id:${reqID}, ${names.length})`
            );
            bufferParser.clear();
            if (req && typeof req.cb === "function")
              req.cb(void 0, names);
            return;
          }
        }
        bufferParser.clear();
        return doFatalSFTPError(sftp, "Malformed NAME packet");
      },
      [RESPONSE.ATTRS]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        let req;
        if (reqID !== void 0) {
          req = sftp._requests[reqID];
          delete sftp._requests[reqID];
        }
        const attrs = readAttrs(sftp._biOpt);
        bufferParser.clear();
        if (attrs !== void 0) {
          sftp._debug && sftp._debug(`SFTP: Inbound: Received ATTRS (id:${reqID})`);
          if (req && typeof req.cb === "function")
            req.cb(void 0, attrs);
          return;
        }
        return doFatalSFTPError(sftp, "Malformed ATTRS packet");
      },
      [RESPONSE.EXTENDED]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        if (reqID !== void 0) {
          const req = sftp._requests[reqID];
          if (req) {
            delete sftp._requests[reqID];
            switch (req.extended) {
              case "statvfs@openssh.com":
              case "fstatvfs@openssh.com": {
                const biOpt = sftp._biOpt;
                const stats = {
                  f_bsize: bufferParser.readUInt64BE(biOpt),
                  f_frsize: bufferParser.readUInt64BE(biOpt),
                  f_blocks: bufferParser.readUInt64BE(biOpt),
                  f_bfree: bufferParser.readUInt64BE(biOpt),
                  f_bavail: bufferParser.readUInt64BE(biOpt),
                  f_files: bufferParser.readUInt64BE(biOpt),
                  f_ffree: bufferParser.readUInt64BE(biOpt),
                  f_favail: bufferParser.readUInt64BE(biOpt),
                  f_sid: bufferParser.readUInt64BE(biOpt),
                  f_flag: bufferParser.readUInt64BE(biOpt),
                  f_namemax: bufferParser.readUInt64BE(biOpt)
                };
                if (stats.f_namemax === void 0)
                  break;
                if (sftp._debug) {
                  sftp._debug(
                    `SFTP: Inbound: Received EXTENDED_REPLY (id:${reqID}, ${req.extended})`
                  );
                }
                bufferParser.clear();
                if (typeof req.cb === "function")
                  req.cb(void 0, stats);
                return;
              }
              case "limits@openssh.com": {
                const limits = {
                  maxPktLen: bufferParser.readUInt64BE(),
                  maxReadLen: bufferParser.readUInt64BE(),
                  maxWriteLen: bufferParser.readUInt64BE(),
                  maxOpenHandles: bufferParser.readUInt64BE()
                };
                if (limits.maxOpenHandles === void 0)
                  break;
                if (sftp._debug) {
                  sftp._debug(
                    `SFTP: Inbound: Received EXTENDED_REPLY (id:${reqID}, ${req.extended})`
                  );
                }
                bufferParser.clear();
                if (typeof req.cb === "function")
                  req.cb(void 0, limits);
                return;
              }
              case "users-groups-by-id@openssh.com": {
                const usernameCount = bufferParser.readUInt32BE();
                if (usernameCount === void 0)
                  break;
                const usernames = new Array(usernameCount);
                for (let i = 0; i < usernames.length; ++i)
                  usernames[i] = bufferParser.readString(true);
                const groupnameCount = bufferParser.readUInt32BE();
                if (groupnameCount === void 0)
                  break;
                const groupnames = new Array(groupnameCount);
                for (let i = 0; i < groupnames.length; ++i)
                  groupnames[i] = bufferParser.readString(true);
                if (groupnames.length > 0 && groupnames[groupnames.length - 1] === void 0) {
                  break;
                }
                if (sftp._debug) {
                  sftp._debug(
                    `SFTP: Inbound: Received EXTENDED_REPLY (id:${reqID}, ${req.extended})`
                  );
                }
                bufferParser.clear();
                if (typeof req.cb === "function")
                  req.cb(void 0, usernames, groupnames);
                return;
              }
              default:
                sftp._debug && sftp._debug(
                  `SFTP: Inbound: Received EXTENDED_REPLY (id:${reqID}, ???)`
                );
                bufferParser.clear();
                if (typeof req.cb === "function")
                  req.cb();
                return;
            }
          } else {
            sftp._debug && sftp._debug(
              `SFTP: Inbound: Received EXTENDED_REPLY (id:${reqID}, ???)`
            );
            bufferParser.clear();
            return;
          }
        }
        bufferParser.clear();
        return doFatalSFTPError(sftp, "Malformed EXTENDED_REPLY packet");
      }
    };
    var SERVER_HANDLERS = {
      [REQUEST.INIT]: (sftp, payload) => {
        if (sftp._version !== -1)
          return doFatalSFTPError(sftp, "Duplicate INIT packet");
        const extensions = {};
        bufferParser.init(payload, 1);
        let version = bufferParser.readUInt32BE();
        while (bufferParser.avail()) {
          const extName = bufferParser.readString(true);
          const extData = bufferParser.readString(true);
          if (extData === void 0) {
            version = void 0;
            break;
          }
          extensions[extName] = extData;
        }
        bufferParser.clear();
        if (version === void 0)
          return doFatalSFTPError(sftp, "Malformed INIT packet");
        if (sftp._debug) {
          const names = Object.keys(extensions);
          if (names.length) {
            sftp._debug(
              `SFTP: Inbound: Received INIT (v${version}, exts:${names})`
            );
          } else {
            sftp._debug(`SFTP: Inbound: Received INIT (v${version})`);
          }
        }
        sendOrBuffer(sftp, SERVER_VERSION_BUFFER);
        sftp._version = version;
        sftp._extensions = extensions;
        sftp.emit("ready");
      },
      [REQUEST.OPEN]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const filename = bufferParser.readString(true);
        const pflags = bufferParser.readUInt32BE();
        const attrs = readAttrs(sftp._biOpt);
        bufferParser.clear();
        if (attrs === void 0)
          return doFatalSFTPError(sftp, "Malformed OPEN packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received OPEN (id:${reqID})`);
        if (!sftp.emit("OPEN", reqID, filename, pflags, attrs)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.CLOSE]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const handle = bufferParser.readString();
        bufferParser.clear();
        if (handle === void 0 || handle.length > 256)
          return doFatalSFTPError(sftp, "Malformed CLOSE packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received CLOSE (id:${reqID})`);
        if (!sftp.emit("CLOSE", reqID, handle)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.READ]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const handle = bufferParser.readString();
        const offset = bufferParser.readUInt64BE(sftp._biOpt);
        const len = bufferParser.readUInt32BE();
        bufferParser.clear();
        if (len === void 0 || handle.length > 256)
          return doFatalSFTPError(sftp, "Malformed READ packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received READ (id:${reqID})`);
        if (!sftp.emit("READ", reqID, handle, offset, len)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.WRITE]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const handle = bufferParser.readString();
        const offset = bufferParser.readUInt64BE(sftp._biOpt);
        const data = bufferParser.readString();
        bufferParser.clear();
        if (data === void 0 || handle.length > 256)
          return doFatalSFTPError(sftp, "Malformed WRITE packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received WRITE (id:${reqID})`);
        if (!sftp.emit("WRITE", reqID, handle, offset, data)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.LSTAT]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const path5 = bufferParser.readString(true);
        bufferParser.clear();
        if (path5 === void 0)
          return doFatalSFTPError(sftp, "Malformed LSTAT packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received LSTAT (id:${reqID})`);
        if (!sftp.emit("LSTAT", reqID, path5)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.FSTAT]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const handle = bufferParser.readString();
        bufferParser.clear();
        if (handle === void 0 || handle.length > 256)
          return doFatalSFTPError(sftp, "Malformed FSTAT packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received FSTAT (id:${reqID})`);
        if (!sftp.emit("FSTAT", reqID, handle)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.SETSTAT]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const path5 = bufferParser.readString(true);
        const attrs = readAttrs(sftp._biOpt);
        bufferParser.clear();
        if (attrs === void 0)
          return doFatalSFTPError(sftp, "Malformed SETSTAT packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received SETSTAT (id:${reqID})`);
        if (!sftp.emit("SETSTAT", reqID, path5, attrs)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.FSETSTAT]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const handle = bufferParser.readString();
        const attrs = readAttrs(sftp._biOpt);
        bufferParser.clear();
        if (attrs === void 0 || handle.length > 256)
          return doFatalSFTPError(sftp, "Malformed FSETSTAT packet");
        sftp._debug && sftp._debug(
          `SFTP: Inbound: Received FSETSTAT (id:${reqID})`
        );
        if (!sftp.emit("FSETSTAT", reqID, handle, attrs)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.OPENDIR]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const path5 = bufferParser.readString(true);
        bufferParser.clear();
        if (path5 === void 0)
          return doFatalSFTPError(sftp, "Malformed OPENDIR packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received OPENDIR (id:${reqID})`);
        if (!sftp.emit("OPENDIR", reqID, path5)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.READDIR]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const handle = bufferParser.readString();
        bufferParser.clear();
        if (handle === void 0 || handle.length > 256)
          return doFatalSFTPError(sftp, "Malformed READDIR packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received READDIR (id:${reqID})`);
        if (!sftp.emit("READDIR", reqID, handle)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.REMOVE]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const path5 = bufferParser.readString(true);
        bufferParser.clear();
        if (path5 === void 0)
          return doFatalSFTPError(sftp, "Malformed REMOVE packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received REMOVE (id:${reqID})`);
        if (!sftp.emit("REMOVE", reqID, path5)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.MKDIR]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const path5 = bufferParser.readString(true);
        const attrs = readAttrs(sftp._biOpt);
        bufferParser.clear();
        if (attrs === void 0)
          return doFatalSFTPError(sftp, "Malformed MKDIR packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received MKDIR (id:${reqID})`);
        if (!sftp.emit("MKDIR", reqID, path5, attrs)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.RMDIR]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const path5 = bufferParser.readString(true);
        bufferParser.clear();
        if (path5 === void 0)
          return doFatalSFTPError(sftp, "Malformed RMDIR packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received RMDIR (id:${reqID})`);
        if (!sftp.emit("RMDIR", reqID, path5)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.REALPATH]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const path5 = bufferParser.readString(true);
        bufferParser.clear();
        if (path5 === void 0)
          return doFatalSFTPError(sftp, "Malformed REALPATH packet");
        sftp._debug && sftp._debug(
          `SFTP: Inbound: Received REALPATH (id:${reqID})`
        );
        if (!sftp.emit("REALPATH", reqID, path5)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.STAT]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const path5 = bufferParser.readString(true);
        bufferParser.clear();
        if (path5 === void 0)
          return doFatalSFTPError(sftp, "Malformed STAT packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received STAT (id:${reqID})`);
        if (!sftp.emit("STAT", reqID, path5)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.RENAME]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const oldPath = bufferParser.readString(true);
        const newPath = bufferParser.readString(true);
        bufferParser.clear();
        if (newPath === void 0)
          return doFatalSFTPError(sftp, "Malformed RENAME packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received RENAME (id:${reqID})`);
        if (!sftp.emit("RENAME", reqID, oldPath, newPath)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.READLINK]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const path5 = bufferParser.readString(true);
        bufferParser.clear();
        if (path5 === void 0)
          return doFatalSFTPError(sftp, "Malformed READLINK packet");
        sftp._debug && sftp._debug(
          `SFTP: Inbound: Received READLINK (id:${reqID})`
        );
        if (!sftp.emit("READLINK", reqID, path5)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.SYMLINK]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const linkPath = bufferParser.readString(true);
        const targetPath = bufferParser.readString(true);
        bufferParser.clear();
        if (targetPath === void 0)
          return doFatalSFTPError(sftp, "Malformed SYMLINK packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received SYMLINK (id:${reqID})`);
        let handled;
        if (sftp._isOpenSSH) {
          handled = sftp.emit("SYMLINK", reqID, targetPath, linkPath);
        } else {
          handled = sftp.emit("SYMLINK", reqID, linkPath, targetPath);
        }
        if (!handled) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.EXTENDED]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const extName = bufferParser.readString(true);
        if (extName === void 0) {
          bufferParser.clear();
          return doFatalSFTPError(sftp, "Malformed EXTENDED packet");
        }
        let extData;
        if (bufferParser.avail())
          extData = bufferParser.readRaw();
        bufferParser.clear();
        sftp._debug && sftp._debug(
          `SFTP: Inbound: Received EXTENDED (id:${reqID})`
        );
        if (!sftp.emit("EXTENDED", reqID, extName, extData)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      }
    };
    var {
      ERR_INVALID_ARG_TYPE,
      ERR_OUT_OF_RANGE,
      validateNumber
    } = require_node_fs_compat();
    var kMinPoolSpace = 128;
    var pool;
    var poolFragments = [];
    function allocNewPool(poolSize) {
      if (poolFragments.length > 0)
        pool = poolFragments.pop();
      else
        pool = Buffer.allocUnsafe(poolSize);
      pool.used = 0;
    }
    function checkPosition(pos, name4) {
      if (!Number.isSafeInteger(pos)) {
        validateNumber(pos, name4);
        if (!Number.isInteger(pos))
          throw new ERR_OUT_OF_RANGE(name4, "an integer", pos);
        throw new ERR_OUT_OF_RANGE(name4, ">= 0 and <= 2 ** 53 - 1", pos);
      }
      if (pos < 0)
        throw new ERR_OUT_OF_RANGE(name4, ">= 0 and <= 2 ** 53 - 1", pos);
    }
    function roundUpToMultipleOf8(n) {
      return n + 7 & ~7;
    }
    function ReadStream(sftp, path5, options) {
      if (options === void 0)
        options = {};
      else if (typeof options === "string")
        options = { encoding: options };
      else if (options === null || typeof options !== "object")
        throw new TypeError('"options" argument must be a string or an object');
      else
        options = Object.create(options);
      if (options.highWaterMark === void 0)
        options.highWaterMark = 64 * 1024;
      options.emitClose = false;
      options.autoDestroy = false;
      ReadableStream.call(this, options);
      this.path = path5;
      this.flags = options.flags === void 0 ? "r" : options.flags;
      this.mode = options.mode === void 0 ? 438 : options.mode;
      this.start = options.start;
      this.end = options.end;
      this.autoClose = options.autoClose === void 0 ? true : options.autoClose;
      this.pos = 0;
      this.bytesRead = 0;
      this.isClosed = false;
      this.handle = options.handle === void 0 ? null : options.handle;
      this.sftp = sftp;
      this._opening = false;
      if (this.start !== void 0) {
        checkPosition(this.start, "start");
        this.pos = this.start;
      }
      if (this.end === void 0) {
        this.end = Infinity;
      } else if (this.end !== Infinity) {
        checkPosition(this.end, "end");
        if (this.start !== void 0 && this.start > this.end) {
          throw new ERR_OUT_OF_RANGE(
            "start",
            `<= "end" (here: ${this.end})`,
            this.start
          );
        }
      }
      this.on("end", function() {
        if (this.autoClose)
          this.destroy();
      });
      if (!Buffer.isBuffer(this.handle))
        this.open();
    }
    inherits(ReadStream, ReadableStream);
    ReadStream.prototype.open = function() {
      if (this._opening)
        return;
      this._opening = true;
      this.sftp.open(this.path, this.flags, this.mode, (er, handle) => {
        this._opening = false;
        if (er) {
          this.emit("error", er);
          if (this.autoClose)
            this.destroy();
          return;
        }
        this.handle = handle;
        this.emit("open", handle);
        this.emit("ready");
        this.read();
      });
    };
    ReadStream.prototype._read = function(n) {
      if (!Buffer.isBuffer(this.handle))
        return this.once("open", () => this._read(n));
      if (this.destroyed)
        return;
      if (!pool || pool.length - pool.used < kMinPoolSpace) {
        allocNewPool(this.readableHighWaterMark || this._readableState.highWaterMark);
      }
      const thisPool = pool;
      let toRead = Math.min(pool.length - pool.used, n);
      const start = pool.used;
      if (this.end !== void 0)
        toRead = Math.min(this.end - this.pos + 1, toRead);
      if (toRead <= 0)
        return this.push(null);
      this.sftp.read(
        this.handle,
        pool,
        pool.used,
        toRead,
        this.pos,
        (er, bytesRead) => {
          if (er) {
            this.emit("error", er);
            if (this.autoClose)
              this.destroy();
            return;
          }
          let b = null;
          if (start + toRead === thisPool.used && thisPool === pool) {
            thisPool.used = roundUpToMultipleOf8(thisPool.used + bytesRead - toRead);
          } else {
            const alignedEnd = start + toRead & ~7;
            const alignedStart = roundUpToMultipleOf8(start + bytesRead);
            if (alignedEnd - alignedStart >= kMinPoolSpace)
              poolFragments.push(thisPool.slice(alignedStart, alignedEnd));
          }
          if (bytesRead > 0) {
            this.bytesRead += bytesRead;
            b = thisPool.slice(start, start + bytesRead);
          }
          this.pos += bytesRead;
          this.push(b);
        }
      );
      pool.used = roundUpToMultipleOf8(pool.used + toRead);
    };
    ReadStream.prototype._destroy = function(err, cb) {
      if (this._opening && !Buffer.isBuffer(this.handle)) {
        this.once("open", closeStream.bind(null, this, cb, err));
        return;
      }
      closeStream(this, cb, err);
      this.handle = null;
      this._opening = false;
    };
    function closeStream(stream3, cb, err) {
      if (!stream3.handle)
        return onclose();
      stream3.sftp.close(stream3.handle, onclose);
      function onclose(er) {
        er = er || err;
        cb(er);
        stream3.isClosed = true;
        if (!er)
          stream3.emit("close");
      }
    }
    ReadStream.prototype.close = function(cb) {
      this.destroy(null, cb);
    };
    Object.defineProperty(ReadStream.prototype, "pending", {
      get() {
        return this.handle === null;
      },
      configurable: true
    });
    function WriteStream(sftp, path5, options) {
      if (options === void 0)
        options = {};
      else if (typeof options === "string")
        options = { encoding: options };
      else if (options === null || typeof options !== "object")
        throw new TypeError('"options" argument must be a string or an object');
      else
        options = Object.create(options);
      options.emitClose = false;
      options.autoDestroy = false;
      WritableStream.call(this, options);
      this.path = path5;
      this.flags = options.flags === void 0 ? "w" : options.flags;
      this.mode = options.mode === void 0 ? 438 : options.mode;
      this.start = options.start;
      this.autoClose = options.autoClose === void 0 ? true : options.autoClose;
      this.pos = 0;
      this.bytesWritten = 0;
      this.isClosed = false;
      this.handle = options.handle === void 0 ? null : options.handle;
      this.sftp = sftp;
      this._opening = false;
      if (this.start !== void 0) {
        checkPosition(this.start, "start");
        this.pos = this.start;
      }
      if (options.encoding)
        this.setDefaultEncoding(options.encoding);
      this.on("finish", function() {
        if (this._writableState.finalCalled)
          return;
        if (this.autoClose)
          this.destroy();
      });
      if (!Buffer.isBuffer(this.handle))
        this.open();
    }
    inherits(WriteStream, WritableStream);
    WriteStream.prototype._final = function(cb) {
      if (this.autoClose)
        this.destroy();
      cb();
    };
    WriteStream.prototype.open = function() {
      if (this._opening)
        return;
      this._opening = true;
      this.sftp.open(this.path, this.flags, this.mode, (er, handle) => {
        this._opening = false;
        if (er) {
          this.emit("error", er);
          if (this.autoClose)
            this.destroy();
          return;
        }
        this.handle = handle;
        const tryAgain = (err) => {
          if (err) {
            this.sftp.chmod(this.path, this.mode, (err_) => tryAgain());
            return;
          }
          if (this.flags[0] === "a") {
            const tryStat = (err2, st) => {
              if (err2) {
                this.sftp.stat(this.path, (err_, st_) => {
                  if (err_) {
                    this.destroy();
                    this.emit("error", err2);
                    return;
                  }
                  tryStat(null, st_);
                });
                return;
              }
              this.pos = st.size;
              this.emit("open", handle);
              this.emit("ready");
            };
            this.sftp.fstat(handle, tryStat);
            return;
          }
          this.emit("open", handle);
          this.emit("ready");
        };
        this.sftp.fchmod(handle, this.mode, tryAgain);
      });
    };
    WriteStream.prototype._write = function(data, encoding, cb) {
      if (!Buffer.isBuffer(data)) {
        const err = new ERR_INVALID_ARG_TYPE("data", "Buffer", data);
        return this.emit("error", err);
      }
      if (!Buffer.isBuffer(this.handle)) {
        return this.once("open", function() {
          this._write(data, encoding, cb);
        });
      }
      this.sftp.write(
        this.handle,
        data,
        0,
        data.length,
        this.pos,
        (er, bytes) => {
          if (er) {
            if (this.autoClose)
              this.destroy();
            return cb(er);
          }
          this.bytesWritten += bytes;
          cb();
        }
      );
      this.pos += data.length;
    };
    WriteStream.prototype._writev = function(data, cb) {
      if (!Buffer.isBuffer(this.handle)) {
        return this.once("open", function() {
          this._writev(data, cb);
        });
      }
      const sftp = this.sftp;
      const handle = this.handle;
      let writesLeft = data.length;
      const onwrite = (er, bytes) => {
        if (er) {
          this.destroy();
          return cb(er);
        }
        this.bytesWritten += bytes;
        if (--writesLeft === 0)
          cb();
      };
      for (let i = 0; i < data.length; ++i) {
        const chunk = data[i].chunk;
        sftp.write(handle, chunk, 0, chunk.length, this.pos, onwrite);
        this.pos += chunk.length;
      }
    };
    if (typeof WritableStream.prototype.destroy !== "function")
      WriteStream.prototype.destroy = ReadStream.prototype.destroy;
    WriteStream.prototype._destroy = ReadStream.prototype._destroy;
    WriteStream.prototype.close = function(cb) {
      if (cb) {
        if (this.isClosed) {
          process.nextTick(cb);
          return;
        }
        this.on("close", cb);
      }
      if (!this.autoClose)
        this.on("finish", this.destroy.bind(this));
      this.end();
    };
    WriteStream.prototype.destroySoon = WriteStream.prototype.end;
    Object.defineProperty(WriteStream.prototype, "pending", {
      get() {
        return this.handle === null;
      },
      configurable: true
    });
    module.exports = {
      flagsToString,
      OPEN_MODE,
      SFTP,
      Stats: Stats2,
      STATUS_CODE,
      stringToFlags
    };
  }
});

// node_modules/ssh2/lib/Channel.js
var require_Channel = __commonJS({
  "node_modules/ssh2/lib/Channel.js"(exports, module) {
    "use strict";
    var {
      Duplex: DuplexStream,
      Readable: ReadableStream,
      Writable: WritableStream
    } = __require("stream");
    var {
      CHANNEL_EXTENDED_DATATYPE: { STDERR }
    } = require_constants5();
    var { bufferSlice } = require_utils7();
    var PACKET_SIZE = 32 * 1024;
    var MAX_WINDOW = 2 * 1024 * 1024;
    var WINDOW_THRESHOLD = MAX_WINDOW / 2;
    var ClientStderr = class extends ReadableStream {
      constructor(channel2, streamOpts) {
        super(streamOpts);
        this._channel = channel2;
      }
      _read(n) {
        if (this._channel._waitChanDrain) {
          this._channel._waitChanDrain = false;
          if (this._channel.incoming.window <= WINDOW_THRESHOLD)
            windowAdjust(this._channel);
        }
      }
    };
    var ServerStderr = class extends WritableStream {
      constructor(channel2) {
        super({ highWaterMark: MAX_WINDOW });
        this._channel = channel2;
      }
      _write(data, encoding, cb) {
        const channel2 = this._channel;
        const protocol = channel2._client._protocol;
        const outgoing = channel2.outgoing;
        const packetSize = outgoing.packetSize;
        const id2 = outgoing.id;
        let window2 = outgoing.window;
        const len = data.length;
        let p = 0;
        if (outgoing.state !== "open")
          return;
        while (len - p > 0 && window2 > 0) {
          let sliceLen = len - p;
          if (sliceLen > window2)
            sliceLen = window2;
          if (sliceLen > packetSize)
            sliceLen = packetSize;
          if (p === 0 && sliceLen === len)
            protocol.channelExtData(id2, data, STDERR);
          else
            protocol.channelExtData(id2, bufferSlice(data, p, p + sliceLen), STDERR);
          p += sliceLen;
          window2 -= sliceLen;
        }
        outgoing.window = window2;
        if (len - p > 0) {
          if (window2 === 0)
            channel2._waitWindow = true;
          if (p > 0)
            channel2._chunkErr = bufferSlice(data, p, len);
          else
            channel2._chunkErr = data;
          channel2._chunkcbErr = cb;
          return;
        }
        cb();
      }
    };
    var Channel = class extends DuplexStream {
      constructor(client, info4, opts) {
        const streamOpts = {
          highWaterMark: MAX_WINDOW,
          allowHalfOpen: !opts || opts && opts.allowHalfOpen !== false,
          emitClose: false
        };
        super(streamOpts);
        this.allowHalfOpen = streamOpts.allowHalfOpen;
        const server = !!(opts && opts.server);
        this.server = server;
        this.type = info4.type;
        this.subtype = void 0;
        this.incoming = info4.incoming;
        this.outgoing = info4.outgoing;
        this._callbacks = [];
        this._client = client;
        this._hasX11 = false;
        this._exit = {
          code: void 0,
          signal: void 0,
          dump: void 0,
          desc: void 0
        };
        this.stdin = this.stdout = this;
        if (server)
          this.stderr = new ServerStderr(this);
        else
          this.stderr = new ClientStderr(this, streamOpts);
        this._waitWindow = false;
        this._waitChanDrain = false;
        this._chunk = void 0;
        this._chunkcb = void 0;
        this._chunkErr = void 0;
        this._chunkcbErr = void 0;
        this.on("finish", onFinish2).on("prefinish", onFinish2);
        this.on("end", onEnd2).on("close", onEnd2);
      }
      _read(n) {
        if (this._waitChanDrain) {
          this._waitChanDrain = false;
          if (this.incoming.window <= WINDOW_THRESHOLD)
            windowAdjust(this);
        }
      }
      _write(data, encoding, cb) {
        const protocol = this._client._protocol;
        const outgoing = this.outgoing;
        const packetSize = outgoing.packetSize;
        const id2 = outgoing.id;
        let window2 = outgoing.window;
        const len = data.length;
        let p = 0;
        if (outgoing.state !== "open")
          return;
        while (len - p > 0 && window2 > 0) {
          let sliceLen = len - p;
          if (sliceLen > window2)
            sliceLen = window2;
          if (sliceLen > packetSize)
            sliceLen = packetSize;
          if (p === 0 && sliceLen === len)
            protocol.channelData(id2, data);
          else
            protocol.channelData(id2, bufferSlice(data, p, p + sliceLen));
          p += sliceLen;
          window2 -= sliceLen;
        }
        outgoing.window = window2;
        if (len - p > 0) {
          if (window2 === 0)
            this._waitWindow = true;
          if (p > 0)
            this._chunk = bufferSlice(data, p, len);
          else
            this._chunk = data;
          this._chunkcb = cb;
          return;
        }
        cb();
      }
      eof() {
        if (this.outgoing.state === "open") {
          this.outgoing.state = "eof";
          this._client._protocol.channelEOF(this.outgoing.id);
        }
      }
      close() {
        if (this.outgoing.state === "open" || this.outgoing.state === "eof") {
          this.outgoing.state = "closing";
          this._client._protocol.channelClose(this.outgoing.id);
        }
      }
      destroy() {
        this.end();
        this.close();
        return this;
      }
      // Session type-specific methods =============================================
      setWindow(rows, cols, height, width2) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        if (this.type === "session" && (this.subtype === "shell" || this.subtype === "exec") && this.writable && this.outgoing.state === "open") {
          this._client._protocol.windowChange(
            this.outgoing.id,
            rows,
            cols,
            height,
            width2
          );
        }
      }
      signal(signalName) {
        if (this.server)
          throw new Error("Client-only method called in server mode");
        if (this.type === "session" && this.writable && this.outgoing.state === "open") {
          this._client._protocol.signal(this.outgoing.id, signalName);
        }
      }
      exit(statusOrSignal, coreDumped, msg) {
        if (!this.server)
          throw new Error("Server-only method called in client mode");
        if (this.type === "session" && this.writable && this.outgoing.state === "open") {
          if (typeof statusOrSignal === "number") {
            this._client._protocol.exitStatus(this.outgoing.id, statusOrSignal);
          } else {
            this._client._protocol.exitSignal(
              this.outgoing.id,
              statusOrSignal,
              coreDumped,
              msg
            );
          }
        }
      }
    };
    function onFinish2() {
      this.eof();
      if (this.server || !this.allowHalfOpen)
        this.close();
      this.writable = false;
    }
    function onEnd2() {
      this.readable = false;
    }
    function windowAdjust(self2) {
      if (self2.outgoing.state === "closed")
        return;
      const amt = MAX_WINDOW - self2.incoming.window;
      if (amt <= 0)
        return;
      self2.incoming.window += amt;
      self2._client._protocol.channelWindowAdjust(self2.outgoing.id, amt);
    }
    module.exports = {
      Channel,
      MAX_WINDOW,
      PACKET_SIZE,
      windowAdjust,
      WINDOW_THRESHOLD
    };
  }
});

// node_modules/ssh2/lib/utils.js
var require_utils8 = __commonJS({
  "node_modules/ssh2/lib/utils.js"(exports, module) {
    "use strict";
    var { SFTP } = require_SFTP();
    var MAX_CHANNEL = 2 ** 32 - 1;
    function onChannelOpenFailure(self2, recipient, info4, cb) {
      self2._chanMgr.remove(recipient);
      if (typeof cb !== "function")
        return;
      let err;
      if (info4 instanceof Error) {
        err = info4;
      } else if (typeof info4 === "object" && info4 !== null) {
        err = new Error(`(SSH) Channel open failure: ${info4.description}`);
        err.reason = info4.reason;
      } else {
        err = new Error(
          "(SSH) Channel open failure: server closed channel unexpectedly"
        );
        err.reason = "";
      }
      cb(err);
    }
    function onCHANNEL_CLOSE(self2, recipient, channel2, err, dead) {
      if (typeof channel2 === "function") {
        onChannelOpenFailure(self2, recipient, err, channel2);
        return;
      }
      if (typeof channel2 !== "object" || channel2 === null)
        return;
      if (channel2.incoming && channel2.incoming.state === "closed")
        return;
      self2._chanMgr.remove(recipient);
      if (channel2.server && channel2.constructor.name === "Session")
        return;
      channel2.incoming.state = "closed";
      if (channel2.readable)
        channel2.push(null);
      if (channel2.server) {
        if (channel2.stderr.writable)
          channel2.stderr.end();
      } else if (channel2.stderr.readable) {
        channel2.stderr.push(null);
      }
      if (channel2.constructor !== SFTP && (channel2.outgoing.state === "open" || channel2.outgoing.state === "eof") && !dead) {
        channel2.close();
      }
      if (channel2.outgoing.state === "closing")
        channel2.outgoing.state = "closed";
      const readState = channel2._readableState;
      const writeState = channel2._writableState;
      if (writeState && !writeState.ending && !writeState.finished && !dead)
        channel2.end();
      const chanCallbacks = channel2._callbacks;
      channel2._callbacks = [];
      for (let i = 0; i < chanCallbacks.length; ++i)
        chanCallbacks[i](true);
      if (channel2.server) {
        if (!channel2.readable || channel2.destroyed || readState && readState.endEmitted) {
          channel2.emit("close");
        } else {
          channel2.once("end", () => channel2.emit("close"));
        }
      } else {
        let doClose;
        switch (channel2.type) {
          case "direct-streamlocal@openssh.com":
          case "direct-tcpip":
            doClose = () => channel2.emit("close");
            break;
          default: {
            const exit2 = channel2._exit;
            doClose = () => {
              if (exit2.code === null)
                channel2.emit("close", exit2.code, exit2.signal, exit2.dump, exit2.desc);
              else
                channel2.emit("close", exit2.code);
            };
          }
        }
        if (!channel2.readable || channel2.destroyed || readState && readState.endEmitted) {
          doClose();
        } else {
          channel2.once("end", doClose);
        }
        const errReadState = channel2.stderr._readableState;
        if (!channel2.stderr.readable || channel2.stderr.destroyed || errReadState && errReadState.endEmitted) {
          channel2.stderr.emit("close");
        } else {
          channel2.stderr.once("end", () => channel2.stderr.emit("close"));
        }
      }
    }
    var ChannelManager = class {
      constructor(client) {
        this._client = client;
        this._channels = {};
        this._cur = -1;
        this._count = 0;
      }
      add(val) {
        let id2;
        if (this._cur < MAX_CHANNEL) {
          id2 = ++this._cur;
        } else if (this._count === 0) {
          this._cur = 0;
          id2 = 0;
        } else {
          const channels = this._channels;
          for (let i = 0; i < MAX_CHANNEL; ++i) {
            if (channels[i] === void 0) {
              id2 = i;
              break;
            }
          }
        }
        if (id2 === void 0)
          return -1;
        this._channels[id2] = val || true;
        ++this._count;
        return id2;
      }
      update(id2, val) {
        if (typeof id2 !== "number" || id2 < 0 || id2 >= MAX_CHANNEL || !isFinite(id2))
          throw new Error(`Invalid channel id: ${id2}`);
        if (val && this._channels[id2])
          this._channels[id2] = val;
      }
      get(id2) {
        if (typeof id2 !== "number" || id2 < 0 || id2 >= MAX_CHANNEL || !isFinite(id2))
          throw new Error(`Invalid channel id: ${id2}`);
        return this._channels[id2];
      }
      remove(id2) {
        if (typeof id2 !== "number" || id2 < 0 || id2 >= MAX_CHANNEL || !isFinite(id2))
          throw new Error(`Invalid channel id: ${id2}`);
        if (this._channels[id2]) {
          delete this._channels[id2];
          if (this._count)
            --this._count;
        }
      }
      cleanup(err) {
        const channels = this._channels;
        this._channels = {};
        this._cur = -1;
        this._count = 0;
        const chanIDs = Object.keys(channels);
        const client = this._client;
        for (let i = 0; i < chanIDs.length; ++i) {
          const id2 = +chanIDs[i];
          const channel2 = channels[id2];
          onCHANNEL_CLOSE(client, id2, channel2._channel || channel2, err, true);
        }
      }
    };
    var isRegExp = (() => {
      const toString12 = Object.prototype.toString;
      return (val) => toString12.call(val) === "[object RegExp]";
    })();
    function generateAlgorithmList(algoList, defaultList, supportedList) {
      if (Array.isArray(algoList) && algoList.length > 0) {
        for (let i = 0; i < algoList.length; ++i) {
          if (supportedList.indexOf(algoList[i]) === -1)
            throw new Error(`Unsupported algorithm: ${algoList[i]}`);
        }
        return algoList;
      }
      if (typeof algoList === "object" && algoList !== null) {
        const keys4 = Object.keys(algoList);
        let list2 = defaultList;
        for (let i = 0; i < keys4.length; ++i) {
          const key = keys4[i];
          let val = algoList[key];
          switch (key) {
            case "append":
              if (!Array.isArray(val))
                val = [val];
              if (Array.isArray(val)) {
                for (let j = 0; j < val.length; ++j) {
                  const append40 = val[j];
                  if (typeof append40 === "string") {
                    if (!append40 || list2.indexOf(append40) !== -1)
                      continue;
                    if (supportedList.indexOf(append40) === -1)
                      throw new Error(`Unsupported algorithm: ${append40}`);
                    if (list2 === defaultList)
                      list2 = list2.slice();
                    list2.push(append40);
                  } else if (isRegExp(append40)) {
                    for (let k = 0; k < supportedList.length; ++k) {
                      const algo = supportedList[k];
                      if (append40.test(algo)) {
                        if (list2.indexOf(algo) !== -1)
                          continue;
                        if (list2 === defaultList)
                          list2 = list2.slice();
                        list2.push(algo);
                      }
                    }
                  }
                }
              }
              break;
            case "prepend":
              if (!Array.isArray(val))
                val = [val];
              if (Array.isArray(val)) {
                for (let j = val.length; j >= 0; --j) {
                  const prepend = val[j];
                  if (typeof prepend === "string") {
                    if (!prepend || list2.indexOf(prepend) !== -1)
                      continue;
                    if (supportedList.indexOf(prepend) === -1)
                      throw new Error(`Unsupported algorithm: ${prepend}`);
                    if (list2 === defaultList)
                      list2 = list2.slice();
                    list2.unshift(prepend);
                  } else if (isRegExp(prepend)) {
                    for (let k = supportedList.length; k >= 0; --k) {
                      const algo = supportedList[k];
                      if (prepend.test(algo)) {
                        if (list2.indexOf(algo) !== -1)
                          continue;
                        if (list2 === defaultList)
                          list2 = list2.slice();
                        list2.unshift(algo);
                      }
                    }
                  }
                }
              }
              break;
            case "remove":
              if (!Array.isArray(val))
                val = [val];
              if (Array.isArray(val)) {
                for (let j = 0; j < val.length; ++j) {
                  const search2 = val[j];
                  if (typeof search2 === "string") {
                    if (!search2)
                      continue;
                    const idx = list2.indexOf(search2);
                    if (idx === -1)
                      continue;
                    if (list2 === defaultList)
                      list2 = list2.slice();
                    list2.splice(idx, 1);
                  } else if (isRegExp(search2)) {
                    for (let k = 0; k < list2.length; ++k) {
                      if (search2.test(list2[k])) {
                        if (list2 === defaultList)
                          list2 = list2.slice();
                        list2.splice(k, 1);
                        --k;
                      }
                    }
                  }
                }
              }
              break;
          }
        }
        return list2;
      }
      return defaultList;
    }
    module.exports = {
      ChannelManager,
      generateAlgorithmList,
      onChannelOpenFailure,
      onCHANNEL_CLOSE,
      isWritable: (stream3) => {
        return stream3 && stream3.writable && stream3._readableState && stream3._readableState.ended === false;
      }
    };
  }
});

// node_modules/ssh2/lib/client.js
var require_client = __commonJS({
  "node_modules/ssh2/lib/client.js"(exports, module) {
    "use strict";
    var {
      createHash: createHash2,
      getHashes,
      randomFillSync
    } = __require("crypto");
    var { Socket } = __require("net");
    var { lookup: dnsLookup } = __require("dns");
    var EventEmitter = __require("events");
    var HASHES = getHashes();
    var {
      COMPAT,
      CHANNEL_EXTENDED_DATATYPE: { STDERR },
      CHANNEL_OPEN_FAILURE,
      DEFAULT_CIPHER,
      DEFAULT_COMPRESSION,
      DEFAULT_KEX,
      DEFAULT_MAC,
      DEFAULT_SERVER_HOST_KEY,
      DISCONNECT_REASON,
      DISCONNECT_REASON_BY_VALUE,
      SUPPORTED_CIPHER,
      SUPPORTED_COMPRESSION,
      SUPPORTED_KEX,
      SUPPORTED_MAC,
      SUPPORTED_SERVER_HOST_KEY
    } = require_constants5();
    var { init: cryptoInit } = require_crypto();
    var Protocol = require_Protocol();
    var { parseKey } = require_keyParser();
    var { SFTP } = require_SFTP();
    var {
      bufferCopy,
      makeBufferParser,
      makeError,
      readUInt32BE,
      sigSSHToASN1,
      writeUInt32BE
    } = require_utils7();
    var { AgentContext, createAgent, isAgent } = require_agent();
    var {
      Channel,
      MAX_WINDOW,
      PACKET_SIZE,
      windowAdjust,
      WINDOW_THRESHOLD
    } = require_Channel();
    var {
      ChannelManager,
      generateAlgorithmList,
      isWritable,
      onChannelOpenFailure,
      onCHANNEL_CLOSE
    } = require_utils8();
    var bufferParser = makeBufferParser();
    var sigParser = makeBufferParser();
    var RE_OPENSSH = /^OpenSSH_(?:(?![0-4])\d)|(?:\d{2,})/;
    var noop = (err) => {
    };
    var Client = class extends EventEmitter {
      constructor() {
        super();
        this.config = {
          host: void 0,
          port: void 0,
          localAddress: void 0,
          localPort: void 0,
          forceIPv4: void 0,
          forceIPv6: void 0,
          keepaliveCountMax: void 0,
          keepaliveInterval: void 0,
          readyTimeout: void 0,
          ident: void 0,
          username: void 0,
          password: void 0,
          privateKey: void 0,
          tryKeyboard: void 0,
          agent: void 0,
          allowAgentFwd: void 0,
          authHandler: void 0,
          hostHashAlgo: void 0,
          hostHashCb: void 0,
          strictVendor: void 0,
          debug: void 0
        };
        this._agent = void 0;
        this._readyTimeout = void 0;
        this._chanMgr = void 0;
        this._callbacks = void 0;
        this._forwarding = void 0;
        this._forwardingUnix = void 0;
        this._acceptX11 = void 0;
        this._agentFwdEnabled = void 0;
        this._remoteVer = void 0;
        this._protocol = void 0;
        this._sock = void 0;
        this._resetKA = void 0;
      }
      connect(cfg) {
        if (this._sock && isWritable(this._sock)) {
          this.once("close", () => {
            this.connect(cfg);
          });
          this.end();
          return this;
        }
        this.config.host = cfg.hostname || cfg.host || "localhost";
        this.config.port = cfg.port || 22;
        this.config.localAddress = typeof cfg.localAddress === "string" ? cfg.localAddress : void 0;
        this.config.localPort = typeof cfg.localPort === "string" || typeof cfg.localPort === "number" ? cfg.localPort : void 0;
        this.config.forceIPv4 = cfg.forceIPv4 || false;
        this.config.forceIPv6 = cfg.forceIPv6 || false;
        this.config.keepaliveCountMax = typeof cfg.keepaliveCountMax === "number" && cfg.keepaliveCountMax >= 0 ? cfg.keepaliveCountMax : 3;
        this.config.keepaliveInterval = typeof cfg.keepaliveInterval === "number" && cfg.keepaliveInterval > 0 ? cfg.keepaliveInterval : 0;
        this.config.readyTimeout = typeof cfg.readyTimeout === "number" && cfg.readyTimeout >= 0 ? cfg.readyTimeout : 2e4;
        this.config.ident = typeof cfg.ident === "string" || Buffer.isBuffer(cfg.ident) ? cfg.ident : void 0;
        const algorithms = {
          kex: void 0,
          serverHostKey: void 0,
          cs: {
            cipher: void 0,
            mac: void 0,
            compress: void 0,
            lang: []
          },
          sc: void 0
        };
        let allOfferDefaults = true;
        if (typeof cfg.algorithms === "object" && cfg.algorithms !== null) {
          algorithms.kex = generateAlgorithmList(
            cfg.algorithms.kex,
            DEFAULT_KEX,
            SUPPORTED_KEX
          );
          if (algorithms.kex !== DEFAULT_KEX)
            allOfferDefaults = false;
          algorithms.serverHostKey = generateAlgorithmList(
            cfg.algorithms.serverHostKey,
            DEFAULT_SERVER_HOST_KEY,
            SUPPORTED_SERVER_HOST_KEY
          );
          if (algorithms.serverHostKey !== DEFAULT_SERVER_HOST_KEY)
            allOfferDefaults = false;
          algorithms.cs.cipher = generateAlgorithmList(
            cfg.algorithms.cipher,
            DEFAULT_CIPHER,
            SUPPORTED_CIPHER
          );
          if (algorithms.cs.cipher !== DEFAULT_CIPHER)
            allOfferDefaults = false;
          algorithms.cs.mac = generateAlgorithmList(
            cfg.algorithms.hmac,
            DEFAULT_MAC,
            SUPPORTED_MAC
          );
          if (algorithms.cs.mac !== DEFAULT_MAC)
            allOfferDefaults = false;
          algorithms.cs.compress = generateAlgorithmList(
            cfg.algorithms.compress,
            DEFAULT_COMPRESSION,
            SUPPORTED_COMPRESSION
          );
          if (algorithms.cs.compress !== DEFAULT_COMPRESSION)
            allOfferDefaults = false;
          if (!allOfferDefaults)
            algorithms.sc = algorithms.cs;
        }
        if (typeof cfg.username === "string")
          this.config.username = cfg.username;
        else if (typeof cfg.user === "string")
          this.config.username = cfg.user;
        else
          throw new Error("Invalid username");
        this.config.password = typeof cfg.password === "string" ? cfg.password : void 0;
        this.config.privateKey = typeof cfg.privateKey === "string" || Buffer.isBuffer(cfg.privateKey) ? cfg.privateKey : void 0;
        this.config.localHostname = typeof cfg.localHostname === "string" ? cfg.localHostname : void 0;
        this.config.localUsername = typeof cfg.localUsername === "string" ? cfg.localUsername : void 0;
        this.config.tryKeyboard = cfg.tryKeyboard === true;
        if (typeof cfg.agent === "string" && cfg.agent.length)
          this.config.agent = createAgent(cfg.agent);
        else if (isAgent(cfg.agent))
          this.config.agent = cfg.agent;
        else
          this.config.agent = void 0;
        this.config.allowAgentFwd = cfg.agentForward === true && this.config.agent !== void 0;
        let authHandler = this.config.authHandler = typeof cfg.authHandler === "function" || Array.isArray(cfg.authHandler) ? cfg.authHandler : void 0;
        this.config.strictVendor = typeof cfg.strictVendor === "boolean" ? cfg.strictVendor : true;
        const debug2 = this.config.debug = typeof cfg.debug === "function" ? cfg.debug : void 0;
        if (cfg.agentForward === true && !this.config.allowAgentFwd) {
          throw new Error(
            "You must set a valid agent path to allow agent forwarding"
          );
        }
        let callbacks = this._callbacks = [];
        this._chanMgr = new ChannelManager(this);
        this._forwarding = {};
        this._forwardingUnix = {};
        this._acceptX11 = 0;
        this._agentFwdEnabled = false;
        this._agent = this.config.agent ? this.config.agent : void 0;
        this._remoteVer = void 0;
        let privateKey;
        if (this.config.privateKey) {
          privateKey = parseKey(this.config.privateKey, cfg.passphrase);
          if (privateKey instanceof Error)
            throw new Error(`Cannot parse privateKey: ${privateKey.message}`);
          if (Array.isArray(privateKey)) {
            privateKey = privateKey[0];
          }
          if (privateKey.getPrivatePEM() === null) {
            throw new Error(
              "privateKey value does not contain a (valid) private key"
            );
          }
        }
        let hostVerifier;
        if (typeof cfg.hostVerifier === "function") {
          const hashCb = cfg.hostVerifier;
          let hasher;
          if (HASHES.indexOf(cfg.hostHash) !== -1) {
            hasher = createHash2(cfg.hostHash);
          }
          hostVerifier = (key, verify) => {
            if (hasher) {
              hasher.update(key);
              key = hasher.digest("hex");
            }
            const ret = hashCb(key, verify);
            if (ret !== void 0)
              verify(ret);
          };
        }
        const sock = this._sock = cfg.sock || new Socket();
        let ready = false;
        let sawHeader = false;
        if (this._protocol)
          this._protocol.cleanup();
        const DEBUG_HANDLER = !debug2 ? void 0 : (p, display, msg) => {
          debug2(`Debug output from server: ${JSON.stringify(msg)}`);
        };
        let serverSigAlgs;
        const proto = this._protocol = new Protocol({
          ident: this.config.ident,
          offer: allOfferDefaults ? void 0 : algorithms,
          onWrite: (data) => {
            if (isWritable(sock))
              sock.write(data);
          },
          onError: (err) => {
            if (err.level === "handshake")
              clearTimeout(this._readyTimeout);
            if (!proto._destruct)
              sock.removeAllListeners("data");
            this.emit("error", err);
            try {
              sock.end();
            } catch {
            }
          },
          onHeader: (header) => {
            sawHeader = true;
            this._remoteVer = header.versions.software;
            if (header.greeting)
              this.emit("greeting", header.greeting);
          },
          onHandshakeComplete: (negotiated) => {
            this.emit("handshake", negotiated);
            if (!ready) {
              ready = true;
              proto.service("ssh-userauth");
            }
          },
          debug: debug2,
          hostVerifier,
          messageHandlers: {
            DEBUG: DEBUG_HANDLER,
            DISCONNECT: (p, reason, desc) => {
              if (reason !== DISCONNECT_REASON.BY_APPLICATION) {
                if (!desc) {
                  desc = DISCONNECT_REASON_BY_VALUE[reason];
                  if (desc === void 0)
                    desc = `Unexpected disconnection reason: ${reason}`;
                }
                const err = new Error(desc);
                err.code = reason;
                this.emit("error", err);
              }
              sock.end();
            },
            SERVICE_ACCEPT: (p, name4) => {
              if (name4 === "ssh-userauth")
                tryNextAuth();
            },
            EXT_INFO: (p, exts) => {
              if (serverSigAlgs === void 0) {
                for (const ext of exts) {
                  if (ext.name === "server-sig-algs") {
                    serverSigAlgs = ext.algs;
                    return;
                  }
                }
                serverSigAlgs = null;
              }
            },
            USERAUTH_BANNER: (p, msg) => {
              this.emit("banner", msg);
            },
            USERAUTH_SUCCESS: (p) => {
              resetKA();
              clearTimeout(this._readyTimeout);
              this.emit("ready");
            },
            USERAUTH_FAILURE: (p, authMethods, partialSuccess) => {
              if (curAuth.keyAlgos) {
                const oldKeyAlgo = curAuth.keyAlgos[0][0];
                if (debug2)
                  debug2(`Client: ${curAuth.type} (${oldKeyAlgo}) auth failed`);
                curAuth.keyAlgos.shift();
                if (curAuth.keyAlgos.length) {
                  const [keyAlgo, hashAlgo] = curAuth.keyAlgos[0];
                  switch (curAuth.type) {
                    case "agent":
                      proto.authPK(
                        curAuth.username,
                        curAuth.agentCtx.currentKey(),
                        keyAlgo
                      );
                      return;
                    case "publickey":
                      proto.authPK(curAuth.username, curAuth.key, keyAlgo);
                      return;
                    case "hostbased":
                      proto.authHostbased(
                        curAuth.username,
                        curAuth.key,
                        curAuth.localHostname,
                        curAuth.localUsername,
                        keyAlgo,
                        (buf, cb) => {
                          const signature = curAuth.key.sign(buf, hashAlgo);
                          if (signature instanceof Error) {
                            signature.message = `Error while signing with key: ${signature.message}`;
                            signature.level = "client-authentication";
                            this.emit("error", signature);
                            return tryNextAuth();
                          }
                          cb(signature);
                        }
                      );
                      return;
                  }
                } else {
                  curAuth.keyAlgos = void 0;
                }
              }
              if (curAuth.type === "agent") {
                const pos = curAuth.agentCtx.pos();
                debug2 && debug2(`Client: Agent key #${pos + 1} failed`);
                return tryNextAgentKey();
              }
              debug2 && debug2(`Client: ${curAuth.type} auth failed`);
              curPartial = partialSuccess;
              curAuthsLeft = authMethods;
              tryNextAuth();
            },
            USERAUTH_PASSWD_CHANGEREQ: (p, prompt) => {
              if (curAuth.type === "password") {
                this.emit("change password", prompt, (newPassword) => {
                  proto.authPassword(
                    this.config.username,
                    this.config.password,
                    newPassword
                  );
                });
              }
            },
            USERAUTH_PK_OK: (p) => {
              let keyAlgo;
              let hashAlgo;
              if (curAuth.keyAlgos)
                [keyAlgo, hashAlgo] = curAuth.keyAlgos[0];
              if (curAuth.type === "agent") {
                const key = curAuth.agentCtx.currentKey();
                proto.authPK(curAuth.username, key, keyAlgo, (buf, cb) => {
                  const opts = { hash: hashAlgo };
                  curAuth.agentCtx.sign(key, buf, opts, (err, signed) => {
                    if (err) {
                      err.level = "agent";
                      this.emit("error", err);
                    } else {
                      return cb(signed);
                    }
                    tryNextAgentKey();
                  });
                });
              } else if (curAuth.type === "publickey") {
                proto.authPK(curAuth.username, curAuth.key, keyAlgo, (buf, cb) => {
                  const signature = curAuth.key.sign(buf, hashAlgo);
                  if (signature instanceof Error) {
                    signature.message = `Error signing data with key: ${signature.message}`;
                    signature.level = "client-authentication";
                    this.emit("error", signature);
                    return tryNextAuth();
                  }
                  cb(signature);
                });
              }
            },
            USERAUTH_INFO_REQUEST: (p, name4, instructions, prompts) => {
              if (curAuth.type === "keyboard-interactive") {
                const nprompts = Array.isArray(prompts) ? prompts.length : 0;
                if (nprompts === 0) {
                  debug2 && debug2(
                    "Client: Sending automatic USERAUTH_INFO_RESPONSE"
                  );
                  proto.authInfoRes();
                  return;
                }
                curAuth.prompt(
                  name4,
                  instructions,
                  "",
                  prompts,
                  (answers) => {
                    proto.authInfoRes(answers);
                  }
                );
              }
            },
            REQUEST_SUCCESS: (p, data) => {
              if (callbacks.length)
                callbacks.shift()(false, data);
            },
            REQUEST_FAILURE: (p) => {
              if (callbacks.length)
                callbacks.shift()(true);
            },
            GLOBAL_REQUEST: (p, name4, wantReply, data) => {
              switch (name4) {
                case "hostkeys-00@openssh.com":
                  hostKeysProve(this, data, (err, keys4) => {
                    if (err)
                      return;
                    this.emit("hostkeys", keys4);
                  });
                  if (wantReply)
                    proto.requestSuccess();
                  break;
                default:
                  if (wantReply)
                    proto.requestFailure();
              }
            },
            CHANNEL_OPEN: (p, info4) => {
              onCHANNEL_OPEN(this, info4);
            },
            CHANNEL_OPEN_CONFIRMATION: (p, info4) => {
              const channel2 = this._chanMgr.get(info4.recipient);
              if (typeof channel2 !== "function")
                return;
              const isSFTP = channel2.type === "sftp";
              const type = isSFTP ? "session" : channel2.type;
              const chanInfo = {
                type,
                incoming: {
                  id: info4.recipient,
                  window: MAX_WINDOW,
                  packetSize: PACKET_SIZE,
                  state: "open"
                },
                outgoing: {
                  id: info4.sender,
                  window: info4.window,
                  packetSize: info4.packetSize,
                  state: "open"
                }
              };
              const instance = isSFTP ? new SFTP(this, chanInfo, { debug: debug2 }) : new Channel(this, chanInfo);
              this._chanMgr.update(info4.recipient, instance);
              channel2(void 0, instance);
            },
            CHANNEL_OPEN_FAILURE: (p, recipient, reason, description) => {
              const channel2 = this._chanMgr.get(recipient);
              if (typeof channel2 !== "function")
                return;
              const info4 = { reason, description };
              onChannelOpenFailure(this, recipient, info4, channel2);
            },
            CHANNEL_DATA: (p, recipient, data) => {
              const channel2 = this._chanMgr.get(recipient);
              if (typeof channel2 !== "object" || channel2 === null)
                return;
              if (channel2.incoming.window === 0)
                return;
              channel2.incoming.window -= data.length;
              if (channel2.push(data) === false) {
                channel2._waitChanDrain = true;
                return;
              }
              if (channel2.incoming.window <= WINDOW_THRESHOLD)
                windowAdjust(channel2);
            },
            CHANNEL_EXTENDED_DATA: (p, recipient, data, type) => {
              if (type !== STDERR)
                return;
              const channel2 = this._chanMgr.get(recipient);
              if (typeof channel2 !== "object" || channel2 === null)
                return;
              if (channel2.incoming.window === 0)
                return;
              channel2.incoming.window -= data.length;
              if (!channel2.stderr.push(data)) {
                channel2._waitChanDrain = true;
                return;
              }
              if (channel2.incoming.window <= WINDOW_THRESHOLD)
                windowAdjust(channel2);
            },
            CHANNEL_WINDOW_ADJUST: (p, recipient, amount) => {
              const channel2 = this._chanMgr.get(recipient);
              if (typeof channel2 !== "object" || channel2 === null)
                return;
              channel2.outgoing.window += amount;
              if (channel2._waitWindow) {
                channel2._waitWindow = false;
                if (channel2._chunk) {
                  channel2._write(channel2._chunk, null, channel2._chunkcb);
                } else if (channel2._chunkcb) {
                  channel2._chunkcb();
                } else if (channel2._chunkErr) {
                  channel2.stderr._write(
                    channel2._chunkErr,
                    null,
                    channel2._chunkcbErr
                  );
                } else if (channel2._chunkcbErr) {
                  channel2._chunkcbErr();
                }
              }
            },
            CHANNEL_SUCCESS: (p, recipient) => {
              const channel2 = this._chanMgr.get(recipient);
              if (typeof channel2 !== "object" || channel2 === null)
                return;
              this._resetKA();
              if (channel2._callbacks.length)
                channel2._callbacks.shift()(false);
            },
            CHANNEL_FAILURE: (p, recipient) => {
              const channel2 = this._chanMgr.get(recipient);
              if (typeof channel2 !== "object" || channel2 === null)
                return;
              this._resetKA();
              if (channel2._callbacks.length)
                channel2._callbacks.shift()(true);
            },
            CHANNEL_REQUEST: (p, recipient, type, wantReply, data) => {
              const channel2 = this._chanMgr.get(recipient);
              if (typeof channel2 !== "object" || channel2 === null)
                return;
              const exit2 = channel2._exit;
              if (exit2.code !== void 0)
                return;
              switch (type) {
                case "exit-status":
                  channel2.emit("exit", exit2.code = data);
                  return;
                case "exit-signal":
                  channel2.emit(
                    "exit",
                    exit2.code = null,
                    exit2.signal = `SIG${data.signal}`,
                    exit2.dump = data.coreDumped,
                    exit2.desc = data.errorMessage
                  );
                  return;
              }
              if (wantReply)
                p.channelFailure(channel2.outgoing.id);
            },
            CHANNEL_EOF: (p, recipient) => {
              const channel2 = this._chanMgr.get(recipient);
              if (typeof channel2 !== "object" || channel2 === null)
                return;
              if (channel2.incoming.state !== "open")
                return;
              channel2.incoming.state = "eof";
              if (channel2.readable)
                channel2.push(null);
              if (channel2.stderr.readable)
                channel2.stderr.push(null);
            },
            CHANNEL_CLOSE: (p, recipient) => {
              onCHANNEL_CLOSE(this, recipient, this._chanMgr.get(recipient));
            }
          }
        });
        sock.pause();
        const kainterval = this.config.keepaliveInterval;
        const kacountmax = this.config.keepaliveCountMax;
        let kacount = 0;
        let katimer;
        const sendKA = () => {
          if (++kacount > kacountmax) {
            clearInterval(katimer);
            if (sock.readable) {
              const err = new Error("Keepalive timeout");
              err.level = "client-timeout";
              this.emit("error", err);
              sock.destroy();
            }
            return;
          }
          if (isWritable(sock)) {
            callbacks.push(resetKA);
            proto.ping();
          } else {
            clearInterval(katimer);
          }
        };
        function resetKA() {
          if (kainterval > 0) {
            kacount = 0;
            clearInterval(katimer);
            if (isWritable(sock))
              katimer = setInterval(sendKA, kainterval);
          }
        }
        this._resetKA = resetKA;
        const onDone = (() => {
          let called = false;
          return () => {
            if (called)
              return;
            called = true;
            if (wasConnected && !sawHeader) {
              const err = makeError("Connection lost before handshake", "protocol", true);
              this.emit("error", err);
            }
          };
        })();
        const onConnect = (() => {
          let called = false;
          return () => {
            if (called)
              return;
            called = true;
            wasConnected = true;
            debug2 && debug2("Socket connected");
            this.emit("connect");
            cryptoInit.then(() => {
              proto.start();
              sock.on("data", (data) => {
                try {
                  proto.parse(data, 0, data.length);
                } catch (ex) {
                  this.emit("error", ex);
                  try {
                    if (isWritable(sock))
                      sock.end();
                  } catch {
                  }
                }
              });
              if (sock.stderr && typeof sock.stderr.resume === "function")
                sock.stderr.resume();
              sock.resume();
            }).catch((err) => {
              this.emit("error", err);
              try {
                if (isWritable(sock))
                  sock.end();
              } catch {
              }
            });
          };
        })();
        let wasConnected = false;
        sock.on("connect", onConnect).on("timeout", () => {
          this.emit("timeout");
        }).on("error", (err) => {
          debug2 && debug2(`Socket error: ${err.message}`);
          clearTimeout(this._readyTimeout);
          err.level = "client-socket";
          this.emit("error", err);
        }).on("end", () => {
          debug2 && debug2("Socket ended");
          onDone();
          proto.cleanup();
          clearTimeout(this._readyTimeout);
          clearInterval(katimer);
          this.emit("end");
        }).on("close", () => {
          debug2 && debug2("Socket closed");
          onDone();
          proto.cleanup();
          clearTimeout(this._readyTimeout);
          clearInterval(katimer);
          this.emit("close");
          const callbacks_ = callbacks;
          callbacks = this._callbacks = [];
          const err = new Error("No response from server");
          for (let i = 0; i < callbacks_.length; ++i)
            callbacks_[i](err);
          this._chanMgr.cleanup(err);
        });
        let curAuth;
        let curPartial = null;
        let curAuthsLeft = null;
        const authsAllowed = ["none"];
        if (this.config.password !== void 0)
          authsAllowed.push("password");
        if (privateKey !== void 0)
          authsAllowed.push("publickey");
        if (this._agent !== void 0)
          authsAllowed.push("agent");
        if (this.config.tryKeyboard)
          authsAllowed.push("keyboard-interactive");
        if (privateKey !== void 0 && this.config.localHostname !== void 0 && this.config.localUsername !== void 0) {
          authsAllowed.push("hostbased");
        }
        if (Array.isArray(authHandler))
          authHandler = makeSimpleAuthHandler(authHandler);
        else if (typeof authHandler !== "function")
          authHandler = makeSimpleAuthHandler(authsAllowed);
        let hasSentAuth = false;
        const doNextAuth = (nextAuth) => {
          if (hasSentAuth)
            return;
          hasSentAuth = true;
          if (nextAuth === false) {
            const err = new Error("All configured authentication methods failed");
            err.level = "client-authentication";
            this.emit("error", err);
            this.end();
            return;
          }
          if (typeof nextAuth === "string") {
            const type = nextAuth;
            if (authsAllowed.indexOf(type) === -1)
              return skipAuth(`Authentication method not allowed: ${type}`);
            const username = this.config.username;
            switch (type) {
              case "password":
                nextAuth = { type, username, password: this.config.password };
                break;
              case "publickey":
                nextAuth = { type, username, key: privateKey };
                break;
              case "hostbased":
                nextAuth = {
                  type,
                  username,
                  key: privateKey,
                  localHostname: this.config.localHostname,
                  localUsername: this.config.localUsername
                };
                break;
              case "agent":
                nextAuth = {
                  type,
                  username,
                  agentCtx: new AgentContext(this._agent)
                };
                break;
              case "keyboard-interactive":
                nextAuth = {
                  type,
                  username,
                  prompt: (...args) => this.emit("keyboard-interactive", ...args)
                };
                break;
              case "none":
                nextAuth = { type, username };
                break;
              default:
                return skipAuth(
                  `Skipping unsupported authentication method: ${nextAuth}`
                );
            }
          } else if (typeof nextAuth !== "object" || nextAuth === null) {
            return skipAuth(
              `Skipping invalid authentication attempt: ${nextAuth}`
            );
          } else {
            const username = nextAuth.username;
            if (typeof username !== "string") {
              return skipAuth(
                `Skipping invalid authentication attempt: ${nextAuth}`
              );
            }
            const type = nextAuth.type;
            switch (type) {
              case "password": {
                const { password } = nextAuth;
                if (typeof password !== "string" && !Buffer.isBuffer(password))
                  return skipAuth("Skipping invalid password auth attempt");
                nextAuth = { type, username, password };
                break;
              }
              case "publickey": {
                const key = parseKey(nextAuth.key, nextAuth.passphrase);
                if (key instanceof Error)
                  return skipAuth("Skipping invalid key auth attempt");
                if (!key.isPrivateKey())
                  return skipAuth("Skipping non-private key");
                nextAuth = { type, username, key };
                break;
              }
              case "hostbased": {
                const { localHostname, localUsername } = nextAuth;
                const key = parseKey(nextAuth.key, nextAuth.passphrase);
                if (key instanceof Error || typeof localHostname !== "string" || typeof localUsername !== "string") {
                  return skipAuth("Skipping invalid hostbased auth attempt");
                }
                if (!key.isPrivateKey())
                  return skipAuth("Skipping non-private key");
                nextAuth = { type, username, key, localHostname, localUsername };
                break;
              }
              case "agent": {
                let agent = nextAuth.agent;
                if (typeof agent === "string" && agent.length) {
                  agent = createAgent(agent);
                } else if (!isAgent(agent)) {
                  return skipAuth(
                    `Skipping invalid agent: ${nextAuth.agent}`
                  );
                }
                nextAuth = { type, username, agentCtx: new AgentContext(agent) };
                break;
              }
              case "keyboard-interactive": {
                const { prompt } = nextAuth;
                if (typeof prompt !== "function") {
                  return skipAuth(
                    "Skipping invalid keyboard-interactive auth attempt"
                  );
                }
                nextAuth = { type, username, prompt };
                break;
              }
              case "none":
                nextAuth = { type, username };
                break;
              default:
                return skipAuth(
                  `Skipping unsupported authentication method: ${nextAuth}`
                );
            }
          }
          curAuth = nextAuth;
          try {
            const username = curAuth.username;
            switch (curAuth.type) {
              case "password":
                proto.authPassword(username, curAuth.password);
                break;
              case "publickey": {
                let keyAlgo;
                curAuth.keyAlgos = getKeyAlgos(this, curAuth.key, serverSigAlgs);
                if (curAuth.keyAlgos) {
                  if (curAuth.keyAlgos.length) {
                    keyAlgo = curAuth.keyAlgos[0][0];
                  } else {
                    return skipAuth(
                      "Skipping key authentication (no mutual hash algorithm)"
                    );
                  }
                }
                proto.authPK(username, curAuth.key, keyAlgo);
                break;
              }
              case "hostbased": {
                let keyAlgo;
                let hashAlgo;
                curAuth.keyAlgos = getKeyAlgos(this, curAuth.key, serverSigAlgs);
                if (curAuth.keyAlgos) {
                  if (curAuth.keyAlgos.length) {
                    [keyAlgo, hashAlgo] = curAuth.keyAlgos[0];
                  } else {
                    return skipAuth(
                      "Skipping hostbased authentication (no mutual hash algorithm)"
                    );
                  }
                }
                proto.authHostbased(
                  username,
                  curAuth.key,
                  curAuth.localHostname,
                  curAuth.localUsername,
                  keyAlgo,
                  (buf, cb) => {
                    const signature = curAuth.key.sign(buf, hashAlgo);
                    if (signature instanceof Error) {
                      signature.message = `Error while signing with key: ${signature.message}`;
                      signature.level = "client-authentication";
                      this.emit("error", signature);
                      return tryNextAuth();
                    }
                    cb(signature);
                  }
                );
                break;
              }
              case "agent":
                curAuth.agentCtx.init((err) => {
                  if (err) {
                    err.level = "agent";
                    this.emit("error", err);
                    return tryNextAuth();
                  }
                  tryNextAgentKey();
                });
                break;
              case "keyboard-interactive":
                proto.authKeyboard(username);
                break;
              case "none":
                proto.authNone(username);
                break;
            }
          } finally {
            hasSentAuth = false;
          }
        };
        function skipAuth(msg) {
          debug2 && debug2(msg);
          process.nextTick(tryNextAuth);
        }
        function tryNextAuth() {
          hasSentAuth = false;
          const auth = authHandler(curAuthsLeft, curPartial, doNextAuth);
          if (hasSentAuth || auth === void 0)
            return;
          doNextAuth(auth);
        }
        const tryNextAgentKey = () => {
          if (curAuth.type === "agent") {
            const key = curAuth.agentCtx.nextKey();
            if (key === false) {
              debug2 && debug2("Agent: No more keys left to try");
              debug2 && debug2("Client: agent auth failed");
              tryNextAuth();
            } else {
              const pos = curAuth.agentCtx.pos();
              let keyAlgo;
              curAuth.keyAlgos = getKeyAlgos(this, key, serverSigAlgs);
              if (curAuth.keyAlgos) {
                if (curAuth.keyAlgos.length) {
                  keyAlgo = curAuth.keyAlgos[0][0];
                } else {
                  debug2 && debug2(
                    `Agent: Skipping key #${pos + 1} (no mutual hash algorithm)`
                  );
                  tryNextAgentKey();
                  return;
                }
              }
              debug2 && debug2(`Agent: Trying key #${pos + 1}`);
              proto.authPK(curAuth.username, key, keyAlgo);
            }
          }
        };
        const startTimeout = () => {
          if (this.config.readyTimeout > 0) {
            this._readyTimeout = setTimeout(() => {
              const err = new Error("Timed out while waiting for handshake");
              err.level = "client-timeout";
              this.emit("error", err);
              sock.destroy();
            }, this.config.readyTimeout);
          }
        };
        if (!cfg.sock) {
          let host = this.config.host;
          const forceIPv4 = this.config.forceIPv4;
          const forceIPv6 = this.config.forceIPv6;
          debug2 && debug2(`Client: Trying ${host} on port ${this.config.port} ...`);
          const doConnect = () => {
            startTimeout();
            sock.connect({
              host,
              port: this.config.port,
              localAddress: this.config.localAddress,
              localPort: this.config.localPort
            });
            sock.setMaxListeners(0);
            sock.setTimeout(typeof cfg.timeout === "number" ? cfg.timeout : 0);
          };
          if (!forceIPv4 && !forceIPv6 || forceIPv4 && forceIPv6) {
            doConnect();
          } else {
            dnsLookup(host, forceIPv4 ? 4 : 6, (err, address, family) => {
              if (err) {
                const type = forceIPv4 ? "IPv4" : "IPv6";
                const error4 = new Error(
                  `Error while looking up ${type} address for '${host}': ${err}`
                );
                clearTimeout(this._readyTimeout);
                error4.level = "client-dns";
                this.emit("error", error4);
                this.emit("close");
                return;
              }
              host = address;
              doConnect();
            });
          }
        } else {
          startTimeout();
          if (typeof sock.connecting === "boolean") {
            if (!sock.connecting) {
              onConnect();
            }
          } else {
            onConnect();
          }
        }
        return this;
      }
      end() {
        if (this._sock && isWritable(this._sock)) {
          this._protocol.disconnect(DISCONNECT_REASON.BY_APPLICATION);
          this._sock.end();
        }
        return this;
      }
      destroy() {
        this._sock && isWritable(this._sock) && this._sock.destroy();
        return this;
      }
      exec(cmd, opts, cb) {
        if (!this._sock || !isWritable(this._sock))
          throw new Error("Not connected");
        if (typeof opts === "function") {
          cb = opts;
          opts = {};
        }
        const extraOpts = { allowHalfOpen: opts.allowHalfOpen !== false };
        openChannel(this, "session", extraOpts, (err, chan) => {
          if (err) {
            cb(err);
            return;
          }
          const todo = [];
          function reqCb(err2) {
            if (err2) {
              chan.close();
              cb(err2);
              return;
            }
            if (todo.length)
              todo.shift()();
          }
          if (this.config.allowAgentFwd === true || opts && opts.agentForward === true && this._agent !== void 0) {
            todo.push(() => reqAgentFwd(chan, reqCb));
          }
          if (typeof opts === "object" && opts !== null) {
            if (typeof opts.env === "object" && opts.env !== null)
              reqEnv(chan, opts.env);
            if (typeof opts.pty === "object" && opts.pty !== null || opts.pty === true) {
              todo.push(() => reqPty(chan, opts.pty, reqCb));
            }
            if (typeof opts.x11 === "object" && opts.x11 !== null || opts.x11 === "number" || opts.x11 === true) {
              todo.push(() => reqX11(chan, opts.x11, reqCb));
            }
          }
          todo.push(() => reqExec(chan, cmd, opts, cb));
          todo.shift()();
        });
        return this;
      }
      shell(wndopts, opts, cb) {
        if (!this._sock || !isWritable(this._sock))
          throw new Error("Not connected");
        if (typeof wndopts === "function") {
          cb = wndopts;
          wndopts = opts = void 0;
        } else if (typeof opts === "function") {
          cb = opts;
          opts = void 0;
        }
        if (wndopts && (wndopts.x11 !== void 0 || wndopts.env !== void 0)) {
          opts = wndopts;
          wndopts = void 0;
        }
        openChannel(this, "session", (err, chan) => {
          if (err) {
            cb(err);
            return;
          }
          const todo = [];
          function reqCb(err2) {
            if (err2) {
              chan.close();
              cb(err2);
              return;
            }
            if (todo.length)
              todo.shift()();
          }
          if (this.config.allowAgentFwd === true || opts && opts.agentForward === true && this._agent !== void 0) {
            todo.push(() => reqAgentFwd(chan, reqCb));
          }
          if (wndopts !== false)
            todo.push(() => reqPty(chan, wndopts, reqCb));
          if (typeof opts === "object" && opts !== null) {
            if (typeof opts.env === "object" && opts.env !== null)
              reqEnv(chan, opts.env);
            if (typeof opts.x11 === "object" && opts.x11 !== null || opts.x11 === "number" || opts.x11 === true) {
              todo.push(() => reqX11(chan, opts.x11, reqCb));
            }
          }
          todo.push(() => reqShell(chan, cb));
          todo.shift()();
        });
        return this;
      }
      subsys(name4, cb) {
        if (!this._sock || !isWritable(this._sock))
          throw new Error("Not connected");
        openChannel(this, "session", (err, chan) => {
          if (err) {
            cb(err);
            return;
          }
          reqSubsystem(chan, name4, (err2, stream3) => {
            if (err2) {
              cb(err2);
              return;
            }
            cb(void 0, stream3);
          });
        });
        return this;
      }
      forwardIn(bindAddr, bindPort, cb) {
        if (!this._sock || !isWritable(this._sock))
          throw new Error("Not connected");
        const wantReply = typeof cb === "function";
        if (wantReply) {
          this._callbacks.push((had_err, data) => {
            if (had_err) {
              cb(had_err !== true ? had_err : new Error(`Unable to bind to ${bindAddr}:${bindPort}`));
              return;
            }
            let realPort = bindPort;
            if (bindPort === 0 && data && data.length >= 4) {
              realPort = readUInt32BE(data, 0);
              if (!(this._protocol._compatFlags & COMPAT.DYN_RPORT_BUG))
                bindPort = realPort;
            }
            this._forwarding[`${bindAddr}:${bindPort}`] = realPort;
            cb(void 0, realPort);
          });
        }
        this._protocol.tcpipForward(bindAddr, bindPort, wantReply);
        return this;
      }
      unforwardIn(bindAddr, bindPort, cb) {
        if (!this._sock || !isWritable(this._sock))
          throw new Error("Not connected");
        const wantReply = typeof cb === "function";
        if (wantReply) {
          this._callbacks.push((had_err) => {
            if (had_err) {
              cb(had_err !== true ? had_err : new Error(`Unable to unbind from ${bindAddr}:${bindPort}`));
              return;
            }
            delete this._forwarding[`${bindAddr}:${bindPort}`];
            cb();
          });
        }
        this._protocol.cancelTcpipForward(bindAddr, bindPort, wantReply);
        return this;
      }
      forwardOut(srcIP, srcPort, dstIP, dstPort, cb) {
        if (!this._sock || !isWritable(this._sock))
          throw new Error("Not connected");
        const cfg = {
          srcIP,
          srcPort,
          dstIP,
          dstPort
        };
        if (typeof cb !== "function")
          cb = noop;
        openChannel(this, "direct-tcpip", cfg, cb);
        return this;
      }
      openssh_noMoreSessions(cb) {
        if (!this._sock || !isWritable(this._sock))
          throw new Error("Not connected");
        const wantReply = typeof cb === "function";
        if (!this.config.strictVendor || this.config.strictVendor && RE_OPENSSH.test(this._remoteVer)) {
          if (wantReply) {
            this._callbacks.push((had_err) => {
              if (had_err) {
                cb(had_err !== true ? had_err : new Error("Unable to disable future sessions"));
                return;
              }
              cb();
            });
          }
          this._protocol.openssh_noMoreSessions(wantReply);
          return this;
        }
        if (!wantReply)
          return this;
        process.nextTick(
          cb,
          new Error(
            "strictVendor enabled and server is not OpenSSH or compatible version"
          )
        );
        return this;
      }
      openssh_forwardInStreamLocal(socketPath, cb) {
        if (!this._sock || !isWritable(this._sock))
          throw new Error("Not connected");
        const wantReply = typeof cb === "function";
        if (!this.config.strictVendor || this.config.strictVendor && RE_OPENSSH.test(this._remoteVer)) {
          if (wantReply) {
            this._callbacks.push((had_err) => {
              if (had_err) {
                cb(had_err !== true ? had_err : new Error(`Unable to bind to ${socketPath}`));
                return;
              }
              this._forwardingUnix[socketPath] = true;
              cb();
            });
          }
          this._protocol.openssh_streamLocalForward(socketPath, wantReply);
          return this;
        }
        if (!wantReply)
          return this;
        process.nextTick(
          cb,
          new Error(
            "strictVendor enabled and server is not OpenSSH or compatible version"
          )
        );
        return this;
      }
      openssh_unforwardInStreamLocal(socketPath, cb) {
        if (!this._sock || !isWritable(this._sock))
          throw new Error("Not connected");
        const wantReply = typeof cb === "function";
        if (!this.config.strictVendor || this.config.strictVendor && RE_OPENSSH.test(this._remoteVer)) {
          if (wantReply) {
            this._callbacks.push((had_err) => {
              if (had_err) {
                cb(had_err !== true ? had_err : new Error(`Unable to unbind from ${socketPath}`));
                return;
              }
              delete this._forwardingUnix[socketPath];
              cb();
            });
          }
          this._protocol.openssh_cancelStreamLocalForward(socketPath, wantReply);
          return this;
        }
        if (!wantReply)
          return this;
        process.nextTick(
          cb,
          new Error(
            "strictVendor enabled and server is not OpenSSH or compatible version"
          )
        );
        return this;
      }
      openssh_forwardOutStreamLocal(socketPath, cb) {
        if (!this._sock || !isWritable(this._sock))
          throw new Error("Not connected");
        if (typeof cb !== "function")
          cb = noop;
        if (!this.config.strictVendor || this.config.strictVendor && RE_OPENSSH.test(this._remoteVer)) {
          openChannel(this, "direct-streamlocal@openssh.com", { socketPath }, cb);
          return this;
        }
        process.nextTick(
          cb,
          new Error(
            "strictVendor enabled and server is not OpenSSH or compatible version"
          )
        );
        return this;
      }
      sftp(cb) {
        if (!this._sock || !isWritable(this._sock))
          throw new Error("Not connected");
        openChannel(this, "sftp", (err, sftp) => {
          if (err) {
            cb(err);
            return;
          }
          reqSubsystem(sftp, "sftp", (err2, sftp_) => {
            if (err2) {
              cb(err2);
              return;
            }
            function removeListeners() {
              sftp.removeListener("ready", onReady);
              sftp.removeListener("error", onError3);
              sftp.removeListener("exit", onExit4);
              sftp.removeListener("close", onExit4);
            }
            function onReady() {
              removeListeners();
              cb(void 0, sftp);
            }
            function onError3(err3) {
              removeListeners();
              cb(err3);
            }
            function onExit4(code, signal) {
              removeListeners();
              let msg;
              if (typeof code === "number")
                msg = `Received exit code ${code} while establishing SFTP session`;
              else if (signal !== void 0)
                msg = `Received signal ${signal} while establishing SFTP session`;
              else
                msg = "Received unexpected SFTP session termination";
              const err3 = new Error(msg);
              err3.code = code;
              err3.signal = signal;
              cb(err3);
            }
            sftp.on("ready", onReady).on("error", onError3).on("exit", onExit4).on("close", onExit4);
            sftp._init();
          });
        });
        return this;
      }
      setNoDelay(noDelay) {
        if (this._sock && typeof this._sock.setNoDelay === "function")
          this._sock.setNoDelay(noDelay);
        return this;
      }
    };
    function openChannel(self2, type, opts, cb) {
      const initWindow = MAX_WINDOW;
      const maxPacket = PACKET_SIZE;
      if (typeof opts === "function") {
        cb = opts;
        opts = {};
      }
      const wrapper = (err, stream3) => {
        cb(err, stream3);
      };
      wrapper.type = type;
      const localChan = self2._chanMgr.add(wrapper);
      if (localChan === -1) {
        cb(new Error("No free channels available"));
        return;
      }
      switch (type) {
        case "session":
        case "sftp":
          self2._protocol.session(localChan, initWindow, maxPacket);
          break;
        case "direct-tcpip":
          self2._protocol.directTcpip(localChan, initWindow, maxPacket, opts);
          break;
        case "direct-streamlocal@openssh.com":
          self2._protocol.openssh_directStreamLocal(
            localChan,
            initWindow,
            maxPacket,
            opts
          );
          break;
        default:
          throw new Error(`Unsupported channel type: ${type}`);
      }
    }
    function reqX11(chan, screen, cb) {
      const cfg = {
        single: false,
        protocol: "MIT-MAGIC-COOKIE-1",
        cookie: void 0,
        screen: 0
      };
      if (typeof screen === "function") {
        cb = screen;
      } else if (typeof screen === "object" && screen !== null) {
        if (typeof screen.single === "boolean")
          cfg.single = screen.single;
        if (typeof screen.screen === "number")
          cfg.screen = screen.screen;
        if (typeof screen.protocol === "string")
          cfg.protocol = screen.protocol;
        if (typeof screen.cookie === "string")
          cfg.cookie = screen.cookie;
        else if (Buffer.isBuffer(screen.cookie))
          cfg.cookie = screen.cookie.hexSlice(0, screen.cookie.length);
      }
      if (cfg.cookie === void 0)
        cfg.cookie = randomCookie();
      const wantReply = typeof cb === "function";
      if (chan.outgoing.state !== "open") {
        if (wantReply)
          cb(new Error("Channel is not open"));
        return;
      }
      if (wantReply) {
        chan._callbacks.push((had_err) => {
          if (had_err) {
            cb(had_err !== true ? had_err : new Error("Unable to request X11"));
            return;
          }
          chan._hasX11 = true;
          ++chan._client._acceptX11;
          chan.once("close", () => {
            if (chan._client._acceptX11)
              --chan._client._acceptX11;
          });
          cb();
        });
      }
      chan._client._protocol.x11Forward(chan.outgoing.id, cfg, wantReply);
    }
    function reqPty(chan, opts, cb) {
      let rows = 24;
      let cols = 80;
      let width2 = 640;
      let height = 480;
      let term = "vt100";
      let modes = null;
      if (typeof opts === "function") {
        cb = opts;
      } else if (typeof opts === "object" && opts !== null) {
        if (typeof opts.rows === "number")
          rows = opts.rows;
        if (typeof opts.cols === "number")
          cols = opts.cols;
        if (typeof opts.width === "number")
          width2 = opts.width;
        if (typeof opts.height === "number")
          height = opts.height;
        if (typeof opts.term === "string")
          term = opts.term;
        if (typeof opts.modes === "object")
          modes = opts.modes;
      }
      const wantReply = typeof cb === "function";
      if (chan.outgoing.state !== "open") {
        if (wantReply)
          cb(new Error("Channel is not open"));
        return;
      }
      if (wantReply) {
        chan._callbacks.push((had_err) => {
          if (had_err) {
            cb(had_err !== true ? had_err : new Error("Unable to request a pseudo-terminal"));
            return;
          }
          cb();
        });
      }
      chan._client._protocol.pty(
        chan.outgoing.id,
        rows,
        cols,
        height,
        width2,
        term,
        modes,
        wantReply
      );
    }
    function reqAgentFwd(chan, cb) {
      const wantReply = typeof cb === "function";
      if (chan.outgoing.state !== "open") {
        wantReply && cb(new Error("Channel is not open"));
        return;
      }
      if (chan._client._agentFwdEnabled) {
        wantReply && cb(false);
        return;
      }
      chan._client._agentFwdEnabled = true;
      chan._callbacks.push((had_err) => {
        if (had_err) {
          chan._client._agentFwdEnabled = false;
          if (wantReply) {
            cb(had_err !== true ? had_err : new Error("Unable to request agent forwarding"));
          }
          return;
        }
        if (wantReply)
          cb();
      });
      chan._client._protocol.openssh_agentForward(chan.outgoing.id, true);
    }
    function reqShell(chan, cb) {
      if (chan.outgoing.state !== "open") {
        cb(new Error("Channel is not open"));
        return;
      }
      chan._callbacks.push((had_err) => {
        if (had_err) {
          cb(had_err !== true ? had_err : new Error("Unable to open shell"));
          return;
        }
        chan.subtype = "shell";
        cb(void 0, chan);
      });
      chan._client._protocol.shell(chan.outgoing.id, true);
    }
    function reqExec(chan, cmd, opts, cb) {
      if (chan.outgoing.state !== "open") {
        cb(new Error("Channel is not open"));
        return;
      }
      chan._callbacks.push((had_err) => {
        if (had_err) {
          cb(had_err !== true ? had_err : new Error("Unable to exec"));
          return;
        }
        chan.subtype = "exec";
        chan.allowHalfOpen = opts.allowHalfOpen !== false;
        cb(void 0, chan);
      });
      chan._client._protocol.exec(chan.outgoing.id, cmd, true);
    }
    function reqEnv(chan, env3) {
      if (chan.outgoing.state !== "open")
        return;
      const keys4 = Object.keys(env3 || {});
      for (let i = 0; i < keys4.length; ++i) {
        const key = keys4[i];
        const val = env3[key];
        chan._client._protocol.env(chan.outgoing.id, key, val, false);
      }
    }
    function reqSubsystem(chan, name4, cb) {
      if (chan.outgoing.state !== "open") {
        cb(new Error("Channel is not open"));
        return;
      }
      chan._callbacks.push((had_err) => {
        if (had_err) {
          cb(had_err !== true ? had_err : new Error(`Unable to start subsystem: ${name4}`));
          return;
        }
        chan.subtype = "subsystem";
        cb(void 0, chan);
      });
      chan._client._protocol.subsystem(chan.outgoing.id, name4, true);
    }
    function onCHANNEL_OPEN(self2, info4) {
      let localChan = -1;
      let reason;
      const accept = () => {
        const chanInfo = {
          type: info4.type,
          incoming: {
            id: localChan,
            window: MAX_WINDOW,
            packetSize: PACKET_SIZE,
            state: "open"
          },
          outgoing: {
            id: info4.sender,
            window: info4.window,
            packetSize: info4.packetSize,
            state: "open"
          }
        };
        const stream3 = new Channel(self2, chanInfo);
        self2._chanMgr.update(localChan, stream3);
        self2._protocol.channelOpenConfirm(
          info4.sender,
          localChan,
          MAX_WINDOW,
          PACKET_SIZE
        );
        return stream3;
      };
      const reject = () => {
        if (reason === void 0) {
          if (localChan === -1)
            reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;
          else
            reason = CHANNEL_OPEN_FAILURE.CONNECT_FAILED;
        }
        if (localChan !== -1)
          self2._chanMgr.remove(localChan);
        self2._protocol.channelOpenFail(info4.sender, reason, "");
      };
      const reserveChannel = () => {
        localChan = self2._chanMgr.add();
        if (localChan === -1) {
          reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;
          if (self2.config.debug) {
            self2.config.debug(
              "Client: Automatic rejection of incoming channel open: no channels available"
            );
          }
        }
        return localChan !== -1;
      };
      const data = info4.data;
      switch (info4.type) {
        case "forwarded-tcpip": {
          const val = self2._forwarding[`${data.destIP}:${data.destPort}`];
          if (val !== void 0 && reserveChannel()) {
            if (data.destPort === 0)
              data.destPort = val;
            self2.emit("tcp connection", data, accept, reject);
            return;
          }
          break;
        }
        case "forwarded-streamlocal@openssh.com":
          if (self2._forwardingUnix[data.socketPath] !== void 0 && reserveChannel()) {
            self2.emit("unix connection", data, accept, reject);
            return;
          }
          break;
        case "auth-agent@openssh.com":
          if (self2._agentFwdEnabled && typeof self2._agent.getStream === "function" && reserveChannel()) {
            self2._agent.getStream((err, stream3) => {
              if (err)
                return reject();
              const upstream = accept();
              upstream.pipe(stream3).pipe(upstream);
            });
            return;
          }
          break;
        case "x11":
          if (self2._acceptX11 !== 0 && reserveChannel()) {
            self2.emit("x11", data, accept, reject);
            return;
          }
          break;
        default:
          reason = CHANNEL_OPEN_FAILURE.UNKNOWN_CHANNEL_TYPE;
          if (self2.config.debug) {
            self2.config.debug(
              `Client: Automatic rejection of unsupported incoming channel open type: ${info4.type}`
            );
          }
      }
      if (reason === void 0) {
        reason = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;
        if (self2.config.debug) {
          self2.config.debug(
            "Client: Automatic rejection of unexpected incoming channel open for: " + info4.type
          );
        }
      }
      reject();
    }
    var randomCookie = (() => {
      const buffer = Buffer.allocUnsafe(16);
      return () => {
        randomFillSync(buffer, 0, 16);
        return buffer.hexSlice(0, 16);
      };
    })();
    function makeSimpleAuthHandler(authList) {
      if (!Array.isArray(authList))
        throw new Error("authList must be an array");
      let a = 0;
      return (authsLeft, partialSuccess, cb) => {
        if (a === authList.length)
          return false;
        return authList[a++];
      };
    }
    function hostKeysProve(client, keys_, cb) {
      if (!client._sock || !isWritable(client._sock))
        return;
      if (typeof cb !== "function")
        cb = noop;
      if (!Array.isArray(keys_))
        throw new TypeError("Invalid keys argument type");
      const keys4 = [];
      for (const key of keys_) {
        const parsed = parseKey(key);
        if (parsed instanceof Error)
          throw parsed;
        keys4.push(parsed);
      }
      if (!client.config.strictVendor || client.config.strictVendor && RE_OPENSSH.test(client._remoteVer)) {
        client._callbacks.push((had_err, data) => {
          if (had_err) {
            cb(had_err !== true ? had_err : new Error("Server failed to prove supplied keys"));
            return;
          }
          const ret = [];
          let keyIdx = 0;
          bufferParser.init(data, 0);
          while (bufferParser.avail()) {
            if (keyIdx === keys4.length)
              break;
            const key = keys4[keyIdx++];
            const keyPublic = key.getPublicSSH();
            const sigEntry = bufferParser.readString();
            sigParser.init(sigEntry, 0);
            const type = sigParser.readString(true);
            let value4 = sigParser.readString();
            let algo;
            if (type !== key.type) {
              if (key.type === "ssh-rsa") {
                switch (type) {
                  case "rsa-sha2-256":
                    algo = "sha256";
                    break;
                  case "rsa-sha2-512":
                    algo = "sha512";
                    break;
                  default:
                    continue;
                }
              } else {
                continue;
              }
            }
            const sessionID = client._protocol._kex.sessionID;
            const verifyData = Buffer.allocUnsafe(
              4 + 29 + 4 + sessionID.length + 4 + keyPublic.length
            );
            let p = 0;
            writeUInt32BE(verifyData, 29, p);
            verifyData.utf8Write("hostkeys-prove-00@openssh.com", p += 4, 29);
            writeUInt32BE(verifyData, sessionID.length, p += 29);
            bufferCopy(sessionID, verifyData, 0, sessionID.length, p += 4);
            writeUInt32BE(verifyData, keyPublic.length, p += sessionID.length);
            bufferCopy(keyPublic, verifyData, 0, keyPublic.length, p += 4);
            if (!(value4 = sigSSHToASN1(value4, type)))
              continue;
            if (key.verify(verifyData, value4, algo) === true)
              ret.push(key);
          }
          sigParser.clear();
          bufferParser.clear();
          cb(null, ret);
        });
        client._protocol.openssh_hostKeysProve(keys4);
        return;
      }
      process.nextTick(
        cb,
        new Error(
          "strictVendor enabled and server is not OpenSSH or compatible version"
        )
      );
    }
    function getKeyAlgos(client, key, serverSigAlgs) {
      switch (key.type) {
        case "ssh-rsa":
          if (client._protocol._compatFlags & COMPAT.IMPLY_RSA_SHA2_SIGALGS) {
            if (!Array.isArray(serverSigAlgs))
              serverSigAlgs = ["rsa-sha2-256", "rsa-sha2-512"];
            else
              serverSigAlgs = ["rsa-sha2-256", "rsa-sha2-512", ...serverSigAlgs];
          }
          if (Array.isArray(serverSigAlgs)) {
            if (serverSigAlgs.indexOf("rsa-sha2-256") !== -1)
              return [["rsa-sha2-256", "sha256"]];
            if (serverSigAlgs.indexOf("rsa-sha2-512") !== -1)
              return [["rsa-sha2-512", "sha512"]];
            if (serverSigAlgs.indexOf("ssh-rsa") === -1)
              return [];
          }
          return [["ssh-rsa", "sha1"]];
      }
    }
    module.exports = Client;
  }
});

// node_modules/ssh2/lib/http-agents.js
var require_http_agents = __commonJS({
  "node_modules/ssh2/lib/http-agents.js"(exports) {
    "use strict";
    var { Agent: HttpAgent } = __require("http");
    var { Agent: HttpsAgent } = __require("https");
    var { connect: tlsConnect } = __require("tls");
    var Client;
    for (const ctor of [HttpAgent, HttpsAgent]) {
      class SSHAgent extends ctor {
        constructor(connectCfg, agentOptions) {
          super(agentOptions);
          this._connectCfg = connectCfg;
          this._defaultSrcIP = agentOptions && agentOptions.srcIP || "localhost";
        }
        createConnection(options, cb) {
          const srcIP = options && options.localAddress || this._defaultSrcIP;
          const srcPort = options && options.localPort || 0;
          const dstIP = options.host;
          const dstPort = options.port;
          if (Client === void 0)
            Client = require_client();
          const client = new Client();
          let triedForward = false;
          client.on("ready", () => {
            client.forwardOut(srcIP, srcPort, dstIP, dstPort, (err, stream3) => {
              triedForward = true;
              if (err) {
                client.end();
                return cb(err);
              }
              stream3.once("close", () => client.end());
              cb(null, decorateStream(stream3, ctor, options));
            });
          }).on("error", cb).on("close", () => {
            if (!triedForward)
              cb(new Error("Unexpected connection close"));
          }).connect(this._connectCfg);
        }
      }
      exports[ctor === HttpAgent ? "SSHTTPAgent" : "SSHTTPSAgent"] = SSHAgent;
    }
    function noop() {
    }
    function decorateStream(stream3, ctor, options) {
      if (ctor === HttpAgent) {
        stream3.setKeepAlive = noop;
        stream3.setNoDelay = noop;
        stream3.setTimeout = noop;
        stream3.ref = noop;
        stream3.unref = noop;
        stream3.destroySoon = stream3.destroy;
        return stream3;
      }
      options.socket = stream3;
      const wrapped2 = tlsConnect(options);
      const onClose3 = (() => {
        let called = false;
        return () => {
          if (called)
            return;
          called = true;
          if (stream3.isPaused())
            stream3.resume();
        };
      })();
      wrapped2.on("end", onClose3).on("close", onClose3);
      return wrapped2;
    }
  }
});

// node_modules/ssh2/lib/server.js
var require_server = __commonJS({
  "node_modules/ssh2/lib/server.js"(exports, module) {
    "use strict";
    var { Server: netServer } = __require("net");
    var EventEmitter = __require("events");
    var { listenerCount } = EventEmitter;
    var {
      CHANNEL_OPEN_FAILURE,
      DEFAULT_CIPHER,
      DEFAULT_COMPRESSION,
      DEFAULT_KEX,
      DEFAULT_MAC,
      DEFAULT_SERVER_HOST_KEY,
      DISCONNECT_REASON,
      DISCONNECT_REASON_BY_VALUE,
      SUPPORTED_CIPHER,
      SUPPORTED_COMPRESSION,
      SUPPORTED_KEX,
      SUPPORTED_MAC,
      SUPPORTED_SERVER_HOST_KEY
    } = require_constants5();
    var { init: cryptoInit } = require_crypto();
    var { KexInit } = require_kex();
    var { parseKey } = require_keyParser();
    var Protocol = require_Protocol();
    var { SFTP } = require_SFTP();
    var { writeUInt32BE } = require_utils7();
    var {
      Channel,
      MAX_WINDOW,
      PACKET_SIZE,
      windowAdjust,
      WINDOW_THRESHOLD
    } = require_Channel();
    var {
      ChannelManager,
      generateAlgorithmList,
      isWritable,
      onChannelOpenFailure,
      onCHANNEL_CLOSE
    } = require_utils8();
    var MAX_PENDING_AUTHS = 10;
    var AuthContext = class extends EventEmitter {
      constructor(protocol, username, service, method, cb) {
        super();
        this.username = this.user = username;
        this.service = service;
        this.method = method;
        this._initialResponse = false;
        this._finalResponse = false;
        this._multistep = false;
        this._cbfinal = (allowed, methodsLeft, isPartial) => {
          if (!this._finalResponse) {
            this._finalResponse = true;
            cb(this, allowed, methodsLeft, isPartial);
          }
        };
        this._protocol = protocol;
      }
      accept() {
        this._cleanup && this._cleanup();
        this._initialResponse = true;
        this._cbfinal(true);
      }
      reject(methodsLeft, isPartial) {
        this._cleanup && this._cleanup();
        this._initialResponse = true;
        this._cbfinal(false, methodsLeft, isPartial);
      }
    };
    var KeyboardAuthContext = class extends AuthContext {
      constructor(protocol, username, service, method, submethods, cb) {
        super(protocol, username, service, method, cb);
        this._multistep = true;
        this._cb = void 0;
        this._onInfoResponse = (responses) => {
          const callback = this._cb;
          if (callback) {
            this._cb = void 0;
            callback(responses);
          }
        };
        this.submethods = submethods;
        this.on("abort", () => {
          this._cb && this._cb(new Error("Authentication request aborted"));
        });
      }
      prompt(prompts, title2, instructions, cb) {
        if (!Array.isArray(prompts))
          prompts = [prompts];
        if (typeof title2 === "function") {
          cb = title2;
          title2 = instructions = void 0;
        } else if (typeof instructions === "function") {
          cb = instructions;
          instructions = void 0;
        } else if (typeof cb !== "function") {
          cb = void 0;
        }
        for (let i = 0; i < prompts.length; ++i) {
          if (typeof prompts[i] === "string") {
            prompts[i] = {
              prompt: prompts[i],
              echo: true
            };
          }
        }
        this._cb = cb;
        this._initialResponse = true;
        this._protocol.authInfoReq(title2, instructions, prompts);
      }
    };
    var PKAuthContext = class extends AuthContext {
      constructor(protocol, username, service, method, pkInfo, cb) {
        super(protocol, username, service, method, cb);
        this.key = { algo: pkInfo.keyAlgo, data: pkInfo.key };
        this.hashAlgo = pkInfo.hashAlgo;
        this.signature = pkInfo.signature;
        this.blob = pkInfo.blob;
      }
      accept() {
        if (!this.signature) {
          this._initialResponse = true;
          this._protocol.authPKOK(this.key.algo, this.key.data);
        } else {
          AuthContext.prototype.accept.call(this);
        }
      }
    };
    var HostbasedAuthContext = class extends AuthContext {
      constructor(protocol, username, service, method, pkInfo, cb) {
        super(protocol, username, service, method, cb);
        this.key = { algo: pkInfo.keyAlgo, data: pkInfo.key };
        this.hashAlgo = pkInfo.hashAlgo;
        this.signature = pkInfo.signature;
        this.blob = pkInfo.blob;
        this.localHostname = pkInfo.localHostname;
        this.localUsername = pkInfo.localUsername;
      }
    };
    var PwdAuthContext = class extends AuthContext {
      constructor(protocol, username, service, method, password, cb) {
        super(protocol, username, service, method, cb);
        this.password = password;
        this._changeCb = void 0;
      }
      requestChange(prompt, cb) {
        if (this._changeCb)
          throw new Error("Change request already in progress");
        if (typeof prompt !== "string")
          throw new Error("prompt argument must be a string");
        if (typeof cb !== "function")
          throw new Error("Callback argument must be a function");
        this._changeCb = cb;
        this._protocol.authPasswdChg(prompt);
      }
    };
    var Session = class extends EventEmitter {
      constructor(client, info4, localChan) {
        super();
        this.type = "session";
        this.subtype = void 0;
        this.server = true;
        this._ending = false;
        this._channel = void 0;
        this._chanInfo = {
          type: "session",
          incoming: {
            id: localChan,
            window: MAX_WINDOW,
            packetSize: PACKET_SIZE,
            state: "open"
          },
          outgoing: {
            id: info4.sender,
            window: info4.window,
            packetSize: info4.packetSize,
            state: "open"
          }
        };
      }
    };
    var Server = class extends EventEmitter {
      constructor(cfg, listener) {
        super();
        if (typeof cfg !== "object" || cfg === null)
          throw new Error("Missing configuration object");
        const hostKeys = /* @__PURE__ */ Object.create(null);
        const hostKeyAlgoOrder = [];
        const hostKeys_ = cfg.hostKeys;
        if (!Array.isArray(hostKeys_))
          throw new Error("hostKeys must be an array");
        const cfgAlgos = typeof cfg.algorithms === "object" && cfg.algorithms !== null ? cfg.algorithms : {};
        const hostKeyAlgos = generateAlgorithmList(
          cfgAlgos.serverHostKey,
          DEFAULT_SERVER_HOST_KEY,
          SUPPORTED_SERVER_HOST_KEY
        );
        for (let i = 0; i < hostKeys_.length; ++i) {
          let privateKey;
          if (Buffer.isBuffer(hostKeys_[i]) || typeof hostKeys_[i] === "string")
            privateKey = parseKey(hostKeys_[i]);
          else
            privateKey = parseKey(hostKeys_[i].key, hostKeys_[i].passphrase);
          if (privateKey instanceof Error)
            throw new Error(`Cannot parse privateKey: ${privateKey.message}`);
          if (Array.isArray(privateKey)) {
            privateKey = privateKey[0];
          }
          if (privateKey.getPrivatePEM() === null)
            throw new Error("privateKey value contains an invalid private key");
          if (hostKeyAlgoOrder.includes(privateKey.type))
            continue;
          if (privateKey.type === "ssh-rsa") {
            let sha1Pos = hostKeyAlgos.indexOf("ssh-rsa");
            const sha256Pos = hostKeyAlgos.indexOf("rsa-sha2-256");
            const sha512Pos = hostKeyAlgos.indexOf("rsa-sha2-512");
            if (sha1Pos === -1) {
              sha1Pos = Infinity;
            }
            [sha1Pos, sha256Pos, sha512Pos].sort(compareNumbers).forEach((pos) => {
              if (pos === -1)
                return;
              let type;
              switch (pos) {
                case sha1Pos:
                  type = "ssh-rsa";
                  break;
                case sha256Pos:
                  type = "rsa-sha2-256";
                  break;
                case sha512Pos:
                  type = "rsa-sha2-512";
                  break;
                default:
                  return;
              }
              hostKeys[type] = privateKey;
              hostKeyAlgoOrder.push(type);
            });
          } else {
            hostKeys[privateKey.type] = privateKey;
            hostKeyAlgoOrder.push(privateKey.type);
          }
        }
        const algorithms = {
          kex: generateAlgorithmList(cfgAlgos.kex, DEFAULT_KEX, SUPPORTED_KEX),
          serverHostKey: hostKeyAlgoOrder,
          cs: {
            cipher: generateAlgorithmList(
              cfgAlgos.cipher,
              DEFAULT_CIPHER,
              SUPPORTED_CIPHER
            ),
            mac: generateAlgorithmList(cfgAlgos.hmac, DEFAULT_MAC, SUPPORTED_MAC),
            compress: generateAlgorithmList(
              cfgAlgos.compress,
              DEFAULT_COMPRESSION,
              SUPPORTED_COMPRESSION
            ),
            lang: []
          },
          sc: void 0
        };
        algorithms.sc = algorithms.cs;
        if (typeof listener === "function")
          this.on("connection", listener);
        const origDebug = typeof cfg.debug === "function" ? cfg.debug : void 0;
        const ident = cfg.ident ? Buffer.from(cfg.ident) : void 0;
        const offer = new KexInit(algorithms);
        this._srv = new netServer((socket) => {
          if (this._connections >= this.maxConnections) {
            socket.destroy();
            return;
          }
          ++this._connections;
          socket.once("close", () => {
            --this._connections;
          });
          let debug2;
          if (origDebug) {
            const debugPrefix = `[${process.hrtime().join(".")}] `;
            debug2 = (msg) => {
              origDebug(`${debugPrefix}${msg}`);
            };
          }
          new Client(socket, hostKeys, ident, offer, debug2, this, cfg);
        }).on("error", (err) => {
          this.emit("error", err);
        }).on("listening", () => {
          this.emit("listening");
        }).on("close", () => {
          this.emit("close");
        });
        this._connections = 0;
        this.maxConnections = Infinity;
      }
      injectSocket(socket) {
        this._srv.emit("connection", socket);
      }
      listen(...args) {
        this._srv.listen(...args);
        return this;
      }
      address() {
        return this._srv.address();
      }
      getConnections(cb) {
        this._srv.getConnections(cb);
        return this;
      }
      close(cb) {
        this._srv.close(cb);
        return this;
      }
      ref() {
        this._srv.ref();
        return this;
      }
      unref() {
        this._srv.unref();
        return this;
      }
    };
    Server.KEEPALIVE_CLIENT_INTERVAL = 15e3;
    Server.KEEPALIVE_CLIENT_COUNT_MAX = 3;
    var Client = class extends EventEmitter {
      constructor(socket, hostKeys, ident, offer, debug2, server, srvCfg) {
        super();
        let exchanges = 0;
        let acceptedAuthSvc = false;
        let pendingAuths = [];
        let authCtx;
        let kaTimer;
        let onPacket;
        const unsentGlobalRequestsReplies = [];
        this._sock = socket;
        this._chanMgr = new ChannelManager(this);
        this._debug = debug2;
        this.noMoreSessions = false;
        this.authenticated = false;
        function onClientPreHeaderError(err) {
        }
        this.on("error", onClientPreHeaderError);
        const DEBUG_HANDLER = !debug2 ? void 0 : (p, display, msg) => {
          debug2(`Debug output from client: ${JSON.stringify(msg)}`);
        };
        const kaIntvl = typeof srvCfg.keepaliveInterval === "number" && isFinite(srvCfg.keepaliveInterval) && srvCfg.keepaliveInterval > 0 ? srvCfg.keepaliveInterval : typeof Server.KEEPALIVE_CLIENT_INTERVAL === "number" && isFinite(Server.KEEPALIVE_CLIENT_INTERVAL) && Server.KEEPALIVE_CLIENT_INTERVAL > 0 ? Server.KEEPALIVE_CLIENT_INTERVAL : -1;
        const kaCountMax = typeof srvCfg.keepaliveCountMax === "number" && isFinite(srvCfg.keepaliveCountMax) && srvCfg.keepaliveCountMax >= 0 ? srvCfg.keepaliveCountMax : typeof Server.KEEPALIVE_CLIENT_COUNT_MAX === "number" && isFinite(Server.KEEPALIVE_CLIENT_COUNT_MAX) && Server.KEEPALIVE_CLIENT_COUNT_MAX >= 0 ? Server.KEEPALIVE_CLIENT_COUNT_MAX : -1;
        let kaCurCount = 0;
        if (kaIntvl !== -1 && kaCountMax !== -1) {
          this.once("ready", () => {
            const onClose3 = () => {
              clearInterval(kaTimer);
            };
            this.on("close", onClose3).on("end", onClose3);
            kaTimer = setInterval(() => {
              if (++kaCurCount > kaCountMax) {
                clearInterval(kaTimer);
                const err = new Error("Keepalive timeout");
                err.level = "client-timeout";
                this.emit("error", err);
                this.end();
              } else {
                proto.ping();
              }
            }, kaIntvl);
          });
          onPacket = () => {
            kaTimer && kaTimer.refresh();
            kaCurCount = 0;
          };
        }
        const proto = this._protocol = new Protocol({
          server: true,
          hostKeys,
          ident,
          offer,
          onPacket,
          greeting: srvCfg.greeting,
          banner: srvCfg.banner,
          onWrite: (data) => {
            if (isWritable(socket))
              socket.write(data);
          },
          onError: (err) => {
            if (!proto._destruct)
              socket.removeAllListeners("data");
            this.emit("error", err);
            try {
              socket.end();
            } catch {
            }
          },
          onHeader: (header) => {
            this.removeListener("error", onClientPreHeaderError);
            const info4 = {
              ip: socket.remoteAddress,
              family: socket.remoteFamily,
              port: socket.remotePort,
              header
            };
            if (!server.emit("connection", this, info4)) {
              proto.disconnect(DISCONNECT_REASON.BY_APPLICATION);
              socket.end();
              return;
            }
            if (header.greeting)
              this.emit("greeting", header.greeting);
          },
          onHandshakeComplete: (negotiated) => {
            if (++exchanges > 1)
              this.emit("rekey");
            this.emit("handshake", negotiated);
          },
          debug: debug2,
          messageHandlers: {
            DEBUG: DEBUG_HANDLER,
            DISCONNECT: (p, reason, desc) => {
              if (reason !== DISCONNECT_REASON.BY_APPLICATION) {
                if (!desc) {
                  desc = DISCONNECT_REASON_BY_VALUE[reason];
                  if (desc === void 0)
                    desc = `Unexpected disconnection reason: ${reason}`;
                }
                const err = new Error(desc);
                err.code = reason;
                this.emit("error", err);
              }
              socket.end();
            },
            CHANNEL_OPEN: (p, info4) => {
              if (info4.type === "session" && this.noMoreSessions || !this.authenticated) {
                const reasonCode = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;
                return proto.channelOpenFail(info4.sender, reasonCode);
              }
              let localChan = -1;
              let reason;
              let replied = false;
              let accept;
              const reject = () => {
                if (replied)
                  return;
                replied = true;
                if (reason === void 0) {
                  if (localChan === -1)
                    reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;
                  else
                    reason = CHANNEL_OPEN_FAILURE.CONNECT_FAILED;
                }
                if (localChan !== -1)
                  this._chanMgr.remove(localChan);
                proto.channelOpenFail(info4.sender, reason, "");
              };
              const reserveChannel = () => {
                localChan = this._chanMgr.add();
                if (localChan === -1) {
                  reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;
                  if (debug2) {
                    debug2("Automatic rejection of incoming channel open: no channels available");
                  }
                }
                return localChan !== -1;
              };
              const data = info4.data;
              switch (info4.type) {
                case "session":
                  if (listenerCount(this, "session") && reserveChannel()) {
                    accept = () => {
                      if (replied)
                        return;
                      replied = true;
                      const instance = new Session(this, info4, localChan);
                      this._chanMgr.update(localChan, instance);
                      proto.channelOpenConfirm(
                        info4.sender,
                        localChan,
                        MAX_WINDOW,
                        PACKET_SIZE
                      );
                      return instance;
                    };
                    this.emit("session", accept, reject);
                    return;
                  }
                  break;
                case "direct-tcpip":
                  if (listenerCount(this, "tcpip") && reserveChannel()) {
                    accept = () => {
                      if (replied)
                        return;
                      replied = true;
                      const chanInfo = {
                        type: void 0,
                        incoming: {
                          id: localChan,
                          window: MAX_WINDOW,
                          packetSize: PACKET_SIZE,
                          state: "open"
                        },
                        outgoing: {
                          id: info4.sender,
                          window: info4.window,
                          packetSize: info4.packetSize,
                          state: "open"
                        }
                      };
                      const stream3 = new Channel(this, chanInfo, { server: true });
                      this._chanMgr.update(localChan, stream3);
                      proto.channelOpenConfirm(
                        info4.sender,
                        localChan,
                        MAX_WINDOW,
                        PACKET_SIZE
                      );
                      return stream3;
                    };
                    this.emit("tcpip", accept, reject, data);
                    return;
                  }
                  break;
                case "direct-streamlocal@openssh.com":
                  if (listenerCount(this, "openssh.streamlocal") && reserveChannel()) {
                    accept = () => {
                      if (replied)
                        return;
                      replied = true;
                      const chanInfo = {
                        type: void 0,
                        incoming: {
                          id: localChan,
                          window: MAX_WINDOW,
                          packetSize: PACKET_SIZE,
                          state: "open"
                        },
                        outgoing: {
                          id: info4.sender,
                          window: info4.window,
                          packetSize: info4.packetSize,
                          state: "open"
                        }
                      };
                      const stream3 = new Channel(this, chanInfo, { server: true });
                      this._chanMgr.update(localChan, stream3);
                      proto.channelOpenConfirm(
                        info4.sender,
                        localChan,
                        MAX_WINDOW,
                        PACKET_SIZE
                      );
                      return stream3;
                    };
                    this.emit("openssh.streamlocal", accept, reject, data);
                    return;
                  }
                  break;
                default:
                  reason = CHANNEL_OPEN_FAILURE.UNKNOWN_CHANNEL_TYPE;
                  if (debug2) {
                    debug2(`Automatic rejection of unsupported incoming channel open type: ${info4.type}`);
                  }
              }
              if (reason === void 0) {
                reason = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;
                if (debug2) {
                  debug2(`Automatic rejection of unexpected incoming channel open for: ${info4.type}`);
                }
              }
              reject();
            },
            CHANNEL_OPEN_CONFIRMATION: (p, info4) => {
              const channel2 = this._chanMgr.get(info4.recipient);
              if (typeof channel2 !== "function")
                return;
              const chanInfo = {
                type: channel2.type,
                incoming: {
                  id: info4.recipient,
                  window: MAX_WINDOW,
                  packetSize: PACKET_SIZE,
                  state: "open"
                },
                outgoing: {
                  id: info4.sender,
                  window: info4.window,
                  packetSize: info4.packetSize,
                  state: "open"
                }
              };
              const instance = new Channel(this, chanInfo, { server: true });
              this._chanMgr.update(info4.recipient, instance);
              channel2(void 0, instance);
            },
            CHANNEL_OPEN_FAILURE: (p, recipient, reason, description) => {
              const channel2 = this._chanMgr.get(recipient);
              if (typeof channel2 !== "function")
                return;
              const info4 = { reason, description };
              onChannelOpenFailure(this, recipient, info4, channel2);
            },
            CHANNEL_DATA: (p, recipient, data) => {
              let channel2 = this._chanMgr.get(recipient);
              if (typeof channel2 !== "object" || channel2 === null)
                return;
              if (channel2.constructor === Session) {
                channel2 = channel2._channel;
                if (!channel2)
                  return;
              }
              if (channel2.incoming.window === 0)
                return;
              channel2.incoming.window -= data.length;
              if (channel2.push(data) === false) {
                channel2._waitChanDrain = true;
                return;
              }
              if (channel2.incoming.window <= WINDOW_THRESHOLD)
                windowAdjust(channel2);
            },
            CHANNEL_EXTENDED_DATA: (p, recipient, data, type) => {
            },
            CHANNEL_WINDOW_ADJUST: (p, recipient, amount) => {
              let channel2 = this._chanMgr.get(recipient);
              if (typeof channel2 !== "object" || channel2 === null)
                return;
              if (channel2.constructor === Session) {
                channel2 = channel2._channel;
                if (!channel2)
                  return;
              }
              channel2.outgoing.window += amount;
              if (channel2._waitWindow) {
                channel2._waitWindow = false;
                if (channel2._chunk) {
                  channel2._write(channel2._chunk, null, channel2._chunkcb);
                } else if (channel2._chunkcb) {
                  channel2._chunkcb();
                } else if (channel2._chunkErr) {
                  channel2.stderr._write(
                    channel2._chunkErr,
                    null,
                    channel2._chunkcbErr
                  );
                } else if (channel2._chunkcbErr) {
                  channel2._chunkcbErr();
                }
              }
            },
            CHANNEL_SUCCESS: (p, recipient) => {
              let channel2 = this._chanMgr.get(recipient);
              if (typeof channel2 !== "object" || channel2 === null)
                return;
              if (channel2.constructor === Session) {
                channel2 = channel2._channel;
                if (!channel2)
                  return;
              }
              if (channel2._callbacks.length)
                channel2._callbacks.shift()(false);
            },
            CHANNEL_FAILURE: (p, recipient) => {
              let channel2 = this._chanMgr.get(recipient);
              if (typeof channel2 !== "object" || channel2 === null)
                return;
              if (channel2.constructor === Session) {
                channel2 = channel2._channel;
                if (!channel2)
                  return;
              }
              if (channel2._callbacks.length)
                channel2._callbacks.shift()(true);
            },
            CHANNEL_REQUEST: (p, recipient, type, wantReply, data) => {
              const session = this._chanMgr.get(recipient);
              if (typeof session !== "object" || session === null)
                return;
              let replied = false;
              let accept;
              let reject;
              if (session.constructor !== Session) {
                if (wantReply)
                  proto.channelFailure(session.outgoing.id);
                return;
              }
              if (wantReply) {
                if (type !== "shell" && type !== "exec" && type !== "subsystem") {
                  accept = () => {
                    if (replied || session._ending || session._channel)
                      return;
                    replied = true;
                    proto.channelSuccess(session._chanInfo.outgoing.id);
                  };
                }
                reject = () => {
                  if (replied || session._ending || session._channel)
                    return;
                  replied = true;
                  proto.channelFailure(session._chanInfo.outgoing.id);
                };
              }
              if (session._ending) {
                reject && reject();
                return;
              }
              switch (type) {
                case "env":
                  if (listenerCount(session, "env")) {
                    session.emit("env", accept, reject, {
                      key: data.name,
                      val: data.value
                    });
                    return;
                  }
                  break;
                case "pty-req":
                  if (listenerCount(session, "pty")) {
                    session.emit("pty", accept, reject, data);
                    return;
                  }
                  break;
                case "window-change":
                  if (listenerCount(session, "window-change"))
                    session.emit("window-change", accept, reject, data);
                  else
                    reject && reject();
                  break;
                case "x11-req":
                  if (listenerCount(session, "x11")) {
                    session.emit("x11", accept, reject, data);
                    return;
                  }
                  break;
                case "signal":
                  if (listenerCount(session, "signal")) {
                    session.emit("signal", accept, reject, {
                      name: data
                    });
                    return;
                  }
                  break;
                case "auth-agent-req@openssh.com":
                  if (listenerCount(session, "auth-agent")) {
                    session.emit("auth-agent", accept, reject);
                    return;
                  }
                  break;
                case "shell":
                  if (listenerCount(session, "shell")) {
                    accept = () => {
                      if (replied || session._ending || session._channel)
                        return;
                      replied = true;
                      if (wantReply)
                        proto.channelSuccess(session._chanInfo.outgoing.id);
                      const channel2 = new Channel(
                        this,
                        session._chanInfo,
                        { server: true }
                      );
                      channel2.subtype = session.subtype = type;
                      session._channel = channel2;
                      return channel2;
                    };
                    session.emit("shell", accept, reject);
                    return;
                  }
                  break;
                case "exec":
                  if (listenerCount(session, "exec")) {
                    accept = () => {
                      if (replied || session._ending || session._channel)
                        return;
                      replied = true;
                      if (wantReply)
                        proto.channelSuccess(session._chanInfo.outgoing.id);
                      const channel2 = new Channel(
                        this,
                        session._chanInfo,
                        { server: true }
                      );
                      channel2.subtype = session.subtype = type;
                      session._channel = channel2;
                      return channel2;
                    };
                    session.emit("exec", accept, reject, {
                      command: data
                    });
                    return;
                  }
                  break;
                case "subsystem": {
                  let useSFTP = data === "sftp";
                  accept = () => {
                    if (replied || session._ending || session._channel)
                      return;
                    replied = true;
                    if (wantReply)
                      proto.channelSuccess(session._chanInfo.outgoing.id);
                    let instance;
                    if (useSFTP) {
                      instance = new SFTP(this, session._chanInfo, {
                        server: true,
                        debug: debug2
                      });
                    } else {
                      instance = new Channel(
                        this,
                        session._chanInfo,
                        { server: true }
                      );
                      instance.subtype = session.subtype = `${type}:${data}`;
                    }
                    session._channel = instance;
                    return instance;
                  };
                  if (data === "sftp") {
                    if (listenerCount(session, "sftp")) {
                      session.emit("sftp", accept, reject);
                      return;
                    }
                    useSFTP = false;
                  }
                  if (listenerCount(session, "subsystem")) {
                    session.emit("subsystem", accept, reject, {
                      name: data
                    });
                    return;
                  }
                  break;
                }
              }
              debug2 && debug2(
                `Automatic rejection of incoming channel request: ${type}`
              );
              reject && reject();
            },
            CHANNEL_EOF: (p, recipient) => {
              let channel2 = this._chanMgr.get(recipient);
              if (typeof channel2 !== "object" || channel2 === null)
                return;
              if (channel2.constructor === Session) {
                if (!channel2._ending) {
                  channel2._ending = true;
                  channel2.emit("eof");
                  channel2.emit("end");
                }
                channel2 = channel2._channel;
                if (!channel2)
                  return;
              }
              if (channel2.incoming.state !== "open")
                return;
              channel2.incoming.state = "eof";
              if (channel2.readable)
                channel2.push(null);
            },
            CHANNEL_CLOSE: (p, recipient) => {
              let channel2 = this._chanMgr.get(recipient);
              if (typeof channel2 !== "object" || channel2 === null)
                return;
              if (channel2.constructor === Session) {
                channel2._ending = true;
                channel2.emit("close");
                channel2 = channel2._channel;
                if (!channel2)
                  return;
              }
              onCHANNEL_CLOSE(this, recipient, channel2);
            },
            // Begin service/auth-related ==========================================
            SERVICE_REQUEST: (p, service) => {
              if (exchanges === 0 || acceptedAuthSvc || this.authenticated || service !== "ssh-userauth") {
                proto.disconnect(DISCONNECT_REASON.SERVICE_NOT_AVAILABLE);
                socket.end();
                return;
              }
              acceptedAuthSvc = true;
              proto.serviceAccept(service);
            },
            USERAUTH_REQUEST: (p, username, service, method, methodData) => {
              if (exchanges === 0 || this.authenticated || authCtx && (authCtx.username !== username || authCtx.service !== service) || method !== "password" && method !== "publickey" && method !== "hostbased" && method !== "keyboard-interactive" && method !== "none" || pendingAuths.length === MAX_PENDING_AUTHS) {
                proto.disconnect(DISCONNECT_REASON.PROTOCOL_ERROR);
                socket.end();
                return;
              } else if (service !== "ssh-connection") {
                proto.disconnect(DISCONNECT_REASON.SERVICE_NOT_AVAILABLE);
                socket.end();
                return;
              }
              let ctx;
              switch (method) {
                case "keyboard-interactive":
                  ctx = new KeyboardAuthContext(
                    proto,
                    username,
                    service,
                    method,
                    methodData,
                    onAuthDecide
                  );
                  break;
                case "publickey":
                  ctx = new PKAuthContext(
                    proto,
                    username,
                    service,
                    method,
                    methodData,
                    onAuthDecide
                  );
                  break;
                case "hostbased":
                  ctx = new HostbasedAuthContext(
                    proto,
                    username,
                    service,
                    method,
                    methodData,
                    onAuthDecide
                  );
                  break;
                case "password":
                  if (authCtx && authCtx instanceof PwdAuthContext && authCtx._changeCb) {
                    const cb = authCtx._changeCb;
                    authCtx._changeCb = void 0;
                    cb(methodData.newPassword);
                    return;
                  }
                  ctx = new PwdAuthContext(
                    proto,
                    username,
                    service,
                    method,
                    methodData,
                    onAuthDecide
                  );
                  break;
                case "none":
                  ctx = new AuthContext(
                    proto,
                    username,
                    service,
                    method,
                    onAuthDecide
                  );
                  break;
              }
              if (authCtx) {
                if (!authCtx._initialResponse) {
                  return pendingAuths.push(ctx);
                } else if (authCtx._multistep && !authCtx._finalResponse) {
                  authCtx._cleanup && authCtx._cleanup();
                  authCtx.emit("abort");
                }
              }
              authCtx = ctx;
              if (listenerCount(this, "authentication"))
                this.emit("authentication", authCtx);
              else
                authCtx.reject();
            },
            USERAUTH_INFO_RESPONSE: (p, responses) => {
              if (authCtx && authCtx instanceof KeyboardAuthContext)
                authCtx._onInfoResponse(responses);
            },
            // End service/auth-related ============================================
            GLOBAL_REQUEST: (p, name4, wantReply, data) => {
              const reply = {
                type: null,
                buf: null
              };
              function setReply(type, buf) {
                reply.type = type;
                reply.buf = buf;
                sendReplies();
              }
              if (wantReply)
                unsentGlobalRequestsReplies.push(reply);
              if ((name4 === "tcpip-forward" || name4 === "cancel-tcpip-forward" || name4 === "no-more-sessions@openssh.com" || name4 === "streamlocal-forward@openssh.com" || name4 === "cancel-streamlocal-forward@openssh.com") && listenerCount(this, "request") && this.authenticated) {
                let accept;
                let reject;
                if (wantReply) {
                  let replied = false;
                  accept = (chosenPort) => {
                    if (replied)
                      return;
                    replied = true;
                    let bufPort;
                    if (name4 === "tcpip-forward" && data.bindPort === 0 && typeof chosenPort === "number") {
                      bufPort = Buffer.allocUnsafe(4);
                      writeUInt32BE(bufPort, chosenPort, 0);
                    }
                    setReply("SUCCESS", bufPort);
                  };
                  reject = () => {
                    if (replied)
                      return;
                    replied = true;
                    setReply("FAILURE");
                  };
                }
                if (name4 === "no-more-sessions@openssh.com") {
                  this.noMoreSessions = true;
                  accept && accept();
                  return;
                }
                this.emit("request", accept, reject, name4, data);
              } else if (wantReply) {
                setReply("FAILURE");
              }
            }
          }
        });
        socket.pause();
        cryptoInit.then(() => {
          proto.start();
          socket.on("data", (data) => {
            try {
              proto.parse(data, 0, data.length);
            } catch (ex) {
              this.emit("error", ex);
              try {
                if (isWritable(socket))
                  socket.end();
              } catch {
              }
            }
          });
          socket.resume();
        }).catch((err) => {
          this.emit("error", err);
          try {
            if (isWritable(socket))
              socket.end();
          } catch {
          }
        });
        socket.on("error", (err) => {
          err.level = "socket";
          this.emit("error", err);
        }).once("end", () => {
          debug2 && debug2("Socket ended");
          proto.cleanup();
          this.emit("end");
        }).once("close", () => {
          debug2 && debug2("Socket closed");
          proto.cleanup();
          this.emit("close");
          const err = new Error("No response from server");
          this._chanMgr.cleanup(err);
        });
        const onAuthDecide = (ctx, allowed, methodsLeft, isPartial) => {
          if (authCtx === ctx && !this.authenticated) {
            if (allowed) {
              authCtx = void 0;
              this.authenticated = true;
              proto.authSuccess();
              pendingAuths = [];
              this.emit("ready");
            } else {
              proto.authFailure(methodsLeft, isPartial);
              if (pendingAuths.length) {
                authCtx = pendingAuths.pop();
                if (listenerCount(this, "authentication"))
                  this.emit("authentication", authCtx);
                else
                  authCtx.reject();
              }
            }
          }
        };
        function sendReplies() {
          while (unsentGlobalRequestsReplies.length > 0 && unsentGlobalRequestsReplies[0].type) {
            const reply = unsentGlobalRequestsReplies.shift();
            if (reply.type === "SUCCESS")
              proto.requestSuccess(reply.buf);
            if (reply.type === "FAILURE")
              proto.requestFailure();
          }
        }
      }
      end() {
        if (this._sock && isWritable(this._sock)) {
          this._protocol.disconnect(DISCONNECT_REASON.BY_APPLICATION);
          this._sock.end();
        }
        return this;
      }
      x11(originAddr, originPort, cb) {
        const opts = { originAddr, originPort };
        openChannel(this, "x11", opts, cb);
        return this;
      }
      forwardOut(boundAddr, boundPort, remoteAddr, remotePort, cb) {
        const opts = { boundAddr, boundPort, remoteAddr, remotePort };
        openChannel(this, "forwarded-tcpip", opts, cb);
        return this;
      }
      openssh_forwardOutStreamLocal(socketPath, cb) {
        const opts = { socketPath };
        openChannel(this, "forwarded-streamlocal@openssh.com", opts, cb);
        return this;
      }
      rekey(cb) {
        let error4;
        try {
          this._protocol.rekey();
        } catch (ex) {
          error4 = ex;
        }
        if (typeof cb === "function") {
          if (error4)
            process.nextTick(cb, error4);
          else
            this.once("rekey", cb);
        }
      }
      setNoDelay(noDelay) {
        if (this._sock && typeof this._sock.setNoDelay === "function")
          this._sock.setNoDelay(noDelay);
        return this;
      }
    };
    function openChannel(self2, type, opts, cb) {
      const initWindow = MAX_WINDOW;
      const maxPacket = PACKET_SIZE;
      if (typeof opts === "function") {
        cb = opts;
        opts = {};
      }
      const wrapper = (err, stream3) => {
        cb(err, stream3);
      };
      wrapper.type = type;
      const localChan = self2._chanMgr.add(wrapper);
      if (localChan === -1) {
        cb(new Error("No free channels available"));
        return;
      }
      switch (type) {
        case "forwarded-tcpip":
          self2._protocol.forwardedTcpip(localChan, initWindow, maxPacket, opts);
          break;
        case "x11":
          self2._protocol.x11(localChan, initWindow, maxPacket, opts);
          break;
        case "forwarded-streamlocal@openssh.com":
          self2._protocol.openssh_forwardedStreamLocal(
            localChan,
            initWindow,
            maxPacket,
            opts
          );
          break;
        default:
          throw new Error(`Unsupported channel type: ${type}`);
      }
    }
    function compareNumbers(a, b) {
      return a - b;
    }
    module.exports = Server;
    module.exports.IncomingClient = Client;
  }
});

// node_modules/ssh2/lib/keygen.js
var require_keygen = __commonJS({
  "node_modules/ssh2/lib/keygen.js"(exports, module) {
    "use strict";
    var {
      createCipheriv,
      generateKeyPair: generateKeyPair_,
      generateKeyPairSync: generateKeyPairSync_,
      getCurves,
      randomBytes
    } = __require("crypto");
    var { Ber } = require_lib2();
    var bcrypt_pbkdf = require_bcrypt_pbkdf().pbkdf;
    var { CIPHER_INFO } = require_crypto();
    var SALT_LEN = 16;
    var DEFAULT_ROUNDS = 16;
    var curves = getCurves();
    var ciphers = new Map(Object.entries(CIPHER_INFO));
    function makeArgs(type, opts) {
      if (typeof type !== "string")
        throw new TypeError("Key type must be a string");
      const publicKeyEncoding = { type: "spki", format: "der" };
      const privateKeyEncoding = { type: "pkcs8", format: "der" };
      switch (type.toLowerCase()) {
        case "rsa": {
          if (typeof opts !== "object" || opts === null)
            throw new TypeError("Missing options object for RSA key");
          const modulusLength = opts.bits;
          if (!Number.isInteger(modulusLength))
            throw new TypeError("RSA bits must be an integer");
          if (modulusLength <= 0 || modulusLength > 16384)
            throw new RangeError("RSA bits must be non-zero and <= 16384");
          return ["rsa", { modulusLength, publicKeyEncoding, privateKeyEncoding }];
        }
        case "ecdsa": {
          if (typeof opts !== "object" || opts === null)
            throw new TypeError("Missing options object for ECDSA key");
          if (!Number.isInteger(opts.bits))
            throw new TypeError("ECDSA bits must be an integer");
          let namedCurve;
          switch (opts.bits) {
            case 256:
              namedCurve = "prime256v1";
              break;
            case 384:
              namedCurve = "secp384r1";
              break;
            case 521:
              namedCurve = "secp521r1";
              break;
            default:
              throw new Error("ECDSA bits must be 256, 384, or 521");
          }
          if (!curves.includes(namedCurve))
            throw new Error("Unsupported ECDSA bits value");
          return ["ec", { namedCurve, publicKeyEncoding, privateKeyEncoding }];
        }
        case "ed25519":
          return ["ed25519", { publicKeyEncoding, privateKeyEncoding }];
        default:
          throw new Error(`Unsupported key type: ${type}`);
      }
    }
    function parseDERs(keyType, pub, priv) {
      switch (keyType) {
        case "rsa": {
          let reader = new Ber.Reader(priv);
          reader.readSequence();
          if (reader.readInt() !== 0)
            throw new Error("Unsupported version in RSA private key");
          reader.readSequence();
          if (reader.readOID() !== "1.2.840.113549.1.1.1")
            throw new Error("Bad RSA private OID");
          if (reader.readByte() !== Ber.Null)
            throw new Error("Malformed RSA private key (expected null)");
          if (reader.readByte() !== 0) {
            throw new Error(
              "Malformed RSA private key (expected zero-length null)"
            );
          }
          reader = new Ber.Reader(reader.readString(Ber.OctetString, true));
          reader.readSequence();
          if (reader.readInt() !== 0)
            throw new Error("Unsupported version in RSA private key");
          const n = reader.readString(Ber.Integer, true);
          const e = reader.readString(Ber.Integer, true);
          const d = reader.readString(Ber.Integer, true);
          const p = reader.readString(Ber.Integer, true);
          const q = reader.readString(Ber.Integer, true);
          reader.readString(Ber.Integer, true);
          reader.readString(Ber.Integer, true);
          const iqmp = reader.readString(Ber.Integer, true);
          const keyName = Buffer.from("ssh-rsa");
          const privBuf = Buffer.allocUnsafe(
            4 + keyName.length + 4 + n.length + 4 + e.length + 4 + d.length + 4 + iqmp.length + 4 + p.length + 4 + q.length
          );
          let pos = 0;
          privBuf.writeUInt32BE(keyName.length, pos += 0);
          privBuf.set(keyName, pos += 4);
          privBuf.writeUInt32BE(n.length, pos += keyName.length);
          privBuf.set(n, pos += 4);
          privBuf.writeUInt32BE(e.length, pos += n.length);
          privBuf.set(e, pos += 4);
          privBuf.writeUInt32BE(d.length, pos += e.length);
          privBuf.set(d, pos += 4);
          privBuf.writeUInt32BE(iqmp.length, pos += d.length);
          privBuf.set(iqmp, pos += 4);
          privBuf.writeUInt32BE(p.length, pos += iqmp.length);
          privBuf.set(p, pos += 4);
          privBuf.writeUInt32BE(q.length, pos += p.length);
          privBuf.set(q, pos += 4);
          const pubBuf = Buffer.allocUnsafe(
            4 + keyName.length + 4 + e.length + 4 + n.length
          );
          pos = 0;
          pubBuf.writeUInt32BE(keyName.length, pos += 0);
          pubBuf.set(keyName, pos += 4);
          pubBuf.writeUInt32BE(e.length, pos += keyName.length);
          pubBuf.set(e, pos += 4);
          pubBuf.writeUInt32BE(n.length, pos += e.length);
          pubBuf.set(n, pos += 4);
          return { sshName: keyName.toString(), priv: privBuf, pub: pubBuf };
        }
        case "ec": {
          let reader = new Ber.Reader(pub);
          reader.readSequence();
          reader.readSequence();
          if (reader.readOID() !== "1.2.840.10045.2.1")
            throw new Error("Bad ECDSA public OID");
          reader.readOID();
          let pubBin = reader.readString(Ber.BitString, true);
          {
            let i = 0;
            for (; i < pubBin.length && pubBin[i] === 0; ++i)
              ;
            if (i > 0)
              pubBin = pubBin.slice(i);
          }
          reader = new Ber.Reader(priv);
          reader.readSequence();
          if (reader.readInt() !== 0)
            throw new Error("Unsupported version in ECDSA private key");
          reader.readSequence();
          if (reader.readOID() !== "1.2.840.10045.2.1")
            throw new Error("Bad ECDSA private OID");
          const curveOID = reader.readOID();
          let sshCurveName;
          switch (curveOID) {
            case "1.2.840.10045.3.1.7":
              sshCurveName = "nistp256";
              break;
            case "1.3.132.0.34":
              sshCurveName = "nistp384";
              break;
            case "1.3.132.0.35":
              sshCurveName = "nistp521";
              break;
            default:
              throw new Error("Unsupported curve in ECDSA private key");
          }
          reader = new Ber.Reader(reader.readString(Ber.OctetString, true));
          reader.readSequence();
          if (reader.readInt() !== 1)
            throw new Error("Unsupported version in ECDSA private key");
          const privBin = Buffer.concat([
            Buffer.from([0]),
            reader.readString(Ber.OctetString, true)
          ]);
          const keyName = Buffer.from(`ecdsa-sha2-${sshCurveName}`);
          sshCurveName = Buffer.from(sshCurveName);
          const privBuf = Buffer.allocUnsafe(
            4 + keyName.length + 4 + sshCurveName.length + 4 + pubBin.length + 4 + privBin.length
          );
          let pos = 0;
          privBuf.writeUInt32BE(keyName.length, pos += 0);
          privBuf.set(keyName, pos += 4);
          privBuf.writeUInt32BE(sshCurveName.length, pos += keyName.length);
          privBuf.set(sshCurveName, pos += 4);
          privBuf.writeUInt32BE(pubBin.length, pos += sshCurveName.length);
          privBuf.set(pubBin, pos += 4);
          privBuf.writeUInt32BE(privBin.length, pos += pubBin.length);
          privBuf.set(privBin, pos += 4);
          const pubBuf = Buffer.allocUnsafe(
            4 + keyName.length + 4 + sshCurveName.length + 4 + pubBin.length
          );
          pos = 0;
          pubBuf.writeUInt32BE(keyName.length, pos += 0);
          pubBuf.set(keyName, pos += 4);
          pubBuf.writeUInt32BE(sshCurveName.length, pos += keyName.length);
          pubBuf.set(sshCurveName, pos += 4);
          pubBuf.writeUInt32BE(pubBin.length, pos += sshCurveName.length);
          pubBuf.set(pubBin, pos += 4);
          return { sshName: keyName.toString(), priv: privBuf, pub: pubBuf };
        }
        case "ed25519": {
          let reader = new Ber.Reader(pub);
          reader.readSequence();
          reader.readSequence();
          if (reader.readOID() !== "1.3.101.112")
            throw new Error("Bad ED25519 public OID");
          let pubBin = reader.readString(Ber.BitString, true);
          {
            let i = 0;
            for (; i < pubBin.length && pubBin[i] === 0; ++i)
              ;
            if (i > 0)
              pubBin = pubBin.slice(i);
          }
          reader = new Ber.Reader(priv);
          reader.readSequence();
          if (reader.readInt() !== 0)
            throw new Error("Unsupported version in ED25519 private key");
          reader.readSequence();
          if (reader.readOID() !== "1.3.101.112")
            throw new Error("Bad ED25519 private OID");
          reader = new Ber.Reader(reader.readString(Ber.OctetString, true));
          const privBin = reader.readString(Ber.OctetString, true);
          const keyName = Buffer.from("ssh-ed25519");
          const privBuf = Buffer.allocUnsafe(
            4 + keyName.length + 4 + pubBin.length + 4 + (privBin.length + pubBin.length)
          );
          let pos = 0;
          privBuf.writeUInt32BE(keyName.length, pos += 0);
          privBuf.set(keyName, pos += 4);
          privBuf.writeUInt32BE(pubBin.length, pos += keyName.length);
          privBuf.set(pubBin, pos += 4);
          privBuf.writeUInt32BE(
            privBin.length + pubBin.length,
            pos += pubBin.length
          );
          privBuf.set(privBin, pos += 4);
          privBuf.set(pubBin, pos += privBin.length);
          const pubBuf = Buffer.allocUnsafe(
            4 + keyName.length + 4 + pubBin.length
          );
          pos = 0;
          pubBuf.writeUInt32BE(keyName.length, pos += 0);
          pubBuf.set(keyName, pos += 4);
          pubBuf.writeUInt32BE(pubBin.length, pos += keyName.length);
          pubBuf.set(pubBin, pos += 4);
          return { sshName: keyName.toString(), priv: privBuf, pub: pubBuf };
        }
      }
    }
    function convertKeys(keyType, pub, priv, opts) {
      let format2 = "new";
      let encrypted;
      let comment2 = "";
      if (typeof opts === "object" && opts !== null) {
        if (typeof opts.comment === "string" && opts.comment)
          comment2 = opts.comment;
        if (typeof opts.format === "string" && opts.format)
          format2 = opts.format;
        if (opts.passphrase) {
          let passphrase;
          if (typeof opts.passphrase === "string")
            passphrase = Buffer.from(opts.passphrase);
          else if (Buffer.isBuffer(opts.passphrase))
            passphrase = opts.passphrase;
          else
            throw new Error("Invalid passphrase");
          if (opts.cipher === void 0)
            throw new Error("Missing cipher name");
          const cipher = ciphers.get(opts.cipher);
          if (cipher === void 0)
            throw new Error("Invalid cipher name");
          if (format2 === "new") {
            let rounds = DEFAULT_ROUNDS;
            if (opts.rounds !== void 0) {
              if (!Number.isInteger(opts.rounds))
                throw new TypeError("rounds must be an integer");
              if (opts.rounds > 0)
                rounds = opts.rounds;
            }
            const gen = Buffer.allocUnsafe(cipher.keyLen + cipher.ivLen);
            const salt = randomBytes(SALT_LEN);
            const r = bcrypt_pbkdf(
              passphrase,
              passphrase.length,
              salt,
              salt.length,
              gen,
              gen.length,
              rounds
            );
            if (r !== 0)
              return new Error("Failed to generate information to encrypt key");
            const kdfOptions = Buffer.allocUnsafe(4 + salt.length + 4);
            {
              let pos = 0;
              kdfOptions.writeUInt32BE(salt.length, pos += 0);
              kdfOptions.set(salt, pos += 4);
              kdfOptions.writeUInt32BE(rounds, pos += salt.length);
            }
            encrypted = {
              cipher,
              cipherName: opts.cipher,
              kdfName: "bcrypt",
              kdfOptions,
              key: gen.slice(0, cipher.keyLen),
              iv: gen.slice(cipher.keyLen)
            };
          }
        }
      }
      switch (format2) {
        case "new": {
          let privateB64 = "-----BEGIN OPENSSH PRIVATE KEY-----\n";
          let publicB64;
          const cipherName = Buffer.from(encrypted ? encrypted.cipherName : "none");
          const kdfName = Buffer.from(encrypted ? encrypted.kdfName : "none");
          const kdfOptions = encrypted ? encrypted.kdfOptions : Buffer.alloc(0);
          const blockLen = encrypted ? encrypted.cipher.blockLen : 8;
          const parsed = parseDERs(keyType, pub, priv);
          const checkInt = randomBytes(4);
          const commentBin = Buffer.from(comment2);
          const privBlobLen = 4 + 4 + parsed.priv.length + 4 + commentBin.length;
          let padding = [];
          for (let i = 1; (privBlobLen + padding.length) % blockLen; ++i)
            padding.push(i & 255);
          padding = Buffer.from(padding);
          let privBlob = Buffer.allocUnsafe(privBlobLen + padding.length);
          let extra;
          {
            let pos = 0;
            privBlob.set(checkInt, pos += 0);
            privBlob.set(checkInt, pos += 4);
            privBlob.set(parsed.priv, pos += 4);
            privBlob.writeUInt32BE(commentBin.length, pos += parsed.priv.length);
            privBlob.set(commentBin, pos += 4);
            privBlob.set(padding, pos += commentBin.length);
          }
          if (encrypted) {
            const options = { authTagLength: encrypted.cipher.authLen };
            const cipher = createCipheriv(
              encrypted.cipher.sslName,
              encrypted.key,
              encrypted.iv,
              options
            );
            cipher.setAutoPadding(false);
            privBlob = Buffer.concat([cipher.update(privBlob), cipher.final()]);
            if (encrypted.cipher.authLen > 0)
              extra = cipher.getAuthTag();
            else
              extra = Buffer.alloc(0);
            encrypted.key.fill(0);
            encrypted.iv.fill(0);
          } else {
            extra = Buffer.alloc(0);
          }
          const magicBytes = Buffer.from("openssh-key-v1\0");
          const privBin = Buffer.allocUnsafe(
            magicBytes.length + 4 + cipherName.length + 4 + kdfName.length + 4 + kdfOptions.length + 4 + 4 + parsed.pub.length + 4 + privBlob.length + extra.length
          );
          {
            let pos = 0;
            privBin.set(magicBytes, pos += 0);
            privBin.writeUInt32BE(cipherName.length, pos += magicBytes.length);
            privBin.set(cipherName, pos += 4);
            privBin.writeUInt32BE(kdfName.length, pos += cipherName.length);
            privBin.set(kdfName, pos += 4);
            privBin.writeUInt32BE(kdfOptions.length, pos += kdfName.length);
            privBin.set(kdfOptions, pos += 4);
            privBin.writeUInt32BE(1, pos += kdfOptions.length);
            privBin.writeUInt32BE(parsed.pub.length, pos += 4);
            privBin.set(parsed.pub, pos += 4);
            privBin.writeUInt32BE(privBlob.length, pos += parsed.pub.length);
            privBin.set(privBlob, pos += 4);
            privBin.set(extra, pos += privBlob.length);
          }
          {
            const b64 = privBin.base64Slice(0, privBin.length);
            let formatted = b64.replace(/.{64}/g, "$&\n");
            if (b64.length & 63)
              formatted += "\n";
            privateB64 += formatted;
          }
          {
            const b64 = parsed.pub.base64Slice(0, parsed.pub.length);
            publicB64 = `${parsed.sshName} ${b64}${comment2 ? ` ${comment2}` : ""}`;
          }
          privateB64 += "-----END OPENSSH PRIVATE KEY-----\n";
          return {
            private: privateB64,
            public: publicB64
          };
        }
        default:
          throw new Error("Invalid output key format");
      }
    }
    function noop() {
    }
    module.exports = {
      generateKeyPair: (keyType, opts, cb) => {
        if (typeof opts === "function") {
          cb = opts;
          opts = void 0;
        }
        if (typeof cb !== "function")
          cb = noop;
        const args = makeArgs(keyType, opts);
        generateKeyPair_(...args, (err, pub, priv) => {
          if (err)
            return cb(err);
          let ret;
          try {
            ret = convertKeys(args[0], pub, priv, opts);
          } catch (ex) {
            return cb(ex);
          }
          cb(null, ret);
        });
      },
      generateKeyPairSync: (keyType, opts) => {
        const args = makeArgs(keyType, opts);
        const { publicKey: pub, privateKey: priv } = generateKeyPairSync_(...args);
        return convertKeys(args[0], pub, priv, opts);
      }
    };
  }
});

// node_modules/ssh2/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/ssh2/lib/index.js"(exports, module) {
    "use strict";
    var {
      AgentProtocol,
      BaseAgent,
      createAgent,
      CygwinAgent,
      OpenSSHAgent,
      PageantAgent
    } = require_agent();
    var {
      SSHTTPAgent: HTTPAgent,
      SSHTTPSAgent: HTTPSAgent
    } = require_http_agents();
    var { parseKey } = require_keyParser();
    var {
      flagsToString,
      OPEN_MODE,
      STATUS_CODE,
      stringToFlags
    } = require_SFTP();
    module.exports = {
      AgentProtocol,
      BaseAgent,
      createAgent,
      Client: require_client(),
      CygwinAgent,
      HTTPAgent,
      HTTPSAgent,
      OpenSSHAgent,
      PageantAgent,
      Server: require_server(),
      utils: {
        parseKey,
        ...require_keygen(),
        sftp: {
          flagsToString,
          OPEN_MODE,
          STATUS_CODE,
          stringToFlags
        }
      }
    };
  }
});

// node_modules/supports-color/index.js
import process2 from "node:process";
import os from "node:os";
import tty from "node:tty";
function hasFlag(flag2, argv2 = globalThis.Deno ? globalThis.Deno.args : process2.argv) {
  const prefix4 = flag2.startsWith("-") ? "" : flag2.length === 1 ? "-" : "--";
  const position2 = argv2.indexOf(prefix4 + flag2);
  const terminatorPosition = argv2.indexOf("--");
  return position2 !== -1 && (terminatorPosition === -1 || position2 < terminatorPosition);
}
var { env } = process2;
var flagForceColor;
if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
  flagForceColor = 0;
} else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
  flagForceColor = 1;
}
function envForceColor() {
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      return 1;
    }
    if (env.FORCE_COLOR === "false") {
      return 0;
    }
    return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
  }
}
function translateLevel(level) {
  if (level === 0) {
    return false;
  }
  return {
    level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3
  };
}
function _supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
  const noFlagForceColor = envForceColor();
  if (noFlagForceColor !== void 0) {
    flagForceColor = noFlagForceColor;
  }
  const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
  if (forceColor === 0) {
    return 0;
  }
  if (sniffFlags) {
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
  }
  if ("TF_BUILD" in env && "AGENT_NAME" in env) {
    return 1;
  }
  if (haveStream && !streamIsTTY && forceColor === void 0) {
    return 0;
  }
  const min8 = forceColor || 0;
  if (env.TERM === "dumb") {
    return min8;
  }
  if (process2.platform === "win32") {
    const osRelease = os.release().split(".");
    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
      return Number(osRelease[2]) >= 14931 ? 3 : 2;
    }
    return 1;
  }
  if ("CI" in env) {
    if ("GITHUB_ACTIONS" in env || "GITEA_ACTIONS" in env) {
      return 3;
    }
    if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((sign2) => sign2 in env) || env.CI_NAME === "codeship") {
      return 1;
    }
    return min8;
  }
  if ("TEAMCITY_VERSION" in env) {
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
  }
  if (env.COLORTERM === "truecolor") {
    return 3;
  }
  if (env.TERM === "xterm-kitty") {
    return 3;
  }
  if ("TERM_PROGRAM" in env) {
    const version = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (env.TERM_PROGRAM) {
      case "iTerm.app": {
        return version >= 3 ? 3 : 2;
      }
      case "Apple_Terminal": {
        return 2;
      }
    }
  }
  if (/-256(color)?$/i.test(env.TERM)) {
    return 2;
  }
  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
    return 1;
  }
  if ("COLORTERM" in env) {
    return 1;
  }
  return min8;
}
function createSupportsColor(stream3, options = {}) {
  const level = _supportsColor(stream3, {
    streamIsTTY: stream3 && stream3.isTTY,
    ...options
  });
  return translateLevel(level);
}
var supportsColor = {
  stdout: createSupportsColor({ isTTY: tty.isatty(1) }),
  stderr: createSupportsColor({ isTTY: tty.isatty(2) })
};
var supports_color_default = supportsColor;

// output/Main/foreign.js
var supportsColor2 = () => {
  if ("NO_COLOR" in process.env) {
    return false;
  }
  ;
  if (supports_color_default.stderr) {
    return true;
  } else {
    return false;
  }
  ;
};

// output/Data.Functor/foreign.js
var arrayMap = function(f) {
  return function(arr) {
    var l = arr.length;
    var result = new Array(l);
    for (var i = 0; i < l; i++) {
      result[i] = f(arr[i]);
    }
    return result;
  };
};

// output/Control.Semigroupoid/index.js
var semigroupoidFn = {
  compose: function(f) {
    return function(g) {
      return function(x) {
        return f(g(x));
      };
    };
  }
};
var compose = function(dict) {
  return dict.compose;
};
var composeFlipped = function(dictSemigroupoid) {
  var compose1 = compose(dictSemigroupoid);
  return function(f) {
    return function(g) {
      return compose1(g)(f);
    };
  };
};

// output/Control.Category/index.js
var identity = function(dict) {
  return dict.identity;
};
var categoryFn = {
  identity: function(x) {
    return x;
  },
  Semigroupoid0: function() {
    return semigroupoidFn;
  }
};

// output/Data.Boolean/index.js
var otherwise = true;

// output/Data.Function/index.js
var on = function(f) {
  return function(g) {
    return function(x) {
      return function(y) {
        return f(g(x))(g(y));
      };
    };
  };
};
var flip = function(f) {
  return function(b) {
    return function(a) {
      return f(a)(b);
    };
  };
};
var $$const = function(a) {
  return function(v) {
    return a;
  };
};
var applyN = function(f) {
  var go = function($copy_n) {
    return function($copy_acc) {
      var $tco_var_n = $copy_n;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(n, acc) {
        if (n <= 0) {
          $tco_done = true;
          return acc;
        }
        ;
        if (otherwise) {
          $tco_var_n = n - 1 | 0;
          $copy_acc = f(acc);
          return;
        }
        ;
        throw new Error("Failed pattern match at Data.Function (line 107, column 3 - line 109, column 37): " + [n.constructor.name, acc.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_n, $copy_acc);
      }
      ;
      return $tco_result;
    };
  };
  return go;
};
var applyFlipped = function(x) {
  return function(f) {
    return f(x);
  };
};
var apply = function(f) {
  return function(x) {
    return f(x);
  };
};

// output/Data.Unit/foreign.js
var unit = void 0;

// output/Type.Proxy/index.js
var $$Proxy = /* @__PURE__ */ function() {
  function $$Proxy2() {
  }
  ;
  $$Proxy2.value = new $$Proxy2();
  return $$Proxy2;
}();

// output/Data.Functor/index.js
var map = function(dict) {
  return dict.map;
};
var mapFlipped = function(dictFunctor) {
  var map136 = map(dictFunctor);
  return function(fa) {
    return function(f) {
      return map136(f)(fa);
    };
  };
};
var $$void = function(dictFunctor) {
  return map(dictFunctor)($$const(unit));
};
var voidLeft = function(dictFunctor) {
  var map136 = map(dictFunctor);
  return function(f) {
    return function(x) {
      return map136($$const(x))(f);
    };
  };
};
var voidRight = function(dictFunctor) {
  var map136 = map(dictFunctor);
  return function(x) {
    return map136($$const(x));
  };
};
var functorFn = {
  map: /* @__PURE__ */ compose(semigroupoidFn)
};
var functorArray = {
  map: arrayMap
};

// output/Data.Semigroup/foreign.js
var concatString = function(s1) {
  return function(s2) {
    return s1 + s2;
  };
};
var concatArray = function(xs) {
  return function(ys) {
    if (xs.length === 0)
      return ys;
    if (ys.length === 0)
      return xs;
    return xs.concat(ys);
  };
};

// output/Data.Symbol/index.js
var reflectSymbol = function(dict) {
  return dict.reflectSymbol;
};

// output/Record.Unsafe/foreign.js
var unsafeGet = function(label) {
  return function(rec) {
    return rec[label];
  };
};
var unsafeSet = function(label) {
  return function(value4) {
    return function(rec) {
      var copy3 = {};
      for (var key in rec) {
        if ({}.hasOwnProperty.call(rec, key)) {
          copy3[key] = rec[key];
        }
      }
      copy3[label] = value4;
      return copy3;
    };
  };
};
var unsafeDelete = function(label) {
  return function(rec) {
    var copy3 = {};
    for (var key in rec) {
      if (key !== label && {}.hasOwnProperty.call(rec, key)) {
        copy3[key] = rec[key];
      }
    }
    return copy3;
  };
};

// output/Data.Semigroup/index.js
var semigroupUnit = {
  append: function(v) {
    return function(v1) {
      return unit;
    };
  }
};
var semigroupString = {
  append: concatString
};
var semigroupRecordNil = {
  appendRecord: function(v) {
    return function(v1) {
      return function(v2) {
        return {};
      };
    };
  }
};
var semigroupArray = {
  append: concatArray
};
var appendRecord = function(dict) {
  return dict.appendRecord;
};
var semigroupRecord = function() {
  return function(dictSemigroupRecord) {
    return {
      append: appendRecord(dictSemigroupRecord)($$Proxy.value)
    };
  };
};
var append = function(dict) {
  return dict.append;
};
var semigroupFn = function(dictSemigroup) {
  var append119 = append(dictSemigroup);
  return {
    append: function(f) {
      return function(g) {
        return function(x) {
          return append119(f(x))(g(x));
        };
      };
    }
  };
};
var semigroupRecordCons = function(dictIsSymbol) {
  var reflectSymbol3 = reflectSymbol(dictIsSymbol);
  return function() {
    return function(dictSemigroupRecord) {
      var appendRecord1 = appendRecord(dictSemigroupRecord);
      return function(dictSemigroup) {
        var append119 = append(dictSemigroup);
        return {
          appendRecord: function(v) {
            return function(ra) {
              return function(rb) {
                var tail3 = appendRecord1($$Proxy.value)(ra)(rb);
                var key = reflectSymbol3($$Proxy.value);
                var insert20 = unsafeSet(key);
                var get7 = unsafeGet(key);
                return insert20(append119(get7(ra))(get7(rb)))(tail3);
              };
            };
          }
        };
      };
    };
  };
};

// output/Control.Alt/index.js
var altArray = {
  alt: /* @__PURE__ */ append(semigroupArray),
  Functor0: function() {
    return functorArray;
  }
};
var alt = function(dict) {
  return dict.alt;
};

// output/Control.Apply/foreign.js
var arrayApply = function(fs2) {
  return function(xs) {
    var l = fs2.length;
    var k = xs.length;
    var result = new Array(l * k);
    var n = 0;
    for (var i = 0; i < l; i++) {
      var f = fs2[i];
      for (var j = 0; j < k; j++) {
        result[n++] = f(xs[j]);
      }
    }
    return result;
  };
};

// output/Control.Apply/index.js
var identity2 = /* @__PURE__ */ identity(categoryFn);
var applyFn = {
  apply: function(f) {
    return function(g) {
      return function(x) {
        return f(x)(g(x));
      };
    };
  },
  Functor0: function() {
    return functorFn;
  }
};
var applyArray = {
  apply: arrayApply,
  Functor0: function() {
    return functorArray;
  }
};
var apply2 = function(dict) {
  return dict.apply;
};
var applyFirst = function(dictApply) {
  var apply111 = apply2(dictApply);
  var map86 = map(dictApply.Functor0());
  return function(a) {
    return function(b) {
      return apply111(map86($$const)(a))(b);
    };
  };
};
var applySecond = function(dictApply) {
  var apply111 = apply2(dictApply);
  var map86 = map(dictApply.Functor0());
  return function(a) {
    return function(b) {
      return apply111(map86($$const(identity2))(a))(b);
    };
  };
};
var lift2 = function(dictApply) {
  var apply111 = apply2(dictApply);
  var map86 = map(dictApply.Functor0());
  return function(f) {
    return function(a) {
      return function(b) {
        return apply111(map86(f)(a))(b);
      };
    };
  };
};

// output/Control.Applicative/index.js
var pure = function(dict) {
  return dict.pure;
};
var unless = function(dictApplicative) {
  var pure122 = pure(dictApplicative);
  return function(v) {
    return function(v1) {
      if (!v) {
        return v1;
      }
      ;
      if (v) {
        return pure122(unit);
      }
      ;
      throw new Error("Failed pattern match at Control.Applicative (line 68, column 1 - line 68, column 65): " + [v.constructor.name, v1.constructor.name]);
    };
  };
};
var when = function(dictApplicative) {
  var pure122 = pure(dictApplicative);
  return function(v) {
    return function(v1) {
      if (v) {
        return v1;
      }
      ;
      if (!v) {
        return pure122(unit);
      }
      ;
      throw new Error("Failed pattern match at Control.Applicative (line 63, column 1 - line 63, column 63): " + [v.constructor.name, v1.constructor.name]);
    };
  };
};
var liftA1 = function(dictApplicative) {
  var apply25 = apply2(dictApplicative.Apply0());
  var pure122 = pure(dictApplicative);
  return function(f) {
    return function(a) {
      return apply25(pure122(f))(a);
    };
  };
};
var applicativeFn = {
  pure: function(x) {
    return function(v) {
      return x;
    };
  },
  Apply0: function() {
    return applyFn;
  }
};
var applicativeArray = {
  pure: function(x) {
    return [x];
  },
  Apply0: function() {
    return applyArray;
  }
};

// output/Control.Bind/foreign.js
var arrayBind = function(arr) {
  return function(f) {
    var result = [];
    for (var i = 0, l = arr.length; i < l; i++) {
      Array.prototype.push.apply(result, f(arr[i]));
    }
    return result;
  };
};

// output/Control.Bind/index.js
var identity3 = /* @__PURE__ */ identity(categoryFn);
var discard = function(dict) {
  return dict.discard;
};
var bindFn = {
  bind: function(m) {
    return function(f) {
      return function(x) {
        return f(m(x))(x);
      };
    };
  },
  Apply0: function() {
    return applyFn;
  }
};
var bindArray = {
  bind: arrayBind,
  Apply0: function() {
    return applyArray;
  }
};
var bind = function(dict) {
  return dict.bind;
};
var bindFlipped = function(dictBind) {
  return flip(bind(dictBind));
};
var composeKleisliFlipped = function(dictBind) {
  var bindFlipped1 = bindFlipped(dictBind);
  return function(f) {
    return function(g) {
      return function(a) {
        return bindFlipped1(f)(g(a));
      };
    };
  };
};
var discardUnit = {
  discard: function(dictBind) {
    return bind(dictBind);
  }
};
var ifM = function(dictBind) {
  var bind122 = bind(dictBind);
  return function(cond) {
    return function(t) {
      return function(f) {
        return bind122(cond)(function(cond$prime) {
          if (cond$prime) {
            return t;
          }
          ;
          return f;
        });
      };
    };
  };
};
var join = function(dictBind) {
  var bind122 = bind(dictBind);
  return function(m) {
    return bind122(m)(identity3);
  };
};

// output/Control.Monad/index.js
var whenM = function(dictMonad) {
  var bind59 = bind(dictMonad.Bind1());
  var when15 = when(dictMonad.Applicative0());
  return function(mb) {
    return function(m) {
      return bind59(mb)(function(b) {
        return when15(b)(m);
      });
    };
  };
};
var unlessM = function(dictMonad) {
  var bind59 = bind(dictMonad.Bind1());
  var unless10 = unless(dictMonad.Applicative0());
  return function(mb) {
    return function(m) {
      return bind59(mb)(function(b) {
        return unless10(b)(m);
      });
    };
  };
};
var liftM1 = function(dictMonad) {
  var bind59 = bind(dictMonad.Bind1());
  var pure75 = pure(dictMonad.Applicative0());
  return function(f) {
    return function(a) {
      return bind59(a)(function(a$prime) {
        return pure75(f(a$prime));
      });
    };
  };
};
var ap = function(dictMonad) {
  var bind59 = bind(dictMonad.Bind1());
  var pure75 = pure(dictMonad.Applicative0());
  return function(f) {
    return function(a) {
      return bind59(f)(function(f$prime) {
        return bind59(a)(function(a$prime) {
          return pure75(f$prime(a$prime));
        });
      });
    };
  };
};

// output/Data.Bounded/foreign.js
var topInt = 2147483647;
var bottomInt = -2147483648;
var topChar = String.fromCharCode(65535);
var bottomChar = String.fromCharCode(0);
var topNumber = Number.POSITIVE_INFINITY;
var bottomNumber = Number.NEGATIVE_INFINITY;

// output/Data.Ord/foreign.js
var unsafeCompareImpl = function(lt) {
  return function(eq31) {
    return function(gt) {
      return function(x) {
        return function(y) {
          return x < y ? lt : x === y ? eq31 : gt;
        };
      };
    };
  };
};
var ordIntImpl = unsafeCompareImpl;
var ordNumberImpl = unsafeCompareImpl;
var ordStringImpl = unsafeCompareImpl;
var ordCharImpl = unsafeCompareImpl;

// output/Data.Eq/foreign.js
var refEq = function(r1) {
  return function(r2) {
    return r1 === r2;
  };
};
var eqBooleanImpl = refEq;
var eqIntImpl = refEq;
var eqNumberImpl = refEq;
var eqCharImpl = refEq;
var eqStringImpl = refEq;
var eqArrayImpl = function(f) {
  return function(xs) {
    return function(ys) {
      if (xs.length !== ys.length)
        return false;
      for (var i = 0; i < xs.length; i++) {
        if (!f(xs[i])(ys[i]))
          return false;
      }
      return true;
    };
  };
};

// output/Data.Eq/index.js
var eqUnit = {
  eq: function(v) {
    return function(v1) {
      return true;
    };
  }
};
var eqString = {
  eq: eqStringImpl
};
var eqRowNil = {
  eqRecord: function(v) {
    return function(v1) {
      return function(v2) {
        return true;
      };
    };
  }
};
var eqRecord = function(dict) {
  return dict.eqRecord;
};
var eqRec = function() {
  return function(dictEqRecord) {
    return {
      eq: eqRecord(dictEqRecord)($$Proxy.value)
    };
  };
};
var eqNumber = {
  eq: eqNumberImpl
};
var eqInt = {
  eq: eqIntImpl
};
var eqChar = {
  eq: eqCharImpl
};
var eqBoolean = {
  eq: eqBooleanImpl
};
var eq = function(dict) {
  return dict.eq;
};
var eq2 = /* @__PURE__ */ eq(eqBoolean);
var eqArray = function(dictEq) {
  return {
    eq: eqArrayImpl(eq(dictEq))
  };
};
var eqRowCons = function(dictEqRecord) {
  var eqRecord1 = eqRecord(dictEqRecord);
  return function() {
    return function(dictIsSymbol) {
      var reflectSymbol3 = reflectSymbol(dictIsSymbol);
      return function(dictEq) {
        var eq34 = eq(dictEq);
        return {
          eqRecord: function(v) {
            return function(ra) {
              return function(rb) {
                var tail3 = eqRecord1($$Proxy.value)(ra)(rb);
                var key = reflectSymbol3($$Proxy.value);
                var get7 = unsafeGet(key);
                return eq34(get7(ra))(get7(rb)) && tail3;
              };
            };
          }
        };
      };
    };
  };
};
var notEq = function(dictEq) {
  var eq34 = eq(dictEq);
  return function(x) {
    return function(y) {
      return eq2(eq34(x)(y))(false);
    };
  };
};

// output/Data.Ordering/index.js
var LT = /* @__PURE__ */ function() {
  function LT2() {
  }
  ;
  LT2.value = new LT2();
  return LT2;
}();
var GT = /* @__PURE__ */ function() {
  function GT2() {
  }
  ;
  GT2.value = new GT2();
  return GT2;
}();
var EQ = /* @__PURE__ */ function() {
  function EQ2() {
  }
  ;
  EQ2.value = new EQ2();
  return EQ2;
}();
var eqOrdering = {
  eq: function(v) {
    return function(v1) {
      if (v instanceof LT && v1 instanceof LT) {
        return true;
      }
      ;
      if (v instanceof GT && v1 instanceof GT) {
        return true;
      }
      ;
      if (v instanceof EQ && v1 instanceof EQ) {
        return true;
      }
      ;
      return false;
    };
  }
};

// output/Data.Ring/foreign.js
var intSub = function(x) {
  return function(y) {
    return x - y | 0;
  };
};

// output/Data.Semiring/foreign.js
var intAdd = function(x) {
  return function(y) {
    return x + y | 0;
  };
};
var intMul = function(x) {
  return function(y) {
    return x * y | 0;
  };
};

// output/Data.Semiring/index.js
var zero = function(dict) {
  return dict.zero;
};
var semiringInt = {
  add: intAdd,
  zero: 0,
  mul: intMul,
  one: 1
};
var one = function(dict) {
  return dict.one;
};
var mul = function(dict) {
  return dict.mul;
};
var add = function(dict) {
  return dict.add;
};

// output/Data.Ring/index.js
var sub = function(dict) {
  return dict.sub;
};
var ringInt = {
  sub: intSub,
  Semiring0: function() {
    return semiringInt;
  }
};
var negate = function(dictRing) {
  var sub1 = sub(dictRing);
  var zero2 = zero(dictRing.Semiring0());
  return function(a) {
    return sub1(zero2)(a);
  };
};

// output/Data.Ord/index.js
var eqRec2 = /* @__PURE__ */ eqRec();
var notEq2 = /* @__PURE__ */ notEq(eqOrdering);
var ordString = /* @__PURE__ */ function() {
  return {
    compare: ordStringImpl(LT.value)(EQ.value)(GT.value),
    Eq0: function() {
      return eqString;
    }
  };
}();
var ordRecordNil = {
  compareRecord: function(v) {
    return function(v1) {
      return function(v2) {
        return EQ.value;
      };
    };
  },
  EqRecord0: function() {
    return eqRowNil;
  }
};
var ordNumber = /* @__PURE__ */ function() {
  return {
    compare: ordNumberImpl(LT.value)(EQ.value)(GT.value),
    Eq0: function() {
      return eqNumber;
    }
  };
}();
var ordInt = /* @__PURE__ */ function() {
  return {
    compare: ordIntImpl(LT.value)(EQ.value)(GT.value),
    Eq0: function() {
      return eqInt;
    }
  };
}();
var ordChar = /* @__PURE__ */ function() {
  return {
    compare: ordCharImpl(LT.value)(EQ.value)(GT.value),
    Eq0: function() {
      return eqChar;
    }
  };
}();
var compareRecord = function(dict) {
  return dict.compareRecord;
};
var ordRecord = function() {
  return function(dictOrdRecord) {
    var eqRec1 = eqRec2(dictOrdRecord.EqRecord0());
    return {
      compare: compareRecord(dictOrdRecord)($$Proxy.value),
      Eq0: function() {
        return eqRec1;
      }
    };
  };
};
var compare = function(dict) {
  return dict.compare;
};
var comparing = function(dictOrd) {
  var compare33 = compare(dictOrd);
  return function(f) {
    return function(x) {
      return function(y) {
        return compare33(f(x))(f(y));
      };
    };
  };
};
var greaterThan = function(dictOrd) {
  var compare33 = compare(dictOrd);
  return function(a1) {
    return function(a2) {
      var v = compare33(a1)(a2);
      if (v instanceof GT) {
        return true;
      }
      ;
      return false;
    };
  };
};
var greaterThanOrEq = function(dictOrd) {
  var compare33 = compare(dictOrd);
  return function(a1) {
    return function(a2) {
      var v = compare33(a1)(a2);
      if (v instanceof LT) {
        return false;
      }
      ;
      return true;
    };
  };
};
var lessThan = function(dictOrd) {
  var compare33 = compare(dictOrd);
  return function(a1) {
    return function(a2) {
      var v = compare33(a1)(a2);
      if (v instanceof LT) {
        return true;
      }
      ;
      return false;
    };
  };
};
var max = function(dictOrd) {
  var compare33 = compare(dictOrd);
  return function(x) {
    return function(y) {
      var v = compare33(x)(y);
      if (v instanceof LT) {
        return y;
      }
      ;
      if (v instanceof EQ) {
        return x;
      }
      ;
      if (v instanceof GT) {
        return x;
      }
      ;
      throw new Error("Failed pattern match at Data.Ord (line 181, column 3 - line 184, column 12): " + [v.constructor.name]);
    };
  };
};
var min = function(dictOrd) {
  var compare33 = compare(dictOrd);
  return function(x) {
    return function(y) {
      var v = compare33(x)(y);
      if (v instanceof LT) {
        return x;
      }
      ;
      if (v instanceof EQ) {
        return x;
      }
      ;
      if (v instanceof GT) {
        return y;
      }
      ;
      throw new Error("Failed pattern match at Data.Ord (line 172, column 3 - line 175, column 12): " + [v.constructor.name]);
    };
  };
};
var ordRecordCons = function(dictOrdRecord) {
  var compareRecord1 = compareRecord(dictOrdRecord);
  var eqRowCons3 = eqRowCons(dictOrdRecord.EqRecord0())();
  return function() {
    return function(dictIsSymbol) {
      var reflectSymbol3 = reflectSymbol(dictIsSymbol);
      var eqRowCons1 = eqRowCons3(dictIsSymbol);
      return function(dictOrd) {
        var compare33 = compare(dictOrd);
        var eqRowCons22 = eqRowCons1(dictOrd.Eq0());
        return {
          compareRecord: function(v) {
            return function(ra) {
              return function(rb) {
                var key = reflectSymbol3($$Proxy.value);
                var left2 = compare33(unsafeGet(key)(ra))(unsafeGet(key)(rb));
                var $95 = notEq2(left2)(EQ.value);
                if ($95) {
                  return left2;
                }
                ;
                return compareRecord1($$Proxy.value)(ra)(rb);
              };
            };
          },
          EqRecord0: function() {
            return eqRowCons22;
          }
        };
      };
    };
  };
};
var abs = function(dictOrd) {
  var greaterThanOrEq12 = greaterThanOrEq(dictOrd);
  return function(dictRing) {
    var zero2 = zero(dictRing.Semiring0());
    var negate1 = negate(dictRing);
    return function(x) {
      var $99 = greaterThanOrEq12(x)(zero2);
      if ($99) {
        return x;
      }
      ;
      return negate1(x);
    };
  };
};

// output/Data.Bounded/index.js
var top = function(dict) {
  return dict.top;
};
var boundedInt = {
  top: topInt,
  bottom: bottomInt,
  Ord0: function() {
    return ordInt;
  }
};
var boundedChar = {
  top: topChar,
  bottom: bottomChar,
  Ord0: function() {
    return ordChar;
  }
};
var bottom = function(dict) {
  return dict.bottom;
};

// output/Data.Show/foreign.js
var showIntImpl = function(n) {
  return n.toString();
};
var showNumberImpl = function(n) {
  var str2 = n.toString();
  return isNaN(str2 + ".0") ? str2 : str2 + ".0";
};
var showCharImpl = function(c) {
  var code = c.charCodeAt(0);
  if (code < 32 || code === 127) {
    switch (c) {
      case "\x07":
        return "'\\a'";
      case "\b":
        return "'\\b'";
      case "\f":
        return "'\\f'";
      case "\n":
        return "'\\n'";
      case "\r":
        return "'\\r'";
      case "	":
        return "'\\t'";
      case "\v":
        return "'\\v'";
    }
    return "'\\" + code.toString(10) + "'";
  }
  return c === "'" || c === "\\" ? "'\\" + c + "'" : "'" + c + "'";
};
var showStringImpl = function(s) {
  var l = s.length;
  return '"' + s.replace(
    /[\0-\x1F\x7F"\\]/g,
    // eslint-disable-line no-control-regex
    function(c, i) {
      switch (c) {
        case '"':
        case "\\":
          return "\\" + c;
        case "\x07":
          return "\\a";
        case "\b":
          return "\\b";
        case "\f":
          return "\\f";
        case "\n":
          return "\\n";
        case "\r":
          return "\\r";
        case "	":
          return "\\t";
        case "\v":
          return "\\v";
      }
      var k = i + 1;
      var empty9 = k < l && s[k] >= "0" && s[k] <= "9" ? "\\&" : "";
      return "\\" + c.charCodeAt(0).toString(10) + empty9;
    }
  ) + '"';
};
var showArrayImpl = function(f) {
  return function(xs) {
    var ss = [];
    for (var i = 0, l = xs.length; i < l; i++) {
      ss[i] = f(xs[i]);
    }
    return "[" + ss.join(",") + "]";
  };
};

// output/Data.Show/index.js
var showString = {
  show: showStringImpl
};
var showRecordFields = function(dict) {
  return dict.showRecordFields;
};
var showRecord = function() {
  return function() {
    return function(dictShowRecordFields) {
      var showRecordFields1 = showRecordFields(dictShowRecordFields);
      return {
        show: function(record4) {
          return "{" + (showRecordFields1($$Proxy.value)(record4) + "}");
        }
      };
    };
  };
};
var showNumber = {
  show: showNumberImpl
};
var showInt = {
  show: showIntImpl
};
var showChar = {
  show: showCharImpl
};
var showBoolean = {
  show: function(v) {
    if (v) {
      return "true";
    }
    ;
    if (!v) {
      return "false";
    }
    ;
    throw new Error("Failed pattern match at Data.Show (line 29, column 1 - line 31, column 23): " + [v.constructor.name]);
  }
};
var show = function(dict) {
  return dict.show;
};
var showArray = function(dictShow) {
  return {
    show: showArrayImpl(show(dictShow))
  };
};
var showRecordFieldsCons = function(dictIsSymbol) {
  var reflectSymbol3 = reflectSymbol(dictIsSymbol);
  return function(dictShowRecordFields) {
    var showRecordFields1 = showRecordFields(dictShowRecordFields);
    return function(dictShow) {
      var show119 = show(dictShow);
      return {
        showRecordFields: function(v) {
          return function(record4) {
            var tail3 = showRecordFields1($$Proxy.value)(record4);
            var key = reflectSymbol3($$Proxy.value);
            var focus = unsafeGet(key)(record4);
            return " " + (key + (": " + (show119(focus) + ("," + tail3))));
          };
        }
      };
    };
  };
};
var showRecordFieldsConsNil = function(dictIsSymbol) {
  var reflectSymbol3 = reflectSymbol(dictIsSymbol);
  return function(dictShow) {
    var show119 = show(dictShow);
    return {
      showRecordFields: function(v) {
        return function(record4) {
          var key = reflectSymbol3($$Proxy.value);
          var focus = unsafeGet(key)(record4);
          return " " + (key + (": " + (show119(focus) + " ")));
        };
      }
    };
  };
};

// output/Data.Generic.Rep/index.js
var Inl = /* @__PURE__ */ function() {
  function Inl2(value0) {
    this.value0 = value0;
  }
  ;
  Inl2.create = function(value0) {
    return new Inl2(value0);
  };
  return Inl2;
}();
var Inr = /* @__PURE__ */ function() {
  function Inr2(value0) {
    this.value0 = value0;
  }
  ;
  Inr2.create = function(value0) {
    return new Inr2(value0);
  };
  return Inr2;
}();
var Product = /* @__PURE__ */ function() {
  function Product3(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Product3.create = function(value0) {
    return function(value12) {
      return new Product3(value0, value12);
    };
  };
  return Product3;
}();
var NoArguments = /* @__PURE__ */ function() {
  function NoArguments2() {
  }
  ;
  NoArguments2.value = new NoArguments2();
  return NoArguments2;
}();
var Constructor = function(x) {
  return x;
};
var Argument = function(x) {
  return x;
};
var to = function(dict) {
  return dict.to;
};
var from = function(dict) {
  return dict.from;
};

// output/Data.Maybe/index.js
var identity4 = /* @__PURE__ */ identity(categoryFn);
var Nothing = /* @__PURE__ */ function() {
  function Nothing2() {
  }
  ;
  Nothing2.value = new Nothing2();
  return Nothing2;
}();
var Just = /* @__PURE__ */ function() {
  function Just2(value0) {
    this.value0 = value0;
  }
  ;
  Just2.create = function(value0) {
    return new Just2(value0);
  };
  return Just2;
}();
var showMaybe = function(dictShow) {
  var show48 = show(dictShow);
  return {
    show: function(v) {
      if (v instanceof Just) {
        return "(Just " + (show48(v.value0) + ")");
      }
      ;
      if (v instanceof Nothing) {
        return "Nothing";
      }
      ;
      throw new Error("Failed pattern match at Data.Maybe (line 223, column 1 - line 225, column 28): " + [v.constructor.name]);
    }
  };
};
var semigroupMaybe = function(dictSemigroup) {
  var append119 = append(dictSemigroup);
  return {
    append: function(v) {
      return function(v1) {
        if (v instanceof Nothing) {
          return v1;
        }
        ;
        if (v1 instanceof Nothing) {
          return v;
        }
        ;
        if (v instanceof Just && v1 instanceof Just) {
          return new Just(append119(v.value0)(v1.value0));
        }
        ;
        throw new Error("Failed pattern match at Data.Maybe (line 182, column 1 - line 185, column 43): " + [v.constructor.name, v1.constructor.name]);
      };
    }
  };
};
var monoidMaybe = function(dictSemigroup) {
  var semigroupMaybe1 = semigroupMaybe(dictSemigroup);
  return {
    mempty: Nothing.value,
    Semigroup0: function() {
      return semigroupMaybe1;
    }
  };
};
var maybe$prime = function(v) {
  return function(v1) {
    return function(v2) {
      if (v2 instanceof Nothing) {
        return v(unit);
      }
      ;
      if (v2 instanceof Just) {
        return v1(v2.value0);
      }
      ;
      throw new Error("Failed pattern match at Data.Maybe (line 250, column 1 - line 250, column 62): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
    };
  };
};
var maybe = function(v) {
  return function(v1) {
    return function(v2) {
      if (v2 instanceof Nothing) {
        return v;
      }
      ;
      if (v2 instanceof Just) {
        return v1(v2.value0);
      }
      ;
      throw new Error("Failed pattern match at Data.Maybe (line 237, column 1 - line 237, column 51): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
    };
  };
};
var isNothing = /* @__PURE__ */ maybe(true)(/* @__PURE__ */ $$const(false));
var isJust = /* @__PURE__ */ maybe(false)(/* @__PURE__ */ $$const(true));
var functorMaybe = {
  map: function(v) {
    return function(v1) {
      if (v1 instanceof Just) {
        return new Just(v(v1.value0));
      }
      ;
      return Nothing.value;
    };
  }
};
var map2 = /* @__PURE__ */ map(functorMaybe);
var fromMaybe$prime = function(a) {
  return maybe$prime(a)(identity4);
};
var fromMaybe = function(a) {
  return maybe(a)(identity4);
};
var fromJust = function() {
  return function(v) {
    if (v instanceof Just) {
      return v.value0;
    }
    ;
    throw new Error("Failed pattern match at Data.Maybe (line 288, column 1 - line 288, column 46): " + [v.constructor.name]);
  };
};
var eqMaybe = function(dictEq) {
  var eq31 = eq(dictEq);
  return {
    eq: function(x) {
      return function(y) {
        if (x instanceof Nothing && y instanceof Nothing) {
          return true;
        }
        ;
        if (x instanceof Just && y instanceof Just) {
          return eq31(x.value0)(y.value0);
        }
        ;
        return false;
      };
    }
  };
};
var applyMaybe = {
  apply: function(v) {
    return function(v1) {
      if (v instanceof Just) {
        return map2(v.value0)(v1);
      }
      ;
      if (v instanceof Nothing) {
        return Nothing.value;
      }
      ;
      throw new Error("Failed pattern match at Data.Maybe (line 67, column 1 - line 69, column 30): " + [v.constructor.name, v1.constructor.name]);
    };
  },
  Functor0: function() {
    return functorMaybe;
  }
};
var bindMaybe = {
  bind: function(v) {
    return function(v1) {
      if (v instanceof Just) {
        return v1(v.value0);
      }
      ;
      if (v instanceof Nothing) {
        return Nothing.value;
      }
      ;
      throw new Error("Failed pattern match at Data.Maybe (line 125, column 1 - line 127, column 28): " + [v.constructor.name, v1.constructor.name]);
    };
  },
  Apply0: function() {
    return applyMaybe;
  }
};
var applicativeMaybe = /* @__PURE__ */ function() {
  return {
    pure: Just.create,
    Apply0: function() {
      return applyMaybe;
    }
  };
}();
var altMaybe = {
  alt: function(v) {
    return function(v1) {
      if (v instanceof Nothing) {
        return v1;
      }
      ;
      return v;
    };
  },
  Functor0: function() {
    return functorMaybe;
  }
};
var plusMaybe = /* @__PURE__ */ function() {
  return {
    empty: Nothing.value,
    Alt0: function() {
      return altMaybe;
    }
  };
}();
var alternativeMaybe = {
  Applicative0: function() {
    return applicativeMaybe;
  },
  Plus1: function() {
    return plusMaybe;
  }
};

// output/Data.Either/index.js
var Left = /* @__PURE__ */ function() {
  function Left2(value0) {
    this.value0 = value0;
  }
  ;
  Left2.create = function(value0) {
    return new Left2(value0);
  };
  return Left2;
}();
var Right = /* @__PURE__ */ function() {
  function Right2(value0) {
    this.value0 = value0;
  }
  ;
  Right2.create = function(value0) {
    return new Right2(value0);
  };
  return Right2;
}();
var showEither = function(dictShow) {
  var show48 = show(dictShow);
  return function(dictShow1) {
    var show119 = show(dictShow1);
    return {
      show: function(v) {
        if (v instanceof Left) {
          return "(Left " + (show48(v.value0) + ")");
        }
        ;
        if (v instanceof Right) {
          return "(Right " + (show119(v.value0) + ")");
        }
        ;
        throw new Error("Failed pattern match at Data.Either (line 173, column 1 - line 175, column 46): " + [v.constructor.name]);
      }
    };
  };
};
var note = function(a) {
  return maybe(new Left(a))(Right.create);
};
var functorEither = {
  map: function(f) {
    return function(m) {
      if (m instanceof Left) {
        return new Left(m.value0);
      }
      ;
      if (m instanceof Right) {
        return new Right(f(m.value0));
      }
      ;
      throw new Error("Failed pattern match at Data.Either (line 0, column 0 - line 0, column 0): " + [m.constructor.name]);
    };
  }
};
var map3 = /* @__PURE__ */ map(functorEither);
var fromRight$prime = function(v) {
  return function(v1) {
    if (v1 instanceof Right) {
      return v1.value0;
    }
    ;
    return v(unit);
  };
};
var either = function(v) {
  return function(v1) {
    return function(v2) {
      if (v2 instanceof Left) {
        return v(v2.value0);
      }
      ;
      if (v2 instanceof Right) {
        return v1(v2.value0);
      }
      ;
      throw new Error("Failed pattern match at Data.Either (line 208, column 1 - line 208, column 64): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
    };
  };
};
var hush = /* @__PURE__ */ function() {
  return either($$const(Nothing.value))(Just.create);
}();
var isLeft = /* @__PURE__ */ either(/* @__PURE__ */ $$const(true))(/* @__PURE__ */ $$const(false));
var applyEither = {
  apply: function(v) {
    return function(v1) {
      if (v instanceof Left) {
        return new Left(v.value0);
      }
      ;
      if (v instanceof Right) {
        return map3(v.value0)(v1);
      }
      ;
      throw new Error("Failed pattern match at Data.Either (line 70, column 1 - line 72, column 30): " + [v.constructor.name, v1.constructor.name]);
    };
  },
  Functor0: function() {
    return functorEither;
  }
};
var bindEither = {
  bind: /* @__PURE__ */ either(function(e) {
    return function(v) {
      return new Left(e);
    };
  })(function(a) {
    return function(f) {
      return f(a);
    };
  }),
  Apply0: function() {
    return applyEither;
  }
};
var applicativeEither = /* @__PURE__ */ function() {
  return {
    pure: Right.create,
    Apply0: function() {
      return applyEither;
    }
  };
}();
var monadEither = {
  Applicative0: function() {
    return applicativeEither;
  },
  Bind1: function() {
    return bindEither;
  }
};
var altEither = {
  alt: function(v) {
    return function(v1) {
      if (v instanceof Left) {
        return v1;
      }
      ;
      return v;
    };
  },
  Functor0: function() {
    return functorEither;
  }
};

// output/Effect/foreign.js
var pureE = function(a) {
  return function() {
    return a;
  };
};
var bindE = function(a) {
  return function(f) {
    return function() {
      return f(a())();
    };
  };
};

// output/Data.EuclideanRing/foreign.js
var intDegree = function(x) {
  return Math.min(Math.abs(x), 2147483647);
};
var intDiv = function(x) {
  return function(y) {
    if (y === 0)
      return 0;
    return y > 0 ? Math.floor(x / y) : -Math.floor(x / -y);
  };
};
var intMod = function(x) {
  return function(y) {
    if (y === 0)
      return 0;
    var yy = Math.abs(y);
    return (x % yy + yy) % yy;
  };
};

// output/Data.CommutativeRing/index.js
var commutativeRingInt = {
  Ring0: function() {
    return ringInt;
  }
};

// output/Data.EuclideanRing/index.js
var mod = function(dict) {
  return dict.mod;
};
var euclideanRingInt = {
  degree: intDegree,
  div: intDiv,
  mod: intMod,
  CommutativeRing0: function() {
    return commutativeRingInt;
  }
};
var div = function(dict) {
  return dict.div;
};

// output/Data.Monoid/index.js
var semigroupRecord2 = /* @__PURE__ */ semigroupRecord();
var mod2 = /* @__PURE__ */ mod(euclideanRingInt);
var div2 = /* @__PURE__ */ div(euclideanRingInt);
var monoidUnit = {
  mempty: unit,
  Semigroup0: function() {
    return semigroupUnit;
  }
};
var monoidString = {
  mempty: "",
  Semigroup0: function() {
    return semigroupString;
  }
};
var monoidRecordNil = {
  memptyRecord: function(v) {
    return {};
  },
  SemigroupRecord0: function() {
    return semigroupRecordNil;
  }
};
var monoidArray = {
  mempty: [],
  Semigroup0: function() {
    return semigroupArray;
  }
};
var memptyRecord = function(dict) {
  return dict.memptyRecord;
};
var monoidRecord = function() {
  return function(dictMonoidRecord) {
    var semigroupRecord1 = semigroupRecord2(dictMonoidRecord.SemigroupRecord0());
    return {
      mempty: memptyRecord(dictMonoidRecord)($$Proxy.value),
      Semigroup0: function() {
        return semigroupRecord1;
      }
    };
  };
};
var mempty = function(dict) {
  return dict.mempty;
};
var monoidFn = function(dictMonoid) {
  var mempty112 = mempty(dictMonoid);
  var semigroupFn2 = semigroupFn(dictMonoid.Semigroup0());
  return {
    mempty: function(v) {
      return mempty112;
    },
    Semigroup0: function() {
      return semigroupFn2;
    }
  };
};
var monoidRecordCons = function(dictIsSymbol) {
  var reflectSymbol3 = reflectSymbol(dictIsSymbol);
  var semigroupRecordCons3 = semigroupRecordCons(dictIsSymbol)();
  return function(dictMonoid) {
    var mempty112 = mempty(dictMonoid);
    var Semigroup0 = dictMonoid.Semigroup0();
    return function() {
      return function(dictMonoidRecord) {
        var memptyRecord1 = memptyRecord(dictMonoidRecord);
        var semigroupRecordCons12 = semigroupRecordCons3(dictMonoidRecord.SemigroupRecord0())(Semigroup0);
        return {
          memptyRecord: function(v) {
            var tail3 = memptyRecord1($$Proxy.value);
            var key = reflectSymbol3($$Proxy.value);
            var insert20 = unsafeSet(key);
            return insert20(mempty112)(tail3);
          },
          SemigroupRecord0: function() {
            return semigroupRecordCons12;
          }
        };
      };
    };
  };
};
var power = function(dictMonoid) {
  var mempty112 = mempty(dictMonoid);
  var append40 = append(dictMonoid.Semigroup0());
  return function(x) {
    var go = function(p) {
      if (p <= 0) {
        return mempty112;
      }
      ;
      if (p === 1) {
        return x;
      }
      ;
      if (mod2(p)(2) === 0) {
        var x$prime = go(div2(p)(2));
        return append40(x$prime)(x$prime);
      }
      ;
      if (otherwise) {
        var x$prime = go(div2(p)(2));
        return append40(x$prime)(append40(x$prime)(x));
      }
      ;
      throw new Error("Failed pattern match at Data.Monoid (line 88, column 3 - line 88, column 17): " + [p.constructor.name]);
    };
    return go;
  };
};
var guard = function(dictMonoid) {
  var mempty112 = mempty(dictMonoid);
  return function(v) {
    return function(v1) {
      if (v) {
        return v1;
      }
      ;
      if (!v) {
        return mempty112;
      }
      ;
      throw new Error("Failed pattern match at Data.Monoid (line 96, column 1 - line 96, column 49): " + [v.constructor.name, v1.constructor.name]);
    };
  };
};

// output/Effect/index.js
var $runtime_lazy = function(name4, moduleName2, init4) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2)
      return val;
    if (state2 === 1)
      throw new ReferenceError(name4 + " was needed before it finished initializing (module " + moduleName2 + ", line " + lineNumber + ")", moduleName2, lineNumber);
    state2 = 1;
    val = init4();
    state2 = 2;
    return val;
  };
};
var monadEffect = {
  Applicative0: function() {
    return applicativeEffect;
  },
  Bind1: function() {
    return bindEffect;
  }
};
var bindEffect = {
  bind: bindE,
  Apply0: function() {
    return $lazy_applyEffect(0);
  }
};
var applicativeEffect = {
  pure: pureE,
  Apply0: function() {
    return $lazy_applyEffect(0);
  }
};
var $lazy_functorEffect = /* @__PURE__ */ $runtime_lazy("functorEffect", "Effect", function() {
  return {
    map: liftA1(applicativeEffect)
  };
});
var $lazy_applyEffect = /* @__PURE__ */ $runtime_lazy("applyEffect", "Effect", function() {
  return {
    apply: ap(monadEffect),
    Functor0: function() {
      return $lazy_functorEffect(0);
    }
  };
});
var functorEffect = /* @__PURE__ */ $lazy_functorEffect(20);
var applyEffect = /* @__PURE__ */ $lazy_applyEffect(23);
var lift22 = /* @__PURE__ */ lift2(applyEffect);
var semigroupEffect = function(dictSemigroup) {
  return {
    append: lift22(append(dictSemigroup))
  };
};
var monoidEffect = function(dictMonoid) {
  var semigroupEffect1 = semigroupEffect(dictMonoid.Semigroup0());
  return {
    mempty: pureE(mempty(dictMonoid)),
    Semigroup0: function() {
      return semigroupEffect1;
    }
  };
};

// output/Effect.Exception/foreign.js
function showErrorImpl(err) {
  return err.stack || err.toString();
}
function error(msg) {
  return new Error(msg);
}
function message(e) {
  return e.message;
}
function throwException(e) {
  return function() {
    throw e;
  };
}
function catchException(c) {
  return function(t) {
    return function() {
      try {
        return t();
      } catch (e) {
        if (e instanceof Error || Object.prototype.toString.call(e) === "[object Error]") {
          return c(e)();
        } else {
          return c(new Error(e.toString()))();
        }
      }
    };
  };
}

// output/Effect.Exception/index.js
var pure2 = /* @__PURE__ */ pure(applicativeEffect);
var map4 = /* @__PURE__ */ map(functorEffect);
var $$try = function(action) {
  return catchException(function($3) {
    return pure2(Left.create($3));
  })(map4(Right.create)(action));
};
var $$throw = function($4) {
  return throwException(error($4));
};
var showError = {
  show: showErrorImpl
};

// output/Control.Monad.Error.Class/index.js
var throwError = function(dict) {
  return dict.throwError;
};
var monadThrowEffect = {
  throwError: throwException,
  Monad0: function() {
    return monadEffect;
  }
};
var monadErrorEffect = {
  catchError: /* @__PURE__ */ flip(catchException),
  MonadThrow0: function() {
    return monadThrowEffect;
  }
};
var liftEither = function(dictMonadThrow) {
  return either(throwError(dictMonadThrow))(pure(dictMonadThrow.Monad0().Applicative0()));
};
var catchError = function(dict) {
  return dict.catchError;
};
var $$try2 = function(dictMonadError) {
  var catchError1 = catchError(dictMonadError);
  var Monad0 = dictMonadError.MonadThrow0().Monad0();
  var map86 = map(Monad0.Bind1().Apply0().Functor0());
  var pure75 = pure(Monad0.Applicative0());
  return function(a) {
    return catchError1(map86(Right.create)(a))(function($52) {
      return pure75(Left.create($52));
    });
  };
};

// output/Control.Monad.Reader.Class/index.js
var ask = function(dict) {
  return dict.ask;
};

// output/Data.Array/foreign.js
var range = function(start) {
  return function(end4) {
    var step3 = start > end4 ? -1 : 1;
    var result = new Array(step3 * (end4 - start) + 1);
    var i = start, n = 0;
    while (i !== end4) {
      result[n++] = i;
      i += step3;
    }
    result[n] = i;
    return result;
  };
};
var replicateFill = function(count) {
  return function(value4) {
    if (count < 1) {
      return [];
    }
    var result = new Array(count);
    return result.fill(value4);
  };
};
var replicatePolyfill = function(count) {
  return function(value4) {
    var result = [];
    var n = 0;
    for (var i = 0; i < count; i++) {
      result[n++] = value4;
    }
    return result;
  };
};
var replicate = typeof Array.prototype.fill === "function" ? replicateFill : replicatePolyfill;
var fromFoldableImpl = function() {
  function Cons4(head6, tail3) {
    this.head = head6;
    this.tail = tail3;
  }
  var emptyList = {};
  function curryCons(head6) {
    return function(tail3) {
      return new Cons4(head6, tail3);
    };
  }
  function listToArray(list2) {
    var result = [];
    var count = 0;
    var xs = list2;
    while (xs !== emptyList) {
      result[count++] = xs.head;
      xs = xs.tail;
    }
    return result;
  }
  return function(foldr14) {
    return function(xs) {
      return listToArray(foldr14(curryCons)(emptyList)(xs));
    };
  };
}();
var length = function(xs) {
  return xs.length;
};
var unconsImpl = function(empty9) {
  return function(next2) {
    return function(xs) {
      return xs.length === 0 ? empty9({}) : next2(xs[0])(xs.slice(1));
    };
  };
};
var indexImpl = function(just) {
  return function(nothing) {
    return function(xs) {
      return function(i) {
        return i < 0 || i >= xs.length ? nothing : just(xs[i]);
      };
    };
  };
};
var findIndexImpl = function(just) {
  return function(nothing) {
    return function(f) {
      return function(xs) {
        for (var i = 0, l = xs.length; i < l; i++) {
          if (f(xs[i]))
            return just(i);
        }
        return nothing;
      };
    };
  };
};
var reverse = function(l) {
  return l.slice().reverse();
};
var filter = function(f) {
  return function(xs) {
    return xs.filter(f);
  };
};
var partition = function(f) {
  return function(xs) {
    var yes = [];
    var no = [];
    for (var i = 0; i < xs.length; i++) {
      var x = xs[i];
      if (f(x))
        yes.push(x);
      else
        no.push(x);
    }
    return { yes, no };
  };
};
var sortByImpl = function() {
  function mergeFromTo(compare10, fromOrdering, xs1, xs2, from3, to2) {
    var mid;
    var i;
    var j;
    var k;
    var x;
    var y;
    var c;
    mid = from3 + (to2 - from3 >> 1);
    if (mid - from3 > 1)
      mergeFromTo(compare10, fromOrdering, xs2, xs1, from3, mid);
    if (to2 - mid > 1)
      mergeFromTo(compare10, fromOrdering, xs2, xs1, mid, to2);
    i = from3;
    j = mid;
    k = from3;
    while (i < mid && j < to2) {
      x = xs2[i];
      y = xs2[j];
      c = fromOrdering(compare10(x)(y));
      if (c > 0) {
        xs1[k++] = y;
        ++j;
      } else {
        xs1[k++] = x;
        ++i;
      }
    }
    while (i < mid) {
      xs1[k++] = xs2[i++];
    }
    while (j < to2) {
      xs1[k++] = xs2[j++];
    }
  }
  return function(compare10) {
    return function(fromOrdering) {
      return function(xs) {
        var out;
        if (xs.length < 2)
          return xs;
        out = xs.slice(0);
        mergeFromTo(compare10, fromOrdering, out, xs.slice(0), 0, xs.length);
        return out;
      };
    };
  };
}();
var slice = function(s) {
  return function(e) {
    return function(l) {
      return l.slice(s, e);
    };
  };
};
var zipWith = function(f) {
  return function(xs) {
    return function(ys) {
      var l = xs.length < ys.length ? xs.length : ys.length;
      var result = new Array(l);
      for (var i = 0; i < l; i++) {
        result[i] = f(xs[i])(ys[i]);
      }
      return result;
    };
  };
};
var any = function(p) {
  return function(xs) {
    var len = xs.length;
    for (var i = 0; i < len; i++) {
      if (p(xs[i]))
        return true;
    }
    return false;
  };
};
var all = function(p) {
  return function(xs) {
    var len = xs.length;
    for (var i = 0; i < len; i++) {
      if (!p(xs[i]))
        return false;
    }
    return true;
  };
};
var unsafeIndexImpl = function(xs) {
  return function(n) {
    return xs[n];
  };
};

// output/Control.Lazy/index.js
var defer = function(dict) {
  return dict.defer;
};

// output/Data.Identity/index.js
var Identity = function(x) {
  return x;
};
var functorIdentity = {
  map: function(f) {
    return function(m) {
      return f(m);
    };
  }
};
var applyIdentity = {
  apply: function(v) {
    return function(v1) {
      return v(v1);
    };
  },
  Functor0: function() {
    return functorIdentity;
  }
};
var bindIdentity = {
  bind: function(v) {
    return function(f) {
      return f(v);
    };
  },
  Apply0: function() {
    return applyIdentity;
  }
};
var applicativeIdentity = {
  pure: Identity,
  Apply0: function() {
    return applyIdentity;
  }
};
var monadIdentity = {
  Applicative0: function() {
    return applicativeIdentity;
  },
  Bind1: function() {
    return bindIdentity;
  }
};

// output/Effect.Ref/foreign.js
var _new = function(val) {
  return function() {
    return { value: val };
  };
};
var read = function(ref2) {
  return function() {
    return ref2.value;
  };
};
var modifyImpl = function(f) {
  return function(ref2) {
    return function() {
      var t = f(ref2.value);
      ref2.value = t.state;
      return t.value;
    };
  };
};
var write = function(val) {
  return function(ref2) {
    return function() {
      ref2.value = val;
    };
  };
};

// output/Effect.Ref/index.js
var $$void2 = /* @__PURE__ */ $$void(functorEffect);
var $$new = _new;
var modify$prime = modifyImpl;
var modify = function(f) {
  return modify$prime(function(s) {
    var s$prime = f(s);
    return {
      state: s$prime,
      value: s$prime
    };
  });
};
var modify_ = function(f) {
  return function(s) {
    return $$void2(modify(f)(s));
  };
};

// output/Control.Monad.Rec.Class/index.js
var bindFlipped2 = /* @__PURE__ */ bindFlipped(bindEffect);
var map5 = /* @__PURE__ */ map(functorEffect);
var Loop = /* @__PURE__ */ function() {
  function Loop2(value0) {
    this.value0 = value0;
  }
  ;
  Loop2.create = function(value0) {
    return new Loop2(value0);
  };
  return Loop2;
}();
var Done = /* @__PURE__ */ function() {
  function Done3(value0) {
    this.value0 = value0;
  }
  ;
  Done3.create = function(value0) {
    return new Done3(value0);
  };
  return Done3;
}();
var tailRecM = function(dict) {
  return dict.tailRecM;
};
var tailRec = function(f) {
  var go = function($copy_v) {
    var $tco_done = false;
    var $tco_result;
    function $tco_loop(v) {
      if (v instanceof Loop) {
        $copy_v = f(v.value0);
        return;
      }
      ;
      if (v instanceof Done) {
        $tco_done = true;
        return v.value0;
      }
      ;
      throw new Error("Failed pattern match at Control.Monad.Rec.Class (line 103, column 3 - line 103, column 25): " + [v.constructor.name]);
    }
    ;
    while (!$tco_done) {
      $tco_result = $tco_loop($copy_v);
    }
    ;
    return $tco_result;
  };
  return function($85) {
    return go(f($85));
  };
};
var monadRecIdentity = {
  tailRecM: function(f) {
    var runIdentity = function(v) {
      return v;
    };
    var $86 = tailRec(function($88) {
      return runIdentity(f($88));
    });
    return function($87) {
      return Identity($86($87));
    };
  },
  Monad0: function() {
    return monadIdentity;
  }
};
var monadRecEffect = {
  tailRecM: function(f) {
    return function(a) {
      var fromDone = function(v) {
        if (v instanceof Done) {
          return v.value0;
        }
        ;
        throw new Error("Failed pattern match at Control.Monad.Rec.Class (line 137, column 30 - line 137, column 44): " + [v.constructor.name]);
      };
      return function __do3() {
        var r = bindFlipped2($$new)(f(a))();
        (function() {
          while (!function __do4() {
            var v = read(r)();
            if (v instanceof Loop) {
              var e = f(v.value0)();
              write(e)(r)();
              return false;
            }
            ;
            if (v instanceof Done) {
              return true;
            }
            ;
            throw new Error("Failed pattern match at Control.Monad.Rec.Class (line 128, column 22 - line 133, column 28): " + [v.constructor.name]);
          }()) {
          }
          ;
          return {};
        })();
        return map5(fromDone)(read(r))();
      };
    };
  },
  Monad0: function() {
    return monadEffect;
  }
};
var bifunctorStep = {
  bimap: function(v) {
    return function(v1) {
      return function(v2) {
        if (v2 instanceof Loop) {
          return new Loop(v(v2.value0));
        }
        ;
        if (v2 instanceof Done) {
          return new Done(v1(v2.value0));
        }
        ;
        throw new Error("Failed pattern match at Control.Monad.Rec.Class (line 33, column 1 - line 35, column 34): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
      };
    };
  }
};

// output/Control.Monad.ST.Internal/foreign.js
var map_ = function(f) {
  return function(a) {
    return function() {
      return f(a());
    };
  };
};
var pure_ = function(a) {
  return function() {
    return a;
  };
};
var bind_ = function(a) {
  return function(f) {
    return function() {
      return f(a())();
    };
  };
};
function forST(lo) {
  return function(hi) {
    return function(f) {
      return function() {
        for (var i = lo; i < hi; i++) {
          f(i)();
        }
      };
    };
  };
}
var foreach = function(as3) {
  return function(f) {
    return function() {
      for (var i = 0, l = as3.length; i < l; i++) {
        f(as3[i])();
      }
    };
  };
};
function newSTRef(val) {
  return function() {
    return { value: val };
  };
}
var read2 = function(ref2) {
  return function() {
    return ref2.value;
  };
};
var modifyImpl2 = function(f) {
  return function(ref2) {
    return function() {
      var t = f(ref2.value);
      ref2.value = t.state;
      return t.value;
    };
  };
};
var write2 = function(a) {
  return function(ref2) {
    return function() {
      return ref2.value = a;
    };
  };
};

// output/Control.Monad.ST.Internal/index.js
var $runtime_lazy2 = function(name4, moduleName2, init4) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2)
      return val;
    if (state2 === 1)
      throw new ReferenceError(name4 + " was needed before it finished initializing (module " + moduleName2 + ", line " + lineNumber + ")", moduleName2, lineNumber);
    state2 = 1;
    val = init4();
    state2 = 2;
    return val;
  };
};
var modify$prime2 = modifyImpl2;
var modify2 = function(f) {
  return modify$prime2(function(s) {
    var s$prime = f(s);
    return {
      state: s$prime,
      value: s$prime
    };
  });
};
var functorST = {
  map: map_
};
var monadST = {
  Applicative0: function() {
    return applicativeST;
  },
  Bind1: function() {
    return bindST;
  }
};
var bindST = {
  bind: bind_,
  Apply0: function() {
    return $lazy_applyST(0);
  }
};
var applicativeST = {
  pure: pure_,
  Apply0: function() {
    return $lazy_applyST(0);
  }
};
var $lazy_applyST = /* @__PURE__ */ $runtime_lazy2("applyST", "Control.Monad.ST.Internal", function() {
  return {
    apply: ap(monadST),
    Functor0: function() {
      return functorST;
    }
  };
});
var applyST = /* @__PURE__ */ $lazy_applyST(47);

// output/Data.Array.ST/foreign.js
function newSTArray() {
  return [];
}
var pushAll = function(as3) {
  return function(xs) {
    return function() {
      return xs.push.apply(xs, as3);
    };
  };
};
var unsafeFreeze = function(xs) {
  return function() {
    return xs;
  };
};
function copyImpl(xs) {
  return function() {
    return xs.slice();
  };
}
var thaw = copyImpl;
var sortByImpl2 = function() {
  function mergeFromTo(compare10, fromOrdering, xs1, xs2, from3, to2) {
    var mid;
    var i;
    var j;
    var k;
    var x;
    var y;
    var c;
    mid = from3 + (to2 - from3 >> 1);
    if (mid - from3 > 1)
      mergeFromTo(compare10, fromOrdering, xs2, xs1, from3, mid);
    if (to2 - mid > 1)
      mergeFromTo(compare10, fromOrdering, xs2, xs1, mid, to2);
    i = from3;
    j = mid;
    k = from3;
    while (i < mid && j < to2) {
      x = xs2[i];
      y = xs2[j];
      c = fromOrdering(compare10(x)(y));
      if (c > 0) {
        xs1[k++] = y;
        ++j;
      } else {
        xs1[k++] = x;
        ++i;
      }
    }
    while (i < mid) {
      xs1[k++] = xs2[i++];
    }
    while (j < to2) {
      xs1[k++] = xs2[j++];
    }
  }
  return function(compare10) {
    return function(fromOrdering) {
      return function(xs) {
        return function() {
          if (xs.length < 2)
            return xs;
          mergeFromTo(compare10, fromOrdering, xs, xs.slice(0), 0, xs.length);
          return xs;
        };
      };
    };
  };
}();

// output/Data.Array.ST/index.js
var bind2 = /* @__PURE__ */ bind(bindST);
var withArray = function(f) {
  return function(xs) {
    return function __do3() {
      var result = thaw(xs)();
      f(result)();
      return unsafeFreeze(result)();
    };
  };
};
var run2 = function(st) {
  return bind2(st)(unsafeFreeze)();
};
var push = function(a) {
  return pushAll([a]);
};

// output/Data.HeytingAlgebra/foreign.js
var boolConj = function(b1) {
  return function(b2) {
    return b1 && b2;
  };
};
var boolDisj = function(b1) {
  return function(b2) {
    return b1 || b2;
  };
};
var boolNot = function(b) {
  return !b;
};

// output/Data.HeytingAlgebra/index.js
var ttRecord = function(dict) {
  return dict.ttRecord;
};
var tt = function(dict) {
  return dict.tt;
};
var notRecord = function(dict) {
  return dict.notRecord;
};
var not = function(dict) {
  return dict.not;
};
var impliesRecord = function(dict) {
  return dict.impliesRecord;
};
var implies = function(dict) {
  return dict.implies;
};
var heytingAlgebraRecordNil = {
  conjRecord: function(v) {
    return function(v1) {
      return function(v2) {
        return {};
      };
    };
  },
  disjRecord: function(v) {
    return function(v1) {
      return function(v2) {
        return {};
      };
    };
  },
  ffRecord: function(v) {
    return function(v1) {
      return {};
    };
  },
  impliesRecord: function(v) {
    return function(v1) {
      return function(v2) {
        return {};
      };
    };
  },
  notRecord: function(v) {
    return function(v1) {
      return {};
    };
  },
  ttRecord: function(v) {
    return function(v1) {
      return {};
    };
  }
};
var ffRecord = function(dict) {
  return dict.ffRecord;
};
var ff = function(dict) {
  return dict.ff;
};
var disjRecord = function(dict) {
  return dict.disjRecord;
};
var disj = function(dict) {
  return dict.disj;
};
var heytingAlgebraBoolean = {
  ff: false,
  tt: true,
  implies: function(a) {
    return function(b) {
      return disj(heytingAlgebraBoolean)(not(heytingAlgebraBoolean)(a))(b);
    };
  },
  conj: boolConj,
  disj: boolDisj,
  not: boolNot
};
var conjRecord = function(dict) {
  return dict.conjRecord;
};
var heytingAlgebraRecord = function() {
  return function(dictHeytingAlgebraRecord) {
    return {
      ff: ffRecord(dictHeytingAlgebraRecord)($$Proxy.value)($$Proxy.value),
      tt: ttRecord(dictHeytingAlgebraRecord)($$Proxy.value)($$Proxy.value),
      conj: conjRecord(dictHeytingAlgebraRecord)($$Proxy.value),
      disj: disjRecord(dictHeytingAlgebraRecord)($$Proxy.value),
      implies: impliesRecord(dictHeytingAlgebraRecord)($$Proxy.value),
      not: notRecord(dictHeytingAlgebraRecord)($$Proxy.value)
    };
  };
};
var conj = function(dict) {
  return dict.conj;
};
var heytingAlgebraFunction = function(dictHeytingAlgebra) {
  var ff1 = ff(dictHeytingAlgebra);
  var tt1 = tt(dictHeytingAlgebra);
  var implies1 = implies(dictHeytingAlgebra);
  var conj1 = conj(dictHeytingAlgebra);
  var disj1 = disj(dictHeytingAlgebra);
  var not12 = not(dictHeytingAlgebra);
  return {
    ff: function(v) {
      return ff1;
    },
    tt: function(v) {
      return tt1;
    },
    implies: function(f) {
      return function(g) {
        return function(a) {
          return implies1(f(a))(g(a));
        };
      };
    },
    conj: function(f) {
      return function(g) {
        return function(a) {
          return conj1(f(a))(g(a));
        };
      };
    },
    disj: function(f) {
      return function(g) {
        return function(a) {
          return disj1(f(a))(g(a));
        };
      };
    },
    not: function(f) {
      return function(a) {
        return not12(f(a));
      };
    }
  };
};
var heytingAlgebraRecordCons = function(dictIsSymbol) {
  var reflectSymbol3 = reflectSymbol(dictIsSymbol);
  return function() {
    return function(dictHeytingAlgebraRecord) {
      var conjRecord1 = conjRecord(dictHeytingAlgebraRecord);
      var disjRecord1 = disjRecord(dictHeytingAlgebraRecord);
      var impliesRecord1 = impliesRecord(dictHeytingAlgebraRecord);
      var ffRecord1 = ffRecord(dictHeytingAlgebraRecord);
      var notRecord1 = notRecord(dictHeytingAlgebraRecord);
      var ttRecord1 = ttRecord(dictHeytingAlgebraRecord);
      return function(dictHeytingAlgebra) {
        var conj1 = conj(dictHeytingAlgebra);
        var disj1 = disj(dictHeytingAlgebra);
        var implies1 = implies(dictHeytingAlgebra);
        var ff1 = ff(dictHeytingAlgebra);
        var not12 = not(dictHeytingAlgebra);
        var tt1 = tt(dictHeytingAlgebra);
        return {
          conjRecord: function(v) {
            return function(ra) {
              return function(rb) {
                var tail3 = conjRecord1($$Proxy.value)(ra)(rb);
                var key = reflectSymbol3($$Proxy.value);
                var insert20 = unsafeSet(key);
                var get7 = unsafeGet(key);
                return insert20(conj1(get7(ra))(get7(rb)))(tail3);
              };
            };
          },
          disjRecord: function(v) {
            return function(ra) {
              return function(rb) {
                var tail3 = disjRecord1($$Proxy.value)(ra)(rb);
                var key = reflectSymbol3($$Proxy.value);
                var insert20 = unsafeSet(key);
                var get7 = unsafeGet(key);
                return insert20(disj1(get7(ra))(get7(rb)))(tail3);
              };
            };
          },
          impliesRecord: function(v) {
            return function(ra) {
              return function(rb) {
                var tail3 = impliesRecord1($$Proxy.value)(ra)(rb);
                var key = reflectSymbol3($$Proxy.value);
                var insert20 = unsafeSet(key);
                var get7 = unsafeGet(key);
                return insert20(implies1(get7(ra))(get7(rb)))(tail3);
              };
            };
          },
          ffRecord: function(v) {
            return function(row) {
              var tail3 = ffRecord1($$Proxy.value)(row);
              var key = reflectSymbol3($$Proxy.value);
              var insert20 = unsafeSet(key);
              return insert20(ff1)(tail3);
            };
          },
          notRecord: function(v) {
            return function(row) {
              var tail3 = notRecord1($$Proxy.value)(row);
              var key = reflectSymbol3($$Proxy.value);
              var insert20 = unsafeSet(key);
              var get7 = unsafeGet(key);
              return insert20(not12(get7(row)))(tail3);
            };
          },
          ttRecord: function(v) {
            return function(row) {
              var tail3 = ttRecord1($$Proxy.value)(row);
              var key = reflectSymbol3($$Proxy.value);
              var insert20 = unsafeSet(key);
              return insert20(tt1)(tail3);
            };
          }
        };
      };
    };
  };
};

// output/Data.Array.ST.Iterator/index.js
var map6 = /* @__PURE__ */ map(functorST);
var not2 = /* @__PURE__ */ not(heytingAlgebraBoolean);
var $$void3 = /* @__PURE__ */ $$void(functorST);
var Iterator = /* @__PURE__ */ function() {
  function Iterator2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Iterator2.create = function(value0) {
    return function(value12) {
      return new Iterator2(value0, value12);
    };
  };
  return Iterator2;
}();
var peek = function(v) {
  return function __do3() {
    var i = read2(v.value1)();
    return v.value0(i);
  };
};
var next = function(v) {
  return function __do3() {
    var i = read2(v.value1)();
    modify2(function(v1) {
      return v1 + 1 | 0;
    })(v.value1)();
    return v.value0(i);
  };
};
var pushWhile = function(p) {
  return function(iter) {
    return function(array2) {
      return function __do3() {
        var $$break2 = newSTRef(false)();
        while (map6(not2)(read2($$break2))()) {
          (function __do4() {
            var mx = peek(iter)();
            if (mx instanceof Just && p(mx.value0)) {
              push(mx.value0)(array2)();
              return $$void3(next(iter))();
            }
            ;
            return $$void3(write2(true)($$break2))();
          })();
        }
        ;
        return {};
      };
    };
  };
};
var iterator = function(f) {
  return map6(Iterator.create(f))(newSTRef(0));
};
var iterate = function(iter) {
  return function(f) {
    return function __do3() {
      var $$break2 = newSTRef(false)();
      while (map6(not2)(read2($$break2))()) {
        (function __do4() {
          var mx = next(iter)();
          if (mx instanceof Just) {
            return f(mx.value0)();
          }
          ;
          if (mx instanceof Nothing) {
            return $$void3(write2(true)($$break2))();
          }
          ;
          throw new Error("Failed pattern match at Data.Array.ST.Iterator (line 42, column 5 - line 44, column 47): " + [mx.constructor.name]);
        })();
      }
      ;
      return {};
    };
  };
};

// output/Data.Foldable/foreign.js
var foldrArray = function(f) {
  return function(init4) {
    return function(xs) {
      var acc = init4;
      var len = xs.length;
      for (var i = len - 1; i >= 0; i--) {
        acc = f(xs[i])(acc);
      }
      return acc;
    };
  };
};
var foldlArray = function(f) {
  return function(init4) {
    return function(xs) {
      var acc = init4;
      var len = xs.length;
      for (var i = 0; i < len; i++) {
        acc = f(acc)(xs[i]);
      }
      return acc;
    };
  };
};

// output/Control.Plus/index.js
var plusArray = {
  empty: [],
  Alt0: function() {
    return altArray;
  }
};
var empty = function(dict) {
  return dict.empty;
};

// output/Data.Tuple/index.js
var Tuple = /* @__PURE__ */ function() {
  function Tuple2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Tuple2.create = function(value0) {
    return function(value12) {
      return new Tuple2(value0, value12);
    };
  };
  return Tuple2;
}();
var uncurry = function(f) {
  return function(v) {
    return f(v.value0)(v.value1);
  };
};
var snd = function(v) {
  return v.value1;
};
var semigroupTuple = function(dictSemigroup) {
  var append119 = append(dictSemigroup);
  return function(dictSemigroup1) {
    var append212 = append(dictSemigroup1);
    return {
      append: function(v) {
        return function(v1) {
          return new Tuple(append119(v.value0)(v1.value0), append212(v.value1)(v1.value1));
        };
      }
    };
  };
};
var monoidTuple = function(dictMonoid) {
  var mempty27 = mempty(dictMonoid);
  var semigroupTuple1 = semigroupTuple(dictMonoid.Semigroup0());
  return function(dictMonoid1) {
    var semigroupTuple2 = semigroupTuple1(dictMonoid1.Semigroup0());
    return {
      mempty: new Tuple(mempty27, mempty(dictMonoid1)),
      Semigroup0: function() {
        return semigroupTuple2;
      }
    };
  };
};
var functorTuple = {
  map: function(f) {
    return function(m) {
      return new Tuple(m.value0, f(m.value1));
    };
  }
};
var fst = function(v) {
  return v.value0;
};
var eqTuple = function(dictEq) {
  var eq31 = eq(dictEq);
  return function(dictEq1) {
    var eq115 = eq(dictEq1);
    return {
      eq: function(x) {
        return function(y) {
          return eq31(x.value0)(y.value0) && eq115(x.value1)(y.value1);
        };
      }
    };
  };
};
var ordTuple = function(dictOrd) {
  var compare10 = compare(dictOrd);
  var eqTuple1 = eqTuple(dictOrd.Eq0());
  return function(dictOrd1) {
    var compare17 = compare(dictOrd1);
    var eqTuple2 = eqTuple1(dictOrd1.Eq0());
    return {
      compare: function(x) {
        return function(y) {
          var v = compare10(x.value0)(y.value0);
          if (v instanceof LT) {
            return LT.value;
          }
          ;
          if (v instanceof GT) {
            return GT.value;
          }
          ;
          return compare17(x.value1)(y.value1);
        };
      },
      Eq0: function() {
        return eqTuple2;
      }
    };
  };
};
var curry = function(f) {
  return function(a) {
    return function(b) {
      return f(new Tuple(a, b));
    };
  };
};
var applyTuple = function(dictSemigroup) {
  var append119 = append(dictSemigroup);
  return {
    apply: function(v) {
      return function(v1) {
        return new Tuple(append119(v.value0)(v1.value0), v.value1(v1.value1));
      };
    },
    Functor0: function() {
      return functorTuple;
    }
  };
};
var applicativeTuple = function(dictMonoid) {
  var applyTuple1 = applyTuple(dictMonoid.Semigroup0());
  return {
    pure: Tuple.create(mempty(dictMonoid)),
    Apply0: function() {
      return applyTuple1;
    }
  };
};

// output/Data.Bifunctor/index.js
var identity5 = /* @__PURE__ */ identity(categoryFn);
var bimap = function(dict) {
  return dict.bimap;
};
var lmap = function(dictBifunctor) {
  var bimap1 = bimap(dictBifunctor);
  return function(f) {
    return bimap1(f)(identity5);
  };
};
var rmap = function(dictBifunctor) {
  return bimap(dictBifunctor)(identity5);
};
var bifunctorTuple = {
  bimap: function(f) {
    return function(g) {
      return function(v) {
        return new Tuple(f(v.value0), g(v.value1));
      };
    };
  }
};
var bifunctorEither = {
  bimap: function(v) {
    return function(v1) {
      return function(v2) {
        if (v2 instanceof Left) {
          return new Left(v(v2.value0));
        }
        ;
        if (v2 instanceof Right) {
          return new Right(v1(v2.value0));
        }
        ;
        throw new Error("Failed pattern match at Data.Bifunctor (line 32, column 1 - line 34, column 36): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
      };
    };
  }
};

// output/Data.Maybe.First/index.js
var First = function(x) {
  return x;
};
var semigroupFirst = {
  append: function(v) {
    return function(v1) {
      if (v instanceof Just) {
        return v;
      }
      ;
      return v1;
    };
  }
};
var monoidFirst = /* @__PURE__ */ function() {
  return {
    mempty: Nothing.value,
    Semigroup0: function() {
      return semigroupFirst;
    }
  };
}();

// output/Data.Monoid.Conj/index.js
var Conj = function(x) {
  return x;
};
var semigroupConj = function(dictHeytingAlgebra) {
  var conj2 = conj(dictHeytingAlgebra);
  return {
    append: function(v) {
      return function(v1) {
        return conj2(v)(v1);
      };
    }
  };
};
var monoidConj = function(dictHeytingAlgebra) {
  var semigroupConj1 = semigroupConj(dictHeytingAlgebra);
  return {
    mempty: tt(dictHeytingAlgebra),
    Semigroup0: function() {
      return semigroupConj1;
    }
  };
};

// output/Data.Monoid.Disj/index.js
var Disj = function(x) {
  return x;
};
var semigroupDisj = function(dictHeytingAlgebra) {
  var disj3 = disj(dictHeytingAlgebra);
  return {
    append: function(v) {
      return function(v1) {
        return disj3(v)(v1);
      };
    }
  };
};
var monoidDisj = function(dictHeytingAlgebra) {
  var semigroupDisj1 = semigroupDisj(dictHeytingAlgebra);
  return {
    mempty: ff(dictHeytingAlgebra),
    Semigroup0: function() {
      return semigroupDisj1;
    }
  };
};

// output/Data.Monoid.Endo/index.js
var semigroupEndo = function(dictSemigroupoid) {
  var compose2 = compose(dictSemigroupoid);
  return {
    append: function(v) {
      return function(v1) {
        return compose2(v)(v1);
      };
    }
  };
};
var monoidEndo = function(dictCategory) {
  var semigroupEndo1 = semigroupEndo(dictCategory.Semigroupoid0());
  return {
    mempty: identity(dictCategory),
    Semigroup0: function() {
      return semigroupEndo1;
    }
  };
};

// output/Unsafe.Coerce/foreign.js
var unsafeCoerce2 = function(x) {
  return x;
};

// output/Safe.Coerce/index.js
var coerce = function() {
  return unsafeCoerce2;
};

// output/Data.Newtype/index.js
var coerce2 = /* @__PURE__ */ coerce();
var wrap = function() {
  return coerce2;
};
var wrap1 = /* @__PURE__ */ wrap();
var unwrap = function() {
  return coerce2;
};
var unwrap1 = /* @__PURE__ */ unwrap();
var under = function() {
  return function() {
    return function(v) {
      return coerce2;
    };
  };
};
var un = function() {
  return function(v) {
    return unwrap1;
  };
};
var over = function() {
  return function() {
    return function(v) {
      return coerce2;
    };
  };
};
var alaF = function() {
  return function() {
    return function() {
      return function() {
        return function(v) {
          return coerce2;
        };
      };
    };
  };
};
var ala = function() {
  return function() {
    return function() {
      return function(v) {
        return function(f) {
          return coerce2(f(wrap1));
        };
      };
    };
  };
};

// output/Data.Foldable/index.js
var identity6 = /* @__PURE__ */ identity(categoryFn);
var eq12 = /* @__PURE__ */ eq(eqOrdering);
var unwrap2 = /* @__PURE__ */ unwrap();
var alaF2 = /* @__PURE__ */ alaF()()()();
var foldr = function(dict) {
  return dict.foldr;
};
var oneOf = function(dictFoldable) {
  var foldr22 = foldr(dictFoldable);
  return function(dictPlus) {
    return foldr22(alt(dictPlus.Alt0()))(empty(dictPlus));
  };
};
var oneOfMap = function(dictFoldable) {
  var foldr22 = foldr(dictFoldable);
  return function(dictPlus) {
    var alt32 = alt(dictPlus.Alt0());
    var empty9 = empty(dictPlus);
    return function(f) {
      return foldr22(function($453) {
        return alt32(f($453));
      })(empty9);
    };
  };
};
var traverse_ = function(dictApplicative) {
  var applySecond9 = applySecond(dictApplicative.Apply0());
  var pure75 = pure(dictApplicative);
  return function(dictFoldable) {
    var foldr22 = foldr(dictFoldable);
    return function(f) {
      return foldr22(function($454) {
        return applySecond9(f($454));
      })(pure75(unit));
    };
  };
};
var for_ = function(dictApplicative) {
  var traverse_1 = traverse_(dictApplicative);
  return function(dictFoldable) {
    return flip(traverse_1(dictFoldable));
  };
};
var sequence_ = function(dictApplicative) {
  var traverse_1 = traverse_(dictApplicative);
  return function(dictFoldable) {
    return traverse_1(dictFoldable)(identity6);
  };
};
var foldl = function(dict) {
  return dict.foldl;
};
var intercalate = function(dictFoldable) {
  var foldl22 = foldl(dictFoldable);
  return function(dictMonoid) {
    var append40 = append(dictMonoid.Semigroup0());
    var mempty27 = mempty(dictMonoid);
    return function(sep2) {
      return function(xs) {
        var go = function(v) {
          return function(v1) {
            if (v.init) {
              return {
                init: false,
                acc: v1
              };
            }
            ;
            return {
              init: false,
              acc: append40(v.acc)(append40(sep2)(v1))
            };
          };
        };
        return foldl22(go)({
          init: true,
          acc: mempty27
        })(xs).acc;
      };
    };
  };
};
var maximumBy = function(dictFoldable) {
  var foldl22 = foldl(dictFoldable);
  return function(cmp) {
    var max$prime = function(v) {
      return function(v1) {
        if (v instanceof Nothing) {
          return new Just(v1);
        }
        ;
        if (v instanceof Just) {
          return new Just(function() {
            var $303 = eq12(cmp(v.value0)(v1))(GT.value);
            if ($303) {
              return v.value0;
            }
            ;
            return v1;
          }());
        }
        ;
        throw new Error("Failed pattern match at Data.Foldable (line 441, column 3 - line 441, column 27): " + [v.constructor.name, v1.constructor.name]);
      };
    };
    return foldl22(max$prime)(Nothing.value);
  };
};
var maximum = function(dictOrd) {
  var compare10 = compare(dictOrd);
  return function(dictFoldable) {
    return maximumBy(dictFoldable)(compare10);
  };
};
var foldableMaybe = {
  foldr: function(v) {
    return function(v1) {
      return function(v2) {
        if (v2 instanceof Nothing) {
          return v1;
        }
        ;
        if (v2 instanceof Just) {
          return v(v2.value0)(v1);
        }
        ;
        throw new Error("Failed pattern match at Data.Foldable (line 138, column 1 - line 144, column 27): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
      };
    };
  },
  foldl: function(v) {
    return function(v1) {
      return function(v2) {
        if (v2 instanceof Nothing) {
          return v1;
        }
        ;
        if (v2 instanceof Just) {
          return v(v1)(v2.value0);
        }
        ;
        throw new Error("Failed pattern match at Data.Foldable (line 138, column 1 - line 144, column 27): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
      };
    };
  },
  foldMap: function(dictMonoid) {
    var mempty27 = mempty(dictMonoid);
    return function(v) {
      return function(v1) {
        if (v1 instanceof Nothing) {
          return mempty27;
        }
        ;
        if (v1 instanceof Just) {
          return v(v1.value0);
        }
        ;
        throw new Error("Failed pattern match at Data.Foldable (line 138, column 1 - line 144, column 27): " + [v.constructor.name, v1.constructor.name]);
      };
    };
  }
};
var foldMapDefaultR = function(dictFoldable) {
  var foldr22 = foldr(dictFoldable);
  return function(dictMonoid) {
    var append40 = append(dictMonoid.Semigroup0());
    var mempty27 = mempty(dictMonoid);
    return function(f) {
      return foldr22(function(x) {
        return function(acc) {
          return append40(f(x))(acc);
        };
      })(mempty27);
    };
  };
};
var foldableArray = {
  foldr: foldrArray,
  foldl: foldlArray,
  foldMap: function(dictMonoid) {
    return foldMapDefaultR(foldableArray)(dictMonoid);
  }
};
var foldMap = function(dict) {
  return dict.foldMap;
};
var lookup = function(dictFoldable) {
  var foldMap25 = foldMap(dictFoldable)(monoidFirst);
  return function(dictEq) {
    var eq212 = eq(dictEq);
    return function(a) {
      var $460 = foldMap25(function(v) {
        var $444 = eq212(a)(v.value0);
        if ($444) {
          return new Just(v.value1);
        }
        ;
        return Nothing.value;
      });
      return function($461) {
        return unwrap2($460($461));
      };
    };
  };
};
var fold = function(dictFoldable) {
  var foldMap25 = foldMap(dictFoldable);
  return function(dictMonoid) {
    return foldMap25(dictMonoid)(identity6);
  };
};
var find = function(dictFoldable) {
  var foldl22 = foldl(dictFoldable);
  return function(p) {
    var go = function(v) {
      return function(v1) {
        if (v instanceof Nothing && p(v1)) {
          return new Just(v1);
        }
        ;
        return v;
      };
    };
    return foldl22(go)(Nothing.value);
  };
};
var any2 = function(dictFoldable) {
  var foldMap25 = foldMap(dictFoldable);
  return function(dictHeytingAlgebra) {
    return alaF2(Disj)(foldMap25(monoidDisj(dictHeytingAlgebra)));
  };
};
var elem = function(dictFoldable) {
  var any1 = any2(dictFoldable)(heytingAlgebraBoolean);
  return function(dictEq) {
    var $462 = eq(dictEq);
    return function($463) {
      return any1($462($463));
    };
  };
};
var all2 = function(dictFoldable) {
  var foldMap25 = foldMap(dictFoldable);
  return function(dictHeytingAlgebra) {
    return alaF2(Conj)(foldMap25(monoidConj(dictHeytingAlgebra)));
  };
};
var and = function(dictFoldable) {
  var all1 = all2(dictFoldable);
  return function(dictHeytingAlgebra) {
    return all1(dictHeytingAlgebra)(identity6);
  };
};

// output/Data.FunctorWithIndex/foreign.js
var mapWithIndexArray = function(f) {
  return function(xs) {
    var l = xs.length;
    var result = Array(l);
    for (var i = 0; i < l; i++) {
      result[i] = f(i)(xs[i]);
    }
    return result;
  };
};

// output/Data.Functor.App/index.js
var App = function(x) {
  return x;
};
var semigroupApp = function(dictApply) {
  var lift26 = lift2(dictApply);
  return function(dictSemigroup) {
    var append119 = append(dictSemigroup);
    return {
      append: function(v) {
        return function(v1) {
          return lift26(append119)(v)(v1);
        };
      }
    };
  };
};

// output/Data.FunctorWithIndex/index.js
var mapWithIndex = function(dict) {
  return dict.mapWithIndex;
};
var functorWithIndexArray = {
  mapWithIndex: mapWithIndexArray,
  Functor0: function() {
    return functorArray;
  }
};

// output/Data.Traversable/foreign.js
var traverseArrayImpl = function() {
  function array1(a) {
    return [a];
  }
  function array2(a) {
    return function(b) {
      return [a, b];
    };
  }
  function array3(a) {
    return function(b) {
      return function(c) {
        return [a, b, c];
      };
    };
  }
  function concat22(xs) {
    return function(ys) {
      return xs.concat(ys);
    };
  }
  return function(apply25) {
    return function(map86) {
      return function(pure75) {
        return function(f) {
          return function(array4) {
            function go(bot, top3) {
              switch (top3 - bot) {
                case 0:
                  return pure75([]);
                case 1:
                  return map86(array1)(f(array4[bot]));
                case 2:
                  return apply25(map86(array2)(f(array4[bot])))(f(array4[bot + 1]));
                case 3:
                  return apply25(apply25(map86(array3)(f(array4[bot])))(f(array4[bot + 1])))(f(array4[bot + 2]));
                default:
                  var pivot = bot + Math.floor((top3 - bot) / 4) * 2;
                  return apply25(map86(concat22)(go(bot, pivot)))(go(pivot, top3));
              }
            }
            return go(0, array4.length);
          };
        };
      };
    };
  };
}();

// output/Data.Traversable/index.js
var identity7 = /* @__PURE__ */ identity(categoryFn);
var traverse = function(dict) {
  return dict.traverse;
};
var traversableMaybe = {
  traverse: function(dictApplicative) {
    var pure75 = pure(dictApplicative);
    var map86 = map(dictApplicative.Apply0().Functor0());
    return function(v) {
      return function(v1) {
        if (v1 instanceof Nothing) {
          return pure75(Nothing.value);
        }
        ;
        if (v1 instanceof Just) {
          return map86(Just.create)(v(v1.value0));
        }
        ;
        throw new Error("Failed pattern match at Data.Traversable (line 115, column 1 - line 119, column 33): " + [v.constructor.name, v1.constructor.name]);
      };
    };
  },
  sequence: function(dictApplicative) {
    var pure75 = pure(dictApplicative);
    var map86 = map(dictApplicative.Apply0().Functor0());
    return function(v) {
      if (v instanceof Nothing) {
        return pure75(Nothing.value);
      }
      ;
      if (v instanceof Just) {
        return map86(Just.create)(v.value0);
      }
      ;
      throw new Error("Failed pattern match at Data.Traversable (line 115, column 1 - line 119, column 33): " + [v.constructor.name]);
    };
  },
  Functor0: function() {
    return functorMaybe;
  },
  Foldable1: function() {
    return foldableMaybe;
  }
};
var sequenceDefault = function(dictTraversable) {
  var traverse22 = traverse(dictTraversable);
  return function(dictApplicative) {
    return traverse22(dictApplicative)(identity7);
  };
};
var traversableArray = {
  traverse: function(dictApplicative) {
    var Apply0 = dictApplicative.Apply0();
    return traverseArrayImpl(apply2(Apply0))(map(Apply0.Functor0()))(pure(dictApplicative));
  },
  sequence: function(dictApplicative) {
    return sequenceDefault(traversableArray)(dictApplicative);
  },
  Functor0: function() {
    return functorArray;
  },
  Foldable1: function() {
    return foldableArray;
  }
};
var sequence = function(dict) {
  return dict.sequence;
};
var $$for = function(dictApplicative) {
  return function(dictTraversable) {
    var traverse22 = traverse(dictTraversable)(dictApplicative);
    return function(x) {
      return function(f) {
        return traverse22(f)(x);
      };
    };
  };
};

// output/Data.Unfoldable/foreign.js
var unfoldrArrayImpl = function(isNothing2) {
  return function(fromJust9) {
    return function(fst2) {
      return function(snd2) {
        return function(f) {
          return function(b) {
            var result = [];
            var value4 = b;
            while (true) {
              var maybe3 = f(value4);
              if (isNothing2(maybe3))
                return result;
              var tuple2 = fromJust9(maybe3);
              result.push(fst2(tuple2));
              value4 = snd2(tuple2);
            }
          };
        };
      };
    };
  };
};

// output/Data.Unfoldable1/foreign.js
var unfoldr1ArrayImpl = function(isNothing2) {
  return function(fromJust9) {
    return function(fst2) {
      return function(snd2) {
        return function(f) {
          return function(b) {
            var result = [];
            var value4 = b;
            while (true) {
              var tuple2 = f(value4);
              result.push(fst2(tuple2));
              var maybe3 = snd2(tuple2);
              if (isNothing2(maybe3))
                return result;
              value4 = fromJust9(maybe3);
            }
          };
        };
      };
    };
  };
};

// output/Data.Ord.Min/index.js
var Min = function(x) {
  return x;
};
var semigroupMin = function(dictOrd) {
  var min8 = min(dictOrd);
  return {
    append: function(v) {
      return function(v1) {
        return min8(v)(v1);
      };
    }
  };
};

// output/Data.Semigroup.Foldable/index.js
var ala2 = /* @__PURE__ */ ala()()();
var JoinWith = function(x) {
  return x;
};
var semigroupJoinWith = function(dictSemigroup) {
  var append40 = append(dictSemigroup);
  return {
    append: function(v) {
      return function(v1) {
        return function(j) {
          return append40(v(j))(append40(j)(v1(j)));
        };
      };
    }
  };
};
var joinee = function(v) {
  return v;
};
var foldr1 = function(dict) {
  return dict.foldr1;
};
var foldl1 = function(dict) {
  return dict.foldl1;
};
var foldMap1DefaultL = function(dictFoldable1) {
  var foldl112 = foldl1(dictFoldable1);
  return function(dictFunctor) {
    var map86 = map(dictFunctor);
    return function(dictSemigroup) {
      var append40 = append(dictSemigroup);
      return function(f) {
        var $162 = foldl112(append40);
        var $163 = map86(f);
        return function($164) {
          return $162($163($164));
        };
      };
    };
  };
};
var foldMap1 = function(dict) {
  return dict.foldMap1;
};
var intercalateMap = function(dictFoldable1) {
  var foldMap112 = foldMap1(dictFoldable1);
  return function(dictSemigroup) {
    var foldMap122 = foldMap112(semigroupJoinWith(dictSemigroup));
    return function(j) {
      return function(f) {
        return function(foldable) {
          return joinee(foldMap122(function($171) {
            return JoinWith($$const(f($171)));
          })(foldable))(j);
        };
      };
    };
  };
};
var minimum2 = function(dictOrd) {
  var semigroupMin2 = semigroupMin(dictOrd);
  return function(dictFoldable1) {
    return ala2(Min)(foldMap1(dictFoldable1)(semigroupMin2));
  };
};

// output/Data.Unfoldable1/index.js
var fromJust2 = /* @__PURE__ */ fromJust();
var unfoldr1 = function(dict) {
  return dict.unfoldr1;
};
var unfoldable1Array = {
  unfoldr1: /* @__PURE__ */ unfoldr1ArrayImpl(isNothing)(fromJust2)(fst)(snd)
};

// output/Data.Unfoldable/index.js
var fromJust3 = /* @__PURE__ */ fromJust();
var unfoldr = function(dict) {
  return dict.unfoldr;
};
var unfoldableArray = {
  unfoldr: /* @__PURE__ */ unfoldrArrayImpl(isNothing)(fromJust3)(fst)(snd),
  Unfoldable10: function() {
    return unfoldable1Array;
  }
};

// output/Data.Array/index.js
var $$void4 = /* @__PURE__ */ $$void(functorST);
var intercalate1 = /* @__PURE__ */ intercalate(foldableArray);
var apply3 = /* @__PURE__ */ apply2(applyMaybe);
var map1 = /* @__PURE__ */ map(functorMaybe);
var foldMap12 = /* @__PURE__ */ foldMap(foldableArray);
var fold1 = /* @__PURE__ */ fold(foldableArray);
var append2 = /* @__PURE__ */ append(semigroupArray);
var traverse2 = /* @__PURE__ */ traverse(traversableArray);
var zip = /* @__PURE__ */ function() {
  return zipWith(Tuple.create);
}();
var unsafeIndex = function() {
  return unsafeIndexImpl;
};
var unsafeIndex1 = /* @__PURE__ */ unsafeIndex();
var uncons = /* @__PURE__ */ function() {
  return unconsImpl($$const(Nothing.value))(function(x) {
    return function(xs) {
      return new Just({
        head: x,
        tail: xs
      });
    };
  });
}();
var toUnfoldable = function(dictUnfoldable) {
  var unfoldr4 = unfoldr(dictUnfoldable);
  return function(xs) {
    var len = length(xs);
    var f = function(i) {
      if (i < len) {
        return new Just(new Tuple(unsafeIndex1(xs)(i), i + 1 | 0));
      }
      ;
      if (otherwise) {
        return Nothing.value;
      }
      ;
      throw new Error("Failed pattern match at Data.Array (line 158, column 3 - line 160, column 26): " + [i.constructor.name]);
    };
    return unfoldr4(f)(0);
  };
};
var take = function(n) {
  return function(xs) {
    var $149 = n < 1;
    if ($149) {
      return [];
    }
    ;
    return slice(0)(n)(xs);
  };
};
var tail = /* @__PURE__ */ function() {
  return unconsImpl($$const(Nothing.value))(function(v) {
    return function(xs) {
      return new Just(xs);
    };
  });
}();
var sortBy = function(comp) {
  return sortByImpl(comp)(function(v) {
    if (v instanceof GT) {
      return 1;
    }
    ;
    if (v instanceof EQ) {
      return 0;
    }
    ;
    if (v instanceof LT) {
      return -1 | 0;
    }
    ;
    throw new Error("Failed pattern match at Data.Array (line 870, column 31 - line 873, column 11): " + [v.constructor.name]);
  });
};
var sort = function(dictOrd) {
  var compare10 = compare(dictOrd);
  return function(xs) {
    return sortBy(compare10)(xs);
  };
};
var snoc = function(xs) {
  return function(x) {
    return withArray(push(x))(xs)();
  };
};
var singleton2 = function(a) {
  return [a];
};
var $$null = function(xs) {
  return length(xs) === 0;
};
var mapWithIndex2 = /* @__PURE__ */ mapWithIndex(functorWithIndexArray);
var intersperse = function(a) {
  return function(arr) {
    var v = length(arr);
    if (v < 2) {
      return arr;
    }
    ;
    if (otherwise) {
      return run2(function() {
        var unsafeGetElem = function(idx) {
          return unsafeIndex1(arr)(idx);
        };
        return function __do3() {
          var out = newSTArray();
          push(unsafeGetElem(0))(out)();
          forST(1)(v)(function(idx) {
            return function __do4() {
              push(a)(out)();
              return $$void4(push(unsafeGetElem(idx))(out))();
            };
          })();
          return out;
        };
      }());
    }
    ;
    throw new Error("Failed pattern match at Data.Array (line 613, column 21 - line 622, column 19): " + [v.constructor.name]);
  };
};
var intercalate2 = function(dictMonoid) {
  return intercalate1(dictMonoid);
};
var init = function(xs) {
  if ($$null(xs)) {
    return Nothing.value;
  }
  ;
  if (otherwise) {
    return new Just(slice(0)(length(xs) - 1 | 0)(xs));
  }
  ;
  throw new Error("Failed pattern match at Data.Array (line 340, column 1 - line 340, column 45): " + [xs.constructor.name]);
};
var index = /* @__PURE__ */ function() {
  return indexImpl(Just.create)(Nothing.value);
}();
var last = function(xs) {
  return index(xs)(length(xs) - 1 | 0);
};
var unsnoc = function(xs) {
  return apply3(map1(function(v) {
    return function(v1) {
      return {
        init: v,
        last: v1
      };
    };
  })(init(xs)))(last(xs));
};
var span = function(p) {
  return function(arr) {
    var go = function($copy_i) {
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(i) {
        var v = index(arr)(i);
        if (v instanceof Just) {
          var $156 = p(v.value0);
          if ($156) {
            $copy_i = i + 1 | 0;
            return;
          }
          ;
          $tco_done = true;
          return new Just(i);
        }
        ;
        if (v instanceof Nothing) {
          $tco_done = true;
          return Nothing.value;
        }
        ;
        throw new Error("Failed pattern match at Data.Array (line 1005, column 5 - line 1007, column 25): " + [v.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($copy_i);
      }
      ;
      return $tco_result;
    };
    var breakIndex = go(0);
    if (breakIndex instanceof Just && breakIndex.value0 === 0) {
      return {
        init: [],
        rest: arr
      };
    }
    ;
    if (breakIndex instanceof Just) {
      return {
        init: slice(0)(breakIndex.value0)(arr),
        rest: slice(breakIndex.value0)(length(arr))(arr)
      };
    }
    ;
    if (breakIndex instanceof Nothing) {
      return {
        init: arr,
        rest: []
      };
    }
    ;
    throw new Error("Failed pattern match at Data.Array (line 992, column 3 - line 998, column 30): " + [breakIndex.constructor.name]);
  };
};
var takeWhile = function(p) {
  return function(xs) {
    return span(p)(xs).init;
  };
};
var head = function(xs) {
  return index(xs)(0);
};
var groupBy = function(op) {
  return function(xs) {
    return function __do3() {
      var result = newSTArray();
      var iter = iterator(function(v) {
        return index(xs)(v);
      })();
      iterate(iter)(function(x) {
        return $$void4(function __do4() {
          var sub1 = newSTArray();
          push(x)(sub1)();
          pushWhile(op(x))(iter)(sub1)();
          var grp = unsafeFreeze(sub1)();
          return push(grp)(result)();
        });
      })();
      return unsafeFreeze(result)();
    }();
  };
};
var fromFoldable = function(dictFoldable) {
  return fromFoldableImpl(foldr(dictFoldable));
};
var foldr2 = /* @__PURE__ */ foldr(foldableArray);
var foldl2 = /* @__PURE__ */ foldl(foldableArray);
var foldMap2 = function(dictMonoid) {
  return foldMap12(dictMonoid);
};
var foldM = function(dictMonad) {
  var pure122 = pure(dictMonad.Applicative0());
  var bind122 = bind(dictMonad.Bind1());
  return function(f) {
    return function(b) {
      return unconsImpl(function(v) {
        return pure122(b);
      })(function(a) {
        return function(as3) {
          return bind122(f(b)(a))(function(b$prime) {
            return foldM(dictMonad)(f)(b$prime)(as3);
          });
        };
      });
    };
  };
};
var fold2 = function(dictMonoid) {
  return fold1(dictMonoid);
};
var findIndex = /* @__PURE__ */ function() {
  return findIndexImpl(Just.create)(Nothing.value);
}();
var find2 = function(f) {
  return function(xs) {
    return map1(unsafeIndex1(xs))(findIndex(f)(xs));
  };
};
var elemIndex = function(dictEq) {
  var eq212 = eq(dictEq);
  return function(x) {
    return findIndex(function(v) {
      return eq212(v)(x);
    });
  };
};
var notElem2 = function(dictEq) {
  var elemIndex1 = elemIndex(dictEq);
  return function(a) {
    return function(arr) {
      return isNothing(elemIndex1(a)(arr));
    };
  };
};
var elem2 = function(dictEq) {
  var elemIndex1 = elemIndex(dictEq);
  return function(a) {
    return function(arr) {
      return isJust(elemIndex1(a)(arr));
    };
  };
};
var drop = function(n) {
  return function(xs) {
    var $173 = n < 1;
    if ($173) {
      return xs;
    }
    ;
    return slice(n)(length(xs))(xs);
  };
};
var cons = function(x) {
  return function(xs) {
    return append2([x])(xs);
  };
};
var some = function(dictAlternative) {
  var apply111 = apply2(dictAlternative.Applicative0().Apply0());
  var map315 = map(dictAlternative.Plus1().Alt0().Functor0());
  return function(dictLazy) {
    var defer6 = defer(dictLazy);
    return function(v) {
      return apply111(map315(cons)(v))(defer6(function(v1) {
        return many(dictAlternative)(dictLazy)(v);
      }));
    };
  };
};
var many = function(dictAlternative) {
  var alt32 = alt(dictAlternative.Plus1().Alt0());
  var pure122 = pure(dictAlternative.Applicative0());
  return function(dictLazy) {
    return function(v) {
      return alt32(some(dictAlternative)(dictLazy)(v))(pure122([]));
    };
  };
};
var concatMap = /* @__PURE__ */ flip(/* @__PURE__ */ bind(bindArray));
var mapMaybe = function(f) {
  return concatMap(function() {
    var $191 = maybe([])(singleton2);
    return function($192) {
      return $191(f($192));
    };
  }());
};
var filterA = function(dictApplicative) {
  var traverse12 = traverse2(dictApplicative);
  var map315 = map(dictApplicative.Apply0().Functor0());
  return function(p) {
    var $193 = map315(mapMaybe(function(v) {
      if (v.value1) {
        return new Just(v.value0);
      }
      ;
      return Nothing.value;
    }));
    var $194 = traverse12(function(x) {
      return map315(Tuple.create(x))(p(x));
    });
    return function($195) {
      return $193($194($195));
    };
  };
};
var catMaybes = /* @__PURE__ */ mapMaybe(/* @__PURE__ */ identity(categoryFn));

// output/Data.Array.NonEmpty.Internal/foreign.js
var foldr1Impl = function(f) {
  return function(xs) {
    var acc = xs[xs.length - 1];
    for (var i = xs.length - 2; i >= 0; i--) {
      acc = f(xs[i])(acc);
    }
    return acc;
  };
};
var foldl1Impl = function(f) {
  return function(xs) {
    var acc = xs[0];
    var len = xs.length;
    for (var i = 1; i < len; i++) {
      acc = f(acc)(xs[i]);
    }
    return acc;
  };
};
var traverse1Impl = function() {
  function Cont(fn) {
    this.fn = fn;
  }
  var emptyList = {};
  var ConsCell = function(head6, tail3) {
    this.head = head6;
    this.tail = tail3;
  };
  function finalCell(head6) {
    return new ConsCell(head6, emptyList);
  }
  function consList(x) {
    return function(xs) {
      return new ConsCell(x, xs);
    };
  }
  function listToArray(list2) {
    var arr = [];
    var xs = list2;
    while (xs !== emptyList) {
      arr.push(xs.head);
      xs = xs.tail;
    }
    return arr;
  }
  return function(apply25) {
    return function(map86) {
      return function(f) {
        var buildFrom = function(x, ys) {
          return apply25(map86(consList)(f(x)))(ys);
        };
        var go = function(acc, currentLen, xs) {
          if (currentLen === 0) {
            return acc;
          } else {
            var last4 = xs[currentLen - 1];
            return new Cont(function() {
              var built = go(buildFrom(last4, acc), currentLen - 1, xs);
              return built;
            });
          }
        };
        return function(array2) {
          var acc = map86(finalCell)(f(array2[array2.length - 1]));
          var result = go(acc, array2.length - 1, array2);
          while (result instanceof Cont) {
            result = result.fn();
          }
          return map86(listToArray)(result);
        };
      };
    };
  };
}();

// output/Data.FoldableWithIndex/index.js
var foldr8 = /* @__PURE__ */ foldr(foldableArray);
var mapWithIndex3 = /* @__PURE__ */ mapWithIndex(functorWithIndexArray);
var foldl8 = /* @__PURE__ */ foldl(foldableArray);
var unwrap3 = /* @__PURE__ */ unwrap();
var foldrWithIndex = function(dict) {
  return dict.foldrWithIndex;
};
var traverseWithIndex_ = function(dictApplicative) {
  var applySecond9 = applySecond(dictApplicative.Apply0());
  var pure75 = pure(dictApplicative);
  return function(dictFoldableWithIndex) {
    var foldrWithIndex1 = foldrWithIndex(dictFoldableWithIndex);
    return function(f) {
      return foldrWithIndex1(function(i) {
        var $289 = f(i);
        return function($290) {
          return applySecond9($289($290));
        };
      })(pure75(unit));
    };
  };
};
var forWithIndex_ = function(dictApplicative) {
  var traverseWithIndex_1 = traverseWithIndex_(dictApplicative);
  return function(dictFoldableWithIndex) {
    return flip(traverseWithIndex_1(dictFoldableWithIndex));
  };
};
var foldlWithIndex = function(dict) {
  return dict.foldlWithIndex;
};
var foldMapWithIndexDefaultR = function(dictFoldableWithIndex) {
  var foldrWithIndex1 = foldrWithIndex(dictFoldableWithIndex);
  return function(dictMonoid) {
    var append40 = append(dictMonoid.Semigroup0());
    var mempty27 = mempty(dictMonoid);
    return function(f) {
      return foldrWithIndex1(function(i) {
        return function(x) {
          return function(acc) {
            return append40(f(i)(x))(acc);
          };
        };
      })(mempty27);
    };
  };
};
var foldableWithIndexArray = {
  foldrWithIndex: function(f) {
    return function(z) {
      var $291 = foldr8(function(v) {
        return function(y) {
          return f(v.value0)(v.value1)(y);
        };
      })(z);
      var $292 = mapWithIndex3(Tuple.create);
      return function($293) {
        return $291($292($293));
      };
    };
  },
  foldlWithIndex: function(f) {
    return function(z) {
      var $294 = foldl8(function(y) {
        return function(v) {
          return f(v.value0)(y)(v.value1);
        };
      })(z);
      var $295 = mapWithIndex3(Tuple.create);
      return function($296) {
        return $294($295($296));
      };
    };
  },
  foldMapWithIndex: function(dictMonoid) {
    return foldMapWithIndexDefaultR(foldableWithIndexArray)(dictMonoid);
  },
  Foldable0: function() {
    return foldableArray;
  }
};
var foldMapWithIndex = function(dict) {
  return dict.foldMapWithIndex;
};
var anyWithIndex = function(dictFoldableWithIndex) {
  var foldMapWithIndex12 = foldMapWithIndex(dictFoldableWithIndex);
  return function(dictHeytingAlgebra) {
    var foldMapWithIndex23 = foldMapWithIndex12(monoidDisj(dictHeytingAlgebra));
    return function(t) {
      var $317 = foldMapWithIndex23(function(i) {
        var $319 = t(i);
        return function($320) {
          return Disj($319($320));
        };
      });
      return function($318) {
        return unwrap3($317($318));
      };
    };
  };
};

// output/Data.TraversableWithIndex/index.js
var traverseWithIndexDefault = function(dictTraversableWithIndex) {
  var sequence4 = sequence(dictTraversableWithIndex.Traversable2());
  var mapWithIndex5 = mapWithIndex(dictTraversableWithIndex.FunctorWithIndex0());
  return function(dictApplicative) {
    var sequence12 = sequence4(dictApplicative);
    return function(f) {
      var $174 = mapWithIndex5(f);
      return function($175) {
        return sequence12($174($175));
      };
    };
  };
};
var traverseWithIndex = function(dict) {
  return dict.traverseWithIndex;
};
var traversableWithIndexArray = {
  traverseWithIndex: function(dictApplicative) {
    return traverseWithIndexDefault(traversableWithIndexArray)(dictApplicative);
  },
  FunctorWithIndex0: function() {
    return functorWithIndexArray;
  },
  FoldableWithIndex1: function() {
    return foldableWithIndexArray;
  },
  Traversable2: function() {
    return traversableArray;
  }
};
var forWithIndex = function(dictApplicative) {
  return function(dictTraversableWithIndex) {
    return flip(traverseWithIndex(dictTraversableWithIndex)(dictApplicative));
  };
};

// output/Data.Array.NonEmpty.Internal/index.js
var NonEmptyArray = function(x) {
  return x;
};
var unfoldable1NonEmptyArray = unfoldable1Array;
var traversableNonEmptyArray = traversableArray;
var showNonEmptyArray = function(dictShow) {
  var show48 = show(showArray(dictShow));
  return {
    show: function(v) {
      return "(NonEmptyArray " + (show48(v) + ")");
    }
  };
};
var semigroupNonEmptyArray = semigroupArray;
var functorNonEmptyArray = functorArray;
var foldableNonEmptyArray = foldableArray;
var foldable1NonEmptyArray = {
  foldMap1: function(dictSemigroup) {
    return foldMap1DefaultL(foldable1NonEmptyArray)(functorNonEmptyArray)(dictSemigroup);
  },
  foldr1: foldr1Impl,
  foldl1: foldl1Impl,
  Foldable0: function() {
    return foldableNonEmptyArray;
  }
};

// output/Data.NonEmpty/index.js
var map7 = /* @__PURE__ */ map(functorTuple);
var map12 = /* @__PURE__ */ map(functorMaybe);
var NonEmpty = /* @__PURE__ */ function() {
  function NonEmpty2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  NonEmpty2.create = function(value0) {
    return function(value12) {
      return new NonEmpty2(value0, value12);
    };
  };
  return NonEmpty2;
}();
var unfoldable1NonEmpty = function(dictUnfoldable) {
  var unfoldr4 = unfoldr(dictUnfoldable);
  return {
    unfoldr1: function(f) {
      return function(b) {
        return uncurry(NonEmpty.create)(map7(unfoldr4(map12(f)))(f(b)));
      };
    }
  };
};
var singleton3 = function(dictPlus) {
  var empty9 = empty(dictPlus);
  return function(a) {
    return new NonEmpty(a, empty9);
  };
};
var functorNonEmpty = function(dictFunctor) {
  var map222 = map(dictFunctor);
  return {
    map: function(f) {
      return function(m) {
        return new NonEmpty(f(m.value0), map222(f)(m.value1));
      };
    }
  };
};
var foldableNonEmpty = function(dictFoldable) {
  var foldMap21 = foldMap(dictFoldable);
  var foldl16 = foldl(dictFoldable);
  var foldr14 = foldr(dictFoldable);
  return {
    foldMap: function(dictMonoid) {
      var append119 = append(dictMonoid.Semigroup0());
      var foldMap111 = foldMap21(dictMonoid);
      return function(f) {
        return function(v) {
          return append119(f(v.value0))(foldMap111(f)(v.value1));
        };
      };
    },
    foldl: function(f) {
      return function(b) {
        return function(v) {
          return foldl16(f)(f(b)(v.value0))(v.value1);
        };
      };
    },
    foldr: function(f) {
      return function(b) {
        return function(v) {
          return f(v.value0)(foldr14(f)(b)(v.value1));
        };
      };
    }
  };
};
var foldable1NonEmpty = function(dictFoldable) {
  var foldl16 = foldl(dictFoldable);
  var foldr14 = foldr(dictFoldable);
  var foldableNonEmpty1 = foldableNonEmpty(dictFoldable);
  return {
    foldMap1: function(dictSemigroup) {
      var append119 = append(dictSemigroup);
      return function(f) {
        return function(v) {
          return foldl16(function(s) {
            return function(a1) {
              return append119(s)(f(a1));
            };
          })(f(v.value0))(v.value1);
        };
      };
    },
    foldr1: function(f) {
      return function(v) {
        return maybe(v.value0)(f(v.value0))(foldr14(function(a1) {
          var $250 = maybe(a1)(f(a1));
          return function($251) {
            return Just.create($250($251));
          };
        })(Nothing.value)(v.value1));
      };
    },
    foldl1: function(f) {
      return function(v) {
        return foldl16(f)(v.value0)(v.value1);
      };
    },
    Foldable0: function() {
      return foldableNonEmpty1;
    }
  };
};

// output/Data.Array.NonEmpty/index.js
var foldMap11 = /* @__PURE__ */ foldMap1(foldable1NonEmptyArray);
var fromJust4 = /* @__PURE__ */ fromJust();
var unsafeFromArray = NonEmptyArray;
var toArray = function(v) {
  return v;
};
var snoc$prime = function(xs) {
  return function(x) {
    return unsafeFromArray(snoc(xs)(x));
  };
};
var snoc2 = function(xs) {
  return function(x) {
    return unsafeFromArray(snoc(toArray(xs))(x));
  };
};
var singleton4 = function($110) {
  return unsafeFromArray(singleton2($110));
};
var fromArray = function(xs) {
  if (length(xs) > 0) {
    return new Just(unsafeFromArray(xs));
  }
  ;
  if (otherwise) {
    return Nothing.value;
  }
  ;
  throw new Error("Failed pattern match at Data.Array.NonEmpty (line 161, column 1 - line 161, column 58): " + [xs.constructor.name]);
};
var fromFoldable2 = function(dictFoldable) {
  var $119 = fromFoldable(dictFoldable);
  return function($120) {
    return fromArray($119($120));
  };
};
var foldMap13 = function(dictSemigroup) {
  return foldMap11(dictSemigroup);
};
var cons$prime = function(x) {
  return function(xs) {
    return unsafeFromArray(cons(x)(xs));
  };
};
var adaptMaybe = function(f) {
  return function($126) {
    return fromJust4(f(toArray($126)));
  };
};
var head2 = /* @__PURE__ */ adaptMaybe(head);
var init2 = /* @__PURE__ */ adaptMaybe(init);
var last2 = /* @__PURE__ */ adaptMaybe(last);
var tail2 = /* @__PURE__ */ adaptMaybe(tail);
var uncons2 = /* @__PURE__ */ adaptMaybe(uncons);
var adaptAny = function(f) {
  return function($128) {
    return f(toArray($128));
  };
};
var takeWhile2 = function(f) {
  return adaptAny(takeWhile(f));
};
var toUnfoldable2 = function(dictUnfoldable) {
  return adaptAny(toUnfoldable(dictUnfoldable));
};
var unsafeAdapt = function(f) {
  var $129 = adaptAny(f);
  return function($130) {
    return unsafeFromArray($129($130));
  };
};
var cons2 = function(x) {
  return unsafeAdapt(cons(x));
};

// output/Data.Codec/index.js
var map8 = /* @__PURE__ */ map(functorTuple);
var Codec = /* @__PURE__ */ function() {
  function Codec2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Codec2.create = function(value0) {
    return function(value12) {
      return new Codec2(value0, value12);
    };
  };
  return Codec2;
}();
var profunctorCodec = function(dictFunctor) {
  var map136 = map(dictFunctor);
  return {
    dimap: function(f) {
      return function(g) {
        return function(v) {
          return new Codec(function() {
            var $78 = map136(g);
            return function($79) {
              return $78(v.value0($79));
            };
          }(), function() {
            var $80 = map8(g);
            return function($81) {
              return $80(v.value1(f($81)));
            };
          }());
        };
      };
    }
  };
};
var encode = function(v) {
  return function($87) {
    return fst(v.value1($87));
  };
};
var decode = function(v) {
  return v.value0;
};
var codec$prime = function(f) {
  return function(g) {
    return new Codec(f, function(b) {
      return new Tuple(g(b), b);
    });
  };
};
var codec = function(f) {
  return function(g) {
    return new Codec(f, function(b) {
      return new Tuple(g(b), b);
    });
  };
};

// output/Data.Argonaut.Core/foreign.js
function id(x) {
  return x;
}
var jsonNull = null;
function stringify(j) {
  return JSON.stringify(j);
}
function stringifyWithIndent(i) {
  return function(j) {
    return JSON.stringify(j, null, i);
  };
}
function _caseJson(isNull3, isBool, isNum, isStr, isArr, isObj, j) {
  if (j == null)
    return isNull3();
  else if (typeof j === "boolean")
    return isBool(j);
  else if (typeof j === "number")
    return isNum(j);
  else if (typeof j === "string")
    return isStr(j);
  else if (Object.prototype.toString.call(j) === "[object Array]")
    return isArr(j);
  else
    return isObj(j);
}

// output/Foreign.Object/foreign.js
function _copyST(m) {
  return function() {
    var r = {};
    for (var k in m) {
      if (hasOwnProperty.call(m, k)) {
        r[k] = m[k];
      }
    }
    return r;
  };
}
var empty2 = {};
function runST(f) {
  return f();
}
function _foldM(bind59) {
  return function(f) {
    return function(mz) {
      return function(m) {
        var acc = mz;
        function g(k2) {
          return function(z) {
            return f(z)(k2)(m[k2]);
          };
        }
        for (var k in m) {
          if (hasOwnProperty.call(m, k)) {
            acc = bind59(acc)(g(k));
          }
        }
        return acc;
      };
    };
  };
}
function all3(f) {
  return function(m) {
    for (var k in m) {
      if (hasOwnProperty.call(m, k) && !f(k)(m[k]))
        return false;
    }
    return true;
  };
}
function _lookup(no, yes, k, m) {
  return k in m ? yes(m[k]) : no;
}
function toArrayWithKey(f) {
  return function(m) {
    var r = [];
    for (var k in m) {
      if (hasOwnProperty.call(m, k)) {
        r.push(f(k)(m[k]));
      }
    }
    return r;
  };
}
var keys = Object.keys || toArrayWithKey(function(k) {
  return function() {
    return k;
  };
});

// output/Data.Function.Uncurried/foreign.js
var mkFn5 = function(fn) {
  return function(a, b, c, d, e) {
    return fn(a)(b)(c)(d)(e);
  };
};
var runFn3 = function(fn) {
  return function(a) {
    return function(b) {
      return function(c) {
        return fn(a, b, c);
      };
    };
  };
};
var runFn4 = function(fn) {
  return function(a) {
    return function(b) {
      return function(c) {
        return function(d) {
          return fn(a, b, c, d);
        };
      };
    };
  };
};

// output/Data.Function.Uncurried/index.js
var runFn1 = function(f) {
  return f;
};

// output/Foreign.Object.ST/foreign.js
var newImpl = function() {
  return {};
};
function poke2(k) {
  return function(v) {
    return function(m) {
      return function() {
        m[k] = v;
        return m;
      };
    };
  };
}
var deleteImpl = function(k) {
  return function(m) {
    return function() {
      delete m[k];
      return m;
    };
  };
};

// output/Foreign.Object/index.js
var $$void5 = /* @__PURE__ */ $$void(functorST);
var toUnfoldable3 = function(dictUnfoldable) {
  var $89 = toUnfoldable(dictUnfoldable);
  var $90 = toArrayWithKey(Tuple.create);
  return function($91) {
    return $89($90($91));
  };
};
var thawST = _copyST;
var mutate = function(f) {
  return function(m) {
    return runST(function __do3() {
      var s = thawST(m)();
      f(s)();
      return s;
    });
  };
};
var lookup2 = /* @__PURE__ */ function() {
  return runFn4(_lookup)(Nothing.value)(Just.create);
}();
var isEmpty = /* @__PURE__ */ all3(function(v) {
  return function(v1) {
    return false;
  };
});
var insert2 = function(k) {
  return function(v) {
    return mutate(poke2(k)(v));
  };
};
var fromHomogeneous = function() {
  return unsafeCoerce2;
};
var fromFoldable3 = function(dictFoldable) {
  var fromFoldable116 = fromFoldable(dictFoldable);
  return function(l) {
    return runST(function __do3() {
      var s = newImpl();
      foreach(fromFoldable116(l))(function(v) {
        return $$void5(poke2(v.value0)(v.value1)(s));
      })();
      return s;
    });
  };
};
var foldM2 = function(dictMonad) {
  var bind122 = bind(dictMonad.Bind1());
  var pure122 = pure(dictMonad.Applicative0());
  return function(f) {
    return function(z) {
      return _foldM(bind122)(f)(pure122(z));
    };
  };
};
var foldM1 = /* @__PURE__ */ foldM2(monadST);
var union = function(m) {
  return mutate(function(s) {
    return foldM1(function(s$prime) {
      return function(k) {
        return function(v) {
          return poke2(k)(v)(s$prime);
        };
      };
    })(s)(m);
  });
};
var fold3 = /* @__PURE__ */ _foldM(applyFlipped);
var $$delete2 = function(k) {
  return mutate(deleteImpl(k));
};
var alter = function(f) {
  return function(k) {
    return function(m) {
      var v = f(lookup2(k)(m));
      if (v instanceof Nothing) {
        return $$delete2(k)(m);
      }
      ;
      if (v instanceof Just) {
        return insert2(k)(v.value0)(m);
      }
      ;
      throw new Error("Failed pattern match at Foreign.Object (line 210, column 15 - line 212, column 25): " + [v.constructor.name]);
    };
  };
};

// output/Data.Argonaut.Core/index.js
var verbJsonType = function(def) {
  return function(f) {
    return function(g) {
      return g(def)(f);
    };
  };
};
var toJsonType = /* @__PURE__ */ function() {
  return verbJsonType(Nothing.value)(Just.create);
}();
var jsonEmptyObject = /* @__PURE__ */ id(empty2);
var isJsonType = /* @__PURE__ */ verbJsonType(false)(/* @__PURE__ */ $$const(true));
var caseJsonString = function(d) {
  return function(f) {
    return function(j) {
      return _caseJson($$const(d), $$const(d), $$const(d), f, $$const(d), $$const(d), j);
    };
  };
};
var toString = /* @__PURE__ */ toJsonType(caseJsonString);
var caseJsonObject = function(d) {
  return function(f) {
    return function(j) {
      return _caseJson($$const(d), $$const(d), $$const(d), $$const(d), $$const(d), f, j);
    };
  };
};
var toObject = /* @__PURE__ */ toJsonType(caseJsonObject);
var caseJsonNumber = function(d) {
  return function(f) {
    return function(j) {
      return _caseJson($$const(d), $$const(d), f, $$const(d), $$const(d), $$const(d), j);
    };
  };
};
var toNumber = /* @__PURE__ */ toJsonType(caseJsonNumber);
var caseJsonNull = function(d) {
  return function(f) {
    return function(j) {
      return _caseJson(f, $$const(d), $$const(d), $$const(d), $$const(d), $$const(d), j);
    };
  };
};
var isNull = /* @__PURE__ */ isJsonType(caseJsonNull);
var caseJsonBoolean = function(d) {
  return function(f) {
    return function(j) {
      return _caseJson($$const(d), f, $$const(d), $$const(d), $$const(d), $$const(d), j);
    };
  };
};
var toBoolean = /* @__PURE__ */ toJsonType(caseJsonBoolean);
var caseJsonArray = function(d) {
  return function(f) {
    return function(j) {
      return _caseJson($$const(d), $$const(d), $$const(d), $$const(d), f, $$const(d), j);
    };
  };
};
var toArray2 = /* @__PURE__ */ toJsonType(caseJsonArray);

// output/Data.Int/foreign.js
var fromNumberImpl = function(just) {
  return function(nothing) {
    return function(n) {
      return (n | 0) === n ? just(n) : nothing;
    };
  };
};
var toNumber2 = function(n) {
  return n;
};
var fromStringAsImpl = function(just) {
  return function(nothing) {
    return function(radix) {
      var digits;
      if (radix < 11) {
        digits = "[0-" + (radix - 1).toString() + "]";
      } else if (radix === 11) {
        digits = "[0-9a]";
      } else {
        digits = "[0-9a-" + String.fromCharCode(86 + radix) + "]";
      }
      var pattern = new RegExp("^[\\+\\-]?" + digits + "+$", "i");
      return function(s) {
        if (pattern.test(s)) {
          var i = parseInt(s, radix);
          return (i | 0) === i ? just(i) : nothing;
        } else {
          return nothing;
        }
      };
    };
  };
};
var toStringAs = function(radix) {
  return function(i) {
    return i.toString(radix);
  };
};
var pow = function(x) {
  return function(y) {
    return Math.pow(x, y) | 0;
  };
};

// output/Data.Number/foreign.js
var infinity = Infinity;
var isFiniteImpl = isFinite;
function fromStringImpl(str2, isFinite2, just, nothing) {
  var num = parseFloat(str2);
  if (isFinite2(num)) {
    return just(num);
  } else {
    return nothing;
  }
}
var ceil = Math.ceil;
var floor = Math.floor;
var round = Math.round;

// output/Data.Number/index.js
var fromString = function(str2) {
  return fromStringImpl(str2, isFiniteImpl, Just.create, Nothing.value);
};

// output/Data.Int/index.js
var top2 = /* @__PURE__ */ top(boundedInt);
var bottom2 = /* @__PURE__ */ bottom(boundedInt);
var hexadecimal = 16;
var fromStringAs = /* @__PURE__ */ function() {
  return fromStringAsImpl(Just.create)(Nothing.value);
}();
var fromString2 = /* @__PURE__ */ fromStringAs(10);
var fromNumber = /* @__PURE__ */ function() {
  return fromNumberImpl(Just.create)(Nothing.value);
}();
var unsafeClamp = function(x) {
  if (!isFiniteImpl(x)) {
    return 0;
  }
  ;
  if (x >= toNumber2(top2)) {
    return top2;
  }
  ;
  if (x <= toNumber2(bottom2)) {
    return bottom2;
  }
  ;
  if (otherwise) {
    return fromMaybe(0)(fromNumber(x));
  }
  ;
  throw new Error("Failed pattern match at Data.Int (line 72, column 1 - line 72, column 29): " + [x.constructor.name]);
};
var round2 = function($37) {
  return unsafeClamp(round($37));
};
var floor2 = function($39) {
  return unsafeClamp(floor($39));
};
var decimal = 10;
var ceil2 = function($40) {
  return unsafeClamp(ceil($40));
};

// output/Data.List.Types/index.js
var Nil = /* @__PURE__ */ function() {
  function Nil4() {
  }
  ;
  Nil4.value = new Nil4();
  return Nil4;
}();
var Cons = /* @__PURE__ */ function() {
  function Cons4(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Cons4.create = function(value0) {
    return function(value12) {
      return new Cons4(value0, value12);
    };
  };
  return Cons4;
}();
var NonEmptyList = function(x) {
  return x;
};
var toList = function(v) {
  return new Cons(v.value0, v.value1);
};
var listMap = function(f) {
  var chunkedRevMap = function($copy_v) {
    return function($copy_v1) {
      var $tco_var_v = $copy_v;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(v, v1) {
        if (v1 instanceof Cons && (v1.value1 instanceof Cons && v1.value1.value1 instanceof Cons)) {
          $tco_var_v = new Cons(v1, v);
          $copy_v1 = v1.value1.value1.value1;
          return;
        }
        ;
        var unrolledMap = function(v2) {
          if (v2 instanceof Cons && (v2.value1 instanceof Cons && v2.value1.value1 instanceof Nil)) {
            return new Cons(f(v2.value0), new Cons(f(v2.value1.value0), Nil.value));
          }
          ;
          if (v2 instanceof Cons && v2.value1 instanceof Nil) {
            return new Cons(f(v2.value0), Nil.value);
          }
          ;
          return Nil.value;
        };
        var reverseUnrolledMap = function($copy_v2) {
          return function($copy_v3) {
            var $tco_var_v2 = $copy_v2;
            var $tco_done1 = false;
            var $tco_result2;
            function $tco_loop2(v2, v3) {
              if (v2 instanceof Cons && (v2.value0 instanceof Cons && (v2.value0.value1 instanceof Cons && v2.value0.value1.value1 instanceof Cons))) {
                $tco_var_v2 = v2.value1;
                $copy_v3 = new Cons(f(v2.value0.value0), new Cons(f(v2.value0.value1.value0), new Cons(f(v2.value0.value1.value1.value0), v3)));
                return;
              }
              ;
              $tco_done1 = true;
              return v3;
            }
            ;
            while (!$tco_done1) {
              $tco_result2 = $tco_loop2($tco_var_v2, $copy_v3);
            }
            ;
            return $tco_result2;
          };
        };
        $tco_done = true;
        return reverseUnrolledMap(v)(unrolledMap(v1));
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_v, $copy_v1);
      }
      ;
      return $tco_result;
    };
  };
  return chunkedRevMap(Nil.value);
};
var functorList = {
  map: listMap
};
var map9 = /* @__PURE__ */ map(functorList);
var functorNonEmptyList = /* @__PURE__ */ functorNonEmpty(functorList);
var foldableList = {
  foldr: function(f) {
    return function(b) {
      var rev = function() {
        var go = function($copy_v) {
          return function($copy_v1) {
            var $tco_var_v = $copy_v;
            var $tco_done = false;
            var $tco_result;
            function $tco_loop(v, v1) {
              if (v1 instanceof Nil) {
                $tco_done = true;
                return v;
              }
              ;
              if (v1 instanceof Cons) {
                $tco_var_v = new Cons(v1.value0, v);
                $copy_v1 = v1.value1;
                return;
              }
              ;
              throw new Error("Failed pattern match at Data.List.Types (line 107, column 7 - line 107, column 23): " + [v.constructor.name, v1.constructor.name]);
            }
            ;
            while (!$tco_done) {
              $tco_result = $tco_loop($tco_var_v, $copy_v1);
            }
            ;
            return $tco_result;
          };
        };
        return go(Nil.value);
      }();
      var $284 = foldl(foldableList)(flip(f))(b);
      return function($285) {
        return $284(rev($285));
      };
    };
  },
  foldl: function(f) {
    var go = function($copy_b) {
      return function($copy_v) {
        var $tco_var_b = $copy_b;
        var $tco_done1 = false;
        var $tco_result;
        function $tco_loop(b, v) {
          if (v instanceof Nil) {
            $tco_done1 = true;
            return b;
          }
          ;
          if (v instanceof Cons) {
            $tco_var_b = f(b)(v.value0);
            $copy_v = v.value1;
            return;
          }
          ;
          throw new Error("Failed pattern match at Data.List.Types (line 111, column 12 - line 113, column 30): " + [v.constructor.name]);
        }
        ;
        while (!$tco_done1) {
          $tco_result = $tco_loop($tco_var_b, $copy_v);
        }
        ;
        return $tco_result;
      };
    };
    return go;
  },
  foldMap: function(dictMonoid) {
    var append212 = append(dictMonoid.Semigroup0());
    var mempty27 = mempty(dictMonoid);
    return function(f) {
      return foldl(foldableList)(function(acc) {
        var $286 = append212(acc);
        return function($287) {
          return $286(f($287));
        };
      })(mempty27);
    };
  }
};
var foldl3 = /* @__PURE__ */ foldl(foldableList);
var foldr3 = /* @__PURE__ */ foldr(foldableList);
var intercalate4 = /* @__PURE__ */ intercalate(foldableList)(monoidString);
var foldableNonEmptyList = /* @__PURE__ */ foldableNonEmpty(foldableList);
var semigroupList = {
  append: function(xs) {
    return function(ys) {
      return foldr3(Cons.create)(ys)(xs);
    };
  }
};
var append1 = /* @__PURE__ */ append(semigroupList);
var monoidList = /* @__PURE__ */ function() {
  return {
    mempty: Nil.value,
    Semigroup0: function() {
      return semigroupList;
    }
  };
}();
var semigroupNonEmptyList = {
  append: function(v) {
    return function(as$prime) {
      return new NonEmpty(v.value0, append1(v.value1)(toList(as$prime)));
    };
  }
};
var showList = function(dictShow) {
  var show48 = show(dictShow);
  return {
    show: function(v) {
      if (v instanceof Nil) {
        return "Nil";
      }
      ;
      return "(" + (intercalate4(" : ")(map9(show48)(v)) + " : Nil)");
    }
  };
};
var unfoldable1List = {
  unfoldr1: function(f) {
    return function(b) {
      var go = function($copy_source) {
        return function($copy_memo) {
          var $tco_var_source = $copy_source;
          var $tco_done = false;
          var $tco_result;
          function $tco_loop(source2, memo) {
            var v = f(source2);
            if (v.value1 instanceof Just) {
              $tco_var_source = v.value1.value0;
              $copy_memo = new Cons(v.value0, memo);
              return;
            }
            ;
            if (v.value1 instanceof Nothing) {
              $tco_done = true;
              return foldl3(flip(Cons.create))(Nil.value)(new Cons(v.value0, memo));
            }
            ;
            throw new Error("Failed pattern match at Data.List.Types (line 135, column 22 - line 137, column 61): " + [v.constructor.name]);
          }
          ;
          while (!$tco_done) {
            $tco_result = $tco_loop($tco_var_source, $copy_memo);
          }
          ;
          return $tco_result;
        };
      };
      return go(b)(Nil.value);
    };
  }
};
var unfoldableList = {
  unfoldr: function(f) {
    return function(b) {
      var go = function($copy_source) {
        return function($copy_memo) {
          var $tco_var_source = $copy_source;
          var $tco_done = false;
          var $tco_result;
          function $tco_loop(source2, memo) {
            var v = f(source2);
            if (v instanceof Nothing) {
              $tco_done = true;
              return foldl3(flip(Cons.create))(Nil.value)(memo);
            }
            ;
            if (v instanceof Just) {
              $tco_var_source = v.value0.value1;
              $copy_memo = new Cons(v.value0.value0, memo);
              return;
            }
            ;
            throw new Error("Failed pattern match at Data.List.Types (line 142, column 22 - line 144, column 52): " + [v.constructor.name]);
          }
          ;
          while (!$tco_done) {
            $tco_result = $tco_loop($tco_var_source, $copy_memo);
          }
          ;
          return $tco_result;
        };
      };
      return go(b)(Nil.value);
    };
  },
  Unfoldable10: function() {
    return unfoldable1List;
  }
};
var unfoldable1NonEmptyList = /* @__PURE__ */ unfoldable1NonEmpty(unfoldableList);
var foldable1NonEmptyList = /* @__PURE__ */ foldable1NonEmpty(foldableList);
var applyList = {
  apply: function(v) {
    return function(v1) {
      if (v instanceof Nil) {
        return Nil.value;
      }
      ;
      if (v instanceof Cons) {
        return append1(map9(v.value0)(v1))(apply2(applyList)(v.value1)(v1));
      }
      ;
      throw new Error("Failed pattern match at Data.List.Types (line 157, column 1 - line 159, column 48): " + [v.constructor.name, v1.constructor.name]);
    };
  },
  Functor0: function() {
    return functorList;
  }
};
var apply4 = /* @__PURE__ */ apply2(applyList);
var applyNonEmptyList = {
  apply: function(v) {
    return function(v1) {
      return new NonEmpty(v.value0(v1.value0), append1(apply4(v.value1)(new Cons(v1.value0, Nil.value)))(apply4(new Cons(v.value0, v.value1))(v1.value1)));
    };
  },
  Functor0: function() {
    return functorNonEmptyList;
  }
};
var applicativeList = {
  pure: function(a) {
    return new Cons(a, Nil.value);
  },
  Apply0: function() {
    return applyList;
  }
};
var altList = {
  alt: append1,
  Functor0: function() {
    return functorList;
  }
};
var plusList = /* @__PURE__ */ function() {
  return {
    empty: Nil.value,
    Alt0: function() {
      return altList;
    }
  };
}();
var applicativeNonEmptyList = {
  pure: /* @__PURE__ */ function() {
    var $315 = singleton3(plusList);
    return function($316) {
      return NonEmptyList($315($316));
    };
  }(),
  Apply0: function() {
    return applyNonEmptyList;
  }
};

// output/Data.String.CodePoints/foreign.js
var hasArrayFrom = typeof Array.from === "function";
var hasStringIterator = typeof Symbol !== "undefined" && Symbol != null && typeof Symbol.iterator !== "undefined" && typeof String.prototype[Symbol.iterator] === "function";
var hasFromCodePoint = typeof String.prototype.fromCodePoint === "function";
var hasCodePointAt = typeof String.prototype.codePointAt === "function";
var _unsafeCodePointAt0 = function(fallback) {
  return hasCodePointAt ? function(str2) {
    return str2.codePointAt(0);
  } : fallback;
};
var _codePointAt = function(fallback) {
  return function(Just2) {
    return function(Nothing2) {
      return function(unsafeCodePointAt02) {
        return function(index4) {
          return function(str2) {
            var length7 = str2.length;
            if (index4 < 0 || index4 >= length7)
              return Nothing2;
            if (hasStringIterator) {
              var iter = str2[Symbol.iterator]();
              for (var i = index4; ; --i) {
                var o = iter.next();
                if (o.done)
                  return Nothing2;
                if (i === 0)
                  return Just2(unsafeCodePointAt02(o.value));
              }
            }
            return fallback(index4)(str2);
          };
        };
      };
    };
  };
};
var _countPrefix = function(fallback) {
  return function(unsafeCodePointAt02) {
    if (hasStringIterator) {
      return function(pred2) {
        return function(str2) {
          var iter = str2[Symbol.iterator]();
          for (var cpCount = 0; ; ++cpCount) {
            var o = iter.next();
            if (o.done)
              return cpCount;
            var cp = unsafeCodePointAt02(o.value);
            if (!pred2(cp))
              return cpCount;
          }
        };
      };
    }
    return fallback;
  };
};
var _singleton = function(fallback) {
  return hasFromCodePoint ? String.fromCodePoint : fallback;
};
var _take = function(fallback) {
  return function(n) {
    if (hasStringIterator) {
      return function(str2) {
        var accum = "";
        var iter = str2[Symbol.iterator]();
        for (var i = 0; i < n; ++i) {
          var o = iter.next();
          if (o.done)
            return accum;
          accum += o.value;
        }
        return accum;
      };
    }
    return fallback(n);
  };
};
var _toCodePointArray = function(fallback) {
  return function(unsafeCodePointAt02) {
    if (hasArrayFrom) {
      return function(str2) {
        return Array.from(str2, unsafeCodePointAt02);
      };
    }
    return fallback;
  };
};

// output/Data.Enum/foreign.js
function toCharCode(c) {
  return c.charCodeAt(0);
}
function fromCharCode(c) {
  return String.fromCharCode(c);
}

// output/Control.Alternative/index.js
var guard2 = function(dictAlternative) {
  var pure75 = pure(dictAlternative.Applicative0());
  var empty9 = empty(dictAlternative.Plus1());
  return function(v) {
    if (v) {
      return pure75(unit);
    }
    ;
    if (!v) {
      return empty9;
    }
    ;
    throw new Error("Failed pattern match at Control.Alternative (line 48, column 1 - line 48, column 54): " + [v.constructor.name]);
  };
};
var alternativeArray = {
  Applicative0: function() {
    return applicativeArray;
  },
  Plus1: function() {
    return plusArray;
  }
};

// output/Data.Enum/index.js
var bottom1 = /* @__PURE__ */ bottom(boundedChar);
var top1 = /* @__PURE__ */ top(boundedChar);
var toEnum = function(dict) {
  return dict.toEnum;
};
var fromEnum = function(dict) {
  return dict.fromEnum;
};
var toEnumWithDefaults = function(dictBoundedEnum) {
  var toEnum12 = toEnum(dictBoundedEnum);
  var fromEnum12 = fromEnum(dictBoundedEnum);
  var bottom22 = bottom(dictBoundedEnum.Bounded0());
  return function(low) {
    return function(high) {
      return function(x) {
        var v = toEnum12(x);
        if (v instanceof Just) {
          return v.value0;
        }
        ;
        if (v instanceof Nothing) {
          var $140 = x < fromEnum12(bottom22);
          if ($140) {
            return low;
          }
          ;
          return high;
        }
        ;
        throw new Error("Failed pattern match at Data.Enum (line 158, column 33 - line 160, column 62): " + [v.constructor.name]);
      };
    };
  };
};
var defaultSucc = function(toEnum$prime) {
  return function(fromEnum$prime) {
    return function(a) {
      return toEnum$prime(fromEnum$prime(a) + 1 | 0);
    };
  };
};
var defaultPred = function(toEnum$prime) {
  return function(fromEnum$prime) {
    return function(a) {
      return toEnum$prime(fromEnum$prime(a) - 1 | 0);
    };
  };
};
var charToEnum = function(v) {
  if (v >= toCharCode(bottom1) && v <= toCharCode(top1)) {
    return new Just(fromCharCode(v));
  }
  ;
  return Nothing.value;
};
var enumChar = {
  succ: /* @__PURE__ */ defaultSucc(charToEnum)(toCharCode),
  pred: /* @__PURE__ */ defaultPred(charToEnum)(toCharCode),
  Ord0: function() {
    return ordChar;
  }
};
var boundedEnumChar = /* @__PURE__ */ function() {
  return {
    cardinality: toCharCode(top1) - toCharCode(bottom1) | 0,
    toEnum: charToEnum,
    fromEnum: toCharCode,
    Bounded0: function() {
      return boundedChar;
    },
    Enum1: function() {
      return enumChar;
    }
  };
}();

// output/Data.String.CodeUnits/foreign.js
var fromCharArray = function(a) {
  return a.join("");
};
var toCharArray = function(s) {
  return s.split("");
};
var singleton6 = function(c) {
  return c;
};
var _charAt = function(just) {
  return function(nothing) {
    return function(i) {
      return function(s) {
        return i >= 0 && i < s.length ? just(s.charAt(i)) : nothing;
      };
    };
  };
};
var length3 = function(s) {
  return s.length;
};
var _indexOf = function(just) {
  return function(nothing) {
    return function(x) {
      return function(s) {
        var i = s.indexOf(x);
        return i === -1 ? nothing : just(i);
      };
    };
  };
};
var _indexOfStartingAt = function(just) {
  return function(nothing) {
    return function(x) {
      return function(startAt) {
        return function(s) {
          if (startAt < 0 || startAt > s.length)
            return nothing;
          var i = s.indexOf(x, startAt);
          return i === -1 ? nothing : just(i);
        };
      };
    };
  };
};
var take2 = function(n) {
  return function(s) {
    return s.substr(0, n);
  };
};
var drop2 = function(n) {
  return function(s) {
    return s.substring(n);
  };
};
var slice2 = function(b) {
  return function(e) {
    return function(s) {
      return s.slice(b, e);
    };
  };
};
var splitAt2 = function(i) {
  return function(s) {
    return { before: s.substring(0, i), after: s.substring(i) };
  };
};

// output/Data.String.Unsafe/foreign.js
var charAt = function(i) {
  return function(s) {
    if (i >= 0 && i < s.length)
      return s.charAt(i);
    throw new Error("Data.String.Unsafe.charAt: Invalid index.");
  };
};

// output/Data.String.CodeUnits/index.js
var stripSuffix = function(v) {
  return function(str2) {
    var v1 = splitAt2(length3(str2) - length3(v) | 0)(str2);
    var $14 = v1.after === v;
    if ($14) {
      return new Just(v1.before);
    }
    ;
    return Nothing.value;
  };
};
var stripPrefix = function(v) {
  return function(str2) {
    var v1 = splitAt2(length3(v))(str2);
    var $20 = v1.before === v;
    if ($20) {
      return new Just(v1.after);
    }
    ;
    return Nothing.value;
  };
};
var indexOf$prime = /* @__PURE__ */ function() {
  return _indexOfStartingAt(Just.create)(Nothing.value);
}();
var indexOf = /* @__PURE__ */ function() {
  return _indexOf(Just.create)(Nothing.value);
}();
var dropRight = function(i) {
  return function(s) {
    return take2(length3(s) - i | 0)(s);
  };
};
var contains = function(pat) {
  var $23 = indexOf(pat);
  return function($24) {
    return isJust($23($24));
  };
};
var charAt2 = /* @__PURE__ */ function() {
  return _charAt(Just.create)(Nothing.value);
}();

// output/Data.String.Common/foreign.js
var replaceAll = function(s1) {
  return function(s2) {
    return function(s3) {
      return s3.replace(new RegExp(s1.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&"), "g"), s2);
    };
  };
};
var split = function(sep2) {
  return function(s) {
    return s.split(sep2);
  };
};
var toLower = function(s) {
  return s.toLowerCase();
};
var toUpper = function(s) {
  return s.toUpperCase();
};
var trim = function(s) {
  return s.trim();
};
var joinWith = function(s) {
  return function(xs) {
    return xs.join(s);
  };
};

// output/Data.String.Common/index.js
var $$null2 = function(s) {
  return s === "";
};

// output/Data.String.CodePoints/index.js
var $runtime_lazy3 = function(name4, moduleName2, init4) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2)
      return val;
    if (state2 === 1)
      throw new ReferenceError(name4 + " was needed before it finished initializing (module " + moduleName2 + ", line " + lineNumber + ")", moduleName2, lineNumber);
    state2 = 1;
    val = init4();
    state2 = 2;
    return val;
  };
};
var fromEnum2 = /* @__PURE__ */ fromEnum(boundedEnumChar);
var map10 = /* @__PURE__ */ map(functorMaybe);
var unfoldr2 = /* @__PURE__ */ unfoldr(unfoldableArray);
var div3 = /* @__PURE__ */ div(euclideanRingInt);
var mod3 = /* @__PURE__ */ mod(euclideanRingInt);
var compare2 = /* @__PURE__ */ compare(ordInt);
var CodePoint = function(x) {
  return x;
};
var unsurrogate = function(lead) {
  return function(trail) {
    return (((lead - 55296 | 0) * 1024 | 0) + (trail - 56320 | 0) | 0) + 65536 | 0;
  };
};
var isTrail = function(cu) {
  return 56320 <= cu && cu <= 57343;
};
var isLead = function(cu) {
  return 55296 <= cu && cu <= 56319;
};
var uncons3 = function(s) {
  var v = length3(s);
  if (v === 0) {
    return Nothing.value;
  }
  ;
  if (v === 1) {
    return new Just({
      head: fromEnum2(charAt(0)(s)),
      tail: ""
    });
  }
  ;
  var cu1 = fromEnum2(charAt(1)(s));
  var cu0 = fromEnum2(charAt(0)(s));
  var $43 = isLead(cu0) && isTrail(cu1);
  if ($43) {
    return new Just({
      head: unsurrogate(cu0)(cu1),
      tail: drop2(2)(s)
    });
  }
  ;
  return new Just({
    head: cu0,
    tail: drop2(1)(s)
  });
};
var unconsButWithTuple = function(s) {
  return map10(function(v) {
    return new Tuple(v.head, v.tail);
  })(uncons3(s));
};
var toCodePointArrayFallback = function(s) {
  return unfoldr2(unconsButWithTuple)(s);
};
var unsafeCodePointAt0Fallback = function(s) {
  var cu0 = fromEnum2(charAt(0)(s));
  var $47 = isLead(cu0) && length3(s) > 1;
  if ($47) {
    var cu1 = fromEnum2(charAt(1)(s));
    var $48 = isTrail(cu1);
    if ($48) {
      return unsurrogate(cu0)(cu1);
    }
    ;
    return cu0;
  }
  ;
  return cu0;
};
var unsafeCodePointAt0 = /* @__PURE__ */ _unsafeCodePointAt0(unsafeCodePointAt0Fallback);
var toCodePointArray = /* @__PURE__ */ _toCodePointArray(toCodePointArrayFallback)(unsafeCodePointAt0);
var length4 = function($74) {
  return length(toCodePointArray($74));
};
var indexOf2 = function(p) {
  return function(s) {
    return map10(function(i) {
      return length4(take2(i)(s));
    })(indexOf(p)(s));
  };
};
var fromCharCode2 = /* @__PURE__ */ function() {
  var $75 = toEnumWithDefaults(boundedEnumChar)(bottom(boundedChar))(top(boundedChar));
  return function($76) {
    return singleton6($75($76));
  };
}();
var singletonFallback = function(v) {
  if (v <= 65535) {
    return fromCharCode2(v);
  }
  ;
  var lead = div3(v - 65536 | 0)(1024) + 55296 | 0;
  var trail = mod3(v - 65536 | 0)(1024) + 56320 | 0;
  return fromCharCode2(lead) + fromCharCode2(trail);
};
var singleton7 = /* @__PURE__ */ _singleton(singletonFallback);
var takeFallback = function(v) {
  return function(v1) {
    if (v < 1) {
      return "";
    }
    ;
    var v2 = uncons3(v1);
    if (v2 instanceof Just) {
      return singleton7(v2.value0.head) + takeFallback(v - 1 | 0)(v2.value0.tail);
    }
    ;
    return v1;
  };
};
var take3 = /* @__PURE__ */ _take(takeFallback);
var splitAt3 = function(i) {
  return function(s) {
    var before = take3(i)(s);
    return {
      before,
      after: drop2(length3(before))(s)
    };
  };
};
var eqCodePoint = {
  eq: function(x) {
    return function(y) {
      return x === y;
    };
  }
};
var ordCodePoint = {
  compare: function(x) {
    return function(y) {
      return compare2(x)(y);
    };
  },
  Eq0: function() {
    return eqCodePoint;
  }
};
var drop3 = function(n) {
  return function(s) {
    return drop2(length3(take3(n)(s)))(s);
  };
};
var countTail = function($copy_p) {
  return function($copy_s) {
    return function($copy_accum) {
      var $tco_var_p = $copy_p;
      var $tco_var_s = $copy_s;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(p, s, accum) {
        var v = uncons3(s);
        if (v instanceof Just) {
          var $61 = p(v.value0.head);
          if ($61) {
            $tco_var_p = p;
            $tco_var_s = v.value0.tail;
            $copy_accum = accum + 1 | 0;
            return;
          }
          ;
          $tco_done = true;
          return accum;
        }
        ;
        $tco_done = true;
        return accum;
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_p, $tco_var_s, $copy_accum);
      }
      ;
      return $tco_result;
    };
  };
};
var countFallback = function(p) {
  return function(s) {
    return countTail(p)(s)(0);
  };
};
var countPrefix2 = /* @__PURE__ */ _countPrefix(countFallback)(unsafeCodePointAt0);
var takeWhile3 = function(p) {
  return function(s) {
    return take3(countPrefix2(p)(s))(s);
  };
};
var codePointFromChar = function($77) {
  return CodePoint(fromEnum2($77));
};
var codePointAtFallback = function($copy_n) {
  return function($copy_s) {
    var $tco_var_n = $copy_n;
    var $tco_done = false;
    var $tco_result;
    function $tco_loop(n, s) {
      var v = uncons3(s);
      if (v instanceof Just) {
        var $66 = n === 0;
        if ($66) {
          $tco_done = true;
          return new Just(v.value0.head);
        }
        ;
        $tco_var_n = n - 1 | 0;
        $copy_s = v.value0.tail;
        return;
      }
      ;
      $tco_done = true;
      return Nothing.value;
    }
    ;
    while (!$tco_done) {
      $tco_result = $tco_loop($tco_var_n, $copy_s);
    }
    ;
    return $tco_result;
  };
};
var codePointAt = function(v) {
  return function(v1) {
    if (v < 0) {
      return Nothing.value;
    }
    ;
    if (v === 0 && v1 === "") {
      return Nothing.value;
    }
    ;
    if (v === 0) {
      return new Just(unsafeCodePointAt0(v1));
    }
    ;
    return _codePointAt(codePointAtFallback)(Just.create)(Nothing.value)(unsafeCodePointAt0)(v)(v1);
  };
};
var boundedCodePoint = {
  bottom: 0,
  top: 1114111,
  Ord0: function() {
    return ordCodePoint;
  }
};
var boundedEnumCodePoint = /* @__PURE__ */ function() {
  return {
    cardinality: 1114111 + 1 | 0,
    fromEnum: function(v) {
      return v;
    },
    toEnum: function(n) {
      if (n >= 0 && n <= 1114111) {
        return new Just(n);
      }
      ;
      if (otherwise) {
        return Nothing.value;
      }
      ;
      throw new Error("Failed pattern match at Data.String.CodePoints (line 63, column 1 - line 68, column 26): " + [n.constructor.name]);
    },
    Bounded0: function() {
      return boundedCodePoint;
    },
    Enum1: function() {
      return $lazy_enumCodePoint(0);
    }
  };
}();
var $lazy_enumCodePoint = /* @__PURE__ */ $runtime_lazy3("enumCodePoint", "Data.String.CodePoints", function() {
  return {
    succ: defaultSucc(toEnum(boundedEnumCodePoint))(fromEnum(boundedEnumCodePoint)),
    pred: defaultPred(toEnum(boundedEnumCodePoint))(fromEnum(boundedEnumCodePoint)),
    Ord0: function() {
      return ordCodePoint;
    }
  };
});

// output/Data.Codec.Argonaut/index.js
var show2 = /* @__PURE__ */ show(showString);
var show1 = /* @__PURE__ */ show(showInt);
var bind3 = /* @__PURE__ */ bind(bindEither);
var lmap2 = /* @__PURE__ */ lmap(bifunctorEither);
var map11 = /* @__PURE__ */ map(functorEither);
var pure3 = /* @__PURE__ */ pure(applicativeEither);
var bindFlipped3 = /* @__PURE__ */ bindFlipped(bindEither);
var fromFoldable4 = /* @__PURE__ */ fromFoldable3(foldableList);
var composeKleisliFlipped2 = /* @__PURE__ */ composeKleisliFlipped(bindMaybe);
var traverseWithIndex2 = /* @__PURE__ */ traverseWithIndex(traversableWithIndexArray)(applicativeEither);
var map13 = /* @__PURE__ */ map(functorArray);
var TypeMismatch = /* @__PURE__ */ function() {
  function TypeMismatch3(value0) {
    this.value0 = value0;
  }
  ;
  TypeMismatch3.create = function(value0) {
    return new TypeMismatch3(value0);
  };
  return TypeMismatch3;
}();
var UnexpectedValue = /* @__PURE__ */ function() {
  function UnexpectedValue2(value0) {
    this.value0 = value0;
  }
  ;
  UnexpectedValue2.create = function(value0) {
    return new UnexpectedValue2(value0);
  };
  return UnexpectedValue2;
}();
var AtIndex = /* @__PURE__ */ function() {
  function AtIndex2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  AtIndex2.create = function(value0) {
    return function(value12) {
      return new AtIndex2(value0, value12);
    };
  };
  return AtIndex2;
}();
var AtKey = /* @__PURE__ */ function() {
  function AtKey2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  AtKey2.create = function(value0) {
    return function(value12) {
      return new AtKey2(value0, value12);
    };
  };
  return AtKey2;
}();
var Named = /* @__PURE__ */ function() {
  function Named2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Named2.create = function(value0) {
    return function(value12) {
      return new Named2(value0, value12);
    };
  };
  return Named2;
}();
var MissingValue = /* @__PURE__ */ function() {
  function MissingValue2() {
  }
  ;
  MissingValue2.value = new MissingValue2();
  return MissingValue2;
}();
var showJsonDecodeError = {
  show: function(v) {
    if (v instanceof TypeMismatch) {
      return "(TypeMismatch " + (show2(v.value0) + ")");
    }
    ;
    if (v instanceof UnexpectedValue) {
      return "(UnexpectedValue " + (stringify(v.value0) + ")");
    }
    ;
    if (v instanceof AtIndex) {
      return "(AtIndex " + (show1(v.value0) + (" " + (show(showJsonDecodeError)(v.value1) + ")")));
    }
    ;
    if (v instanceof AtKey) {
      return "(AtKey " + (show2(v.value0) + (" " + (show(showJsonDecodeError)(v.value1) + ")")));
    }
    ;
    if (v instanceof Named) {
      return "(Named " + (show2(v.value0) + (" " + (show(showJsonDecodeError)(v.value1) + ")")));
    }
    ;
    if (v instanceof MissingValue) {
      return "MissingValue";
    }
    ;
    throw new Error("Failed pattern match at Data.Codec.Argonaut (line 77, column 10 - line 83, column 34): " + [v.constructor.name]);
  }
};
var recordPropOptional = function(dictIsSymbol) {
  var reflectSymbol3 = reflectSymbol(dictIsSymbol);
  return function() {
    return function(p) {
      return function(codecA) {
        return function(codecR) {
          var key = reflectSymbol3(p);
          var enc$prime = function(val) {
            var w = encode(codecR)(val);
            var v = unsafeGet(key)(val);
            if (v instanceof Just) {
              return new Cons(new Tuple(key, encode(codecA)(v.value0)), w);
            }
            ;
            if (v instanceof Nothing) {
              return w;
            }
            ;
            throw new Error("Failed pattern match at Data.Codec.Argonaut (line 308, column 5 - line 310, column 18): " + [v.constructor.name]);
          };
          var dec$prime = function(obj) {
            return bind3(decode(codecR)(obj))(function(r) {
              return bind3(lmap2(AtKey.create(key))(function() {
                var v = lookup2(key)(obj);
                if (v instanceof Just) {
                  return map11(Just.create)(decode(codecA)(v.value0));
                }
                ;
                return new Right(Nothing.value);
              }()))(function(a) {
                return pure3(unsafeSet(key)(a)(r));
              });
            });
          };
          return codec(dec$prime)(enc$prime);
        };
      };
    };
  };
};
var recordProp = function(dictIsSymbol) {
  var reflectSymbol3 = reflectSymbol(dictIsSymbol);
  return function() {
    return function(p) {
      return function(codecA) {
        return function(codecR) {
          var enc$prime = function(key2) {
            return function(val) {
              return new Cons(new Tuple(key2, encode(codecA)(unsafeGet(key2)(val))), encode(codecR)(val));
            };
          };
          var dec$prime = function(key2) {
            return function(obj) {
              return bind3(decode(codecR)(obj))(function(r) {
                return bind3(lmap2(AtKey.create(key2))(function() {
                  var v = lookup2(key2)(obj);
                  if (v instanceof Just) {
                    return decode(codecA)(v.value0);
                  }
                  ;
                  if (v instanceof Nothing) {
                    return new Left(MissingValue.value);
                  }
                  ;
                  throw new Error("Failed pattern match at Data.Codec.Argonaut (line 264, column 29 - line 266, column 34): " + [v.constructor.name]);
                }()))(function(a) {
                  return pure3(unsafeSet(key2)(a)(r));
                });
              });
            };
          };
          var key = reflectSymbol3(p);
          return codec(dec$prime(key))(enc$prime(key));
        };
      };
    };
  };
};
var record = /* @__PURE__ */ function() {
  return new Codec($$const(pure3({})), pure(applicativeTuple(monoidList)));
}();
var prismaticCodec = function(name4) {
  return function(f) {
    return function(g) {
      return function(codec11) {
        return codec$prime(function(j) {
          return bindFlipped3(function() {
            var $203 = note(new Named(name4, new UnexpectedValue(j)));
            return function($204) {
              return $203(f($204));
            };
          }())(decode(codec11)(j));
        })(function() {
          var $205 = encode(codec11);
          return function($206) {
            return $205(g($206));
          };
        }());
      };
    };
  };
};
var printJsonDecodeError = function(err) {
  var go = function(v) {
    if (v instanceof TypeMismatch) {
      return "  Expected value of type '" + (v.value0 + "'.");
    }
    ;
    if (v instanceof UnexpectedValue) {
      return "  Unexpected value " + (stringify(v.value0) + ".");
    }
    ;
    if (v instanceof AtIndex) {
      return "  At array index " + (show1(v.value0) + (":\n" + go(v.value1)));
    }
    ;
    if (v instanceof AtKey) {
      return "  At object key " + (v.value0 + (":\n" + go(v.value1)));
    }
    ;
    if (v instanceof Named) {
      return "  Under '" + (v.value0 + ("':\n" + go(v.value1)));
    }
    ;
    if (v instanceof MissingValue) {
      return "  No value was found.";
    }
    ;
    throw new Error("Failed pattern match at Data.Codec.Argonaut (line 90, column 8 - line 96, column 43): " + [v.constructor.name]);
  };
  return "An error occurred while decoding a JSON value:\n" + go(err);
};
var jsonPrimCodec = function(ty) {
  return function(f) {
    return codec$prime(function() {
      var $210 = maybe(new Left(new TypeMismatch(ty)))(pure3);
      return function($211) {
        return $210(f($211));
      };
    }());
  };
};
var number = /* @__PURE__ */ jsonPrimCodec("Number")(toNumber)(id);
var string = /* @__PURE__ */ jsonPrimCodec("String")(toString)(id);
var jobject = /* @__PURE__ */ jsonPrimCodec("Object")(toObject)(id);
var object = function(name4) {
  return function(codec11) {
    return codec$prime(function(j) {
      return lmap2(Named.create(name4))(bindFlipped3(decode(codec11))(decode(jobject)(j)));
    })(function(a) {
      return encode(jobject)(fromFoldable4(encode(codec11)(a)));
    });
  };
};
var jarray = /* @__PURE__ */ jsonPrimCodec("Array")(toArray2)(id);
var $$int = /* @__PURE__ */ jsonPrimCodec("Int")(/* @__PURE__ */ composeKleisliFlipped2(fromNumber)(toNumber))(function($212) {
  return id(toNumber2($212));
});
var $$boolean = /* @__PURE__ */ jsonPrimCodec("Boolean")(toBoolean)(id);
var array = function(codec11) {
  return codec$prime(function(j) {
    return bindFlipped3(traverseWithIndex2(function(ix) {
      return function(j$prime) {
        return lmap2(AtIndex.create(ix))(decode(codec11)(j$prime));
      };
    }))(decode(jarray)(j));
  })(function(a) {
    return id(map13(encode(codec11))(a));
  });
};

// output/Data.Codec.Argonaut.Sum/index.js
var bindFlipped4 = /* @__PURE__ */ bindFlipped(bindEither);
var enumSum = function(printTag) {
  return function(parseTag) {
    return codec(function(j) {
      return bindFlipped4(function() {
        var $18 = maybe(new Left(new UnexpectedValue(j)))(Right.create);
        return function($19) {
          return $18(parseTag($19));
        };
      }())(decode(string)(j));
    })(function() {
      var $20 = encode(string);
      return function($21) {
        return $20(printTag($21));
      };
    }());
  };
};

// output/Data.List/index.js
var map14 = /* @__PURE__ */ map(functorMaybe);
var foldl4 = /* @__PURE__ */ foldl(foldableList);
var uncons4 = function(v) {
  if (v instanceof Nil) {
    return Nothing.value;
  }
  ;
  if (v instanceof Cons) {
    return new Just({
      head: v.value0,
      tail: v.value1
    });
  }
  ;
  throw new Error("Failed pattern match at Data.List (line 259, column 1 - line 259, column 66): " + [v.constructor.name]);
};
var toUnfoldable4 = function(dictUnfoldable) {
  return unfoldr(dictUnfoldable)(function(xs) {
    return map14(function(rec) {
      return new Tuple(rec.head, rec.tail);
    })(uncons4(xs));
  });
};
var span2 = function(v) {
  return function(v1) {
    if (v1 instanceof Cons && v(v1.value0)) {
      var v2 = span2(v)(v1.value1);
      return {
        init: new Cons(v1.value0, v2.init),
        rest: v2.rest
      };
    }
    ;
    return {
      init: Nil.value,
      rest: v1
    };
  };
};
var singleton8 = function(a) {
  return new Cons(a, Nil.value);
};
var reverse2 = /* @__PURE__ */ function() {
  var go = function($copy_v) {
    return function($copy_v1) {
      var $tco_var_v = $copy_v;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(v, v1) {
        if (v1 instanceof Nil) {
          $tco_done = true;
          return v;
        }
        ;
        if (v1 instanceof Cons) {
          $tco_var_v = new Cons(v1.value0, v);
          $copy_v1 = v1.value1;
          return;
        }
        ;
        throw new Error("Failed pattern match at Data.List (line 368, column 3 - line 368, column 19): " + [v.constructor.name, v1.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_v, $copy_v1);
      }
      ;
      return $tco_result;
    };
  };
  return go(Nil.value);
}();
var takeWhile4 = function(p) {
  var go = function($copy_v) {
    return function($copy_v1) {
      var $tco_var_v = $copy_v;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(v, v1) {
        if (v1 instanceof Cons && p(v1.value0)) {
          $tco_var_v = new Cons(v1.value0, v);
          $copy_v1 = v1.value1;
          return;
        }
        ;
        $tco_done = true;
        return reverse2(v);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_v, $copy_v1);
      }
      ;
      return $tco_result;
    };
  };
  return go(Nil.value);
};
var $$null3 = function(v) {
  if (v instanceof Nil) {
    return true;
  }
  ;
  return false;
};
var some2 = function(dictAlternative) {
  var apply25 = apply2(dictAlternative.Applicative0().Apply0());
  var map136 = map(dictAlternative.Plus1().Alt0().Functor0());
  return function(dictLazy) {
    var defer6 = defer(dictLazy);
    return function(v) {
      return apply25(map136(Cons.create)(v))(defer6(function(v1) {
        return many2(dictAlternative)(dictLazy)(v);
      }));
    };
  };
};
var many2 = function(dictAlternative) {
  var alt32 = alt(dictAlternative.Plus1().Alt0());
  var pure75 = pure(dictAlternative.Applicative0());
  return function(dictLazy) {
    return function(v) {
      return alt32(some2(dictAlternative)(dictLazy)(v))(pure75(Nil.value));
    };
  };
};
var length5 = /* @__PURE__ */ foldl4(function(acc) {
  return function(v) {
    return acc + 1 | 0;
  };
})(0);
var head3 = function(v) {
  if (v instanceof Nil) {
    return Nothing.value;
  }
  ;
  if (v instanceof Cons) {
    return new Just(v.value0);
  }
  ;
  throw new Error("Failed pattern match at Data.List (line 230, column 1 - line 230, column 22): " + [v.constructor.name]);
};
var fromFoldable5 = function(dictFoldable) {
  return foldr(dictFoldable)(Cons.create)(Nil.value);
};
var filter2 = function(p) {
  var go = function($copy_v) {
    return function($copy_v1) {
      var $tco_var_v = $copy_v;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(v, v1) {
        if (v1 instanceof Nil) {
          $tco_done = true;
          return reverse2(v);
        }
        ;
        if (v1 instanceof Cons) {
          if (p(v1.value0)) {
            $tco_var_v = new Cons(v1.value0, v);
            $copy_v1 = v1.value1;
            return;
          }
          ;
          if (otherwise) {
            $tco_var_v = v;
            $copy_v1 = v1.value1;
            return;
          }
          ;
        }
        ;
        throw new Error("Failed pattern match at Data.List (line 390, column 3 - line 390, column 27): " + [v.constructor.name, v1.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_v, $copy_v1);
      }
      ;
      return $tco_result;
    };
  };
  return go(Nil.value);
};
var nubByEq2 = function(v) {
  return function(v1) {
    if (v1 instanceof Nil) {
      return Nil.value;
    }
    ;
    if (v1 instanceof Cons) {
      return new Cons(v1.value0, nubByEq2(v)(filter2(function(y) {
        return !v(v1.value0)(y);
      })(v1.value1)));
    }
    ;
    throw new Error("Failed pattern match at Data.List (line 705, column 1 - line 705, column 61): " + [v.constructor.name, v1.constructor.name]);
  };
};

// output/Partial.Unsafe/foreign.js
var _unsafePartial = function(f) {
  return f();
};

// output/Partial/foreign.js
var _crashWith = function(msg) {
  throw new Error(msg);
};

// output/Partial/index.js
var crashWith = function() {
  return _crashWith;
};

// output/Partial.Unsafe/index.js
var crashWith2 = /* @__PURE__ */ crashWith();
var unsafePartial = _unsafePartial;
var unsafeCrashWith = function(msg) {
  return unsafePartial(function() {
    return crashWith2(msg);
  });
};

// output/Data.List.NonEmpty/index.js
var singleton9 = /* @__PURE__ */ function() {
  var $200 = singleton3(plusList);
  return function($201) {
    return NonEmptyList($200($201));
  };
}();
var head4 = function(v) {
  return v.value0;
};
var fromList = function(v) {
  if (v instanceof Nil) {
    return Nothing.value;
  }
  ;
  if (v instanceof Cons) {
    return new Just(new NonEmpty(v.value0, v.value1));
  }
  ;
  throw new Error("Failed pattern match at Data.List.NonEmpty (line 121, column 1 - line 121, column 57): " + [v.constructor.name]);
};
var cons3 = function(y) {
  return function(v) {
    return new NonEmpty(y, new Cons(v.value0, v.value1));
  };
};

// output/Data.Lazy/foreign.js
var defer2 = function(thunk) {
  var v = null;
  return function() {
    if (thunk === void 0)
      return v;
    v = thunk();
    thunk = void 0;
    return v;
  };
};
var force = function(l) {
  return l();
};

// output/Data.Lazy/index.js
var functorLazy = {
  map: function(f) {
    return function(l) {
      return defer2(function(v) {
        return f(force(l));
      });
    };
  }
};
var applyLazy = {
  apply: function(f) {
    return function(x) {
      return defer2(function(v) {
        return force(f)(force(x));
      });
    };
  },
  Functor0: function() {
    return functorLazy;
  }
};
var bindLazy = {
  bind: function(l) {
    return function(f) {
      return defer2(function(v) {
        return force(f(force(l)));
      });
    };
  },
  Apply0: function() {
    return applyLazy;
  }
};

// output/Data.List.Lazy.Types/index.js
var unwrap4 = /* @__PURE__ */ unwrap();
var List = function(x) {
  return x;
};
var Nil2 = /* @__PURE__ */ function() {
  function Nil4() {
  }
  ;
  Nil4.value = new Nil4();
  return Nil4;
}();
var Cons2 = /* @__PURE__ */ function() {
  function Cons4(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Cons4.create = function(value0) {
    return function(value12) {
      return new Cons4(value0, value12);
    };
  };
  return Cons4;
}();
var nil = /* @__PURE__ */ defer2(function(v) {
  return Nil2.value;
});
var step = function($319) {
  return force(unwrap4($319));
};
var lazyList = {
  defer: function(f) {
    return defer2(function($320) {
      return step(f($320));
    });
  }
};
var defer3 = /* @__PURE__ */ defer(lazyList);
var cons4 = function(x) {
  return function(xs) {
    return defer2(function(v) {
      return new Cons2(x, xs);
    });
  };
};
var foldableList2 = {
  foldr: function(op) {
    return function(z) {
      return function(xs) {
        var rev = foldl(foldableList2)(flip(cons4))(nil);
        return foldl(foldableList2)(flip(op))(z)(rev(xs));
      };
    };
  },
  foldl: function(op) {
    var go = function($copy_b) {
      return function($copy_xs) {
        var $tco_var_b = $copy_b;
        var $tco_done = false;
        var $tco_result;
        function $tco_loop(b, xs) {
          var v = step(xs);
          if (v instanceof Nil2) {
            $tco_done = true;
            return b;
          }
          ;
          if (v instanceof Cons2) {
            $tco_var_b = op(b)(v.value0);
            $copy_xs = v.value1;
            return;
          }
          ;
          throw new Error("Failed pattern match at Data.List.Lazy.Types (line 127, column 7 - line 129, column 40): " + [v.constructor.name]);
        }
        ;
        while (!$tco_done) {
          $tco_result = $tco_loop($tco_var_b, $copy_xs);
        }
        ;
        return $tco_result;
      };
    };
    return go;
  },
  foldMap: function(dictMonoid) {
    var append212 = append(dictMonoid.Semigroup0());
    var mempty27 = mempty(dictMonoid);
    return function(f) {
      return foldl(foldableList2)(function(b) {
        return function(a) {
          return append212(b)(f(a));
        };
      })(mempty27);
    };
  }
};
var unfoldable1List2 = {
  unfoldr1: /* @__PURE__ */ function() {
    var go = function(f) {
      return function(b) {
        return defer3(function(v) {
          var v1 = f(b);
          if (v1.value1 instanceof Just) {
            return cons4(v1.value0)(go(f)(v1.value1.value0));
          }
          ;
          if (v1.value1 instanceof Nothing) {
            return cons4(v1.value0)(nil);
          }
          ;
          throw new Error("Failed pattern match at Data.List.Lazy.Types (line 151, column 28 - line 153, column 33): " + [v1.constructor.name]);
        });
      };
    };
    return go;
  }()
};
var unfoldableList2 = {
  unfoldr: /* @__PURE__ */ function() {
    var go = function(f) {
      return function(b) {
        return defer3(function(v) {
          var v1 = f(b);
          if (v1 instanceof Nothing) {
            return nil;
          }
          ;
          if (v1 instanceof Just) {
            return cons4(v1.value0.value0)(go(f)(v1.value0.value1));
          }
          ;
          throw new Error("Failed pattern match at Data.List.Lazy.Types (line 157, column 28 - line 159, column 39): " + [v1.constructor.name]);
        });
      };
    };
    return go;
  }(),
  Unfoldable10: function() {
    return unfoldable1List2;
  }
};

// output/Data.List.Lazy/index.js
var map15 = /* @__PURE__ */ map(functorLazy);
var unwrap5 = /* @__PURE__ */ unwrap();
var replicateM = function(dictMonad) {
  var pure122 = pure(dictMonad.Applicative0());
  var bind215 = bind(dictMonad.Bind1());
  return function(n) {
    return function(m) {
      if (n < 1) {
        return pure122(nil);
      }
      ;
      if (otherwise) {
        return bind215(m)(function(a) {
          return bind215(replicateM(dictMonad)(n - 1 | 0)(m))(function(as3) {
            return pure122(cons4(a)(as3));
          });
        });
      }
      ;
      throw new Error("Failed pattern match at Data.List.Lazy (line 164, column 1 - line 164, column 62): " + [n.constructor.name, m.constructor.name]);
    };
  };
};
var filter3 = function(p) {
  var go = function($copy_v) {
    var $tco_done = false;
    var $tco_result;
    function $tco_loop(v) {
      if (v instanceof Nil2) {
        $tco_done = true;
        return Nil2.value;
      }
      ;
      if (v instanceof Cons2) {
        if (p(v.value0)) {
          $tco_done = true;
          return new Cons2(v.value0, filter3(p)(v.value1));
        }
        ;
        if (otherwise) {
          $copy_v = step(v.value1);
          return;
        }
        ;
      }
      ;
      throw new Error("Failed pattern match at Data.List.Lazy (line 416, column 3 - line 416, column 15): " + [v.constructor.name]);
    }
    ;
    while (!$tco_done) {
      $tco_result = $tco_loop($copy_v);
    }
    ;
    return $tco_result;
  };
  var $344 = map15(go);
  return function($345) {
    return List($344(unwrap5($345)));
  };
};

// output/Data.Map.Internal/index.js
var identity9 = /* @__PURE__ */ identity(categoryFn);
var foldl5 = /* @__PURE__ */ foldl(foldableList);
var Leaf = /* @__PURE__ */ function() {
  function Leaf3() {
  }
  ;
  Leaf3.value = new Leaf3();
  return Leaf3;
}();
var Two = /* @__PURE__ */ function() {
  function Two2(value0, value12, value22, value32) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
    this.value3 = value32;
  }
  ;
  Two2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return function(value32) {
          return new Two2(value0, value12, value22, value32);
        };
      };
    };
  };
  return Two2;
}();
var Three = /* @__PURE__ */ function() {
  function Three2(value0, value12, value22, value32, value4, value5, value6) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
    this.value3 = value32;
    this.value4 = value4;
    this.value5 = value5;
    this.value6 = value6;
  }
  ;
  Three2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return function(value32) {
          return function(value4) {
            return function(value5) {
              return function(value6) {
                return new Three2(value0, value12, value22, value32, value4, value5, value6);
              };
            };
          };
        };
      };
    };
  };
  return Three2;
}();
var TwoLeft = /* @__PURE__ */ function() {
  function TwoLeft2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  TwoLeft2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new TwoLeft2(value0, value12, value22);
      };
    };
  };
  return TwoLeft2;
}();
var TwoRight = /* @__PURE__ */ function() {
  function TwoRight2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  TwoRight2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new TwoRight2(value0, value12, value22);
      };
    };
  };
  return TwoRight2;
}();
var ThreeLeft = /* @__PURE__ */ function() {
  function ThreeLeft2(value0, value12, value22, value32, value4, value5) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
    this.value3 = value32;
    this.value4 = value4;
    this.value5 = value5;
  }
  ;
  ThreeLeft2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return function(value32) {
          return function(value4) {
            return function(value5) {
              return new ThreeLeft2(value0, value12, value22, value32, value4, value5);
            };
          };
        };
      };
    };
  };
  return ThreeLeft2;
}();
var ThreeMiddle = /* @__PURE__ */ function() {
  function ThreeMiddle2(value0, value12, value22, value32, value4, value5) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
    this.value3 = value32;
    this.value4 = value4;
    this.value5 = value5;
  }
  ;
  ThreeMiddle2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return function(value32) {
          return function(value4) {
            return function(value5) {
              return new ThreeMiddle2(value0, value12, value22, value32, value4, value5);
            };
          };
        };
      };
    };
  };
  return ThreeMiddle2;
}();
var ThreeRight = /* @__PURE__ */ function() {
  function ThreeRight2(value0, value12, value22, value32, value4, value5) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
    this.value3 = value32;
    this.value4 = value4;
    this.value5 = value5;
  }
  ;
  ThreeRight2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return function(value32) {
          return function(value4) {
            return function(value5) {
              return new ThreeRight2(value0, value12, value22, value32, value4, value5);
            };
          };
        };
      };
    };
  };
  return ThreeRight2;
}();
var KickUp = /* @__PURE__ */ function() {
  function KickUp2(value0, value12, value22, value32) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
    this.value3 = value32;
  }
  ;
  KickUp2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return function(value32) {
          return new KickUp2(value0, value12, value22, value32);
        };
      };
    };
  };
  return KickUp2;
}();
var size2 = function(v) {
  if (v instanceof Leaf) {
    return 0;
  }
  ;
  if (v instanceof Two) {
    return (1 + size2(v.value0) | 0) + size2(v.value3) | 0;
  }
  ;
  if (v instanceof Three) {
    return ((2 + size2(v.value0) | 0) + size2(v.value3) | 0) + size2(v.value6) | 0;
  }
  ;
  throw new Error("Failed pattern match at Data.Map.Internal (line 705, column 1 - line 705, column 35): " + [v.constructor.name]);
};
var singleton10 = function(k) {
  return function(v) {
    return new Two(Leaf.value, k, v, Leaf.value);
  };
};
var toUnfoldable5 = function(dictUnfoldable) {
  var unfoldr4 = unfoldr(dictUnfoldable);
  return function(m) {
    var go = function($copy_v) {
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(v) {
        if (v instanceof Nil) {
          $tco_done = true;
          return Nothing.value;
        }
        ;
        if (v instanceof Cons) {
          if (v.value0 instanceof Leaf) {
            $copy_v = v.value1;
            return;
          }
          ;
          if (v.value0 instanceof Two && (v.value0.value0 instanceof Leaf && v.value0.value3 instanceof Leaf)) {
            $tco_done = true;
            return new Just(new Tuple(new Tuple(v.value0.value1, v.value0.value2), v.value1));
          }
          ;
          if (v.value0 instanceof Two && v.value0.value0 instanceof Leaf) {
            $tco_done = true;
            return new Just(new Tuple(new Tuple(v.value0.value1, v.value0.value2), new Cons(v.value0.value3, v.value1)));
          }
          ;
          if (v.value0 instanceof Two) {
            $copy_v = new Cons(v.value0.value0, new Cons(singleton10(v.value0.value1)(v.value0.value2), new Cons(v.value0.value3, v.value1)));
            return;
          }
          ;
          if (v.value0 instanceof Three) {
            $copy_v = new Cons(v.value0.value0, new Cons(singleton10(v.value0.value1)(v.value0.value2), new Cons(v.value0.value3, new Cons(singleton10(v.value0.value4)(v.value0.value5), new Cons(v.value0.value6, v.value1)))));
            return;
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 624, column 18 - line 633, column 71): " + [v.value0.constructor.name]);
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 623, column 3 - line 623, column 19): " + [v.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($copy_v);
      }
      ;
      return $tco_result;
    };
    return unfoldr4(go)(new Cons(m, Nil.value));
  };
};
var toUnfoldable1 = /* @__PURE__ */ toUnfoldable5(unfoldableList2);
var toUnfoldable22 = /* @__PURE__ */ toUnfoldable5(unfoldableList);
var toAscArray = /* @__PURE__ */ toUnfoldable5(unfoldableArray);
var lookup3 = function(dictOrd) {
  var compare10 = compare(dictOrd);
  return function(k) {
    var go = function($copy_v) {
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(v) {
        if (v instanceof Leaf) {
          $tco_done = true;
          return Nothing.value;
        }
        ;
        if (v instanceof Two) {
          var v2 = compare10(k)(v.value1);
          if (v2 instanceof EQ) {
            $tco_done = true;
            return new Just(v.value2);
          }
          ;
          if (v2 instanceof LT) {
            $copy_v = v.value0;
            return;
          }
          ;
          $copy_v = v.value3;
          return;
        }
        ;
        if (v instanceof Three) {
          var v3 = compare10(k)(v.value1);
          if (v3 instanceof EQ) {
            $tco_done = true;
            return new Just(v.value2);
          }
          ;
          var v4 = compare10(k)(v.value4);
          if (v4 instanceof EQ) {
            $tco_done = true;
            return new Just(v.value5);
          }
          ;
          if (v3 instanceof LT) {
            $copy_v = v.value0;
            return;
          }
          ;
          if (v4 instanceof GT) {
            $copy_v = v.value6;
            return;
          }
          ;
          $copy_v = v.value3;
          return;
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 241, column 5 - line 241, column 22): " + [v.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($copy_v);
      }
      ;
      return $tco_result;
    };
    return go;
  };
};
var member = function(dictOrd) {
  var lookup18 = lookup3(dictOrd);
  return function(k) {
    return function(m) {
      return isJust(lookup18(k)(m));
    };
  };
};
var isEmpty2 = function(v) {
  if (v instanceof Leaf) {
    return true;
  }
  ;
  return false;
};
var functorMap = {
  map: function(v) {
    return function(v1) {
      if (v1 instanceof Leaf) {
        return Leaf.value;
      }
      ;
      if (v1 instanceof Two) {
        return new Two(map(functorMap)(v)(v1.value0), v1.value1, v(v1.value2), map(functorMap)(v)(v1.value3));
      }
      ;
      if (v1 instanceof Three) {
        return new Three(map(functorMap)(v)(v1.value0), v1.value1, v(v1.value2), map(functorMap)(v)(v1.value3), v1.value4, v(v1.value5), map(functorMap)(v)(v1.value6));
      }
      ;
      throw new Error("Failed pattern match at Data.Map.Internal (line 116, column 1 - line 119, column 110): " + [v.constructor.name, v1.constructor.name]);
    };
  }
};
var functorWithIndexMap = {
  mapWithIndex: function(v) {
    return function(v1) {
      if (v1 instanceof Leaf) {
        return Leaf.value;
      }
      ;
      if (v1 instanceof Two) {
        return new Two(mapWithIndex(functorWithIndexMap)(v)(v1.value0), v1.value1, v(v1.value1)(v1.value2), mapWithIndex(functorWithIndexMap)(v)(v1.value3));
      }
      ;
      if (v1 instanceof Three) {
        return new Three(mapWithIndex(functorWithIndexMap)(v)(v1.value0), v1.value1, v(v1.value1)(v1.value2), mapWithIndex(functorWithIndexMap)(v)(v1.value3), v1.value4, v(v1.value4)(v1.value5), mapWithIndex(functorWithIndexMap)(v)(v1.value6));
      }
      ;
      throw new Error("Failed pattern match at Data.Map.Internal (line 121, column 1 - line 124, column 152): " + [v.constructor.name, v1.constructor.name]);
    };
  },
  Functor0: function() {
    return functorMap;
  }
};
var fromZipper = function($copy_dictOrd) {
  return function($copy_v) {
    return function($copy_v1) {
      var $tco_var_dictOrd = $copy_dictOrd;
      var $tco_var_v = $copy_v;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(dictOrd, v, v1) {
        if (v instanceof Nil) {
          $tco_done = true;
          return v1;
        }
        ;
        if (v instanceof Cons) {
          if (v.value0 instanceof TwoLeft) {
            $tco_var_dictOrd = dictOrd;
            $tco_var_v = v.value1;
            $copy_v1 = new Two(v1, v.value0.value0, v.value0.value1, v.value0.value2);
            return;
          }
          ;
          if (v.value0 instanceof TwoRight) {
            $tco_var_dictOrd = dictOrd;
            $tco_var_v = v.value1;
            $copy_v1 = new Two(v.value0.value0, v.value0.value1, v.value0.value2, v1);
            return;
          }
          ;
          if (v.value0 instanceof ThreeLeft) {
            $tco_var_dictOrd = dictOrd;
            $tco_var_v = v.value1;
            $copy_v1 = new Three(v1, v.value0.value0, v.value0.value1, v.value0.value2, v.value0.value3, v.value0.value4, v.value0.value5);
            return;
          }
          ;
          if (v.value0 instanceof ThreeMiddle) {
            $tco_var_dictOrd = dictOrd;
            $tco_var_v = v.value1;
            $copy_v1 = new Three(v.value0.value0, v.value0.value1, v.value0.value2, v1, v.value0.value3, v.value0.value4, v.value0.value5);
            return;
          }
          ;
          if (v.value0 instanceof ThreeRight) {
            $tco_var_dictOrd = dictOrd;
            $tco_var_v = v.value1;
            $copy_v1 = new Three(v.value0.value0, v.value0.value1, v.value0.value2, v.value0.value3, v.value0.value4, v.value0.value5, v1);
            return;
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 462, column 3 - line 467, column 88): " + [v.value0.constructor.name]);
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 459, column 1 - line 459, column 80): " + [v.constructor.name, v1.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_dictOrd, $tco_var_v, $copy_v1);
      }
      ;
      return $tco_result;
    };
  };
};
var insert3 = function(dictOrd) {
  var fromZipper1 = fromZipper(dictOrd);
  var compare10 = compare(dictOrd);
  return function(k) {
    return function(v) {
      var up = function($copy_v1) {
        return function($copy_v2) {
          var $tco_var_v1 = $copy_v1;
          var $tco_done = false;
          var $tco_result;
          function $tco_loop(v1, v2) {
            if (v1 instanceof Nil) {
              $tco_done = true;
              return new Two(v2.value0, v2.value1, v2.value2, v2.value3);
            }
            ;
            if (v1 instanceof Cons) {
              if (v1.value0 instanceof TwoLeft) {
                $tco_done = true;
                return fromZipper1(v1.value1)(new Three(v2.value0, v2.value1, v2.value2, v2.value3, v1.value0.value0, v1.value0.value1, v1.value0.value2));
              }
              ;
              if (v1.value0 instanceof TwoRight) {
                $tco_done = true;
                return fromZipper1(v1.value1)(new Three(v1.value0.value0, v1.value0.value1, v1.value0.value2, v2.value0, v2.value1, v2.value2, v2.value3));
              }
              ;
              if (v1.value0 instanceof ThreeLeft) {
                $tco_var_v1 = v1.value1;
                $copy_v2 = new KickUp(new Two(v2.value0, v2.value1, v2.value2, v2.value3), v1.value0.value0, v1.value0.value1, new Two(v1.value0.value2, v1.value0.value3, v1.value0.value4, v1.value0.value5));
                return;
              }
              ;
              if (v1.value0 instanceof ThreeMiddle) {
                $tco_var_v1 = v1.value1;
                $copy_v2 = new KickUp(new Two(v1.value0.value0, v1.value0.value1, v1.value0.value2, v2.value0), v2.value1, v2.value2, new Two(v2.value3, v1.value0.value3, v1.value0.value4, v1.value0.value5));
                return;
              }
              ;
              if (v1.value0 instanceof ThreeRight) {
                $tco_var_v1 = v1.value1;
                $copy_v2 = new KickUp(new Two(v1.value0.value0, v1.value0.value1, v1.value0.value2, v1.value0.value3), v1.value0.value4, v1.value0.value5, new Two(v2.value0, v2.value1, v2.value2, v2.value3));
                return;
              }
              ;
              throw new Error("Failed pattern match at Data.Map.Internal (line 498, column 5 - line 503, column 108): " + [v1.value0.constructor.name, v2.constructor.name]);
            }
            ;
            throw new Error("Failed pattern match at Data.Map.Internal (line 495, column 3 - line 495, column 56): " + [v1.constructor.name, v2.constructor.name]);
          }
          ;
          while (!$tco_done) {
            $tco_result = $tco_loop($tco_var_v1, $copy_v2);
          }
          ;
          return $tco_result;
        };
      };
      var down = function($copy_v1) {
        return function($copy_v2) {
          var $tco_var_v1 = $copy_v1;
          var $tco_done1 = false;
          var $tco_result;
          function $tco_loop(v1, v2) {
            if (v2 instanceof Leaf) {
              $tco_done1 = true;
              return up(v1)(new KickUp(Leaf.value, k, v, Leaf.value));
            }
            ;
            if (v2 instanceof Two) {
              var v3 = compare10(k)(v2.value1);
              if (v3 instanceof EQ) {
                $tco_done1 = true;
                return fromZipper1(v1)(new Two(v2.value0, k, v, v2.value3));
              }
              ;
              if (v3 instanceof LT) {
                $tco_var_v1 = new Cons(new TwoLeft(v2.value1, v2.value2, v2.value3), v1);
                $copy_v2 = v2.value0;
                return;
              }
              ;
              $tco_var_v1 = new Cons(new TwoRight(v2.value0, v2.value1, v2.value2), v1);
              $copy_v2 = v2.value3;
              return;
            }
            ;
            if (v2 instanceof Three) {
              var v3 = compare10(k)(v2.value1);
              if (v3 instanceof EQ) {
                $tco_done1 = true;
                return fromZipper1(v1)(new Three(v2.value0, k, v, v2.value3, v2.value4, v2.value5, v2.value6));
              }
              ;
              var v4 = compare10(k)(v2.value4);
              if (v4 instanceof EQ) {
                $tco_done1 = true;
                return fromZipper1(v1)(new Three(v2.value0, v2.value1, v2.value2, v2.value3, k, v, v2.value6));
              }
              ;
              if (v3 instanceof LT) {
                $tco_var_v1 = new Cons(new ThreeLeft(v2.value1, v2.value2, v2.value3, v2.value4, v2.value5, v2.value6), v1);
                $copy_v2 = v2.value0;
                return;
              }
              ;
              if (v3 instanceof GT && v4 instanceof LT) {
                $tco_var_v1 = new Cons(new ThreeMiddle(v2.value0, v2.value1, v2.value2, v2.value4, v2.value5, v2.value6), v1);
                $copy_v2 = v2.value3;
                return;
              }
              ;
              $tco_var_v1 = new Cons(new ThreeRight(v2.value0, v2.value1, v2.value2, v2.value3, v2.value4, v2.value5), v1);
              $copy_v2 = v2.value6;
              return;
            }
            ;
            throw new Error("Failed pattern match at Data.Map.Internal (line 478, column 3 - line 478, column 55): " + [v1.constructor.name, v2.constructor.name]);
          }
          ;
          while (!$tco_done1) {
            $tco_result = $tco_loop($tco_var_v1, $copy_v2);
          }
          ;
          return $tco_result;
        };
      };
      return down(Nil.value);
    };
  };
};
var pop = function(dictOrd) {
  var fromZipper1 = fromZipper(dictOrd);
  var compare10 = compare(dictOrd);
  return function(k) {
    var up = function($copy_ctxs) {
      return function($copy_tree) {
        var $tco_var_ctxs = $copy_ctxs;
        var $tco_done = false;
        var $tco_result;
        function $tco_loop(ctxs, tree) {
          if (ctxs instanceof Nil) {
            $tco_done = true;
            return tree;
          }
          ;
          if (ctxs instanceof Cons) {
            if (ctxs.value0 instanceof TwoLeft && (ctxs.value0.value2 instanceof Leaf && tree instanceof Leaf)) {
              $tco_done = true;
              return fromZipper1(ctxs.value1)(new Two(Leaf.value, ctxs.value0.value0, ctxs.value0.value1, Leaf.value));
            }
            ;
            if (ctxs.value0 instanceof TwoRight && (ctxs.value0.value0 instanceof Leaf && tree instanceof Leaf)) {
              $tco_done = true;
              return fromZipper1(ctxs.value1)(new Two(Leaf.value, ctxs.value0.value1, ctxs.value0.value2, Leaf.value));
            }
            ;
            if (ctxs.value0 instanceof TwoLeft && ctxs.value0.value2 instanceof Two) {
              $tco_var_ctxs = ctxs.value1;
              $copy_tree = new Three(tree, ctxs.value0.value0, ctxs.value0.value1, ctxs.value0.value2.value0, ctxs.value0.value2.value1, ctxs.value0.value2.value2, ctxs.value0.value2.value3);
              return;
            }
            ;
            if (ctxs.value0 instanceof TwoRight && ctxs.value0.value0 instanceof Two) {
              $tco_var_ctxs = ctxs.value1;
              $copy_tree = new Three(ctxs.value0.value0.value0, ctxs.value0.value0.value1, ctxs.value0.value0.value2, ctxs.value0.value0.value3, ctxs.value0.value1, ctxs.value0.value2, tree);
              return;
            }
            ;
            if (ctxs.value0 instanceof TwoLeft && ctxs.value0.value2 instanceof Three) {
              $tco_done = true;
              return fromZipper1(ctxs.value1)(new Two(new Two(tree, ctxs.value0.value0, ctxs.value0.value1, ctxs.value0.value2.value0), ctxs.value0.value2.value1, ctxs.value0.value2.value2, new Two(ctxs.value0.value2.value3, ctxs.value0.value2.value4, ctxs.value0.value2.value5, ctxs.value0.value2.value6)));
            }
            ;
            if (ctxs.value0 instanceof TwoRight && ctxs.value0.value0 instanceof Three) {
              $tco_done = true;
              return fromZipper1(ctxs.value1)(new Two(new Two(ctxs.value0.value0.value0, ctxs.value0.value0.value1, ctxs.value0.value0.value2, ctxs.value0.value0.value3), ctxs.value0.value0.value4, ctxs.value0.value0.value5, new Two(ctxs.value0.value0.value6, ctxs.value0.value1, ctxs.value0.value2, tree)));
            }
            ;
            if (ctxs.value0 instanceof ThreeLeft && (ctxs.value0.value2 instanceof Leaf && (ctxs.value0.value5 instanceof Leaf && tree instanceof Leaf))) {
              $tco_done = true;
              return fromZipper1(ctxs.value1)(new Three(Leaf.value, ctxs.value0.value0, ctxs.value0.value1, Leaf.value, ctxs.value0.value3, ctxs.value0.value4, Leaf.value));
            }
            ;
            if (ctxs.value0 instanceof ThreeMiddle && (ctxs.value0.value0 instanceof Leaf && (ctxs.value0.value5 instanceof Leaf && tree instanceof Leaf))) {
              $tco_done = true;
              return fromZipper1(ctxs.value1)(new Three(Leaf.value, ctxs.value0.value1, ctxs.value0.value2, Leaf.value, ctxs.value0.value3, ctxs.value0.value4, Leaf.value));
            }
            ;
            if (ctxs.value0 instanceof ThreeRight && (ctxs.value0.value0 instanceof Leaf && (ctxs.value0.value3 instanceof Leaf && tree instanceof Leaf))) {
              $tco_done = true;
              return fromZipper1(ctxs.value1)(new Three(Leaf.value, ctxs.value0.value1, ctxs.value0.value2, Leaf.value, ctxs.value0.value4, ctxs.value0.value5, Leaf.value));
            }
            ;
            if (ctxs.value0 instanceof ThreeLeft && ctxs.value0.value2 instanceof Two) {
              $tco_done = true;
              return fromZipper1(ctxs.value1)(new Two(new Three(tree, ctxs.value0.value0, ctxs.value0.value1, ctxs.value0.value2.value0, ctxs.value0.value2.value1, ctxs.value0.value2.value2, ctxs.value0.value2.value3), ctxs.value0.value3, ctxs.value0.value4, ctxs.value0.value5));
            }
            ;
            if (ctxs.value0 instanceof ThreeMiddle && ctxs.value0.value0 instanceof Two) {
              $tco_done = true;
              return fromZipper1(ctxs.value1)(new Two(new Three(ctxs.value0.value0.value0, ctxs.value0.value0.value1, ctxs.value0.value0.value2, ctxs.value0.value0.value3, ctxs.value0.value1, ctxs.value0.value2, tree), ctxs.value0.value3, ctxs.value0.value4, ctxs.value0.value5));
            }
            ;
            if (ctxs.value0 instanceof ThreeMiddle && ctxs.value0.value5 instanceof Two) {
              $tco_done = true;
              return fromZipper1(ctxs.value1)(new Two(ctxs.value0.value0, ctxs.value0.value1, ctxs.value0.value2, new Three(tree, ctxs.value0.value3, ctxs.value0.value4, ctxs.value0.value5.value0, ctxs.value0.value5.value1, ctxs.value0.value5.value2, ctxs.value0.value5.value3)));
            }
            ;
            if (ctxs.value0 instanceof ThreeRight && ctxs.value0.value3 instanceof Two) {
              $tco_done = true;
              return fromZipper1(ctxs.value1)(new Two(ctxs.value0.value0, ctxs.value0.value1, ctxs.value0.value2, new Three(ctxs.value0.value3.value0, ctxs.value0.value3.value1, ctxs.value0.value3.value2, ctxs.value0.value3.value3, ctxs.value0.value4, ctxs.value0.value5, tree)));
            }
            ;
            if (ctxs.value0 instanceof ThreeLeft && ctxs.value0.value2 instanceof Three) {
              $tco_done = true;
              return fromZipper1(ctxs.value1)(new Three(new Two(tree, ctxs.value0.value0, ctxs.value0.value1, ctxs.value0.value2.value0), ctxs.value0.value2.value1, ctxs.value0.value2.value2, new Two(ctxs.value0.value2.value3, ctxs.value0.value2.value4, ctxs.value0.value2.value5, ctxs.value0.value2.value6), ctxs.value0.value3, ctxs.value0.value4, ctxs.value0.value5));
            }
            ;
            if (ctxs.value0 instanceof ThreeMiddle && ctxs.value0.value0 instanceof Three) {
              $tco_done = true;
              return fromZipper1(ctxs.value1)(new Three(new Two(ctxs.value0.value0.value0, ctxs.value0.value0.value1, ctxs.value0.value0.value2, ctxs.value0.value0.value3), ctxs.value0.value0.value4, ctxs.value0.value0.value5, new Two(ctxs.value0.value0.value6, ctxs.value0.value1, ctxs.value0.value2, tree), ctxs.value0.value3, ctxs.value0.value4, ctxs.value0.value5));
            }
            ;
            if (ctxs.value0 instanceof ThreeMiddle && ctxs.value0.value5 instanceof Three) {
              $tco_done = true;
              return fromZipper1(ctxs.value1)(new Three(ctxs.value0.value0, ctxs.value0.value1, ctxs.value0.value2, new Two(tree, ctxs.value0.value3, ctxs.value0.value4, ctxs.value0.value5.value0), ctxs.value0.value5.value1, ctxs.value0.value5.value2, new Two(ctxs.value0.value5.value3, ctxs.value0.value5.value4, ctxs.value0.value5.value5, ctxs.value0.value5.value6)));
            }
            ;
            if (ctxs.value0 instanceof ThreeRight && ctxs.value0.value3 instanceof Three) {
              $tco_done = true;
              return fromZipper1(ctxs.value1)(new Three(ctxs.value0.value0, ctxs.value0.value1, ctxs.value0.value2, new Two(ctxs.value0.value3.value0, ctxs.value0.value3.value1, ctxs.value0.value3.value2, ctxs.value0.value3.value3), ctxs.value0.value3.value4, ctxs.value0.value3.value5, new Two(ctxs.value0.value3.value6, ctxs.value0.value4, ctxs.value0.value5, tree)));
            }
            ;
            $tco_done = true;
            return unsafeCrashWith("The impossible happened in partial function `up`.");
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 552, column 5 - line 573, column 86): " + [ctxs.constructor.name]);
        }
        ;
        while (!$tco_done) {
          $tco_result = $tco_loop($tco_var_ctxs, $copy_tree);
        }
        ;
        return $tco_result;
      };
    };
    var removeMaxNode = function($copy_ctx) {
      return function($copy_m) {
        var $tco_var_ctx = $copy_ctx;
        var $tco_done1 = false;
        var $tco_result;
        function $tco_loop(ctx, m) {
          if (m instanceof Two && (m.value0 instanceof Leaf && m.value3 instanceof Leaf)) {
            $tco_done1 = true;
            return up(ctx)(Leaf.value);
          }
          ;
          if (m instanceof Two) {
            $tco_var_ctx = new Cons(new TwoRight(m.value0, m.value1, m.value2), ctx);
            $copy_m = m.value3;
            return;
          }
          ;
          if (m instanceof Three && (m.value0 instanceof Leaf && (m.value3 instanceof Leaf && m.value6 instanceof Leaf))) {
            $tco_done1 = true;
            return up(new Cons(new TwoRight(Leaf.value, m.value1, m.value2), ctx))(Leaf.value);
          }
          ;
          if (m instanceof Three) {
            $tco_var_ctx = new Cons(new ThreeRight(m.value0, m.value1, m.value2, m.value3, m.value4, m.value5), ctx);
            $copy_m = m.value6;
            return;
          }
          ;
          $tco_done1 = true;
          return unsafeCrashWith("The impossible happened in partial function `removeMaxNode`.");
        }
        ;
        while (!$tco_done1) {
          $tco_result = $tco_loop($tco_var_ctx, $copy_m);
        }
        ;
        return $tco_result;
      };
    };
    var maxNode = function($copy_m) {
      var $tco_done2 = false;
      var $tco_result;
      function $tco_loop(m) {
        if (m instanceof Two && m.value3 instanceof Leaf) {
          $tco_done2 = true;
          return {
            key: m.value1,
            value: m.value2
          };
        }
        ;
        if (m instanceof Two) {
          $copy_m = m.value3;
          return;
        }
        ;
        if (m instanceof Three && m.value6 instanceof Leaf) {
          $tco_done2 = true;
          return {
            key: m.value4,
            value: m.value5
          };
        }
        ;
        if (m instanceof Three) {
          $copy_m = m.value6;
          return;
        }
        ;
        $tco_done2 = true;
        return unsafeCrashWith("The impossible happened in partial function `maxNode`.");
      }
      ;
      while (!$tco_done2) {
        $tco_result = $tco_loop($copy_m);
      }
      ;
      return $tco_result;
    };
    var down = function($copy_ctx) {
      return function($copy_m) {
        var $tco_var_ctx = $copy_ctx;
        var $tco_done3 = false;
        var $tco_result;
        function $tco_loop(ctx, m) {
          if (m instanceof Leaf) {
            $tco_done3 = true;
            return Nothing.value;
          }
          ;
          if (m instanceof Two) {
            var v = compare10(k)(m.value1);
            if (m.value3 instanceof Leaf && v instanceof EQ) {
              $tco_done3 = true;
              return new Just(new Tuple(m.value2, up(ctx)(Leaf.value)));
            }
            ;
            if (v instanceof EQ) {
              var max8 = maxNode(m.value0);
              $tco_done3 = true;
              return new Just(new Tuple(m.value2, removeMaxNode(new Cons(new TwoLeft(max8.key, max8.value, m.value3), ctx))(m.value0)));
            }
            ;
            if (v instanceof LT) {
              $tco_var_ctx = new Cons(new TwoLeft(m.value1, m.value2, m.value3), ctx);
              $copy_m = m.value0;
              return;
            }
            ;
            $tco_var_ctx = new Cons(new TwoRight(m.value0, m.value1, m.value2), ctx);
            $copy_m = m.value3;
            return;
          }
          ;
          if (m instanceof Three) {
            var leaves = function() {
              if (m.value0 instanceof Leaf && (m.value3 instanceof Leaf && m.value6 instanceof Leaf)) {
                return true;
              }
              ;
              return false;
            }();
            var v = compare10(k)(m.value4);
            var v3 = compare10(k)(m.value1);
            if (leaves && v3 instanceof EQ) {
              $tco_done3 = true;
              return new Just(new Tuple(m.value2, fromZipper1(ctx)(new Two(Leaf.value, m.value4, m.value5, Leaf.value))));
            }
            ;
            if (leaves && v instanceof EQ) {
              $tco_done3 = true;
              return new Just(new Tuple(m.value5, fromZipper1(ctx)(new Two(Leaf.value, m.value1, m.value2, Leaf.value))));
            }
            ;
            if (v3 instanceof EQ) {
              var max8 = maxNode(m.value0);
              $tco_done3 = true;
              return new Just(new Tuple(m.value2, removeMaxNode(new Cons(new ThreeLeft(max8.key, max8.value, m.value3, m.value4, m.value5, m.value6), ctx))(m.value0)));
            }
            ;
            if (v instanceof EQ) {
              var max8 = maxNode(m.value3);
              $tco_done3 = true;
              return new Just(new Tuple(m.value5, removeMaxNode(new Cons(new ThreeMiddle(m.value0, m.value1, m.value2, max8.key, max8.value, m.value6), ctx))(m.value3)));
            }
            ;
            if (v3 instanceof LT) {
              $tco_var_ctx = new Cons(new ThreeLeft(m.value1, m.value2, m.value3, m.value4, m.value5, m.value6), ctx);
              $copy_m = m.value0;
              return;
            }
            ;
            if (v3 instanceof GT && v instanceof LT) {
              $tco_var_ctx = new Cons(new ThreeMiddle(m.value0, m.value1, m.value2, m.value4, m.value5, m.value6), ctx);
              $copy_m = m.value3;
              return;
            }
            ;
            $tco_var_ctx = new Cons(new ThreeRight(m.value0, m.value1, m.value2, m.value3, m.value4, m.value5), ctx);
            $copy_m = m.value6;
            return;
          }
          ;
          throw new Error("Failed pattern match at Data.Map.Internal (line 525, column 16 - line 548, column 80): " + [m.constructor.name]);
        }
        ;
        while (!$tco_done3) {
          $tco_result = $tco_loop($tco_var_ctx, $copy_m);
        }
        ;
        return $tco_result;
      };
    };
    return down(Nil.value);
  };
};
var foldableMap = {
  foldr: function(f) {
    return function(z) {
      return function(m) {
        if (m instanceof Leaf) {
          return z;
        }
        ;
        if (m instanceof Two) {
          return foldr(foldableMap)(f)(f(m.value2)(foldr(foldableMap)(f)(z)(m.value3)))(m.value0);
        }
        ;
        if (m instanceof Three) {
          return foldr(foldableMap)(f)(f(m.value2)(foldr(foldableMap)(f)(f(m.value5)(foldr(foldableMap)(f)(z)(m.value6)))(m.value3)))(m.value0);
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 133, column 17 - line 136, column 85): " + [m.constructor.name]);
      };
    };
  },
  foldl: function(f) {
    return function(z) {
      return function(m) {
        if (m instanceof Leaf) {
          return z;
        }
        ;
        if (m instanceof Two) {
          return foldl(foldableMap)(f)(f(foldl(foldableMap)(f)(z)(m.value0))(m.value2))(m.value3);
        }
        ;
        if (m instanceof Three) {
          return foldl(foldableMap)(f)(f(foldl(foldableMap)(f)(f(foldl(foldableMap)(f)(z)(m.value0))(m.value2))(m.value3))(m.value5))(m.value6);
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 137, column 17 - line 140, column 85): " + [m.constructor.name]);
      };
    };
  },
  foldMap: function(dictMonoid) {
    var mempty27 = mempty(dictMonoid);
    var append212 = append(dictMonoid.Semigroup0());
    return function(f) {
      return function(m) {
        if (m instanceof Leaf) {
          return mempty27;
        }
        ;
        if (m instanceof Two) {
          return append212(foldMap(foldableMap)(dictMonoid)(f)(m.value0))(append212(f(m.value2))(foldMap(foldableMap)(dictMonoid)(f)(m.value3)));
        }
        ;
        if (m instanceof Three) {
          return append212(foldMap(foldableMap)(dictMonoid)(f)(m.value0))(append212(f(m.value2))(append212(foldMap(foldableMap)(dictMonoid)(f)(m.value3))(append212(f(m.value5))(foldMap(foldableMap)(dictMonoid)(f)(m.value6)))));
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 141, column 17 - line 144, column 93): " + [m.constructor.name]);
      };
    };
  }
};
var foldableWithIndexMap = {
  foldrWithIndex: function(f) {
    return function(z) {
      return function(m) {
        if (m instanceof Leaf) {
          return z;
        }
        ;
        if (m instanceof Two) {
          return foldrWithIndex(foldableWithIndexMap)(f)(f(m.value1)(m.value2)(foldrWithIndex(foldableWithIndexMap)(f)(z)(m.value3)))(m.value0);
        }
        ;
        if (m instanceof Three) {
          return foldrWithIndex(foldableWithIndexMap)(f)(f(m.value1)(m.value2)(foldrWithIndex(foldableWithIndexMap)(f)(f(m.value4)(m.value5)(foldrWithIndex(foldableWithIndexMap)(f)(z)(m.value6)))(m.value3)))(m.value0);
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 147, column 26 - line 150, column 120): " + [m.constructor.name]);
      };
    };
  },
  foldlWithIndex: function(f) {
    return function(z) {
      return function(m) {
        if (m instanceof Leaf) {
          return z;
        }
        ;
        if (m instanceof Two) {
          return foldlWithIndex(foldableWithIndexMap)(f)(f(m.value1)(foldlWithIndex(foldableWithIndexMap)(f)(z)(m.value0))(m.value2))(m.value3);
        }
        ;
        if (m instanceof Three) {
          return foldlWithIndex(foldableWithIndexMap)(f)(f(m.value4)(foldlWithIndex(foldableWithIndexMap)(f)(f(m.value1)(foldlWithIndex(foldableWithIndexMap)(f)(z)(m.value0))(m.value2))(m.value3))(m.value5))(m.value6);
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 151, column 26 - line 154, column 120): " + [m.constructor.name]);
      };
    };
  },
  foldMapWithIndex: function(dictMonoid) {
    var mempty27 = mempty(dictMonoid);
    var append212 = append(dictMonoid.Semigroup0());
    return function(f) {
      return function(m) {
        if (m instanceof Leaf) {
          return mempty27;
        }
        ;
        if (m instanceof Two) {
          return append212(foldMapWithIndex(foldableWithIndexMap)(dictMonoid)(f)(m.value0))(append212(f(m.value1)(m.value2))(foldMapWithIndex(foldableWithIndexMap)(dictMonoid)(f)(m.value3)));
        }
        ;
        if (m instanceof Three) {
          return append212(foldMapWithIndex(foldableWithIndexMap)(dictMonoid)(f)(m.value0))(append212(f(m.value1)(m.value2))(append212(foldMapWithIndex(foldableWithIndexMap)(dictMonoid)(f)(m.value3))(append212(f(m.value4)(m.value5))(foldMapWithIndex(foldableWithIndexMap)(dictMonoid)(f)(m.value6)))));
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 155, column 26 - line 158, column 128): " + [m.constructor.name]);
      };
    };
  },
  Foldable0: function() {
    return foldableMap;
  }
};
var foldrWithIndex2 = /* @__PURE__ */ foldrWithIndex(foldableWithIndexMap);
var foldlWithIndex2 = /* @__PURE__ */ foldlWithIndex(foldableWithIndexMap);
var keys2 = /* @__PURE__ */ function() {
  return foldrWithIndex2(function(k) {
    return function(v) {
      return function(acc) {
        return new Cons(k, acc);
      };
    };
  })(Nil.value);
}();
var traversableMap = {
  traverse: function(dictApplicative) {
    var pure122 = pure(dictApplicative);
    var Apply0 = dictApplicative.Apply0();
    var apply25 = apply2(Apply0);
    var map136 = map(Apply0.Functor0());
    return function(v) {
      return function(v1) {
        if (v1 instanceof Leaf) {
          return pure122(Leaf.value);
        }
        ;
        if (v1 instanceof Two) {
          return apply25(apply25(apply25(map136(Two.create)(traverse(traversableMap)(dictApplicative)(v)(v1.value0)))(pure122(v1.value1)))(v(v1.value2)))(traverse(traversableMap)(dictApplicative)(v)(v1.value3));
        }
        ;
        if (v1 instanceof Three) {
          return apply25(apply25(apply25(apply25(apply25(apply25(map136(Three.create)(traverse(traversableMap)(dictApplicative)(v)(v1.value0)))(pure122(v1.value1)))(v(v1.value2)))(traverse(traversableMap)(dictApplicative)(v)(v1.value3)))(pure122(v1.value4)))(v(v1.value5)))(traverse(traversableMap)(dictApplicative)(v)(v1.value6));
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 160, column 1 - line 175, column 31): " + [v.constructor.name, v1.constructor.name]);
      };
    };
  },
  sequence: function(dictApplicative) {
    return traverse(traversableMap)(dictApplicative)(identity9);
  },
  Functor0: function() {
    return functorMap;
  },
  Foldable1: function() {
    return foldableMap;
  }
};
var traversableWithIndexMap = {
  traverseWithIndex: function(dictApplicative) {
    var pure122 = pure(dictApplicative);
    var Apply0 = dictApplicative.Apply0();
    var apply25 = apply2(Apply0);
    var map136 = map(Apply0.Functor0());
    return function(v) {
      return function(v1) {
        if (v1 instanceof Leaf) {
          return pure122(Leaf.value);
        }
        ;
        if (v1 instanceof Two) {
          return apply25(apply25(apply25(map136(Two.create)(traverseWithIndex(traversableWithIndexMap)(dictApplicative)(v)(v1.value0)))(pure122(v1.value1)))(v(v1.value1)(v1.value2)))(traverseWithIndex(traversableWithIndexMap)(dictApplicative)(v)(v1.value3));
        }
        ;
        if (v1 instanceof Three) {
          return apply25(apply25(apply25(apply25(apply25(apply25(map136(Three.create)(traverseWithIndex(traversableWithIndexMap)(dictApplicative)(v)(v1.value0)))(pure122(v1.value1)))(v(v1.value1)(v1.value2)))(traverseWithIndex(traversableWithIndexMap)(dictApplicative)(v)(v1.value3)))(pure122(v1.value4)))(v(v1.value4)(v1.value5)))(traverseWithIndex(traversableWithIndexMap)(dictApplicative)(v)(v1.value6));
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 177, column 1 - line 191, column 40): " + [v.constructor.name, v1.constructor.name]);
      };
    };
  },
  FunctorWithIndex0: function() {
    return functorWithIndexMap;
  },
  FoldableWithIndex1: function() {
    return foldableWithIndexMap;
  },
  Traversable2: function() {
    return traversableMap;
  }
};
var findMin = /* @__PURE__ */ function() {
  var go = function($copy_v) {
    return function($copy_v1) {
      var $tco_var_v = $copy_v;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(v, v1) {
        if (v1 instanceof Leaf) {
          $tco_done = true;
          return v;
        }
        ;
        if (v1 instanceof Two) {
          $tco_var_v = new Just({
            key: v1.value1,
            value: v1.value2
          });
          $copy_v1 = v1.value0;
          return;
        }
        ;
        if (v1 instanceof Three) {
          $tco_var_v = new Just({
            key: v1.value1,
            value: v1.value2
          });
          $copy_v1 = v1.value0;
          return;
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 338, column 5 - line 338, column 22): " + [v.constructor.name, v1.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_v, $copy_v1);
      }
      ;
      return $tco_result;
    };
  };
  return go(Nothing.value);
}();
var findMax = /* @__PURE__ */ function() {
  var go = function($copy_v) {
    return function($copy_v1) {
      var $tco_var_v = $copy_v;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(v, v1) {
        if (v1 instanceof Leaf) {
          $tco_done = true;
          return v;
        }
        ;
        if (v1 instanceof Two) {
          $tco_var_v = new Just({
            key: v1.value1,
            value: v1.value2
          });
          $copy_v1 = v1.value3;
          return;
        }
        ;
        if (v1 instanceof Three) {
          $tco_var_v = new Just({
            key: v1.value4,
            value: v1.value5
          });
          $copy_v1 = v1.value6;
          return;
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 330, column 5 - line 330, column 22): " + [v.constructor.name, v1.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_v, $copy_v1);
      }
      ;
      return $tco_result;
    };
  };
  return go(Nothing.value);
}();
var eqMap = function(dictEq) {
  var eqTuple2 = eqTuple(dictEq);
  return function(dictEq1) {
    var eq115 = eq(eqArray(eqTuple2(dictEq1)));
    return {
      eq: function(m1) {
        return function(m2) {
          return eq115(toAscArray(m1))(toAscArray(m2));
        };
      }
    };
  };
};
var empty3 = /* @__PURE__ */ function() {
  return Leaf.value;
}();
var fromFoldable6 = function(dictOrd) {
  var insert110 = insert3(dictOrd);
  return function(dictFoldable) {
    return foldl(dictFoldable)(function(m) {
      return function(v) {
        return insert110(v.value0)(v.value1)(m);
      };
    })(empty3);
  };
};
var filterWithKey = function(dictOrd) {
  var fromFoldable116 = fromFoldable6(dictOrd)(foldableList2);
  return function(predicate) {
    var $927 = filter3(uncurry(predicate));
    return function($928) {
      return fromFoldable116($927(toUnfoldable1($928)));
    };
  };
};
var filterKeys = function(dictOrd) {
  var filterWithKey12 = filterWithKey(dictOrd);
  return function(predicate) {
    return filterWithKey12(function($929) {
      return $$const(predicate($929));
    });
  };
};
var intersectionWith = function(dictOrd) {
  var compare10 = compare(dictOrd);
  var insert110 = insert3(dictOrd);
  return function(f) {
    return function(m1) {
      return function(m2) {
        var go = function($copy_v) {
          return function($copy_v1) {
            return function($copy_v2) {
              var $tco_var_v = $copy_v;
              var $tco_var_v1 = $copy_v1;
              var $tco_done = false;
              var $tco_result;
              function $tco_loop(v, v1, v2) {
                if (v instanceof Nil) {
                  $tco_done = true;
                  return v2;
                }
                ;
                if (v1 instanceof Nil) {
                  $tco_done = true;
                  return v2;
                }
                ;
                if (v instanceof Cons && v1 instanceof Cons) {
                  var v3 = compare10(v.value0.value0)(v1.value0.value0);
                  if (v3 instanceof LT) {
                    $tco_var_v = v.value1;
                    $tco_var_v1 = v1;
                    $copy_v2 = v2;
                    return;
                  }
                  ;
                  if (v3 instanceof EQ) {
                    $tco_var_v = v.value1;
                    $tco_var_v1 = v1.value1;
                    $copy_v2 = insert110(v.value0.value0)(f(v.value0.value1)(v1.value0.value1))(v2);
                    return;
                  }
                  ;
                  if (v3 instanceof GT) {
                    $tco_var_v = v;
                    $tco_var_v1 = v1.value1;
                    $copy_v2 = v2;
                    return;
                  }
                  ;
                  throw new Error("Failed pattern match at Data.Map.Internal (line 684, column 5 - line 687, column 27): " + [v3.constructor.name]);
                }
                ;
                throw new Error("Failed pattern match at Data.Map.Internal (line 681, column 3 - line 681, column 17): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
              }
              ;
              while (!$tco_done) {
                $tco_result = $tco_loop($tco_var_v, $tco_var_v1, $copy_v2);
              }
              ;
              return $tco_result;
            };
          };
        };
        return go(toUnfoldable22(m1))(toUnfoldable22(m2))(empty3);
      };
    };
  };
};
var mapMaybeWithKey = function(dictOrd) {
  var insert110 = insert3(dictOrd);
  return function(f) {
    return foldrWithIndex2(function(k) {
      return function(a) {
        return function(acc) {
          return maybe(acc)(function(b) {
            return insert110(k)(b)(acc);
          })(f(k)(a));
        };
      };
    })(empty3);
  };
};
var mapMaybe3 = function(dictOrd) {
  var $930 = mapMaybeWithKey(dictOrd);
  return function($931) {
    return $930($$const($931));
  };
};
var $$delete3 = function(dictOrd) {
  var pop1 = pop(dictOrd);
  return function(k) {
    return function(m) {
      return maybe(m)(snd)(pop1(k)(m));
    };
  };
};
var difference2 = function(dictOrd) {
  var delete1 = $$delete3(dictOrd);
  return function(m1) {
    return function(m2) {
      return foldl5(flip(delete1))(m1)(keys2(m2));
    };
  };
};
var catMaybes3 = function(dictOrd) {
  return mapMaybe3(dictOrd)(identity9);
};
var applyMap = function(dictOrd) {
  return {
    apply: intersectionWith(dictOrd)(identity9),
    Functor0: function() {
      return functorMap;
    }
  };
};
var alter2 = function(dictOrd) {
  var lookup18 = lookup3(dictOrd);
  var delete1 = $$delete3(dictOrd);
  var insert110 = insert3(dictOrd);
  return function(f) {
    return function(k) {
      return function(m) {
        var v = f(lookup18(k)(m));
        if (v instanceof Nothing) {
          return delete1(k)(m);
        }
        ;
        if (v instanceof Just) {
          return insert110(k)(v.value0)(m);
        }
        ;
        throw new Error("Failed pattern match at Data.Map.Internal (line 596, column 15 - line 598, column 25): " + [v.constructor.name]);
      };
    };
  };
};
var unionWith = function(dictOrd) {
  var alter12 = alter2(dictOrd);
  return function(f) {
    return function(m1) {
      return function(m2) {
        var go = function(k) {
          return function(m) {
            return function(v) {
              return alter12(function() {
                var $936 = maybe(v)(f(v));
                return function($937) {
                  return Just.create($936($937));
                };
              }())(k)(m);
            };
          };
        };
        return foldlWithIndex2(go)(m2)(m1);
      };
    };
  };
};
var union3 = function(dictOrd) {
  return unionWith(dictOrd)($$const);
};

// output/Data.Profunctor/index.js
var identity10 = /* @__PURE__ */ identity(categoryFn);
var wrap2 = /* @__PURE__ */ wrap();
var unwrap6 = /* @__PURE__ */ unwrap();
var dimap = function(dict) {
  return dict.dimap;
};
var rmap2 = function(dictProfunctor) {
  var dimap1 = dimap(dictProfunctor);
  return function(b2c) {
    return dimap1(identity10)(b2c);
  };
};
var wrapIso = function(dictProfunctor) {
  var dimap1 = dimap(dictProfunctor);
  return function() {
    return function(v) {
      return dimap1(unwrap6)(wrap2);
    };
  };
};

// output/Data.Set/index.js
var foldMap3 = /* @__PURE__ */ foldMap(foldableList);
var foldl6 = /* @__PURE__ */ foldl(foldableList);
var foldr4 = /* @__PURE__ */ foldr(foldableList);
var $$Set = function(x) {
  return x;
};
var union4 = function(dictOrd) {
  var union13 = union3(dictOrd);
  return function(v) {
    return function(v1) {
      return union13(v)(v1);
    };
  };
};
var toList2 = function(v) {
  return keys2(v);
};
var toUnfoldable6 = function(dictUnfoldable) {
  var $127 = toUnfoldable4(dictUnfoldable);
  return function($128) {
    return $127(toList2($128));
  };
};
var singleton11 = function(a) {
  return singleton10(a)(unit);
};
var semigroupSet = function(dictOrd) {
  return {
    append: union4(dictOrd)
  };
};
var member2 = function(dictOrd) {
  var member1 = member(dictOrd);
  return function(a) {
    return function(v) {
      return member1(a)(v);
    };
  };
};
var isEmpty3 = function(v) {
  return isEmpty2(v);
};
var insert4 = function(dictOrd) {
  var insert110 = insert3(dictOrd);
  return function(a) {
    return function(v) {
      return insert110(a)(unit)(v);
    };
  };
};
var fromMap = $$Set;
var foldableSet = {
  foldMap: function(dictMonoid) {
    var foldMap111 = foldMap3(dictMonoid);
    return function(f) {
      var $129 = foldMap111(f);
      return function($130) {
        return $129(toList2($130));
      };
    };
  },
  foldl: function(f) {
    return function(x) {
      var $131 = foldl6(f)(x);
      return function($132) {
        return $131(toList2($132));
      };
    };
  },
  foldr: function(f) {
    return function(x) {
      var $133 = foldr4(f)(x);
      return function($134) {
        return $133(toList2($134));
      };
    };
  }
};
var foldl12 = /* @__PURE__ */ foldl(foldableSet);
var eqSet = function(dictEq) {
  var eq31 = eq(eqMap(dictEq)(eqUnit));
  return {
    eq: function(v) {
      return function(v1) {
        return eq31(v)(v1);
      };
    }
  };
};
var empty4 = empty3;
var fromFoldable7 = function(dictFoldable) {
  var foldl22 = foldl(dictFoldable);
  return function(dictOrd) {
    var insert110 = insert4(dictOrd);
    return foldl22(function(m) {
      return function(a) {
        return insert110(a)(m);
      };
    })(empty4);
  };
};
var map16 = function(dictOrd) {
  var insert110 = insert4(dictOrd);
  return function(f) {
    return foldl12(function(m) {
      return function(a) {
        return insert110(f(a))(m);
      };
    })(empty4);
  };
};
var monoidSet = function(dictOrd) {
  var semigroupSet1 = semigroupSet(dictOrd);
  return {
    mempty: empty4,
    Semigroup0: function() {
      return semigroupSet1;
    }
  };
};
var $$delete4 = function(dictOrd) {
  var delete1 = $$delete3(dictOrd);
  return function(a) {
    return function(v) {
      return delete1(a)(v);
    };
  };
};
var difference3 = function(dictOrd) {
  var delete1 = $$delete4(dictOrd);
  return function(s1) {
    return function(s2) {
      return foldl6(flip(delete1))(s1)(toList2(s2));
    };
  };
};

// output/Data.Set.NonEmpty/index.js
var toUnfoldable23 = /* @__PURE__ */ toUnfoldable6(unfoldableList);
var foldMap14 = /* @__PURE__ */ foldMap1(foldable1NonEmptyList);
var foldr12 = /* @__PURE__ */ foldr1(foldable1NonEmptyList);
var foldl13 = /* @__PURE__ */ foldl1(foldable1NonEmptyList);
var toUnfoldable12 = function(dictUnfoldable1) {
  var unfoldr12 = unfoldr1(dictUnfoldable1);
  return function(v) {
    var go = function(v1) {
      if (v1 instanceof Cons && v1.value1 instanceof Nil) {
        return new Tuple(v1.value0, Nothing.value);
      }
      ;
      if (v1 instanceof Cons) {
        return new Tuple(v1.value0, new Just(v1.value1));
      }
      ;
      throw new Error("Failed pattern match at Data.Set.NonEmpty (line 95, column 24 - line 97, column 38): " + [v1.constructor.name]);
    };
    return unfoldr12(go)(toUnfoldable23(v));
  };
};
var toUnfoldable11 = /* @__PURE__ */ toUnfoldable12(unfoldable1NonEmptyArray);
var toUnfoldable122 = /* @__PURE__ */ toUnfoldable12(unfoldable1NonEmptyList);
var toUnfoldable7 = function(dictUnfoldable) {
  var toUnfoldable32 = toUnfoldable6(dictUnfoldable);
  return function(v) {
    return toUnfoldable32(v);
  };
};
var toSet = function(v) {
  return v;
};
var singleton12 = function(a) {
  return singleton11(a);
};
var showNonEmptySet = function(dictShow) {
  var show48 = show(showNonEmptyArray(dictShow));
  return {
    show: function(s) {
      return "(fromFoldable1 " + (show48(toUnfoldable11(s)) + ")");
    }
  };
};
var semigroupNonEmptySet = function(dictOrd) {
  return semigroupSet(dictOrd);
};
var fromSet = function(s) {
  var $105 = isEmpty3(s);
  if ($105) {
    return Nothing.value;
  }
  ;
  return new Just(s);
};
var fromFoldable8 = function(dictFoldable) {
  var fromFoldable212 = fromFoldable7(dictFoldable);
  return function(dictOrd) {
    var $114 = fromFoldable212(dictOrd);
    return function($115) {
      return fromSet($114($115));
    };
  };
};
var foldableNonEmptySet = foldableSet;
var foldable1NonEmptySet = {
  foldMap1: function(dictSemigroup) {
    var foldMap112 = foldMap14(dictSemigroup);
    return function(f) {
      var $116 = foldMap112(f);
      return function($117) {
        return $116(toUnfoldable122($117));
      };
    };
  },
  foldr1: function(f) {
    var $118 = foldr12(f);
    return function($119) {
      return $118(toUnfoldable122($119));
    };
  },
  foldl1: function(f) {
    var $120 = foldl13(f);
    return function($121) {
      return $120(toUnfoldable122($121));
    };
  },
  Foldable0: function() {
    return foldableNonEmptySet;
  }
};
var eqNonEmptySet = function(dictEq) {
  return eqSet(dictEq);
};

// output/Data.String.NonEmpty.Internal/index.js
var toString2 = function(v) {
  return v;
};
var fromString3 = function(v) {
  if (v === "") {
    return Nothing.value;
  }
  ;
  return new Just(v);
};

// output/Data.Codec.Argonaut.Common/index.js
var fromFoldable22 = /* @__PURE__ */ fromFoldable8(foldableArray);
var toUnfoldable8 = /* @__PURE__ */ toUnfoldable7(unfoldableArray);
var nonEmptyString = /* @__PURE__ */ prismaticCodec("NonEmptyString")(fromString3)(toString2)(string);
var nonEmptySet = function(dictOrd) {
  var fromFoldable72 = fromFoldable22(dictOrd);
  return function(codec11) {
    return prismaticCodec("NonEmptySet")(fromFoldable72)(toUnfoldable8)(array(codec11));
  };
};
var nonEmptyArray = function(codec11) {
  return prismaticCodec("NonEmptyArray")(fromArray)(toArray)(array(codec11));
};

// output/Data.Compactable/index.js
var $$void7 = /* @__PURE__ */ $$void(functorST);
var pure1 = /* @__PURE__ */ pure(applicativeST);
var apply5 = /* @__PURE__ */ apply2(applyST);
var map17 = /* @__PURE__ */ map(functorST);
var compactableArray = {
  compact: function(xs) {
    return function __do3() {
      var result = newSTArray();
      var iter = iterator(function(v) {
        return index(xs)(v);
      })();
      iterate(iter)(function($108) {
        return $$void7(function(v) {
          if (v instanceof Nothing) {
            return pure1(0);
          }
          ;
          if (v instanceof Just) {
            return push(v.value0)(result);
          }
          ;
          throw new Error("Failed pattern match at Data.Compactable (line 111, column 34 - line 113, column 35): " + [v.constructor.name]);
        }($108));
      })();
      return unsafeFreeze(result)();
    }();
  },
  separate: function(xs) {
    return function __do3() {
      var ls4 = newSTArray();
      var rs = newSTArray();
      var iter = iterator(function(v) {
        return index(xs)(v);
      })();
      iterate(iter)(function($109) {
        return $$void7(function(v) {
          if (v instanceof Left) {
            return push(v.value0)(ls4);
          }
          ;
          if (v instanceof Right) {
            return push(v.value0)(rs);
          }
          ;
          throw new Error("Failed pattern match at Data.Compactable (line 122, column 34 - line 124, column 31): " + [v.constructor.name]);
        }($109));
      })();
      return apply5(map17(function(v) {
        return function(v1) {
          return {
            left: v,
            right: v1
          };
        };
      })(unsafeFreeze(ls4)))(unsafeFreeze(rs))();
    }();
  }
};

// output/Data.Filterable/index.js
var append3 = /* @__PURE__ */ append(semigroupArray);
var foldl7 = /* @__PURE__ */ foldl(foldableArray);
var partitionMap = function(dict) {
  return dict.partitionMap;
};
var partition3 = function(dict) {
  return dict.partition;
};
var filterableArray = {
  partitionMap: function(p) {
    var go = function(acc) {
      return function(x) {
        var v = p(x);
        if (v instanceof Left) {
          return {
            left: append3(acc.left)([v.value0]),
            right: acc.right
          };
        }
        ;
        if (v instanceof Right) {
          return {
            right: append3(acc.right)([v.value0]),
            left: acc.left
          };
        }
        ;
        throw new Error("Failed pattern match at Data.Filterable (line 149, column 16 - line 151, column 50): " + [v.constructor.name]);
      };
    };
    return foldl7(go)({
      left: [],
      right: []
    });
  },
  partition,
  filterMap: mapMaybe,
  filter,
  Compactable0: function() {
    return compactableArray;
  },
  Functor1: function() {
    return functorArray;
  }
};

// output/Data.JSDate/foreign.js
function now() {
  return /* @__PURE__ */ new Date();
}
function toInstantImpl(just) {
  return function(nothing) {
    return function(date2) {
      var t = date2.getTime();
      return isNaN(t) ? nothing : just(t);
    };
  };
}
function dateMethod(method, date2) {
  return date2[method]();
}

// output/Data.Date/foreign.js
var createDate = function(y, m, d) {
  var date2 = new Date(Date.UTC(y, m, d));
  if (y >= 0 && y < 100) {
    date2.setUTCFullYear(y);
  }
  return date2;
};
function canonicalDateImpl(ctor, y, m, d) {
  var date2 = createDate(y, m - 1, d);
  return ctor(date2.getUTCFullYear())(date2.getUTCMonth() + 1)(date2.getUTCDate());
}
function calcWeekday(y, m, d) {
  return createDate(y, m - 1, d).getUTCDay();
}

// output/Data.Date.Component/index.js
var $runtime_lazy4 = function(name4, moduleName2, init4) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2)
      return val;
    if (state2 === 1)
      throw new ReferenceError(name4 + " was needed before it finished initializing (module " + moduleName2 + ", line " + lineNumber + ")", moduleName2, lineNumber);
    state2 = 1;
    val = init4();
    state2 = 2;
    return val;
  };
};
var Monday = /* @__PURE__ */ function() {
  function Monday2() {
  }
  ;
  Monday2.value = new Monday2();
  return Monday2;
}();
var Tuesday = /* @__PURE__ */ function() {
  function Tuesday2() {
  }
  ;
  Tuesday2.value = new Tuesday2();
  return Tuesday2;
}();
var Wednesday = /* @__PURE__ */ function() {
  function Wednesday2() {
  }
  ;
  Wednesday2.value = new Wednesday2();
  return Wednesday2;
}();
var Thursday = /* @__PURE__ */ function() {
  function Thursday2() {
  }
  ;
  Thursday2.value = new Thursday2();
  return Thursday2;
}();
var Friday = /* @__PURE__ */ function() {
  function Friday2() {
  }
  ;
  Friday2.value = new Friday2();
  return Friday2;
}();
var Saturday = /* @__PURE__ */ function() {
  function Saturday2() {
  }
  ;
  Saturday2.value = new Saturday2();
  return Saturday2;
}();
var Sunday = /* @__PURE__ */ function() {
  function Sunday2() {
  }
  ;
  Sunday2.value = new Sunday2();
  return Sunday2;
}();
var January = /* @__PURE__ */ function() {
  function January2() {
  }
  ;
  January2.value = new January2();
  return January2;
}();
var February = /* @__PURE__ */ function() {
  function February2() {
  }
  ;
  February2.value = new February2();
  return February2;
}();
var March = /* @__PURE__ */ function() {
  function March2() {
  }
  ;
  March2.value = new March2();
  return March2;
}();
var April = /* @__PURE__ */ function() {
  function April2() {
  }
  ;
  April2.value = new April2();
  return April2;
}();
var May = /* @__PURE__ */ function() {
  function May2() {
  }
  ;
  May2.value = new May2();
  return May2;
}();
var June = /* @__PURE__ */ function() {
  function June2() {
  }
  ;
  June2.value = new June2();
  return June2;
}();
var July = /* @__PURE__ */ function() {
  function July2() {
  }
  ;
  July2.value = new July2();
  return July2;
}();
var August = /* @__PURE__ */ function() {
  function August2() {
  }
  ;
  August2.value = new August2();
  return August2;
}();
var September = /* @__PURE__ */ function() {
  function September2() {
  }
  ;
  September2.value = new September2();
  return September2;
}();
var October = /* @__PURE__ */ function() {
  function October2() {
  }
  ;
  October2.value = new October2();
  return October2;
}();
var November = /* @__PURE__ */ function() {
  function November2() {
  }
  ;
  November2.value = new November2();
  return November2;
}();
var December = /* @__PURE__ */ function() {
  function December2() {
  }
  ;
  December2.value = new December2();
  return December2;
}();
var showWeekday = {
  show: function(v) {
    if (v instanceof Monday) {
      return "Monday";
    }
    ;
    if (v instanceof Tuesday) {
      return "Tuesday";
    }
    ;
    if (v instanceof Wednesday) {
      return "Wednesday";
    }
    ;
    if (v instanceof Thursday) {
      return "Thursday";
    }
    ;
    if (v instanceof Friday) {
      return "Friday";
    }
    ;
    if (v instanceof Saturday) {
      return "Saturday";
    }
    ;
    if (v instanceof Sunday) {
      return "Sunday";
    }
    ;
    throw new Error("Failed pattern match at Data.Date.Component (line 184, column 1 - line 191, column 25): " + [v.constructor.name]);
  }
};
var showMonth = {
  show: function(v) {
    if (v instanceof January) {
      return "January";
    }
    ;
    if (v instanceof February) {
      return "February";
    }
    ;
    if (v instanceof March) {
      return "March";
    }
    ;
    if (v instanceof April) {
      return "April";
    }
    ;
    if (v instanceof May) {
      return "May";
    }
    ;
    if (v instanceof June) {
      return "June";
    }
    ;
    if (v instanceof July) {
      return "July";
    }
    ;
    if (v instanceof August) {
      return "August";
    }
    ;
    if (v instanceof September) {
      return "September";
    }
    ;
    if (v instanceof October) {
      return "October";
    }
    ;
    if (v instanceof November) {
      return "November";
    }
    ;
    if (v instanceof December) {
      return "December";
    }
    ;
    throw new Error("Failed pattern match at Data.Date.Component (line 101, column 1 - line 113, column 29): " + [v.constructor.name]);
  }
};
var ordYear = ordInt;
var ordDay = ordInt;
var eqYear = eqInt;
var eqWeekday = {
  eq: function(x) {
    return function(y) {
      if (x instanceof Monday && y instanceof Monday) {
        return true;
      }
      ;
      if (x instanceof Tuesday && y instanceof Tuesday) {
        return true;
      }
      ;
      if (x instanceof Wednesday && y instanceof Wednesday) {
        return true;
      }
      ;
      if (x instanceof Thursday && y instanceof Thursday) {
        return true;
      }
      ;
      if (x instanceof Friday && y instanceof Friday) {
        return true;
      }
      ;
      if (x instanceof Saturday && y instanceof Saturday) {
        return true;
      }
      ;
      if (x instanceof Sunday && y instanceof Sunday) {
        return true;
      }
      ;
      return false;
    };
  }
};
var ordWeekday = {
  compare: function(x) {
    return function(y) {
      if (x instanceof Monday && y instanceof Monday) {
        return EQ.value;
      }
      ;
      if (x instanceof Monday) {
        return LT.value;
      }
      ;
      if (y instanceof Monday) {
        return GT.value;
      }
      ;
      if (x instanceof Tuesday && y instanceof Tuesday) {
        return EQ.value;
      }
      ;
      if (x instanceof Tuesday) {
        return LT.value;
      }
      ;
      if (y instanceof Tuesday) {
        return GT.value;
      }
      ;
      if (x instanceof Wednesday && y instanceof Wednesday) {
        return EQ.value;
      }
      ;
      if (x instanceof Wednesday) {
        return LT.value;
      }
      ;
      if (y instanceof Wednesday) {
        return GT.value;
      }
      ;
      if (x instanceof Thursday && y instanceof Thursday) {
        return EQ.value;
      }
      ;
      if (x instanceof Thursday) {
        return LT.value;
      }
      ;
      if (y instanceof Thursday) {
        return GT.value;
      }
      ;
      if (x instanceof Friday && y instanceof Friday) {
        return EQ.value;
      }
      ;
      if (x instanceof Friday) {
        return LT.value;
      }
      ;
      if (y instanceof Friday) {
        return GT.value;
      }
      ;
      if (x instanceof Saturday && y instanceof Saturday) {
        return EQ.value;
      }
      ;
      if (x instanceof Saturday) {
        return LT.value;
      }
      ;
      if (y instanceof Saturday) {
        return GT.value;
      }
      ;
      if (x instanceof Sunday && y instanceof Sunday) {
        return EQ.value;
      }
      ;
      throw new Error("Failed pattern match at Data.Date.Component (line 0, column 0 - line 0, column 0): " + [x.constructor.name, y.constructor.name]);
    };
  },
  Eq0: function() {
    return eqWeekday;
  }
};
var eqMonth = {
  eq: function(x) {
    return function(y) {
      if (x instanceof January && y instanceof January) {
        return true;
      }
      ;
      if (x instanceof February && y instanceof February) {
        return true;
      }
      ;
      if (x instanceof March && y instanceof March) {
        return true;
      }
      ;
      if (x instanceof April && y instanceof April) {
        return true;
      }
      ;
      if (x instanceof May && y instanceof May) {
        return true;
      }
      ;
      if (x instanceof June && y instanceof June) {
        return true;
      }
      ;
      if (x instanceof July && y instanceof July) {
        return true;
      }
      ;
      if (x instanceof August && y instanceof August) {
        return true;
      }
      ;
      if (x instanceof September && y instanceof September) {
        return true;
      }
      ;
      if (x instanceof October && y instanceof October) {
        return true;
      }
      ;
      if (x instanceof November && y instanceof November) {
        return true;
      }
      ;
      if (x instanceof December && y instanceof December) {
        return true;
      }
      ;
      return false;
    };
  }
};
var ordMonth = {
  compare: function(x) {
    return function(y) {
      if (x instanceof January && y instanceof January) {
        return EQ.value;
      }
      ;
      if (x instanceof January) {
        return LT.value;
      }
      ;
      if (y instanceof January) {
        return GT.value;
      }
      ;
      if (x instanceof February && y instanceof February) {
        return EQ.value;
      }
      ;
      if (x instanceof February) {
        return LT.value;
      }
      ;
      if (y instanceof February) {
        return GT.value;
      }
      ;
      if (x instanceof March && y instanceof March) {
        return EQ.value;
      }
      ;
      if (x instanceof March) {
        return LT.value;
      }
      ;
      if (y instanceof March) {
        return GT.value;
      }
      ;
      if (x instanceof April && y instanceof April) {
        return EQ.value;
      }
      ;
      if (x instanceof April) {
        return LT.value;
      }
      ;
      if (y instanceof April) {
        return GT.value;
      }
      ;
      if (x instanceof May && y instanceof May) {
        return EQ.value;
      }
      ;
      if (x instanceof May) {
        return LT.value;
      }
      ;
      if (y instanceof May) {
        return GT.value;
      }
      ;
      if (x instanceof June && y instanceof June) {
        return EQ.value;
      }
      ;
      if (x instanceof June) {
        return LT.value;
      }
      ;
      if (y instanceof June) {
        return GT.value;
      }
      ;
      if (x instanceof July && y instanceof July) {
        return EQ.value;
      }
      ;
      if (x instanceof July) {
        return LT.value;
      }
      ;
      if (y instanceof July) {
        return GT.value;
      }
      ;
      if (x instanceof August && y instanceof August) {
        return EQ.value;
      }
      ;
      if (x instanceof August) {
        return LT.value;
      }
      ;
      if (y instanceof August) {
        return GT.value;
      }
      ;
      if (x instanceof September && y instanceof September) {
        return EQ.value;
      }
      ;
      if (x instanceof September) {
        return LT.value;
      }
      ;
      if (y instanceof September) {
        return GT.value;
      }
      ;
      if (x instanceof October && y instanceof October) {
        return EQ.value;
      }
      ;
      if (x instanceof October) {
        return LT.value;
      }
      ;
      if (y instanceof October) {
        return GT.value;
      }
      ;
      if (x instanceof November && y instanceof November) {
        return EQ.value;
      }
      ;
      if (x instanceof November) {
        return LT.value;
      }
      ;
      if (y instanceof November) {
        return GT.value;
      }
      ;
      if (x instanceof December && y instanceof December) {
        return EQ.value;
      }
      ;
      throw new Error("Failed pattern match at Data.Date.Component (line 0, column 0 - line 0, column 0): " + [x.constructor.name, y.constructor.name]);
    };
  },
  Eq0: function() {
    return eqMonth;
  }
};
var eqDay = eqInt;
var boundedYear = /* @__PURE__ */ function() {
  return {
    bottom: -271820 | 0,
    top: 275759,
    Ord0: function() {
      return ordYear;
    }
  };
}();
var boundedWeekday = /* @__PURE__ */ function() {
  return {
    bottom: Monday.value,
    top: Sunday.value,
    Ord0: function() {
      return ordWeekday;
    }
  };
}();
var boundedMonth = /* @__PURE__ */ function() {
  return {
    bottom: January.value,
    top: December.value,
    Ord0: function() {
      return ordMonth;
    }
  };
}();
var boundedEnumYear = {
  cardinality: 547580,
  toEnum: function(n) {
    if (n >= (-271820 | 0) && n <= 275759) {
      return new Just(n);
    }
    ;
    if (otherwise) {
      return Nothing.value;
    }
    ;
    throw new Error("Failed pattern match at Data.Date.Component (line 35, column 1 - line 40, column 24): " + [n.constructor.name]);
  },
  fromEnum: function(v) {
    return v;
  },
  Bounded0: function() {
    return boundedYear;
  },
  Enum1: function() {
    return $lazy_enumYear(0);
  }
};
var $lazy_enumYear = /* @__PURE__ */ $runtime_lazy4("enumYear", "Data.Date.Component", function() {
  return {
    succ: function() {
      var $55 = toEnum(boundedEnumYear);
      var $56 = fromEnum(boundedEnumYear);
      return function($57) {
        return $55(function(v) {
          return v + 1 | 0;
        }($56($57)));
      };
    }(),
    pred: function() {
      var $58 = toEnum(boundedEnumYear);
      var $59 = fromEnum(boundedEnumYear);
      return function($60) {
        return $58(function(v) {
          return v - 1 | 0;
        }($59($60)));
      };
    }(),
    Ord0: function() {
      return ordYear;
    }
  };
});
var boundedEnumWeekday = {
  cardinality: 7,
  toEnum: function(v) {
    if (v === 1) {
      return new Just(Monday.value);
    }
    ;
    if (v === 2) {
      return new Just(Tuesday.value);
    }
    ;
    if (v === 3) {
      return new Just(Wednesday.value);
    }
    ;
    if (v === 4) {
      return new Just(Thursday.value);
    }
    ;
    if (v === 5) {
      return new Just(Friday.value);
    }
    ;
    if (v === 6) {
      return new Just(Saturday.value);
    }
    ;
    if (v === 7) {
      return new Just(Sunday.value);
    }
    ;
    return Nothing.value;
  },
  fromEnum: function(v) {
    if (v instanceof Monday) {
      return 1;
    }
    ;
    if (v instanceof Tuesday) {
      return 2;
    }
    ;
    if (v instanceof Wednesday) {
      return 3;
    }
    ;
    if (v instanceof Thursday) {
      return 4;
    }
    ;
    if (v instanceof Friday) {
      return 5;
    }
    ;
    if (v instanceof Saturday) {
      return 6;
    }
    ;
    if (v instanceof Sunday) {
      return 7;
    }
    ;
    throw new Error("Failed pattern match at Data.Date.Component (line 175, column 14 - line 182, column 16): " + [v.constructor.name]);
  },
  Bounded0: function() {
    return boundedWeekday;
  },
  Enum1: function() {
    return $lazy_enumWeekday(0);
  }
};
var $lazy_enumWeekday = /* @__PURE__ */ $runtime_lazy4("enumWeekday", "Data.Date.Component", function() {
  return {
    succ: function() {
      var $61 = toEnum(boundedEnumWeekday);
      var $62 = fromEnum(boundedEnumWeekday);
      return function($63) {
        return $61(function(v) {
          return v + 1 | 0;
        }($62($63)));
      };
    }(),
    pred: function() {
      var $64 = toEnum(boundedEnumWeekday);
      var $65 = fromEnum(boundedEnumWeekday);
      return function($66) {
        return $64(function(v) {
          return v - 1 | 0;
        }($65($66)));
      };
    }(),
    Ord0: function() {
      return ordWeekday;
    }
  };
});
var boundedEnumMonth = {
  cardinality: 12,
  toEnum: function(v) {
    if (v === 1) {
      return new Just(January.value);
    }
    ;
    if (v === 2) {
      return new Just(February.value);
    }
    ;
    if (v === 3) {
      return new Just(March.value);
    }
    ;
    if (v === 4) {
      return new Just(April.value);
    }
    ;
    if (v === 5) {
      return new Just(May.value);
    }
    ;
    if (v === 6) {
      return new Just(June.value);
    }
    ;
    if (v === 7) {
      return new Just(July.value);
    }
    ;
    if (v === 8) {
      return new Just(August.value);
    }
    ;
    if (v === 9) {
      return new Just(September.value);
    }
    ;
    if (v === 10) {
      return new Just(October.value);
    }
    ;
    if (v === 11) {
      return new Just(November.value);
    }
    ;
    if (v === 12) {
      return new Just(December.value);
    }
    ;
    return Nothing.value;
  },
  fromEnum: function(v) {
    if (v instanceof January) {
      return 1;
    }
    ;
    if (v instanceof February) {
      return 2;
    }
    ;
    if (v instanceof March) {
      return 3;
    }
    ;
    if (v instanceof April) {
      return 4;
    }
    ;
    if (v instanceof May) {
      return 5;
    }
    ;
    if (v instanceof June) {
      return 6;
    }
    ;
    if (v instanceof July) {
      return 7;
    }
    ;
    if (v instanceof August) {
      return 8;
    }
    ;
    if (v instanceof September) {
      return 9;
    }
    ;
    if (v instanceof October) {
      return 10;
    }
    ;
    if (v instanceof November) {
      return 11;
    }
    ;
    if (v instanceof December) {
      return 12;
    }
    ;
    throw new Error("Failed pattern match at Data.Date.Component (line 87, column 14 - line 99, column 19): " + [v.constructor.name]);
  },
  Bounded0: function() {
    return boundedMonth;
  },
  Enum1: function() {
    return $lazy_enumMonth(0);
  }
};
var $lazy_enumMonth = /* @__PURE__ */ $runtime_lazy4("enumMonth", "Data.Date.Component", function() {
  return {
    succ: function() {
      var $67 = toEnum(boundedEnumMonth);
      var $68 = fromEnum(boundedEnumMonth);
      return function($69) {
        return $67(function(v) {
          return v + 1 | 0;
        }($68($69)));
      };
    }(),
    pred: function() {
      var $70 = toEnum(boundedEnumMonth);
      var $71 = fromEnum(boundedEnumMonth);
      return function($72) {
        return $70(function(v) {
          return v - 1 | 0;
        }($71($72)));
      };
    }(),
    Ord0: function() {
      return ordMonth;
    }
  };
});
var boundedDay = {
  bottom: 1,
  top: 31,
  Ord0: function() {
    return ordDay;
  }
};
var boundedEnumDay = {
  cardinality: 31,
  toEnum: function(n) {
    if (n >= 1 && n <= 31) {
      return new Just(n);
    }
    ;
    if (otherwise) {
      return Nothing.value;
    }
    ;
    throw new Error("Failed pattern match at Data.Date.Component (line 133, column 1 - line 138, column 23): " + [n.constructor.name]);
  },
  fromEnum: function(v) {
    return v;
  },
  Bounded0: function() {
    return boundedDay;
  },
  Enum1: function() {
    return $lazy_enumDay(0);
  }
};
var $lazy_enumDay = /* @__PURE__ */ $runtime_lazy4("enumDay", "Data.Date.Component", function() {
  return {
    succ: function() {
      var $73 = toEnum(boundedEnumDay);
      var $74 = fromEnum(boundedEnumDay);
      return function($75) {
        return $73(function(v) {
          return v + 1 | 0;
        }($74($75)));
      };
    }(),
    pred: function() {
      var $76 = toEnum(boundedEnumDay);
      var $77 = fromEnum(boundedEnumDay);
      return function($78) {
        return $76(function(v) {
          return v - 1 | 0;
        }($77($78)));
      };
    }(),
    Ord0: function() {
      return ordDay;
    }
  };
});

// output/Data.Time.Duration/index.js
var show3 = /* @__PURE__ */ show(showNumber);
var Milliseconds = function(x) {
  return x;
};
var showMilliseconds = {
  show: function(v) {
    return "(Milliseconds " + (show3(v) + ")");
  }
};

// output/Data.Date/index.js
var fromEnum3 = /* @__PURE__ */ fromEnum(boundedEnumMonth);
var fromJust5 = /* @__PURE__ */ fromJust();
var toEnum2 = /* @__PURE__ */ toEnum(boundedEnumWeekday);
var eq13 = /* @__PURE__ */ eq(eqYear);
var eq22 = /* @__PURE__ */ eq(eqMonth);
var eq3 = /* @__PURE__ */ eq(eqDay);
var compare3 = /* @__PURE__ */ compare(ordYear);
var compare12 = /* @__PURE__ */ compare(ordMonth);
var compare22 = /* @__PURE__ */ compare(ordDay);
var toEnum22 = /* @__PURE__ */ toEnum(boundedEnumMonth);
var $$Date = /* @__PURE__ */ function() {
  function $$Date2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  $$Date2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new $$Date2(value0, value12, value22);
      };
    };
  };
  return $$Date2;
}();
var year = function(v) {
  return v.value0;
};
var weekday = function(v) {
  var n = calcWeekday(v.value0, fromEnum3(v.value1), v.value2);
  var $86 = n === 0;
  if ($86) {
    return fromJust5(toEnum2(7));
  }
  ;
  return fromJust5(toEnum2(n));
};
var month = function(v) {
  return v.value1;
};
var eqDate = {
  eq: function(x) {
    return function(y) {
      return eq13(x.value0)(y.value0) && eq22(x.value1)(y.value1) && eq3(x.value2)(y.value2);
    };
  }
};
var ordDate = {
  compare: function(x) {
    return function(y) {
      var v = compare3(x.value0)(y.value0);
      if (v instanceof LT) {
        return LT.value;
      }
      ;
      if (v instanceof GT) {
        return GT.value;
      }
      ;
      var v1 = compare12(x.value1)(y.value1);
      if (v1 instanceof LT) {
        return LT.value;
      }
      ;
      if (v1 instanceof GT) {
        return GT.value;
      }
      ;
      return compare22(x.value2)(y.value2);
    };
  },
  Eq0: function() {
    return eqDate;
  }
};
var day = function(v) {
  return v.value2;
};
var canonicalDate = function(y) {
  return function(m) {
    return function(d) {
      var mkDate = function(y$prime) {
        return function(m$prime) {
          return function(d$prime) {
            return new $$Date(y$prime, fromJust5(toEnum22(m$prime)), d$prime);
          };
        };
      };
      return canonicalDateImpl(mkDate, y, fromEnum3(m), d);
    };
  };
};

// output/Data.Time.Component/index.js
var $runtime_lazy5 = function(name4, moduleName2, init4) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2)
      return val;
    if (state2 === 1)
      throw new ReferenceError(name4 + " was needed before it finished initializing (module " + moduleName2 + ", line " + lineNumber + ")", moduleName2, lineNumber);
    state2 = 1;
    val = init4();
    state2 = 2;
    return val;
  };
};
var ordSecond = ordInt;
var ordMinute = ordInt;
var ordMillisecond = ordInt;
var ordHour = ordInt;
var eqSecond = eqInt;
var eqMinute = eqInt;
var eqMillisecond = eqInt;
var eqHour = eqInt;
var boundedSecond = {
  bottom: 0,
  top: 59,
  Ord0: function() {
    return ordSecond;
  }
};
var boundedMinute = {
  bottom: 0,
  top: 59,
  Ord0: function() {
    return ordMinute;
  }
};
var boundedMillisecond = {
  bottom: 0,
  top: 999,
  Ord0: function() {
    return ordMillisecond;
  }
};
var boundedHour = {
  bottom: 0,
  top: 23,
  Ord0: function() {
    return ordHour;
  }
};
var boundedEnumSecond = {
  cardinality: 60,
  toEnum: function(n) {
    if (n >= 0 && n <= 59) {
      return new Just(n);
    }
    ;
    if (otherwise) {
      return Nothing.value;
    }
    ;
    throw new Error("Failed pattern match at Data.Time.Component (line 90, column 1 - line 95, column 26): " + [n.constructor.name]);
  },
  fromEnum: function(v) {
    return v;
  },
  Bounded0: function() {
    return boundedSecond;
  },
  Enum1: function() {
    return $lazy_enumSecond(0);
  }
};
var $lazy_enumSecond = /* @__PURE__ */ $runtime_lazy5("enumSecond", "Data.Time.Component", function() {
  return {
    succ: function() {
      var $36 = toEnum(boundedEnumSecond);
      var $37 = fromEnum(boundedEnumSecond);
      return function($38) {
        return $36(function(v) {
          return v + 1 | 0;
        }($37($38)));
      };
    }(),
    pred: function() {
      var $39 = toEnum(boundedEnumSecond);
      var $40 = fromEnum(boundedEnumSecond);
      return function($41) {
        return $39(function(v) {
          return v - 1 | 0;
        }($40($41)));
      };
    }(),
    Ord0: function() {
      return ordSecond;
    }
  };
});
var boundedEnumMinute = {
  cardinality: 60,
  toEnum: function(n) {
    if (n >= 0 && n <= 59) {
      return new Just(n);
    }
    ;
    if (otherwise) {
      return Nothing.value;
    }
    ;
    throw new Error("Failed pattern match at Data.Time.Component (line 61, column 1 - line 66, column 26): " + [n.constructor.name]);
  },
  fromEnum: function(v) {
    return v;
  },
  Bounded0: function() {
    return boundedMinute;
  },
  Enum1: function() {
    return $lazy_enumMinute(0);
  }
};
var $lazy_enumMinute = /* @__PURE__ */ $runtime_lazy5("enumMinute", "Data.Time.Component", function() {
  return {
    succ: function() {
      var $42 = toEnum(boundedEnumMinute);
      var $43 = fromEnum(boundedEnumMinute);
      return function($44) {
        return $42(function(v) {
          return v + 1 | 0;
        }($43($44)));
      };
    }(),
    pred: function() {
      var $45 = toEnum(boundedEnumMinute);
      var $46 = fromEnum(boundedEnumMinute);
      return function($47) {
        return $45(function(v) {
          return v - 1 | 0;
        }($46($47)));
      };
    }(),
    Ord0: function() {
      return ordMinute;
    }
  };
});
var boundedEnumMillisecond = {
  cardinality: 1e3,
  toEnum: function(n) {
    if (n >= 0 && n <= 999) {
      return new Just(n);
    }
    ;
    if (otherwise) {
      return Nothing.value;
    }
    ;
    throw new Error("Failed pattern match at Data.Time.Component (line 120, column 1 - line 125, column 31): " + [n.constructor.name]);
  },
  fromEnum: function(v) {
    return v;
  },
  Bounded0: function() {
    return boundedMillisecond;
  },
  Enum1: function() {
    return $lazy_enumMillisecond(0);
  }
};
var $lazy_enumMillisecond = /* @__PURE__ */ $runtime_lazy5("enumMillisecond", "Data.Time.Component", function() {
  return {
    succ: function() {
      var $48 = toEnum(boundedEnumMillisecond);
      var $49 = fromEnum(boundedEnumMillisecond);
      return function($50) {
        return $48(function(v) {
          return v + 1 | 0;
        }($49($50)));
      };
    }(),
    pred: function() {
      var $51 = toEnum(boundedEnumMillisecond);
      var $52 = fromEnum(boundedEnumMillisecond);
      return function($53) {
        return $51(function(v) {
          return v - 1 | 0;
        }($52($53)));
      };
    }(),
    Ord0: function() {
      return ordMillisecond;
    }
  };
});
var boundedEnumHour = {
  cardinality: 24,
  toEnum: function(n) {
    if (n >= 0 && n <= 23) {
      return new Just(n);
    }
    ;
    if (otherwise) {
      return Nothing.value;
    }
    ;
    throw new Error("Failed pattern match at Data.Time.Component (line 32, column 1 - line 37, column 24): " + [n.constructor.name]);
  },
  fromEnum: function(v) {
    return v;
  },
  Bounded0: function() {
    return boundedHour;
  },
  Enum1: function() {
    return $lazy_enumHour(0);
  }
};
var $lazy_enumHour = /* @__PURE__ */ $runtime_lazy5("enumHour", "Data.Time.Component", function() {
  return {
    succ: function() {
      var $54 = toEnum(boundedEnumHour);
      var $55 = fromEnum(boundedEnumHour);
      return function($56) {
        return $54(function(v) {
          return v + 1 | 0;
        }($55($56)));
      };
    }(),
    pred: function() {
      var $57 = toEnum(boundedEnumHour);
      var $58 = fromEnum(boundedEnumHour);
      return function($59) {
        return $57(function(v) {
          return v - 1 | 0;
        }($58($59)));
      };
    }(),
    Ord0: function() {
      return ordHour;
    }
  };
});

// output/Data.Time/index.js
var eq4 = /* @__PURE__ */ eq(eqHour);
var eq14 = /* @__PURE__ */ eq(eqMinute);
var eq23 = /* @__PURE__ */ eq(eqSecond);
var eq32 = /* @__PURE__ */ eq(eqMillisecond);
var compare4 = /* @__PURE__ */ compare(ordHour);
var compare13 = /* @__PURE__ */ compare(ordMinute);
var compare23 = /* @__PURE__ */ compare(ordSecond);
var compare32 = /* @__PURE__ */ compare(ordMillisecond);
var Time = /* @__PURE__ */ function() {
  function Time2(value0, value12, value22, value32) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
    this.value3 = value32;
  }
  ;
  Time2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return function(value32) {
          return new Time2(value0, value12, value22, value32);
        };
      };
    };
  };
  return Time2;
}();
var second = function(v) {
  return v.value2;
};
var minute = function(v) {
  return v.value1;
};
var millisecond = function(v) {
  return v.value3;
};
var hour = function(v) {
  return v.value0;
};
var eqTime = {
  eq: function(x) {
    return function(y) {
      return eq4(x.value0)(y.value0) && eq14(x.value1)(y.value1) && eq23(x.value2)(y.value2) && eq32(x.value3)(y.value3);
    };
  }
};
var ordTime = {
  compare: function(x) {
    return function(y) {
      var v = compare4(x.value0)(y.value0);
      if (v instanceof LT) {
        return LT.value;
      }
      ;
      if (v instanceof GT) {
        return GT.value;
      }
      ;
      var v1 = compare13(x.value1)(y.value1);
      if (v1 instanceof LT) {
        return LT.value;
      }
      ;
      if (v1 instanceof GT) {
        return GT.value;
      }
      ;
      var v2 = compare23(x.value2)(y.value2);
      if (v2 instanceof LT) {
        return LT.value;
      }
      ;
      if (v2 instanceof GT) {
        return GT.value;
      }
      ;
      return compare32(x.value3)(y.value3);
    };
  },
  Eq0: function() {
    return eqTime;
  }
};

// output/Data.DateTime/index.js
var eq5 = /* @__PURE__ */ eq(eqDate);
var eq15 = /* @__PURE__ */ eq(eqTime);
var compare5 = /* @__PURE__ */ compare(ordDate);
var compare14 = /* @__PURE__ */ compare(ordTime);
var DateTime = /* @__PURE__ */ function() {
  function DateTime2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  DateTime2.create = function(value0) {
    return function(value12) {
      return new DateTime2(value0, value12);
    };
  };
  return DateTime2;
}();
var eqDateTime = {
  eq: function(x) {
    return function(y) {
      return eq5(x.value0)(y.value0) && eq15(x.value1)(y.value1);
    };
  }
};
var ordDateTime = {
  compare: function(x) {
    return function(y) {
      var v = compare5(x.value0)(y.value0);
      if (v instanceof LT) {
        return LT.value;
      }
      ;
      if (v instanceof GT) {
        return GT.value;
      }
      ;
      return compare14(x.value1)(y.value1);
    };
  },
  Eq0: function() {
    return eqDateTime;
  }
};

// output/Data.DateTime.Instant/foreign.js
var createDateTime = function(y, m, d, h, mi, s, ms) {
  var dateTime = new Date(Date.UTC(y, m, d, h, mi, s, ms));
  if (y >= 0 && y < 100) {
    dateTime.setUTCFullYear(y);
  }
  return dateTime;
};
function fromDateTimeImpl(y, mo, d, h, mi, s, ms) {
  return createDateTime(y, mo - 1, d, h, mi, s, ms).getTime();
}
function toDateTimeImpl(ctor) {
  return function(instant2) {
    var dt = new Date(instant2);
    return ctor(dt.getUTCFullYear())(dt.getUTCMonth() + 1)(dt.getUTCDate())(dt.getUTCHours())(dt.getUTCMinutes())(dt.getUTCSeconds())(dt.getUTCMilliseconds());
  };
}

// output/Data.DateTime.Instant/index.js
var fromJust6 = /* @__PURE__ */ fromJust();
var toEnum3 = /* @__PURE__ */ toEnum(boundedEnumMonth);
var show4 = /* @__PURE__ */ show(showMilliseconds);
var fromEnum4 = /* @__PURE__ */ fromEnum(boundedEnumMonth);
var unInstant = function(v) {
  return v;
};
var toDateTime = /* @__PURE__ */ function() {
  var mkDateTime = function(y) {
    return function(mo) {
      return function(d) {
        return function(h) {
          return function(mi) {
            return function(s) {
              return function(ms) {
                return new DateTime(canonicalDate(y)(fromJust6(toEnum3(mo)))(d), new Time(h, mi, s, ms));
              };
            };
          };
        };
      };
    };
  };
  return toDateTimeImpl(mkDateTime);
}();
var showInstant = {
  show: function(v) {
    return "(Instant " + (show4(v) + ")");
  }
};
var instant = function(v) {
  if (v >= -86399778816e5 && v <= 8639977881599999) {
    return new Just(v);
  }
  ;
  if (otherwise) {
    return Nothing.value;
  }
  ;
  throw new Error("Failed pattern match at Data.DateTime.Instant (line 44, column 1 - line 44, column 41): " + [v.constructor.name]);
};
var fromDateTime = function(v) {
  return fromDateTimeImpl(year(v.value0), fromEnum4(month(v.value0)), day(v.value0), hour(v.value1), minute(v.value1), second(v.value1), millisecond(v.value1));
};

// output/Foreign/foreign.js
function tagOf(value4) {
  return Object.prototype.toString.call(value4).slice(8, -1);
}
var isArray = Array.isArray || function(value4) {
  return Object.prototype.toString.call(value4) === "[object Array]";
};

// output/Control.Monad.State.Class/index.js
var state = function(dict) {
  return dict.state;
};
var put = function(dictMonadState) {
  var state1 = state(dictMonadState);
  return function(s) {
    return state1(function(v) {
      return new Tuple(unit, s);
    });
  };
};
var modify_2 = function(dictMonadState) {
  var state1 = state(dictMonadState);
  return function(f) {
    return state1(function(s) {
      return new Tuple(unit, f(s));
    });
  };
};
var get = function(dictMonadState) {
  return state(dictMonadState)(function(s) {
    return new Tuple(s, s);
  });
};

// output/Control.Monad.Trans.Class/index.js
var lift = function(dict) {
  return dict.lift;
};

// output/Effect.Class/index.js
var monadEffectEffect = {
  liftEffect: /* @__PURE__ */ identity(categoryFn),
  Monad0: function() {
    return monadEffect;
  }
};
var liftEffect = function(dict) {
  return dict.liftEffect;
};

// output/Control.Monad.Except.Trans/index.js
var map18 = /* @__PURE__ */ map(functorEither);
var ExceptT = function(x) {
  return x;
};
var withExceptT = function(dictFunctor) {
  var map136 = map(dictFunctor);
  return function(f) {
    return function(v) {
      var mapLeft = function(v1) {
        return function(v2) {
          if (v2 instanceof Right) {
            return new Right(v2.value0);
          }
          ;
          if (v2 instanceof Left) {
            return new Left(v1(v2.value0));
          }
          ;
          throw new Error("Failed pattern match at Control.Monad.Except.Trans (line 42, column 3 - line 42, column 32): " + [v1.constructor.name, v2.constructor.name]);
        };
      };
      return map136(mapLeft(f))(v);
    };
  };
};
var runExceptT = function(v) {
  return v;
};
var monadTransExceptT = {
  lift: function(dictMonad) {
    var bind59 = bind(dictMonad.Bind1());
    var pure75 = pure(dictMonad.Applicative0());
    return function(m) {
      return bind59(m)(function(a) {
        return pure75(new Right(a));
      });
    };
  }
};
var mapExceptT = function(f) {
  return function(v) {
    return f(v);
  };
};
var functorExceptT = function(dictFunctor) {
  var map136 = map(dictFunctor);
  return {
    map: function(f) {
      return mapExceptT(map136(map18(f)));
    }
  };
};
var monadExceptT = function(dictMonad) {
  return {
    Applicative0: function() {
      return applicativeExceptT(dictMonad);
    },
    Bind1: function() {
      return bindExceptT(dictMonad);
    }
  };
};
var bindExceptT = function(dictMonad) {
  var bind59 = bind(dictMonad.Bind1());
  var pure75 = pure(dictMonad.Applicative0());
  return {
    bind: function(v) {
      return function(k) {
        return bind59(v)(either(function($187) {
          return pure75(Left.create($187));
        })(function(a) {
          var v1 = k(a);
          return v1;
        }));
      };
    },
    Apply0: function() {
      return applyExceptT(dictMonad);
    }
  };
};
var applyExceptT = function(dictMonad) {
  var functorExceptT1 = functorExceptT(dictMonad.Bind1().Apply0().Functor0());
  return {
    apply: ap(monadExceptT(dictMonad)),
    Functor0: function() {
      return functorExceptT1;
    }
  };
};
var applicativeExceptT = function(dictMonad) {
  return {
    pure: function() {
      var $188 = pure(dictMonad.Applicative0());
      return function($189) {
        return ExceptT($188(Right.create($189)));
      };
    }(),
    Apply0: function() {
      return applyExceptT(dictMonad);
    }
  };
};
var monadThrowExceptT = function(dictMonad) {
  var monadExceptT1 = monadExceptT(dictMonad);
  return {
    throwError: function() {
      var $198 = pure(dictMonad.Applicative0());
      return function($199) {
        return ExceptT($198(Left.create($199)));
      };
    }(),
    Monad0: function() {
      return monadExceptT1;
    }
  };
};
var altExceptT = function(dictSemigroup) {
  var append40 = append(dictSemigroup);
  return function(dictMonad) {
    var Bind1 = dictMonad.Bind1();
    var bind59 = bind(Bind1);
    var pure75 = pure(dictMonad.Applicative0());
    var functorExceptT1 = functorExceptT(Bind1.Apply0().Functor0());
    return {
      alt: function(v) {
        return function(v1) {
          return bind59(v)(function(rm2) {
            if (rm2 instanceof Right) {
              return pure75(new Right(rm2.value0));
            }
            ;
            if (rm2 instanceof Left) {
              return bind59(v1)(function(rn) {
                if (rn instanceof Right) {
                  return pure75(new Right(rn.value0));
                }
                ;
                if (rn instanceof Left) {
                  return pure75(new Left(append40(rm2.value0)(rn.value0)));
                }
                ;
                throw new Error("Failed pattern match at Control.Monad.Except.Trans (line 86, column 9 - line 88, column 49): " + [rn.constructor.name]);
              });
            }
            ;
            throw new Error("Failed pattern match at Control.Monad.Except.Trans (line 82, column 5 - line 88, column 49): " + [rm2.constructor.name]);
          });
        };
      },
      Functor0: function() {
        return functorExceptT1;
      }
    };
  };
};

// output/Foreign/index.js
var show5 = /* @__PURE__ */ show(showString);
var show12 = /* @__PURE__ */ show(showInt);
var pure4 = /* @__PURE__ */ pure(applicativeEither);
var ForeignError = /* @__PURE__ */ function() {
  function ForeignError2(value0) {
    this.value0 = value0;
  }
  ;
  ForeignError2.create = function(value0) {
    return new ForeignError2(value0);
  };
  return ForeignError2;
}();
var TypeMismatch2 = /* @__PURE__ */ function() {
  function TypeMismatch3(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TypeMismatch3.create = function(value0) {
    return function(value12) {
      return new TypeMismatch3(value0, value12);
    };
  };
  return TypeMismatch3;
}();
var ErrorAtIndex = /* @__PURE__ */ function() {
  function ErrorAtIndex2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ErrorAtIndex2.create = function(value0) {
    return function(value12) {
      return new ErrorAtIndex2(value0, value12);
    };
  };
  return ErrorAtIndex2;
}();
var ErrorAtProperty = /* @__PURE__ */ function() {
  function ErrorAtProperty2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ErrorAtProperty2.create = function(value0) {
    return function(value12) {
      return new ErrorAtProperty2(value0, value12);
    };
  };
  return ErrorAtProperty2;
}();
var unsafeToForeign = unsafeCoerce2;
var unsafeFromForeign = unsafeCoerce2;
var renderForeignError = function(v) {
  if (v instanceof ForeignError) {
    return v.value0;
  }
  ;
  if (v instanceof ErrorAtIndex) {
    return "Error at array index " + (show12(v.value0) + (": " + renderForeignError(v.value1)));
  }
  ;
  if (v instanceof ErrorAtProperty) {
    return "Error at property " + (show5(v.value0) + (": " + renderForeignError(v.value1)));
  }
  ;
  if (v instanceof TypeMismatch2) {
    return "Type mismatch: expected " + (v.value0 + (", found " + v.value1));
  }
  ;
  throw new Error("Failed pattern match at Foreign (line 78, column 1 - line 78, column 45): " + [v.constructor.name]);
};
var fail = function(dictMonad) {
  var $153 = throwError(monadThrowExceptT(dictMonad));
  return function($154) {
    return $153(singleton9($154));
  };
};
var unsafeReadTagged = function(dictMonad) {
  var pure122 = pure(applicativeExceptT(dictMonad));
  var fail1 = fail(dictMonad);
  return function(tag) {
    return function(value4) {
      if (tagOf(value4) === tag) {
        return pure122(unsafeFromForeign(value4));
      }
      ;
      if (otherwise) {
        return fail1(new TypeMismatch2(tag, tagOf(value4)));
      }
      ;
      throw new Error("Failed pattern match at Foreign (line 123, column 1 - line 123, column 104): " + [tag.constructor.name, value4.constructor.name]);
    };
  };
};
var readNumber = function(dictMonad) {
  return unsafeReadTagged(dictMonad)("Number");
};
var readInt = function(dictMonad) {
  var map86 = map(dictMonad.Bind1().Apply0().Functor0());
  var readNumber1 = readNumber(dictMonad);
  return function(value4) {
    var error4 = new Left(singleton9(new TypeMismatch2("Int", tagOf(value4))));
    var fromNumber2 = function() {
      var $155 = maybe(error4)(pure4);
      return function($156) {
        return $155(fromNumber($156));
      };
    }();
    return mapExceptT(map86(either($$const(error4))(fromNumber2)))(readNumber1(value4));
  };
};
var readString = function(dictMonad) {
  return unsafeReadTagged(dictMonad)("String");
};

// output/Data.JSDate/index.js
var map19 = /* @__PURE__ */ map(functorFn);
var map110 = /* @__PURE__ */ map(functorMaybe);
var toInstant = /* @__PURE__ */ function() {
  return composeKleisliFlipped(bindMaybe)(function($21) {
    return instant(Milliseconds($21));
  })(toInstantImpl(Just.create)(Nothing.value));
}();
var toDateTime2 = /* @__PURE__ */ map19(/* @__PURE__ */ map110(toDateTime))(toInstant);
var getTime = function(dt) {
  return dateMethod("getTime", dt);
};

// output/Data.String.Regex/foreign.js
var regexImpl = function(left2) {
  return function(right2) {
    return function(s1) {
      return function(s2) {
        try {
          return right2(new RegExp(s1, s2));
        } catch (e) {
          return left2(e.message);
        }
      };
    };
  };
};
var test = function(r) {
  return function(s) {
    var lastIndex = r.lastIndex;
    var result = r.test(s);
    r.lastIndex = lastIndex;
    return result;
  };
};
var _match = function(just) {
  return function(nothing) {
    return function(r) {
      return function(s) {
        var m = s.match(r);
        if (m == null || m.length === 0) {
          return nothing;
        } else {
          for (var i = 0; i < m.length; i++) {
            m[i] = m[i] == null ? nothing : just(m[i]);
          }
          return just(m);
        }
      };
    };
  };
};
var replace2 = function(r) {
  return function(s1) {
    return function(s2) {
      return s2.replace(r, s1);
    };
  };
};
var split2 = function(r) {
  return function(s) {
    return s.split(r);
  };
};

// output/Data.String.Regex.Flags/index.js
var unicode = {
  global: false,
  ignoreCase: false,
  multiline: false,
  dotAll: false,
  sticky: false,
  unicode: true
};
var noFlags = {
  global: false,
  ignoreCase: false,
  multiline: false,
  dotAll: false,
  sticky: false,
  unicode: false
};
var ignoreCase = {
  global: false,
  ignoreCase: true,
  multiline: false,
  dotAll: false,
  sticky: false,
  unicode: false
};
var global2 = {
  global: true,
  ignoreCase: false,
  multiline: false,
  dotAll: false,
  sticky: false,
  unicode: false
};

// output/Data.String.Regex/index.js
var renderFlags = function(v) {
  return function() {
    if (v.global) {
      return "g";
    }
    ;
    return "";
  }() + (function() {
    if (v.ignoreCase) {
      return "i";
    }
    ;
    return "";
  }() + (function() {
    if (v.multiline) {
      return "m";
    }
    ;
    return "";
  }() + (function() {
    if (v.dotAll) {
      return "s";
    }
    ;
    return "";
  }() + (function() {
    if (v.sticky) {
      return "y";
    }
    ;
    return "";
  }() + function() {
    if (v.unicode) {
      return "u";
    }
    ;
    return "";
  }()))));
};
var regex = function(s) {
  return function(f) {
    return regexImpl(Left.create)(Right.create)(s)(renderFlags(f));
  };
};
var match = /* @__PURE__ */ function() {
  return _match(Just.create)(Nothing.value);
}();

// output/Data.String.Regex.Unsafe/index.js
var identity11 = /* @__PURE__ */ identity(categoryFn);
var unsafeRegex = function(s) {
  return function(f) {
    return either(unsafeCrashWith)(identity11)(regex(s)(f));
  };
};

// output/Dodo.Internal/index.js
var Append = /* @__PURE__ */ function() {
  function Append2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Append2.create = function(value0) {
    return function(value12) {
      return new Append2(value0, value12);
    };
  };
  return Append2;
}();
var Indent = /* @__PURE__ */ function() {
  function Indent2(value0) {
    this.value0 = value0;
  }
  ;
  Indent2.create = function(value0) {
    return new Indent2(value0);
  };
  return Indent2;
}();
var Align = /* @__PURE__ */ function() {
  function Align2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Align2.create = function(value0) {
    return function(value12) {
      return new Align2(value0, value12);
    };
  };
  return Align2;
}();
var Annotate = /* @__PURE__ */ function() {
  function Annotate2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Annotate2.create = function(value0) {
    return function(value12) {
      return new Annotate2(value0, value12);
    };
  };
  return Annotate2;
}();
var FlexSelect = /* @__PURE__ */ function() {
  function FlexSelect2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  FlexSelect2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new FlexSelect2(value0, value12, value22);
      };
    };
  };
  return FlexSelect2;
}();
var FlexAlt = /* @__PURE__ */ function() {
  function FlexAlt2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  FlexAlt2.create = function(value0) {
    return function(value12) {
      return new FlexAlt2(value0, value12);
    };
  };
  return FlexAlt2;
}();
var WithPosition = /* @__PURE__ */ function() {
  function WithPosition2(value0) {
    this.value0 = value0;
  }
  ;
  WithPosition2.create = function(value0) {
    return new WithPosition2(value0);
  };
  return WithPosition2;
}();
var Local = /* @__PURE__ */ function() {
  function Local2(value0) {
    this.value0 = value0;
  }
  ;
  Local2.create = function(value0) {
    return new Local2(value0);
  };
  return Local2;
}();
var Text = /* @__PURE__ */ function() {
  function Text3(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Text3.create = function(value0) {
    return function(value12) {
      return new Text3(value0, value12);
    };
  };
  return Text3;
}();
var Break = /* @__PURE__ */ function() {
  function Break2() {
  }
  ;
  Break2.value = new Break2();
  return Break2;
}();
var Empty = /* @__PURE__ */ function() {
  function Empty3() {
  }
  ;
  Empty3.value = new Empty3();
  return Empty3;
}();
var notEmpty = function(f) {
  return function(v) {
    if (v instanceof Empty) {
      return Empty.value;
    }
    ;
    return f(v);
  };
};
var isEmpty4 = function(v) {
  if (v instanceof Empty) {
    return true;
  }
  ;
  return false;
};
var bothNotEmpty = function(f) {
  return function(v) {
    return function(v1) {
      if (v instanceof Empty) {
        return v1;
      }
      ;
      if (v1 instanceof Empty) {
        return v;
      }
      ;
      return f(v)(v1);
    };
  };
};
var semigroupDoc = {
  append: /* @__PURE__ */ bothNotEmpty(function(v) {
    return function(v1) {
      if (v instanceof Text && v1 instanceof Text) {
        return new Text(v.value0 + v1.value0 | 0, v.value1 + v1.value1);
      }
      ;
      return new Append(v, v1);
    };
  })
};
var monoidDoc = /* @__PURE__ */ function() {
  return {
    mempty: Empty.value,
    Semigroup0: function() {
      return semigroupDoc;
    }
  };
}();

// output/Dodo.Internal.Buffer/index.js
var foldr5 = /* @__PURE__ */ foldr(foldableList);
var $$new2 = function(buffer) {
  return {
    buffer,
    queue: Nil.value
  };
};
var modify4 = function(f) {
  return function(v) {
    if (v.queue instanceof Cons) {
      return {
        buffer: v.buffer,
        queue: new Cons(new Cons(f, v.queue.value0), v.queue.value1)
      };
    }
    ;
    return {
      buffer: f(v.buffer),
      queue: v.queue
    };
  };
};
var commit = function(v) {
  return {
    buffer: foldr5(flip(foldr5(apply)))(v.buffer)(v.queue),
    queue: Nil.value
  };
};
var get2 = function($23) {
  return function(v) {
    return v.buffer;
  }(commit($23));
};
var branch = function(v) {
  return {
    buffer: v.buffer,
    queue: new Cons(Nil.value, v.queue)
  };
};

// output/Dodo/index.js
var mempty2 = /* @__PURE__ */ mempty(monoidDoc);
var append12 = /* @__PURE__ */ append(semigroupDoc);
var max3 = /* @__PURE__ */ max(ordInt);
var max1 = /* @__PURE__ */ max(ordNumber);
var min3 = /* @__PURE__ */ min(ordNumber);
var power2 = /* @__PURE__ */ power(monoidString);
var pure5 = /* @__PURE__ */ pure(applicativeList);
var Doc = /* @__PURE__ */ function() {
  function Doc2(value0) {
    this.value0 = value0;
  }
  ;
  Doc2.create = function(value0) {
    return new Doc2(value0);
  };
  return Doc2;
}();
var Dedent = /* @__PURE__ */ function() {
  function Dedent2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Dedent2.create = function(value0) {
    return function(value12) {
      return new Dedent2(value0, value12);
    };
  };
  return Dedent2;
}();
var LeaveAnnotation = /* @__PURE__ */ function() {
  function LeaveAnnotation2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  LeaveAnnotation2.create = function(value0) {
    return function(value12) {
      return new LeaveAnnotation2(value0, value12);
    };
  };
  return LeaveAnnotation2;
}();
var LeaveFlexGroup = /* @__PURE__ */ function() {
  function LeaveFlexGroup2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  LeaveFlexGroup2.create = function(value0) {
    return function(value12) {
      return new LeaveFlexGroup2(value0, value12);
    };
  };
  return LeaveFlexGroup2;
}();
var LeaveLocal = /* @__PURE__ */ function() {
  function LeaveLocal2(value0) {
    this.value0 = value0;
  }
  ;
  LeaveLocal2.create = function(value0) {
    return new LeaveLocal2(value0);
  };
  return LeaveLocal2;
}();
var NoFlexGroup = /* @__PURE__ */ function() {
  function NoFlexGroup2() {
  }
  ;
  NoFlexGroup2.value = new NoFlexGroup2();
  return NoFlexGroup2;
}();
var FlexGroupPending = /* @__PURE__ */ function() {
  function FlexGroupPending2() {
  }
  ;
  FlexGroupPending2.value = new FlexGroupPending2();
  return FlexGroupPending2;
}();
var FlexGroupReset = /* @__PURE__ */ function() {
  function FlexGroupReset2(value0) {
    this.value0 = value0;
  }
  ;
  FlexGroupReset2.create = function(value0) {
    return new FlexGroupReset2(value0);
  };
  return FlexGroupReset2;
}();
var twoSpaces = {
  pageWidth: 80,
  ribbonRatio: 1,
  indentUnit: "  ",
  indentWidth: 2
};
var text = function(v) {
  if (v === "") {
    return Empty.value;
  }
  ;
  return new Text(length4(v), v);
};
var storeState = function(stack) {
  return function(v) {
    return {
      position: v.position,
      buffer: v.buffer,
      annotations: v.annotations,
      indentSpaces: v.indentSpaces,
      stack,
      options: v.options
    };
  };
};
var space = /* @__PURE__ */ text(" ");
var resetState = function(v) {
  return {
    position: v.position,
    buffer: v.buffer,
    annotations: v.annotations,
    indentSpaces: v.indentSpaces,
    flexGroup: NoFlexGroup.value,
    options: v.options
  };
};
var plainText = {
  emptyBuffer: "",
  writeText: function(v) {
    return function(str2) {
      return function(buff) {
        return buff + str2;
      };
    };
  },
  writeIndent: function(v) {
    return function(str2) {
      return function(buff) {
        return buff + str2;
      };
    };
  },
  writeBreak: function(buff) {
    return buff + "\n";
  },
  enterAnnotation: function(v) {
    return function(v1) {
      return function(buff) {
        return buff;
      };
    };
  },
  leaveAnnotation: function(v) {
    return function(v1) {
      return function(buff) {
        return buff;
      };
    };
  },
  flushBuffer: function(buff) {
    return buff;
  }
};
var indent = /* @__PURE__ */ function() {
  return notEmpty(Indent.create);
}();
var foldWith = function(dictFoldable) {
  var foldr14 = foldr(dictFoldable);
  return function(f) {
    return foldr14(bothNotEmpty(f))(mempty2);
  };
};
var foldWithSeparator = function(dictFoldable) {
  var foldWith1 = foldWith(dictFoldable);
  return function(separator) {
    return foldWith1(function(a) {
      return function(b) {
        return append12(a)(append12(separator)(b));
      };
    });
  };
};
var calcRibbonWidth = function(v) {
  return function(n) {
    return max3(0)(ceil2(v.ribbonRatio * toNumber2(v.pageWidth - n | 0)));
  };
};
var storeOptions = function(prevIndent) {
  return function(localOptions) {
    return function(state2) {
      var newOptions = {
        indentUnit: localOptions.indentUnit,
        indentWidth: localOptions.indentWidth,
        pageWidth: localOptions.pageWidth,
        ribbonRatio: localOptions.ribbonRatio
      };
      return {
        position: {
          line: state2.position.line,
          column: state2.position.column,
          indent: state2.position.indent,
          nextIndent: localOptions.indent,
          pageWidth: newOptions.pageWidth,
          ribbonWidth: calcRibbonWidth(newOptions)(prevIndent)
        },
        buffer: state2.buffer,
        annotations: state2.annotations,
        indentSpaces: localOptions.indentSpaces,
        flexGroup: state2.flexGroup,
        options: newOptions
      };
    };
  };
};
var print = function(v) {
  return function(opts) {
    var initOptions = {
      pageWidth: opts.pageWidth,
      ribbonRatio: max1(0)(min3(1)(opts.ribbonRatio)),
      indentUnit: opts.indentUnit,
      indentWidth: opts.indentWidth
    };
    var initState = {
      position: {
        line: 0,
        column: 0,
        indent: 0,
        nextIndent: 0,
        pageWidth: initOptions.pageWidth,
        ribbonWidth: calcRibbonWidth(initOptions)(0)
      },
      buffer: $$new2(v.emptyBuffer),
      annotations: Nil.value,
      indentSpaces: "",
      flexGroup: NoFlexGroup.value,
      options: initOptions
    };
    var go = function($copy_stack) {
      return function($copy_state) {
        var $tco_var_stack = $copy_stack;
        var $tco_done = false;
        var $tco_result;
        function $tco_loop(stack, state2) {
          if (stack instanceof Nil) {
            $tco_done = true;
            return v.flushBuffer(get2(state2.buffer));
          }
          ;
          if (stack instanceof Cons) {
            if (stack.value0 instanceof Doc) {
              if (stack.value0.value0 instanceof Append) {
                $tco_var_stack = new Cons(new Doc(stack.value0.value0.value0), new Cons(new Doc(stack.value0.value0.value1), stack.value1));
                $copy_state = state2;
                return;
              }
              ;
              if (stack.value0.value0 instanceof Text) {
                if (state2.position.column === 0 && state2.position.indent > 0) {
                  $tco_var_stack = stack;
                  $copy_state = {
                    position: {
                      line: state2.position.line,
                      column: state2.position.indent,
                      indent: state2.position.indent,
                      nextIndent: state2.position.nextIndent,
                      pageWidth: state2.position.pageWidth,
                      ribbonWidth: state2.position.ribbonWidth
                    },
                    buffer: modify4(v.writeIndent(state2.position.indent)(state2.indentSpaces))(state2.buffer),
                    annotations: state2.annotations,
                    indentSpaces: state2.indentSpaces,
                    flexGroup: state2.flexGroup,
                    options: state2.options
                  };
                  return;
                }
                ;
                if ((state2.position.column + stack.value0.value0.value0 | 0) <= (state2.position.indent + state2.position.ribbonWidth | 0)) {
                  $tco_var_stack = stack.value1;
                  $copy_state = {
                    position: {
                      line: state2.position.line,
                      column: state2.position.column + stack.value0.value0.value0 | 0,
                      indent: state2.position.indent,
                      nextIndent: state2.position.nextIndent,
                      pageWidth: state2.position.pageWidth,
                      ribbonWidth: state2.position.ribbonWidth
                    },
                    buffer: modify4(v.writeText(stack.value0.value0.value0)(stack.value0.value0.value1))(state2.buffer),
                    annotations: state2.annotations,
                    indentSpaces: state2.indentSpaces,
                    flexGroup: state2.flexGroup,
                    options: state2.options
                  };
                  return;
                }
                ;
                if (otherwise) {
                  if (state2.flexGroup instanceof FlexGroupReset) {
                    $tco_var_stack = state2.flexGroup.value0.stack;
                    $copy_state = resetState(state2.flexGroup.value0);
                    return;
                  }
                  ;
                  $tco_var_stack = stack.value1;
                  $copy_state = {
                    position: {
                      line: state2.position.line,
                      column: state2.position.column + stack.value0.value0.value0 | 0,
                      indent: state2.position.indent,
                      nextIndent: state2.position.nextIndent,
                      pageWidth: state2.position.pageWidth,
                      ribbonWidth: state2.position.ribbonWidth
                    },
                    buffer: modify4(v.writeText(stack.value0.value0.value0)(stack.value0.value0.value1))(state2.buffer),
                    annotations: state2.annotations,
                    indentSpaces: state2.indentSpaces,
                    flexGroup: NoFlexGroup.value,
                    options: state2.options
                  };
                  return;
                }
                ;
              }
              ;
              if (stack.value0.value0 instanceof Break) {
                if (state2.flexGroup instanceof FlexGroupReset) {
                  $tco_var_stack = state2.flexGroup.value0.stack;
                  $copy_state = resetState(state2.flexGroup.value0);
                  return;
                }
                ;
                $tco_var_stack = stack.value1;
                $copy_state = {
                  position: {
                    line: state2.position.line + 1 | 0,
                    column: 0,
                    indent: state2.position.nextIndent,
                    nextIndent: state2.position.nextIndent,
                    pageWidth: state2.position.pageWidth,
                    ribbonWidth: calcRibbonWidth(state2.options)(state2.position.nextIndent)
                  },
                  buffer: modify4(v.writeBreak)(state2.buffer),
                  annotations: state2.annotations,
                  indentSpaces: state2.indentSpaces,
                  flexGroup: NoFlexGroup.value,
                  options: state2.options
                };
                return;
              }
              ;
              if (stack.value0.value0 instanceof Indent) {
                if (state2.position.column === 0) {
                  $tco_var_stack = new Cons(new Doc(stack.value0.value0.value0), new Cons(new Dedent(state2.indentSpaces, state2.position.nextIndent), stack.value1));
                  $copy_state = {
                    position: {
                      line: state2.position.line,
                      column: state2.position.column,
                      indent: state2.position.nextIndent + opts.indentWidth | 0,
                      nextIndent: state2.position.nextIndent + opts.indentWidth | 0,
                      pageWidth: state2.position.pageWidth,
                      ribbonWidth: calcRibbonWidth(state2.options)(state2.position.nextIndent + opts.indentWidth | 0)
                    },
                    buffer: state2.buffer,
                    annotations: state2.annotations,
                    indentSpaces: state2.indentSpaces + opts.indentUnit,
                    flexGroup: state2.flexGroup,
                    options: state2.options
                  };
                  return;
                }
                ;
                if (otherwise) {
                  $tco_var_stack = new Cons(new Doc(stack.value0.value0.value0), new Cons(new Dedent(state2.indentSpaces, state2.position.nextIndent), stack.value1));
                  $copy_state = {
                    position: {
                      line: state2.position.line,
                      column: state2.position.column,
                      indent: state2.position.indent,
                      nextIndent: state2.position.nextIndent + opts.indentWidth | 0,
                      pageWidth: state2.position.pageWidth,
                      ribbonWidth: state2.position.ribbonWidth
                    },
                    buffer: state2.buffer,
                    annotations: state2.annotations,
                    indentSpaces: state2.indentSpaces + opts.indentUnit,
                    flexGroup: state2.flexGroup,
                    options: state2.options
                  };
                  return;
                }
                ;
              }
              ;
              if (stack.value0.value0 instanceof Align) {
                if (state2.position.column === 0) {
                  $tco_var_stack = new Cons(new Doc(stack.value0.value0.value1), new Cons(new Dedent(state2.indentSpaces, state2.position.nextIndent), stack.value1));
                  $copy_state = {
                    position: {
                      line: state2.position.line,
                      column: state2.position.column,
                      indent: state2.position.nextIndent + stack.value0.value0.value0 | 0,
                      nextIndent: state2.position.nextIndent + stack.value0.value0.value0 | 0,
                      pageWidth: state2.position.pageWidth,
                      ribbonWidth: calcRibbonWidth(state2.options)(state2.position.nextIndent + stack.value0.value0.value0 | 0)
                    },
                    buffer: state2.buffer,
                    annotations: state2.annotations,
                    indentSpaces: state2.indentSpaces + power2(" ")(stack.value0.value0.value0),
                    flexGroup: state2.flexGroup,
                    options: state2.options
                  };
                  return;
                }
                ;
                if (otherwise) {
                  $tco_var_stack = new Cons(new Doc(stack.value0.value0.value1), new Cons(new Dedent(state2.indentSpaces, state2.position.nextIndent), stack.value1));
                  $copy_state = {
                    position: {
                      line: state2.position.line,
                      column: state2.position.column,
                      indent: state2.position.indent,
                      nextIndent: state2.position.nextIndent + stack.value0.value0.value0 | 0,
                      pageWidth: state2.position.pageWidth,
                      ribbonWidth: state2.position.ribbonWidth
                    },
                    buffer: state2.buffer,
                    annotations: state2.annotations,
                    indentSpaces: state2.indentSpaces + power2(" ")(stack.value0.value0.value0),
                    flexGroup: state2.flexGroup,
                    options: state2.options
                  };
                  return;
                }
                ;
              }
              ;
              if (stack.value0.value0 instanceof FlexSelect) {
                if (state2.flexGroup instanceof NoFlexGroup) {
                  $tco_var_stack = new Cons(new Doc(stack.value0.value0.value0), new Cons(new LeaveFlexGroup(stack.value0.value0.value1, stack.value0.value0.value2), stack.value1));
                  $copy_state = {
                    position: state2.position,
                    buffer: state2.buffer,
                    annotations: state2.annotations,
                    indentSpaces: state2.indentSpaces,
                    flexGroup: FlexGroupPending.value,
                    options: state2.options
                  };
                  return;
                }
                ;
                if (state2.flexGroup instanceof FlexGroupPending && state2.position.ribbonWidth > 0) {
                  $tco_var_stack = new Cons(new Doc(stack.value0.value0.value0), new Cons(new Doc(stack.value0.value0.value1), stack.value1));
                  $copy_state = {
                    position: state2.position,
                    buffer: branch(state2.buffer),
                    annotations: state2.annotations,
                    indentSpaces: state2.indentSpaces,
                    flexGroup: new FlexGroupReset(storeState(stack)(state2)),
                    options: state2.options
                  };
                  return;
                }
                ;
                $tco_var_stack = new Cons(new Doc(stack.value0.value0.value0), new Cons(new Doc(stack.value0.value0.value1), stack.value1));
                $copy_state = state2;
                return;
              }
              ;
              if (stack.value0.value0 instanceof FlexAlt) {
                if (state2.flexGroup instanceof FlexGroupReset) {
                  $tco_var_stack = new Cons(new Doc(stack.value0.value0.value0), stack.value1);
                  $copy_state = state2;
                  return;
                }
                ;
                if (state2.flexGroup instanceof FlexGroupPending && state2.position.ribbonWidth > 0) {
                  $tco_var_stack = new Cons(new Doc(stack.value0.value0.value0), stack.value1);
                  $copy_state = {
                    position: state2.position,
                    buffer: branch(state2.buffer),
                    annotations: state2.annotations,
                    indentSpaces: state2.indentSpaces,
                    flexGroup: new FlexGroupReset(storeState(new Cons(new Doc(stack.value0.value0.value1), stack.value1))(state2)),
                    options: state2.options
                  };
                  return;
                }
                ;
                $tco_var_stack = new Cons(new Doc(stack.value0.value0.value1), stack.value1);
                $copy_state = state2;
                return;
              }
              ;
              if (stack.value0.value0 instanceof WithPosition) {
                if (state2.position.column === 0 && state2.position.nextIndent > 0) {
                  $tco_var_stack = new Cons(new Doc(stack.value0.value0.value0({
                    line: state2.position.line,
                    column: state2.position.nextIndent,
                    indent: state2.position.indent,
                    nextIndent: state2.position.nextIndent,
                    pageWidth: state2.position.pageWidth,
                    ribbonWidth: state2.position.ribbonWidth
                  })), stack.value1);
                  $copy_state = state2;
                  return;
                }
                ;
                if (otherwise) {
                  $tco_var_stack = new Cons(new Doc(stack.value0.value0.value0(state2.position)), stack.value1);
                  $copy_state = state2;
                  return;
                }
                ;
              }
              ;
              if (stack.value0.value0 instanceof Annotate) {
                $tco_var_stack = new Cons(new Doc(stack.value0.value0.value1), new Cons(new LeaveAnnotation(stack.value0.value0.value0, state2.annotations), stack.value1));
                $copy_state = {
                  position: state2.position,
                  buffer: modify4(v.enterAnnotation(stack.value0.value0.value0)(state2.annotations))(state2.buffer),
                  annotations: new Cons(stack.value0.value0.value0, state2.annotations),
                  indentSpaces: state2.indentSpaces,
                  flexGroup: state2.flexGroup,
                  options: state2.options
                };
                return;
              }
              ;
              if (stack.value0.value0 instanceof Local) {
                var prevOptions = {
                  indent: state2.position.indent,
                  indentSpaces: state2.indentSpaces,
                  indentUnit: state2.options.indentUnit,
                  indentWidth: state2.options.indentWidth,
                  pageWidth: state2.options.pageWidth,
                  ribbonRatio: state2.options.ribbonRatio
                };
                var v1 = stack.value0.value0.value0(prevOptions);
                $tco_var_stack = new Cons(new Doc(v1.value1), new Cons(new LeaveLocal(prevOptions), stack.value1));
                $copy_state = storeOptions(state2.position.indent)(v1.value0)(state2);
                return;
              }
              ;
              if (stack.value0.value0 instanceof Empty) {
                $tco_var_stack = stack.value1;
                $copy_state = state2;
                return;
              }
              ;
              throw new Error("Failed pattern match at Dodo (line 365, column 18 - line 477, column 23): " + [stack.value0.value0.constructor.name]);
            }
            ;
            if (stack.value0 instanceof LeaveFlexGroup) {
              if (state2.flexGroup instanceof NoFlexGroup) {
                $tco_var_stack = new Cons(new Doc(stack.value0.value1), stack.value1);
                $copy_state = {
                  position: state2.position,
                  buffer: commit(state2.buffer),
                  annotations: state2.annotations,
                  indentSpaces: state2.indentSpaces,
                  flexGroup: state2.flexGroup,
                  options: state2.options
                };
                return;
              }
              ;
              $tco_var_stack = new Cons(new Doc(stack.value0.value0), stack.value1);
              $copy_state = {
                position: state2.position,
                buffer: commit(state2.buffer),
                annotations: state2.annotations,
                indentSpaces: state2.indentSpaces,
                flexGroup: NoFlexGroup.value,
                options: state2.options
              };
              return;
            }
            ;
            if (stack.value0 instanceof Dedent) {
              $tco_var_stack = stack.value1;
              $copy_state = {
                position: {
                  line: state2.position.line,
                  column: state2.position.column,
                  indent: state2.position.indent,
                  nextIndent: stack.value0.value1,
                  pageWidth: state2.position.pageWidth,
                  ribbonWidth: state2.position.ribbonWidth
                },
                buffer: state2.buffer,
                annotations: state2.annotations,
                indentSpaces: stack.value0.value0,
                flexGroup: state2.flexGroup,
                options: state2.options
              };
              return;
            }
            ;
            if (stack.value0 instanceof LeaveAnnotation) {
              $tco_var_stack = stack.value1;
              $copy_state = {
                position: state2.position,
                buffer: modify4(v.leaveAnnotation(stack.value0.value0)(stack.value0.value1))(state2.buffer),
                annotations: stack.value0.value1,
                indentSpaces: state2.indentSpaces,
                flexGroup: state2.flexGroup,
                options: state2.options
              };
              return;
            }
            ;
            if (stack.value0 instanceof LeaveLocal) {
              $tco_var_stack = stack.value1;
              $copy_state = storeOptions(state2.position.indent)(stack.value0.value0)(state2);
              return;
            }
            ;
            throw new Error("Failed pattern match at Dodo (line 364, column 18 - line 499, column 70): " + [stack.value0.constructor.name]);
          }
          ;
          throw new Error("Failed pattern match at Dodo (line 361, column 20 - line 499, column 70): " + [stack.constructor.name]);
        }
        ;
        while (!$tco_done) {
          $tco_result = $tco_loop($tco_var_stack, $copy_state);
        }
        ;
        return $tco_result;
      };
    };
    var $135 = flip(go)(initState);
    return function($136) {
      return $135(pure5(Doc.create($136)));
    };
  };
};
var $$break = /* @__PURE__ */ function() {
  return Break.value;
}();
var appendSpace = /* @__PURE__ */ bothNotEmpty(function(a) {
  return function(b) {
    return append12(a)(append12(space)(b));
  };
});
var words = function(dictFoldable) {
  return foldr(dictFoldable)(appendSpace)(Empty.value);
};
var appendBreak = /* @__PURE__ */ bothNotEmpty(function(a) {
  return function(b) {
    return append12(a)(append12($$break)(b));
  };
});
var lines = function(dictFoldable) {
  return foldr(dictFoldable)(appendBreak)(Empty.value);
};
var annotate = function($141) {
  return notEmpty(Annotate.create($141));
};

// output/Effect.Aff/foreign.js
var Aff = function() {
  var EMPTY = {};
  var PURE = "Pure";
  var THROW = "Throw";
  var CATCH = "Catch";
  var SYNC = "Sync";
  var ASYNC = "Async";
  var BIND = "Bind";
  var BRACKET = "Bracket";
  var FORK = "Fork";
  var SEQ = "Sequential";
  var MAP = "Map";
  var APPLY = "Apply";
  var ALT = "Alt";
  var CONS = "Cons";
  var RESUME = "Resume";
  var RELEASE = "Release";
  var FINALIZER = "Finalizer";
  var FINALIZED = "Finalized";
  var FORKED = "Forked";
  var FIBER = "Fiber";
  var THUNK = "Thunk";
  function Aff2(tag, _1, _2, _3) {
    this.tag = tag;
    this._1 = _1;
    this._2 = _2;
    this._3 = _3;
  }
  function AffCtr(tag) {
    var fn = function(_1, _2, _3) {
      return new Aff2(tag, _1, _2, _3);
    };
    fn.tag = tag;
    return fn;
  }
  function nonCanceler2(error4) {
    return new Aff2(PURE, void 0);
  }
  function runEff(eff) {
    try {
      eff();
    } catch (error4) {
      setTimeout(function() {
        throw error4;
      }, 0);
    }
  }
  function runSync(left2, right2, eff) {
    try {
      return right2(eff());
    } catch (error4) {
      return left2(error4);
    }
  }
  function runAsync(left2, eff, k) {
    try {
      return eff(k)();
    } catch (error4) {
      k(left2(error4))();
      return nonCanceler2;
    }
  }
  var Scheduler = function() {
    var limit = 1024;
    var size10 = 0;
    var ix = 0;
    var queue = new Array(limit);
    var draining = false;
    function drain() {
      var thunk;
      draining = true;
      while (size10 !== 0) {
        size10--;
        thunk = queue[ix];
        queue[ix] = void 0;
        ix = (ix + 1) % limit;
        thunk();
      }
      draining = false;
    }
    return {
      isDraining: function() {
        return draining;
      },
      enqueue: function(cb) {
        var i, tmp;
        if (size10 === limit) {
          tmp = draining;
          drain();
          draining = tmp;
        }
        queue[(ix + size10) % limit] = cb;
        size10++;
        if (!draining) {
          drain();
        }
      }
    };
  }();
  function Supervisor(util) {
    var fibers = {};
    var fiberId = 0;
    var count = 0;
    return {
      register: function(fiber) {
        var fid = fiberId++;
        fiber.onComplete({
          rethrow: true,
          handler: function(result) {
            return function() {
              count--;
              delete fibers[fid];
            };
          }
        })();
        fibers[fid] = fiber;
        count++;
      },
      isEmpty: function() {
        return count === 0;
      },
      killAll: function(killError, cb) {
        return function() {
          if (count === 0) {
            return cb();
          }
          var killCount = 0;
          var kills = {};
          function kill2(fid) {
            kills[fid] = fibers[fid].kill(killError, function(result) {
              return function() {
                delete kills[fid];
                killCount--;
                if (util.isLeft(result) && util.fromLeft(result)) {
                  setTimeout(function() {
                    throw util.fromLeft(result);
                  }, 0);
                }
                if (killCount === 0) {
                  cb();
                }
              };
            })();
          }
          for (var k in fibers) {
            if (fibers.hasOwnProperty(k)) {
              killCount++;
              kill2(k);
            }
          }
          fibers = {};
          fiberId = 0;
          count = 0;
          return function(error4) {
            return new Aff2(SYNC, function() {
              for (var k2 in kills) {
                if (kills.hasOwnProperty(k2)) {
                  kills[k2]();
                }
              }
            });
          };
        };
      }
    };
  }
  var SUSPENDED = 0;
  var CONTINUE = 1;
  var STEP_BIND = 2;
  var STEP_RESULT = 3;
  var PENDING = 4;
  var RETURN = 5;
  var COMPLETED = 6;
  function Fiber(util, supervisor, aff) {
    var runTick = 0;
    var status = SUSPENDED;
    var step3 = aff;
    var fail5 = null;
    var interrupt = null;
    var bhead = null;
    var btail = null;
    var attempts = null;
    var bracketCount = 0;
    var joinId = 0;
    var joins = null;
    var rethrow = true;
    function run13(localRunTick) {
      var tmp, result, attempt2;
      while (true) {
        tmp = null;
        result = null;
        attempt2 = null;
        switch (status) {
          case STEP_BIND:
            status = CONTINUE;
            try {
              step3 = bhead(step3);
              if (btail === null) {
                bhead = null;
              } else {
                bhead = btail._1;
                btail = btail._2;
              }
            } catch (e) {
              status = RETURN;
              fail5 = util.left(e);
              step3 = null;
            }
            break;
          case STEP_RESULT:
            if (util.isLeft(step3)) {
              status = RETURN;
              fail5 = step3;
              step3 = null;
            } else if (bhead === null) {
              status = RETURN;
            } else {
              status = STEP_BIND;
              step3 = util.fromRight(step3);
            }
            break;
          case CONTINUE:
            switch (step3.tag) {
              case BIND:
                if (bhead) {
                  btail = new Aff2(CONS, bhead, btail);
                }
                bhead = step3._2;
                status = CONTINUE;
                step3 = step3._1;
                break;
              case PURE:
                if (bhead === null) {
                  status = RETURN;
                  step3 = util.right(step3._1);
                } else {
                  status = STEP_BIND;
                  step3 = step3._1;
                }
                break;
              case SYNC:
                status = STEP_RESULT;
                step3 = runSync(util.left, util.right, step3._1);
                break;
              case ASYNC:
                status = PENDING;
                step3 = runAsync(util.left, step3._1, function(result2) {
                  return function() {
                    if (runTick !== localRunTick) {
                      return;
                    }
                    runTick++;
                    Scheduler.enqueue(function() {
                      if (runTick !== localRunTick + 1) {
                        return;
                      }
                      status = STEP_RESULT;
                      step3 = result2;
                      run13(runTick);
                    });
                  };
                });
                return;
              case THROW:
                status = RETURN;
                fail5 = util.left(step3._1);
                step3 = null;
                break;
              case CATCH:
                if (bhead === null) {
                  attempts = new Aff2(CONS, step3, attempts, interrupt);
                } else {
                  attempts = new Aff2(CONS, step3, new Aff2(CONS, new Aff2(RESUME, bhead, btail), attempts, interrupt), interrupt);
                }
                bhead = null;
                btail = null;
                status = CONTINUE;
                step3 = step3._1;
                break;
              case BRACKET:
                bracketCount++;
                if (bhead === null) {
                  attempts = new Aff2(CONS, step3, attempts, interrupt);
                } else {
                  attempts = new Aff2(CONS, step3, new Aff2(CONS, new Aff2(RESUME, bhead, btail), attempts, interrupt), interrupt);
                }
                bhead = null;
                btail = null;
                status = CONTINUE;
                step3 = step3._1;
                break;
              case FORK:
                status = STEP_RESULT;
                tmp = Fiber(util, supervisor, step3._2);
                if (supervisor) {
                  supervisor.register(tmp);
                }
                if (step3._1) {
                  tmp.run();
                }
                step3 = util.right(tmp);
                break;
              case SEQ:
                status = CONTINUE;
                step3 = sequential3(util, supervisor, step3._1);
                break;
            }
            break;
          case RETURN:
            bhead = null;
            btail = null;
            if (attempts === null) {
              status = COMPLETED;
              step3 = interrupt || fail5 || step3;
            } else {
              tmp = attempts._3;
              attempt2 = attempts._1;
              attempts = attempts._2;
              switch (attempt2.tag) {
                case CATCH:
                  if (interrupt && interrupt !== tmp && bracketCount === 0) {
                    status = RETURN;
                  } else if (fail5) {
                    status = CONTINUE;
                    step3 = attempt2._2(util.fromLeft(fail5));
                    fail5 = null;
                  }
                  break;
                case RESUME:
                  if (interrupt && interrupt !== tmp && bracketCount === 0 || fail5) {
                    status = RETURN;
                  } else {
                    bhead = attempt2._1;
                    btail = attempt2._2;
                    status = STEP_BIND;
                    step3 = util.fromRight(step3);
                  }
                  break;
                case BRACKET:
                  bracketCount--;
                  if (fail5 === null) {
                    result = util.fromRight(step3);
                    attempts = new Aff2(CONS, new Aff2(RELEASE, attempt2._2, result), attempts, tmp);
                    if (interrupt === tmp || bracketCount > 0) {
                      status = CONTINUE;
                      step3 = attempt2._3(result);
                    }
                  }
                  break;
                case RELEASE:
                  attempts = new Aff2(CONS, new Aff2(FINALIZED, step3, fail5), attempts, interrupt);
                  status = CONTINUE;
                  if (interrupt && interrupt !== tmp && bracketCount === 0) {
                    step3 = attempt2._1.killed(util.fromLeft(interrupt))(attempt2._2);
                  } else if (fail5) {
                    step3 = attempt2._1.failed(util.fromLeft(fail5))(attempt2._2);
                  } else {
                    step3 = attempt2._1.completed(util.fromRight(step3))(attempt2._2);
                  }
                  fail5 = null;
                  bracketCount++;
                  break;
                case FINALIZER:
                  bracketCount++;
                  attempts = new Aff2(CONS, new Aff2(FINALIZED, step3, fail5), attempts, interrupt);
                  status = CONTINUE;
                  step3 = attempt2._1;
                  break;
                case FINALIZED:
                  bracketCount--;
                  status = RETURN;
                  step3 = attempt2._1;
                  fail5 = attempt2._2;
                  break;
              }
            }
            break;
          case COMPLETED:
            for (var k in joins) {
              if (joins.hasOwnProperty(k)) {
                rethrow = rethrow && joins[k].rethrow;
                runEff(joins[k].handler(step3));
              }
            }
            joins = null;
            if (interrupt && fail5) {
              setTimeout(function() {
                throw util.fromLeft(fail5);
              }, 0);
            } else if (util.isLeft(step3) && rethrow) {
              setTimeout(function() {
                if (rethrow) {
                  throw util.fromLeft(step3);
                }
              }, 0);
            }
            return;
          case SUSPENDED:
            status = CONTINUE;
            break;
          case PENDING:
            return;
        }
      }
    }
    function onComplete(join6) {
      return function() {
        if (status === COMPLETED) {
          rethrow = rethrow && join6.rethrow;
          join6.handler(step3)();
          return function() {
          };
        }
        var jid = joinId++;
        joins = joins || {};
        joins[jid] = join6;
        return function() {
          if (joins !== null) {
            delete joins[jid];
          }
        };
      };
    }
    function kill2(error4, cb) {
      return function() {
        if (status === COMPLETED) {
          cb(util.right(void 0))();
          return function() {
          };
        }
        var canceler = onComplete({
          rethrow: false,
          handler: function() {
            return cb(util.right(void 0));
          }
        })();
        switch (status) {
          case SUSPENDED:
            interrupt = util.left(error4);
            status = COMPLETED;
            step3 = interrupt;
            run13(runTick);
            break;
          case PENDING:
            if (interrupt === null) {
              interrupt = util.left(error4);
            }
            if (bracketCount === 0) {
              if (status === PENDING) {
                attempts = new Aff2(CONS, new Aff2(FINALIZER, step3(error4)), attempts, interrupt);
              }
              status = RETURN;
              step3 = null;
              fail5 = null;
              run13(++runTick);
            }
            break;
          default:
            if (interrupt === null) {
              interrupt = util.left(error4);
            }
            if (bracketCount === 0) {
              status = RETURN;
              step3 = null;
              fail5 = null;
            }
        }
        return canceler;
      };
    }
    function join5(cb) {
      return function() {
        var canceler = onComplete({
          rethrow: false,
          handler: cb
        })();
        if (status === SUSPENDED) {
          run13(runTick);
        }
        return canceler;
      };
    }
    return {
      kill: kill2,
      join: join5,
      onComplete,
      isSuspended: function() {
        return status === SUSPENDED;
      },
      run: function() {
        if (status === SUSPENDED) {
          if (!Scheduler.isDraining()) {
            Scheduler.enqueue(function() {
              run13(runTick);
            });
          } else {
            run13(runTick);
          }
        }
      }
    };
  }
  function runPar(util, supervisor, par, cb) {
    var fiberId = 0;
    var fibers = {};
    var killId = 0;
    var kills = {};
    var early = new Error("[ParAff] Early exit");
    var interrupt = null;
    var root2 = EMPTY;
    function kill2(error4, par2, cb2) {
      var step3 = par2;
      var head6 = null;
      var tail3 = null;
      var count = 0;
      var kills2 = {};
      var tmp, kid;
      loop:
        while (true) {
          tmp = null;
          switch (step3.tag) {
            case FORKED:
              if (step3._3 === EMPTY) {
                tmp = fibers[step3._1];
                kills2[count++] = tmp.kill(error4, function(result) {
                  return function() {
                    count--;
                    if (count === 0) {
                      cb2(result)();
                    }
                  };
                });
              }
              if (head6 === null) {
                break loop;
              }
              step3 = head6._2;
              if (tail3 === null) {
                head6 = null;
              } else {
                head6 = tail3._1;
                tail3 = tail3._2;
              }
              break;
            case MAP:
              step3 = step3._2;
              break;
            case APPLY:
            case ALT:
              if (head6) {
                tail3 = new Aff2(CONS, head6, tail3);
              }
              head6 = step3;
              step3 = step3._1;
              break;
          }
        }
      if (count === 0) {
        cb2(util.right(void 0))();
      } else {
        kid = 0;
        tmp = count;
        for (; kid < tmp; kid++) {
          kills2[kid] = kills2[kid]();
        }
      }
      return kills2;
    }
    function join5(result, head6, tail3) {
      var fail5, step3, lhs, rhs, tmp, kid;
      if (util.isLeft(result)) {
        fail5 = result;
        step3 = null;
      } else {
        step3 = result;
        fail5 = null;
      }
      loop:
        while (true) {
          lhs = null;
          rhs = null;
          tmp = null;
          kid = null;
          if (interrupt !== null) {
            return;
          }
          if (head6 === null) {
            cb(fail5 || step3)();
            return;
          }
          if (head6._3 !== EMPTY) {
            return;
          }
          switch (head6.tag) {
            case MAP:
              if (fail5 === null) {
                head6._3 = util.right(head6._1(util.fromRight(step3)));
                step3 = head6._3;
              } else {
                head6._3 = fail5;
              }
              break;
            case APPLY:
              lhs = head6._1._3;
              rhs = head6._2._3;
              if (fail5) {
                head6._3 = fail5;
                tmp = true;
                kid = killId++;
                kills[kid] = kill2(early, fail5 === lhs ? head6._2 : head6._1, function() {
                  return function() {
                    delete kills[kid];
                    if (tmp) {
                      tmp = false;
                    } else if (tail3 === null) {
                      join5(fail5, null, null);
                    } else {
                      join5(fail5, tail3._1, tail3._2);
                    }
                  };
                });
                if (tmp) {
                  tmp = false;
                  return;
                }
              } else if (lhs === EMPTY || rhs === EMPTY) {
                return;
              } else {
                step3 = util.right(util.fromRight(lhs)(util.fromRight(rhs)));
                head6._3 = step3;
              }
              break;
            case ALT:
              lhs = head6._1._3;
              rhs = head6._2._3;
              if (lhs === EMPTY && util.isLeft(rhs) || rhs === EMPTY && util.isLeft(lhs)) {
                return;
              }
              if (lhs !== EMPTY && util.isLeft(lhs) && rhs !== EMPTY && util.isLeft(rhs)) {
                fail5 = step3 === lhs ? rhs : lhs;
                step3 = null;
                head6._3 = fail5;
              } else {
                head6._3 = step3;
                tmp = true;
                kid = killId++;
                kills[kid] = kill2(early, step3 === lhs ? head6._2 : head6._1, function() {
                  return function() {
                    delete kills[kid];
                    if (tmp) {
                      tmp = false;
                    } else if (tail3 === null) {
                      join5(step3, null, null);
                    } else {
                      join5(step3, tail3._1, tail3._2);
                    }
                  };
                });
                if (tmp) {
                  tmp = false;
                  return;
                }
              }
              break;
          }
          if (tail3 === null) {
            head6 = null;
          } else {
            head6 = tail3._1;
            tail3 = tail3._2;
          }
        }
    }
    function resolve2(fiber) {
      return function(result) {
        return function() {
          delete fibers[fiber._1];
          fiber._3 = result;
          join5(result, fiber._2._1, fiber._2._2);
        };
      };
    }
    function run13() {
      var status = CONTINUE;
      var step3 = par;
      var head6 = null;
      var tail3 = null;
      var tmp, fid;
      loop:
        while (true) {
          tmp = null;
          fid = null;
          switch (status) {
            case CONTINUE:
              switch (step3.tag) {
                case MAP:
                  if (head6) {
                    tail3 = new Aff2(CONS, head6, tail3);
                  }
                  head6 = new Aff2(MAP, step3._1, EMPTY, EMPTY);
                  step3 = step3._2;
                  break;
                case APPLY:
                  if (head6) {
                    tail3 = new Aff2(CONS, head6, tail3);
                  }
                  head6 = new Aff2(APPLY, EMPTY, step3._2, EMPTY);
                  step3 = step3._1;
                  break;
                case ALT:
                  if (head6) {
                    tail3 = new Aff2(CONS, head6, tail3);
                  }
                  head6 = new Aff2(ALT, EMPTY, step3._2, EMPTY);
                  step3 = step3._1;
                  break;
                default:
                  fid = fiberId++;
                  status = RETURN;
                  tmp = step3;
                  step3 = new Aff2(FORKED, fid, new Aff2(CONS, head6, tail3), EMPTY);
                  tmp = Fiber(util, supervisor, tmp);
                  tmp.onComplete({
                    rethrow: false,
                    handler: resolve2(step3)
                  })();
                  fibers[fid] = tmp;
                  if (supervisor) {
                    supervisor.register(tmp);
                  }
              }
              break;
            case RETURN:
              if (head6 === null) {
                break loop;
              }
              if (head6._1 === EMPTY) {
                head6._1 = step3;
                status = CONTINUE;
                step3 = head6._2;
                head6._2 = EMPTY;
              } else {
                head6._2 = step3;
                step3 = head6;
                if (tail3 === null) {
                  head6 = null;
                } else {
                  head6 = tail3._1;
                  tail3 = tail3._2;
                }
              }
          }
        }
      root2 = step3;
      for (fid = 0; fid < fiberId; fid++) {
        fibers[fid].run();
      }
    }
    function cancel(error4, cb2) {
      interrupt = util.left(error4);
      var innerKills;
      for (var kid in kills) {
        if (kills.hasOwnProperty(kid)) {
          innerKills = kills[kid];
          for (kid in innerKills) {
            if (innerKills.hasOwnProperty(kid)) {
              innerKills[kid]();
            }
          }
        }
      }
      kills = null;
      var newKills = kill2(error4, root2, cb2);
      return function(killError) {
        return new Aff2(ASYNC, function(killCb) {
          return function() {
            for (var kid2 in newKills) {
              if (newKills.hasOwnProperty(kid2)) {
                newKills[kid2]();
              }
            }
            return nonCanceler2;
          };
        });
      };
    }
    run13();
    return function(killError) {
      return new Aff2(ASYNC, function(killCb) {
        return function() {
          return cancel(killError, killCb);
        };
      });
    };
  }
  function sequential3(util, supervisor, par) {
    return new Aff2(ASYNC, function(cb) {
      return function() {
        return runPar(util, supervisor, par, cb);
      };
    });
  }
  Aff2.EMPTY = EMPTY;
  Aff2.Pure = AffCtr(PURE);
  Aff2.Throw = AffCtr(THROW);
  Aff2.Catch = AffCtr(CATCH);
  Aff2.Sync = AffCtr(SYNC);
  Aff2.Async = AffCtr(ASYNC);
  Aff2.Bind = AffCtr(BIND);
  Aff2.Bracket = AffCtr(BRACKET);
  Aff2.Fork = AffCtr(FORK);
  Aff2.Seq = AffCtr(SEQ);
  Aff2.ParMap = AffCtr(MAP);
  Aff2.ParApply = AffCtr(APPLY);
  Aff2.ParAlt = AffCtr(ALT);
  Aff2.Fiber = Fiber;
  Aff2.Supervisor = Supervisor;
  Aff2.Scheduler = Scheduler;
  Aff2.nonCanceler = nonCanceler2;
  return Aff2;
}();
var _pure = Aff.Pure;
var _throwError = Aff.Throw;
function _catchError(aff) {
  return function(k) {
    return Aff.Catch(aff, k);
  };
}
function _map(f) {
  return function(aff) {
    if (aff.tag === Aff.Pure.tag) {
      return Aff.Pure(f(aff._1));
    } else {
      return Aff.Bind(aff, function(value4) {
        return Aff.Pure(f(value4));
      });
    }
  };
}
function _bind(aff) {
  return function(k) {
    return Aff.Bind(aff, k);
  };
}
function _fork(immediate) {
  return function(aff) {
    return Aff.Fork(immediate, aff);
  };
}
var _liftEffect = Aff.Sync;
function _parAffMap(f) {
  return function(aff) {
    return Aff.ParMap(f, aff);
  };
}
function _parAffApply(aff1) {
  return function(aff2) {
    return Aff.ParApply(aff1, aff2);
  };
}
function _parAffAlt(aff1) {
  return function(aff2) {
    return Aff.ParAlt(aff1, aff2);
  };
}
var makeAff = Aff.Async;
function generalBracket(acquire) {
  return function(options) {
    return function(k) {
      return Aff.Bracket(acquire, options, k);
    };
  };
}
function _makeFiber(util, aff) {
  return function() {
    return Aff.Fiber(util, null, aff);
  };
}
var _delay = function() {
  function setDelay(n, k) {
    if (n === 0 && typeof setImmediate !== "undefined") {
      return setImmediate(k);
    } else {
      return setTimeout(k, n);
    }
  }
  function clearDelay(n, t) {
    if (n === 0 && typeof clearImmediate !== "undefined") {
      return clearImmediate(t);
    } else {
      return clearTimeout(t);
    }
  }
  return function(right2, ms) {
    return Aff.Async(function(cb) {
      return function() {
        var timer = setDelay(ms, cb(right2()));
        return function() {
          return Aff.Sync(function() {
            return right2(clearDelay(ms, timer));
          });
        };
      };
    });
  };
}();
var _sequential = Aff.Seq;

// output/Control.Monad.Reader.Trans/index.js
var ReaderT = function(x) {
  return x;
};
var runReaderT = function(v) {
  return v;
};
var monadTransReaderT = {
  lift: function(dictMonad) {
    return function($147) {
      return ReaderT($$const($147));
    };
  }
};
var lift3 = /* @__PURE__ */ lift(monadTransReaderT);
var mapReaderT = function(f) {
  return function(v) {
    return function($148) {
      return f(v($148));
    };
  };
};
var functorReaderT = function(dictFunctor) {
  return {
    map: function() {
      var $149 = map(dictFunctor);
      return function($150) {
        return mapReaderT($149($150));
      };
    }()
  };
};
var applyReaderT = function(dictApply) {
  var apply25 = apply2(dictApply);
  var functorReaderT1 = functorReaderT(dictApply.Functor0());
  return {
    apply: function(v) {
      return function(v1) {
        return function(r) {
          return apply25(v(r))(v1(r));
        };
      };
    },
    Functor0: function() {
      return functorReaderT1;
    }
  };
};
var bindReaderT = function(dictBind) {
  var bind59 = bind(dictBind);
  var applyReaderT1 = applyReaderT(dictBind.Apply0());
  return {
    bind: function(v) {
      return function(k) {
        return function(r) {
          return bind59(v(r))(function(a) {
            var v1 = k(a);
            return v1(r);
          });
        };
      };
    },
    Apply0: function() {
      return applyReaderT1;
    }
  };
};
var semigroupReaderT = function(dictApply) {
  var lift26 = lift2(applyReaderT(dictApply));
  return function(dictSemigroup) {
    return {
      append: lift26(append(dictSemigroup))
    };
  };
};
var applicativeReaderT = function(dictApplicative) {
  var applyReaderT1 = applyReaderT(dictApplicative.Apply0());
  return {
    pure: function() {
      var $154 = pure(dictApplicative);
      return function($155) {
        return ReaderT($$const($154($155)));
      };
    }(),
    Apply0: function() {
      return applyReaderT1;
    }
  };
};
var monadReaderT = function(dictMonad) {
  var applicativeReaderT1 = applicativeReaderT(dictMonad.Applicative0());
  var bindReaderT1 = bindReaderT(dictMonad.Bind1());
  return {
    Applicative0: function() {
      return applicativeReaderT1;
    },
    Bind1: function() {
      return bindReaderT1;
    }
  };
};
var monadAskReaderT = function(dictMonad) {
  var monadReaderT12 = monadReaderT(dictMonad);
  return {
    ask: pure(dictMonad.Applicative0()),
    Monad0: function() {
      return monadReaderT12;
    }
  };
};
var monadEffectReader = function(dictMonadEffect) {
  var Monad0 = dictMonadEffect.Monad0();
  var monadReaderT12 = monadReaderT(Monad0);
  return {
    liftEffect: function() {
      var $157 = lift3(Monad0);
      var $158 = liftEffect(dictMonadEffect);
      return function($159) {
        return $157($158($159));
      };
    }(),
    Monad0: function() {
      return monadReaderT12;
    }
  };
};
var monadThrowReaderT = function(dictMonadThrow) {
  var Monad0 = dictMonadThrow.Monad0();
  var monadReaderT12 = monadReaderT(Monad0);
  return {
    throwError: function() {
      var $166 = lift3(Monad0);
      var $167 = throwError(dictMonadThrow);
      return function($168) {
        return $166($167($168));
      };
    }(),
    Monad0: function() {
      return monadReaderT12;
    }
  };
};
var monadErrorReaderT = function(dictMonadError) {
  var catchError3 = catchError(dictMonadError);
  var monadThrowReaderT1 = monadThrowReaderT(dictMonadError.MonadThrow0());
  return {
    catchError: function(v) {
      return function(h) {
        return function(r) {
          return catchError3(v(r))(function(e) {
            var v1 = h(e);
            return v1(r);
          });
        };
      };
    },
    MonadThrow0: function() {
      return monadThrowReaderT1;
    }
  };
};

// output/Control.Parallel.Class/index.js
var sequential = function(dict) {
  return dict.sequential;
};
var parallel = function(dict) {
  return dict.parallel;
};

// output/Control.Parallel/index.js
var identity12 = /* @__PURE__ */ identity(categoryFn);
var parTraverse_ = function(dictParallel) {
  var sequential3 = sequential(dictParallel);
  var traverse_3 = traverse_(dictParallel.Applicative1());
  var parallel3 = parallel(dictParallel);
  return function(dictFoldable) {
    var traverse_1 = traverse_3(dictFoldable);
    return function(f) {
      var $48 = traverse_1(function($50) {
        return parallel3(f($50));
      });
      return function($49) {
        return sequential3($48($49));
      };
    };
  };
};
var parTraverse = function(dictParallel) {
  var sequential3 = sequential(dictParallel);
  var Applicative1 = dictParallel.Applicative1();
  var parallel3 = parallel(dictParallel);
  return function(dictTraversable) {
    var traverse12 = traverse(dictTraversable)(Applicative1);
    return function(f) {
      var $51 = traverse12(function($53) {
        return parallel3(f($53));
      });
      return function($52) {
        return sequential3($51($52));
      };
    };
  };
};
var parSequence_ = function(dictParallel) {
  var parTraverse_1 = parTraverse_(dictParallel);
  return function(dictFoldable) {
    return parTraverse_1(dictFoldable)(identity12);
  };
};
var parSequence = function(dictParallel) {
  var parTraverse1 = parTraverse(dictParallel);
  return function(dictTraversable) {
    return parTraverse1(dictTraversable)(identity12);
  };
};
var parOneOf = function(dictParallel) {
  var sequential3 = sequential(dictParallel);
  var parallel3 = parallel(dictParallel);
  return function(dictAlternative) {
    var Plus1 = dictAlternative.Plus1();
    return function(dictFoldable) {
      var oneOfMap2 = oneOfMap(dictFoldable)(Plus1);
      return function(dictFunctor) {
        var $57 = oneOfMap2(parallel3);
        return function($58) {
          return sequential3($57($58));
        };
      };
    };
  };
};

// output/Effect.Unsafe/foreign.js
var unsafePerformEffect = function(f) {
  return f();
};

// output/Effect.Aff/index.js
var $runtime_lazy6 = function(name4, moduleName2, init4) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2)
      return val;
    if (state2 === 1)
      throw new ReferenceError(name4 + " was needed before it finished initializing (module " + moduleName2 + ", line " + lineNumber + ")", moduleName2, lineNumber);
    state2 = 1;
    val = init4();
    state2 = 2;
    return val;
  };
};
var pure6 = /* @__PURE__ */ pure(applicativeEffect);
var $$void8 = /* @__PURE__ */ $$void(functorEffect);
var map20 = /* @__PURE__ */ map(functorEffect);
var Canceler = function(x) {
  return x;
};
var suspendAff = /* @__PURE__ */ _fork(false);
var functorParAff = {
  map: _parAffMap
};
var functorAff = {
  map: _map
};
var forkAff = /* @__PURE__ */ _fork(true);
var ffiUtil = /* @__PURE__ */ function() {
  var unsafeFromRight2 = function(v) {
    if (v instanceof Right) {
      return v.value0;
    }
    ;
    if (v instanceof Left) {
      return unsafeCrashWith("unsafeFromRight: Left");
    }
    ;
    throw new Error("Failed pattern match at Effect.Aff (line 412, column 21 - line 414, column 54): " + [v.constructor.name]);
  };
  var unsafeFromLeft = function(v) {
    if (v instanceof Left) {
      return v.value0;
    }
    ;
    if (v instanceof Right) {
      return unsafeCrashWith("unsafeFromLeft: Right");
    }
    ;
    throw new Error("Failed pattern match at Effect.Aff (line 407, column 20 - line 409, column 55): " + [v.constructor.name]);
  };
  var isLeft2 = function(v) {
    if (v instanceof Left) {
      return true;
    }
    ;
    if (v instanceof Right) {
      return false;
    }
    ;
    throw new Error("Failed pattern match at Effect.Aff (line 402, column 12 - line 404, column 21): " + [v.constructor.name]);
  };
  return {
    isLeft: isLeft2,
    fromLeft: unsafeFromLeft,
    fromRight: unsafeFromRight2,
    left: Left.create,
    right: Right.create
  };
}();
var makeFiber = function(aff) {
  return _makeFiber(ffiUtil, aff);
};
var launchAff = function(aff) {
  return function __do3() {
    var fiber = makeFiber(aff)();
    fiber.run();
    return fiber;
  };
};
var launchAff_ = function($74) {
  return $$void8(launchAff($74));
};
var delay = function(v) {
  return _delay(Right.create, v);
};
var bracket = function(acquire) {
  return function(completed) {
    return generalBracket(acquire)({
      killed: $$const(completed),
      failed: $$const(completed),
      completed: $$const(completed)
    });
  };
};
var applyParAff = {
  apply: _parAffApply,
  Functor0: function() {
    return functorParAff;
  }
};
var monadAff = {
  Applicative0: function() {
    return applicativeAff;
  },
  Bind1: function() {
    return bindAff;
  }
};
var bindAff = {
  bind: _bind,
  Apply0: function() {
    return $lazy_applyAff(0);
  }
};
var applicativeAff = {
  pure: _pure,
  Apply0: function() {
    return $lazy_applyAff(0);
  }
};
var $lazy_applyAff = /* @__PURE__ */ $runtime_lazy6("applyAff", "Effect.Aff", function() {
  return {
    apply: ap(monadAff),
    Functor0: function() {
      return functorAff;
    }
  };
});
var applyAff = /* @__PURE__ */ $lazy_applyAff(73);
var pure22 = /* @__PURE__ */ pure(applicativeAff);
var lift21 = /* @__PURE__ */ lift2(applyAff);
var $$finally = function(fin) {
  return function(a) {
    return bracket(pure22(unit))($$const(fin))($$const(a));
  };
};
var semigroupAff = function(dictSemigroup) {
  return {
    append: lift21(append(dictSemigroup))
  };
};
var monadEffectAff = {
  liftEffect: _liftEffect,
  Monad0: function() {
    return monadAff;
  }
};
var liftEffect2 = /* @__PURE__ */ liftEffect(monadEffectAff);
var effectCanceler = function($75) {
  return Canceler($$const(liftEffect2($75)));
};
var joinFiber = function(v) {
  return makeAff(function(k) {
    return map20(effectCanceler)(v.join(k));
  });
};
var monadThrowAff = {
  throwError: _throwError,
  Monad0: function() {
    return monadAff;
  }
};
var monadErrorAff = {
  catchError: _catchError,
  MonadThrow0: function() {
    return monadThrowAff;
  }
};
var $$try3 = /* @__PURE__ */ $$try2(monadErrorAff);
var catchError2 = /* @__PURE__ */ catchError(monadErrorAff);
var attempt = $$try3;
var parallelAff = {
  parallel: unsafeCoerce2,
  sequential: _sequential,
  Monad0: function() {
    return monadAff;
  },
  Applicative1: function() {
    return $lazy_applicativeParAff(0);
  }
};
var $lazy_applicativeParAff = /* @__PURE__ */ $runtime_lazy6("applicativeParAff", "Effect.Aff", function() {
  return {
    pure: function() {
      var $82 = parallel(parallelAff);
      return function($83) {
        return $82(pure22($83));
      };
    }(),
    Apply0: function() {
      return applyParAff;
    }
  };
});
var applicativeParAff = /* @__PURE__ */ $lazy_applicativeParAff(136);
var parSequence_2 = /* @__PURE__ */ parSequence_(parallelAff)(foldableArray);
var semigroupCanceler = {
  append: function(v) {
    return function(v1) {
      return function(err) {
        return parSequence_2([v(err), v1(err)]);
      };
    };
  }
};
var monoidAff = function(dictMonoid) {
  var semigroupAff1 = semigroupAff(dictMonoid.Semigroup0());
  return {
    mempty: pure22(mempty(dictMonoid)),
    Semigroup0: function() {
      return semigroupAff1;
    }
  };
};
var nonCanceler = /* @__PURE__ */ $$const(/* @__PURE__ */ pure22(unit));
var monoidCanceler = {
  mempty: nonCanceler,
  Semigroup0: function() {
    return semigroupCanceler;
  }
};
var mempty3 = /* @__PURE__ */ mempty(monoidCanceler);
var never = /* @__PURE__ */ makeAff(function(v) {
  return pure6(mempty3);
});
var altParAff = {
  alt: _parAffAlt,
  Functor0: function() {
    return functorParAff;
  }
};
var altAff = {
  alt: function(a1) {
    return function(a2) {
      return catchError2(a1)($$const(a2));
    };
  },
  Functor0: function() {
    return functorAff;
  }
};
var plusAff = {
  empty: /* @__PURE__ */ throwError(monadThrowAff)(/* @__PURE__ */ error("Always fails")),
  Alt0: function() {
    return altAff;
  }
};
var plusParAff = {
  empty: /* @__PURE__ */ parallel(parallelAff)(/* @__PURE__ */ empty(plusAff)),
  Alt0: function() {
    return altParAff;
  }
};
var alternativeParAff = {
  Applicative0: function() {
    return applicativeParAff;
  },
  Plus1: function() {
    return plusParAff;
  }
};

// output/Control.Monad.State.Trans/index.js
var StateT = function(x) {
  return x;
};
var runStateT = function(v) {
  return v;
};
var monadTransStateT = {
  lift: function(dictMonad) {
    var bind59 = bind(dictMonad.Bind1());
    var pure75 = pure(dictMonad.Applicative0());
    return function(m) {
      return function(s) {
        return bind59(m)(function(x) {
          return pure75(new Tuple(x, s));
        });
      };
    };
  }
};
var functorStateT = function(dictFunctor) {
  var map86 = map(dictFunctor);
  return {
    map: function(f) {
      return function(v) {
        return function(s) {
          return map86(function(v1) {
            return new Tuple(f(v1.value0), v1.value1);
          })(v(s));
        };
      };
    }
  };
};
var evalStateT = function(dictFunctor) {
  var map86 = map(dictFunctor);
  return function(v) {
    return function(s) {
      return map86(fst)(v(s));
    };
  };
};
var monadStateT = function(dictMonad) {
  return {
    Applicative0: function() {
      return applicativeStateT(dictMonad);
    },
    Bind1: function() {
      return bindStateT(dictMonad);
    }
  };
};
var bindStateT = function(dictMonad) {
  var bind59 = bind(dictMonad.Bind1());
  return {
    bind: function(v) {
      return function(f) {
        return function(s) {
          return bind59(v(s))(function(v1) {
            var v3 = f(v1.value0);
            return v3(v1.value1);
          });
        };
      };
    },
    Apply0: function() {
      return applyStateT(dictMonad);
    }
  };
};
var applyStateT = function(dictMonad) {
  var functorStateT1 = functorStateT(dictMonad.Bind1().Apply0().Functor0());
  return {
    apply: ap(monadStateT(dictMonad)),
    Functor0: function() {
      return functorStateT1;
    }
  };
};
var applicativeStateT = function(dictMonad) {
  var pure75 = pure(dictMonad.Applicative0());
  return {
    pure: function(a) {
      return function(s) {
        return pure75(new Tuple(a, s));
      };
    },
    Apply0: function() {
      return applyStateT(dictMonad);
    }
  };
};
var monadRecStateT = function(dictMonadRec) {
  var Monad0 = dictMonadRec.Monad0();
  var bind59 = bind(Monad0.Bind1());
  var pure75 = pure(Monad0.Applicative0());
  var tailRecM6 = tailRecM(dictMonadRec);
  var monadStateT1 = monadStateT(Monad0);
  return {
    tailRecM: function(f) {
      return function(a) {
        var f$prime = function(v) {
          var v1 = f(v.value0);
          return bind59(v1(v.value1))(function(v2) {
            return pure75(function() {
              if (v2.value0 instanceof Loop) {
                return new Loop(new Tuple(v2.value0.value0, v2.value1));
              }
              ;
              if (v2.value0 instanceof Done) {
                return new Done(new Tuple(v2.value0.value0, v2.value1));
              }
              ;
              throw new Error("Failed pattern match at Control.Monad.State.Trans (line 87, column 16 - line 89, column 40): " + [v2.value0.constructor.name]);
            }());
          });
        };
        return function(s) {
          return tailRecM6(f$prime)(new Tuple(a, s));
        };
      };
    },
    Monad0: function() {
      return monadStateT1;
    }
  };
};
var monadStateStateT = function(dictMonad) {
  var pure75 = pure(dictMonad.Applicative0());
  var monadStateT1 = monadStateT(dictMonad);
  return {
    state: function(f) {
      return function($200) {
        return pure75(f($200));
      };
    },
    Monad0: function() {
      return monadStateT1;
    }
  };
};

// output/Effect.Aff.Class/index.js
var lift4 = /* @__PURE__ */ lift(monadTransReaderT);
var monadAffAff = {
  liftAff: /* @__PURE__ */ identity(categoryFn),
  MonadEffect0: function() {
    return monadEffectAff;
  }
};
var liftAff = function(dict) {
  return dict.liftAff;
};
var monadAffReader = function(dictMonadAff) {
  var MonadEffect0 = dictMonadAff.MonadEffect0();
  var monadEffectReader2 = monadEffectReader(MonadEffect0);
  return {
    liftAff: function() {
      var $79 = lift4(MonadEffect0.Monad0());
      var $80 = liftAff(dictMonadAff);
      return function($81) {
        return $79($80($81));
      };
    }(),
    MonadEffect0: function() {
      return monadEffectReader2;
    }
  };
};

// output/Node.Path/foreign.js
import path from "path";
var normalize = path.normalize;
function concat2(segments) {
  return path.join.apply(this, segments);
}
function resolve(from3) {
  return (to2) => () => path.resolve.apply(this, from3.concat([to2]));
}
function relative(from3) {
  return (to2) => path.relative(from3, to2);
}
function dirname(p) {
  return path.normalize(path.dirname(p));
}
var basename = path.basename;
var extname = path.extname;
var sep = path.sep;
var delimiter = path.delimiter;
var parse2 = path.parse;
var isAbsolute = path.isAbsolute;

// output/Node.Process/foreign.js
import process3 from "process";
function chdir(dir) {
  return () => {
    process3.chdir(dir);
  };
}
function exit(code) {
  return () => {
    process3.exit(code);
  };
}
function copyArray(xs) {
  return () => xs.slice();
}
function copyObject(o) {
  return () => Object.assign({}, o);
}

// output/Node.Platform/index.js
var AIX = /* @__PURE__ */ function() {
  function AIX2() {
  }
  ;
  AIX2.value = new AIX2();
  return AIX2;
}();
var Darwin = /* @__PURE__ */ function() {
  function Darwin2() {
  }
  ;
  Darwin2.value = new Darwin2();
  return Darwin2;
}();
var FreeBSD = /* @__PURE__ */ function() {
  function FreeBSD2() {
  }
  ;
  FreeBSD2.value = new FreeBSD2();
  return FreeBSD2;
}();
var Linux = /* @__PURE__ */ function() {
  function Linux2() {
  }
  ;
  Linux2.value = new Linux2();
  return Linux2;
}();
var OpenBSD = /* @__PURE__ */ function() {
  function OpenBSD2() {
  }
  ;
  OpenBSD2.value = new OpenBSD2();
  return OpenBSD2;
}();
var SunOS = /* @__PURE__ */ function() {
  function SunOS2() {
  }
  ;
  SunOS2.value = new SunOS2();
  return SunOS2;
}();
var Win32 = /* @__PURE__ */ function() {
  function Win322() {
  }
  ;
  Win322.value = new Win322();
  return Win322;
}();
var Android = /* @__PURE__ */ function() {
  function Android2() {
  }
  ;
  Android2.value = new Android2();
  return Android2;
}();
var fromString4 = function(v) {
  if (v === "aix") {
    return new Just(AIX.value);
  }
  ;
  if (v === "darwin") {
    return new Just(Darwin.value);
  }
  ;
  if (v === "freebsd") {
    return new Just(FreeBSD.value);
  }
  ;
  if (v === "linux") {
    return new Just(Linux.value);
  }
  ;
  if (v === "openbsd") {
    return new Just(OpenBSD.value);
  }
  ;
  if (v === "sunos") {
    return new Just(SunOS.value);
  }
  ;
  if (v === "win32") {
    return new Just(Win32.value);
  }
  ;
  if (v === "android") {
    return new Just(Android.value);
  }
  ;
  return Nothing.value;
};
var eqPlatform = {
  eq: function(x) {
    return function(y) {
      if (x instanceof AIX && y instanceof AIX) {
        return true;
      }
      ;
      if (x instanceof Darwin && y instanceof Darwin) {
        return true;
      }
      ;
      if (x instanceof FreeBSD && y instanceof FreeBSD) {
        return true;
      }
      ;
      if (x instanceof Linux && y instanceof Linux) {
        return true;
      }
      ;
      if (x instanceof OpenBSD && y instanceof OpenBSD) {
        return true;
      }
      ;
      if (x instanceof SunOS && y instanceof SunOS) {
        return true;
      }
      ;
      if (x instanceof Win32 && y instanceof Win32) {
        return true;
      }
      ;
      if (x instanceof Android && y instanceof Android) {
        return true;
      }
      ;
      return false;
    };
  }
};

// output/Node.Process/index.js
var stdout = /* @__PURE__ */ function() {
  return process3.stdout;
}();
var stdin = /* @__PURE__ */ function() {
  return process3.stdin;
}();
var stderr = /* @__PURE__ */ function() {
  return process3.stderr;
}();
var platformStr = /* @__PURE__ */ function() {
  return process3.platform;
}();
var platform = /* @__PURE__ */ fromString4(platformStr);
var pid = /* @__PURE__ */ function() {
  return process3.pid;
}();
var mkEffect = unsafeCoerce2;
var lookupMutableObject = function(k) {
  return function(o) {
    return mkEffect(function(v) {
      return lookup2(k)(o);
    });
  };
};
var lookupEnv = function(k) {
  return lookupMutableObject(k)(process3.env);
};
var getEnv = /* @__PURE__ */ function() {
  return copyObject(process3.env);
}();
var execPath = /* @__PURE__ */ mkEffect(function(v) {
  return process3.execPath;
});
var cwd = /* @__PURE__ */ function() {
  return process3.cwd;
}();
var argv = /* @__PURE__ */ function() {
  return copyArray(process3.argv);
}();

// output/ExitCodes/index.js
var Success = /* @__PURE__ */ function() {
  function Success4() {
  }
  ;
  Success4.value = new Success4();
  return Success4;
}();
var $$Error = /* @__PURE__ */ function() {
  function $$Error4() {
  }
  ;
  $$Error4.value = new $$Error4();
  return $$Error4;
}();
var MisuseOfShellBuiltins = /* @__PURE__ */ function() {
  function MisuseOfShellBuiltins2() {
  }
  ;
  MisuseOfShellBuiltins2.value = new MisuseOfShellBuiltins2();
  return MisuseOfShellBuiltins2;
}();
var CLIUsageError = /* @__PURE__ */ function() {
  function CLIUsageError2() {
  }
  ;
  CLIUsageError2.value = new CLIUsageError2();
  return CLIUsageError2;
}();
var DataFormatError = /* @__PURE__ */ function() {
  function DataFormatError2() {
  }
  ;
  DataFormatError2.value = new DataFormatError2();
  return DataFormatError2;
}();
var CannotOpenInput = /* @__PURE__ */ function() {
  function CannotOpenInput2() {
  }
  ;
  CannotOpenInput2.value = new CannotOpenInput2();
  return CannotOpenInput2;
}();
var AddresseeUnknown = /* @__PURE__ */ function() {
  function AddresseeUnknown2() {
  }
  ;
  AddresseeUnknown2.value = new AddresseeUnknown2();
  return AddresseeUnknown2;
}();
var HostNameUnknown = /* @__PURE__ */ function() {
  function HostNameUnknown2() {
  }
  ;
  HostNameUnknown2.value = new HostNameUnknown2();
  return HostNameUnknown2;
}();
var ServiceUnavailable = /* @__PURE__ */ function() {
  function ServiceUnavailable2() {
  }
  ;
  ServiceUnavailable2.value = new ServiceUnavailable2();
  return ServiceUnavailable2;
}();
var InternalSoftwareError = /* @__PURE__ */ function() {
  function InternalSoftwareError2() {
  }
  ;
  InternalSoftwareError2.value = new InternalSoftwareError2();
  return InternalSoftwareError2;
}();
var SystemError = /* @__PURE__ */ function() {
  function SystemError2() {
  }
  ;
  SystemError2.value = new SystemError2();
  return SystemError2;
}();
var CriticalOSFileMissing = /* @__PURE__ */ function() {
  function CriticalOSFileMissing2() {
  }
  ;
  CriticalOSFileMissing2.value = new CriticalOSFileMissing2();
  return CriticalOSFileMissing2;
}();
var CannotCreateOutputFile = /* @__PURE__ */ function() {
  function CannotCreateOutputFile2() {
  }
  ;
  CannotCreateOutputFile2.value = new CannotCreateOutputFile2();
  return CannotCreateOutputFile2;
}();
var IOError = /* @__PURE__ */ function() {
  function IOError2() {
  }
  ;
  IOError2.value = new IOError2();
  return IOError2;
}();
var TemporaryFailure = /* @__PURE__ */ function() {
  function TemporaryFailure2() {
  }
  ;
  TemporaryFailure2.value = new TemporaryFailure2();
  return TemporaryFailure2;
}();
var RemoteError = /* @__PURE__ */ function() {
  function RemoteError2() {
  }
  ;
  RemoteError2.value = new RemoteError2();
  return RemoteError2;
}();
var PermissionDenied = /* @__PURE__ */ function() {
  function PermissionDenied2() {
  }
  ;
  PermissionDenied2.value = new PermissionDenied2();
  return PermissionDenied2;
}();
var ConfigurationError = /* @__PURE__ */ function() {
  function ConfigurationError2() {
  }
  ;
  ConfigurationError2.value = new ConfigurationError2();
  return ConfigurationError2;
}();
var CannotExecute = /* @__PURE__ */ function() {
  function CannotExecute2() {
  }
  ;
  CannotExecute2.value = new CannotExecute2();
  return CannotExecute2;
}();
var CommandNotFound = /* @__PURE__ */ function() {
  function CommandNotFound2() {
  }
  ;
  CommandNotFound2.value = new CommandNotFound2();
  return CommandNotFound2;
}();
var InvalidExitArgument = /* @__PURE__ */ function() {
  function InvalidExitArgument2() {
  }
  ;
  InvalidExitArgument2.value = new InvalidExitArgument2();
  return InvalidExitArgument2;
}();
var SIGHUP = /* @__PURE__ */ function() {
  function SIGHUP2() {
  }
  ;
  SIGHUP2.value = new SIGHUP2();
  return SIGHUP2;
}();
var SIGINT = /* @__PURE__ */ function() {
  function SIGINT2() {
  }
  ;
  SIGINT2.value = new SIGINT2();
  return SIGINT2;
}();
var SIGQUIT = /* @__PURE__ */ function() {
  function SIGQUIT2() {
  }
  ;
  SIGQUIT2.value = new SIGQUIT2();
  return SIGQUIT2;
}();
var SIGILL = /* @__PURE__ */ function() {
  function SIGILL2() {
  }
  ;
  SIGILL2.value = new SIGILL2();
  return SIGILL2;
}();
var SIGABRT = /* @__PURE__ */ function() {
  function SIGABRT2() {
  }
  ;
  SIGABRT2.value = new SIGABRT2();
  return SIGABRT2;
}();
var SIGFPE = /* @__PURE__ */ function() {
  function SIGFPE2() {
  }
  ;
  SIGFPE2.value = new SIGFPE2();
  return SIGFPE2;
}();
var SIGKILL = /* @__PURE__ */ function() {
  function SIGKILL2() {
  }
  ;
  SIGKILL2.value = new SIGKILL2();
  return SIGKILL2;
}();
var SIGSEGV = /* @__PURE__ */ function() {
  function SIGSEGV2() {
  }
  ;
  SIGSEGV2.value = new SIGSEGV2();
  return SIGSEGV2;
}();
var SIGPIPE = /* @__PURE__ */ function() {
  function SIGPIPE2() {
  }
  ;
  SIGPIPE2.value = new SIGPIPE2();
  return SIGPIPE2;
}();
var SIGALRM = /* @__PURE__ */ function() {
  function SIGALRM2() {
  }
  ;
  SIGALRM2.value = new SIGALRM2();
  return SIGALRM2;
}();
var SIGTERM = /* @__PURE__ */ function() {
  function SIGTERM2() {
  }
  ;
  SIGTERM2.value = new SIGTERM2();
  return SIGTERM2;
}();
var eqExitCode = {
  eq: function(x) {
    return function(y) {
      if (x instanceof Success && y instanceof Success) {
        return true;
      }
      ;
      if (x instanceof $$Error && y instanceof $$Error) {
        return true;
      }
      ;
      if (x instanceof MisuseOfShellBuiltins && y instanceof MisuseOfShellBuiltins) {
        return true;
      }
      ;
      if (x instanceof CLIUsageError && y instanceof CLIUsageError) {
        return true;
      }
      ;
      if (x instanceof DataFormatError && y instanceof DataFormatError) {
        return true;
      }
      ;
      if (x instanceof CannotOpenInput && y instanceof CannotOpenInput) {
        return true;
      }
      ;
      if (x instanceof AddresseeUnknown && y instanceof AddresseeUnknown) {
        return true;
      }
      ;
      if (x instanceof HostNameUnknown && y instanceof HostNameUnknown) {
        return true;
      }
      ;
      if (x instanceof ServiceUnavailable && y instanceof ServiceUnavailable) {
        return true;
      }
      ;
      if (x instanceof InternalSoftwareError && y instanceof InternalSoftwareError) {
        return true;
      }
      ;
      if (x instanceof SystemError && y instanceof SystemError) {
        return true;
      }
      ;
      if (x instanceof CriticalOSFileMissing && y instanceof CriticalOSFileMissing) {
        return true;
      }
      ;
      if (x instanceof CannotCreateOutputFile && y instanceof CannotCreateOutputFile) {
        return true;
      }
      ;
      if (x instanceof IOError && y instanceof IOError) {
        return true;
      }
      ;
      if (x instanceof TemporaryFailure && y instanceof TemporaryFailure) {
        return true;
      }
      ;
      if (x instanceof RemoteError && y instanceof RemoteError) {
        return true;
      }
      ;
      if (x instanceof PermissionDenied && y instanceof PermissionDenied) {
        return true;
      }
      ;
      if (x instanceof ConfigurationError && y instanceof ConfigurationError) {
        return true;
      }
      ;
      if (x instanceof CannotExecute && y instanceof CannotExecute) {
        return true;
      }
      ;
      if (x instanceof CommandNotFound && y instanceof CommandNotFound) {
        return true;
      }
      ;
      if (x instanceof InvalidExitArgument && y instanceof InvalidExitArgument) {
        return true;
      }
      ;
      if (x instanceof SIGHUP && y instanceof SIGHUP) {
        return true;
      }
      ;
      if (x instanceof SIGINT && y instanceof SIGINT) {
        return true;
      }
      ;
      if (x instanceof SIGQUIT && y instanceof SIGQUIT) {
        return true;
      }
      ;
      if (x instanceof SIGILL && y instanceof SIGILL) {
        return true;
      }
      ;
      if (x instanceof SIGABRT && y instanceof SIGABRT) {
        return true;
      }
      ;
      if (x instanceof SIGFPE && y instanceof SIGFPE) {
        return true;
      }
      ;
      if (x instanceof SIGKILL && y instanceof SIGKILL) {
        return true;
      }
      ;
      if (x instanceof SIGSEGV && y instanceof SIGSEGV) {
        return true;
      }
      ;
      if (x instanceof SIGPIPE && y instanceof SIGPIPE) {
        return true;
      }
      ;
      if (x instanceof SIGALRM && y instanceof SIGALRM) {
        return true;
      }
      ;
      if (x instanceof SIGTERM && y instanceof SIGTERM) {
        return true;
      }
      ;
      return false;
    };
  }
};
var ordExitCode = {
  compare: function(x) {
    return function(y) {
      if (x instanceof Success && y instanceof Success) {
        return EQ.value;
      }
      ;
      if (x instanceof Success) {
        return LT.value;
      }
      ;
      if (y instanceof Success) {
        return GT.value;
      }
      ;
      if (x instanceof $$Error && y instanceof $$Error) {
        return EQ.value;
      }
      ;
      if (x instanceof $$Error) {
        return LT.value;
      }
      ;
      if (y instanceof $$Error) {
        return GT.value;
      }
      ;
      if (x instanceof MisuseOfShellBuiltins && y instanceof MisuseOfShellBuiltins) {
        return EQ.value;
      }
      ;
      if (x instanceof MisuseOfShellBuiltins) {
        return LT.value;
      }
      ;
      if (y instanceof MisuseOfShellBuiltins) {
        return GT.value;
      }
      ;
      if (x instanceof CLIUsageError && y instanceof CLIUsageError) {
        return EQ.value;
      }
      ;
      if (x instanceof CLIUsageError) {
        return LT.value;
      }
      ;
      if (y instanceof CLIUsageError) {
        return GT.value;
      }
      ;
      if (x instanceof DataFormatError && y instanceof DataFormatError) {
        return EQ.value;
      }
      ;
      if (x instanceof DataFormatError) {
        return LT.value;
      }
      ;
      if (y instanceof DataFormatError) {
        return GT.value;
      }
      ;
      if (x instanceof CannotOpenInput && y instanceof CannotOpenInput) {
        return EQ.value;
      }
      ;
      if (x instanceof CannotOpenInput) {
        return LT.value;
      }
      ;
      if (y instanceof CannotOpenInput) {
        return GT.value;
      }
      ;
      if (x instanceof AddresseeUnknown && y instanceof AddresseeUnknown) {
        return EQ.value;
      }
      ;
      if (x instanceof AddresseeUnknown) {
        return LT.value;
      }
      ;
      if (y instanceof AddresseeUnknown) {
        return GT.value;
      }
      ;
      if (x instanceof HostNameUnknown && y instanceof HostNameUnknown) {
        return EQ.value;
      }
      ;
      if (x instanceof HostNameUnknown) {
        return LT.value;
      }
      ;
      if (y instanceof HostNameUnknown) {
        return GT.value;
      }
      ;
      if (x instanceof ServiceUnavailable && y instanceof ServiceUnavailable) {
        return EQ.value;
      }
      ;
      if (x instanceof ServiceUnavailable) {
        return LT.value;
      }
      ;
      if (y instanceof ServiceUnavailable) {
        return GT.value;
      }
      ;
      if (x instanceof InternalSoftwareError && y instanceof InternalSoftwareError) {
        return EQ.value;
      }
      ;
      if (x instanceof InternalSoftwareError) {
        return LT.value;
      }
      ;
      if (y instanceof InternalSoftwareError) {
        return GT.value;
      }
      ;
      if (x instanceof SystemError && y instanceof SystemError) {
        return EQ.value;
      }
      ;
      if (x instanceof SystemError) {
        return LT.value;
      }
      ;
      if (y instanceof SystemError) {
        return GT.value;
      }
      ;
      if (x instanceof CriticalOSFileMissing && y instanceof CriticalOSFileMissing) {
        return EQ.value;
      }
      ;
      if (x instanceof CriticalOSFileMissing) {
        return LT.value;
      }
      ;
      if (y instanceof CriticalOSFileMissing) {
        return GT.value;
      }
      ;
      if (x instanceof CannotCreateOutputFile && y instanceof CannotCreateOutputFile) {
        return EQ.value;
      }
      ;
      if (x instanceof CannotCreateOutputFile) {
        return LT.value;
      }
      ;
      if (y instanceof CannotCreateOutputFile) {
        return GT.value;
      }
      ;
      if (x instanceof IOError && y instanceof IOError) {
        return EQ.value;
      }
      ;
      if (x instanceof IOError) {
        return LT.value;
      }
      ;
      if (y instanceof IOError) {
        return GT.value;
      }
      ;
      if (x instanceof TemporaryFailure && y instanceof TemporaryFailure) {
        return EQ.value;
      }
      ;
      if (x instanceof TemporaryFailure) {
        return LT.value;
      }
      ;
      if (y instanceof TemporaryFailure) {
        return GT.value;
      }
      ;
      if (x instanceof RemoteError && y instanceof RemoteError) {
        return EQ.value;
      }
      ;
      if (x instanceof RemoteError) {
        return LT.value;
      }
      ;
      if (y instanceof RemoteError) {
        return GT.value;
      }
      ;
      if (x instanceof PermissionDenied && y instanceof PermissionDenied) {
        return EQ.value;
      }
      ;
      if (x instanceof PermissionDenied) {
        return LT.value;
      }
      ;
      if (y instanceof PermissionDenied) {
        return GT.value;
      }
      ;
      if (x instanceof ConfigurationError && y instanceof ConfigurationError) {
        return EQ.value;
      }
      ;
      if (x instanceof ConfigurationError) {
        return LT.value;
      }
      ;
      if (y instanceof ConfigurationError) {
        return GT.value;
      }
      ;
      if (x instanceof CannotExecute && y instanceof CannotExecute) {
        return EQ.value;
      }
      ;
      if (x instanceof CannotExecute) {
        return LT.value;
      }
      ;
      if (y instanceof CannotExecute) {
        return GT.value;
      }
      ;
      if (x instanceof CommandNotFound && y instanceof CommandNotFound) {
        return EQ.value;
      }
      ;
      if (x instanceof CommandNotFound) {
        return LT.value;
      }
      ;
      if (y instanceof CommandNotFound) {
        return GT.value;
      }
      ;
      if (x instanceof InvalidExitArgument && y instanceof InvalidExitArgument) {
        return EQ.value;
      }
      ;
      if (x instanceof InvalidExitArgument) {
        return LT.value;
      }
      ;
      if (y instanceof InvalidExitArgument) {
        return GT.value;
      }
      ;
      if (x instanceof SIGHUP && y instanceof SIGHUP) {
        return EQ.value;
      }
      ;
      if (x instanceof SIGHUP) {
        return LT.value;
      }
      ;
      if (y instanceof SIGHUP) {
        return GT.value;
      }
      ;
      if (x instanceof SIGINT && y instanceof SIGINT) {
        return EQ.value;
      }
      ;
      if (x instanceof SIGINT) {
        return LT.value;
      }
      ;
      if (y instanceof SIGINT) {
        return GT.value;
      }
      ;
      if (x instanceof SIGQUIT && y instanceof SIGQUIT) {
        return EQ.value;
      }
      ;
      if (x instanceof SIGQUIT) {
        return LT.value;
      }
      ;
      if (y instanceof SIGQUIT) {
        return GT.value;
      }
      ;
      if (x instanceof SIGILL && y instanceof SIGILL) {
        return EQ.value;
      }
      ;
      if (x instanceof SIGILL) {
        return LT.value;
      }
      ;
      if (y instanceof SIGILL) {
        return GT.value;
      }
      ;
      if (x instanceof SIGABRT && y instanceof SIGABRT) {
        return EQ.value;
      }
      ;
      if (x instanceof SIGABRT) {
        return LT.value;
      }
      ;
      if (y instanceof SIGABRT) {
        return GT.value;
      }
      ;
      if (x instanceof SIGFPE && y instanceof SIGFPE) {
        return EQ.value;
      }
      ;
      if (x instanceof SIGFPE) {
        return LT.value;
      }
      ;
      if (y instanceof SIGFPE) {
        return GT.value;
      }
      ;
      if (x instanceof SIGKILL && y instanceof SIGKILL) {
        return EQ.value;
      }
      ;
      if (x instanceof SIGKILL) {
        return LT.value;
      }
      ;
      if (y instanceof SIGKILL) {
        return GT.value;
      }
      ;
      if (x instanceof SIGSEGV && y instanceof SIGSEGV) {
        return EQ.value;
      }
      ;
      if (x instanceof SIGSEGV) {
        return LT.value;
      }
      ;
      if (y instanceof SIGSEGV) {
        return GT.value;
      }
      ;
      if (x instanceof SIGPIPE && y instanceof SIGPIPE) {
        return EQ.value;
      }
      ;
      if (x instanceof SIGPIPE) {
        return LT.value;
      }
      ;
      if (y instanceof SIGPIPE) {
        return GT.value;
      }
      ;
      if (x instanceof SIGALRM && y instanceof SIGALRM) {
        return EQ.value;
      }
      ;
      if (x instanceof SIGALRM) {
        return LT.value;
      }
      ;
      if (y instanceof SIGALRM) {
        return GT.value;
      }
      ;
      if (x instanceof SIGTERM && y instanceof SIGTERM) {
        return EQ.value;
      }
      ;
      throw new Error("Failed pattern match at ExitCodes (line 0, column 0 - line 0, column 0): " + [x.constructor.name, y.constructor.name]);
    };
  },
  Eq0: function() {
    return eqExitCode;
  }
};
var enumExitCode = {
  succ: function(v) {
    if (v instanceof Success) {
      return new Just($$Error.value);
    }
    ;
    if (v instanceof $$Error) {
      return new Just(MisuseOfShellBuiltins.value);
    }
    ;
    if (v instanceof MisuseOfShellBuiltins) {
      return new Just(CLIUsageError.value);
    }
    ;
    if (v instanceof CLIUsageError) {
      return new Just(DataFormatError.value);
    }
    ;
    if (v instanceof DataFormatError) {
      return new Just(CannotOpenInput.value);
    }
    ;
    if (v instanceof CannotOpenInput) {
      return new Just(AddresseeUnknown.value);
    }
    ;
    if (v instanceof AddresseeUnknown) {
      return new Just(HostNameUnknown.value);
    }
    ;
    if (v instanceof HostNameUnknown) {
      return new Just(ServiceUnavailable.value);
    }
    ;
    if (v instanceof ServiceUnavailable) {
      return new Just(InternalSoftwareError.value);
    }
    ;
    if (v instanceof InternalSoftwareError) {
      return new Just(SystemError.value);
    }
    ;
    if (v instanceof SystemError) {
      return new Just(CriticalOSFileMissing.value);
    }
    ;
    if (v instanceof CriticalOSFileMissing) {
      return new Just(CannotCreateOutputFile.value);
    }
    ;
    if (v instanceof CannotCreateOutputFile) {
      return new Just(IOError.value);
    }
    ;
    if (v instanceof IOError) {
      return new Just(TemporaryFailure.value);
    }
    ;
    if (v instanceof TemporaryFailure) {
      return new Just(RemoteError.value);
    }
    ;
    if (v instanceof RemoteError) {
      return new Just(PermissionDenied.value);
    }
    ;
    if (v instanceof PermissionDenied) {
      return new Just(ConfigurationError.value);
    }
    ;
    if (v instanceof ConfigurationError) {
      return new Just(CannotExecute.value);
    }
    ;
    if (v instanceof CannotExecute) {
      return new Just(CommandNotFound.value);
    }
    ;
    if (v instanceof CommandNotFound) {
      return new Just(InvalidExitArgument.value);
    }
    ;
    if (v instanceof InvalidExitArgument) {
      return new Just(SIGHUP.value);
    }
    ;
    if (v instanceof SIGHUP) {
      return new Just(SIGINT.value);
    }
    ;
    if (v instanceof SIGINT) {
      return new Just(SIGQUIT.value);
    }
    ;
    if (v instanceof SIGQUIT) {
      return new Just(SIGILL.value);
    }
    ;
    if (v instanceof SIGILL) {
      return new Just(SIGABRT.value);
    }
    ;
    if (v instanceof SIGABRT) {
      return new Just(SIGFPE.value);
    }
    ;
    if (v instanceof SIGFPE) {
      return new Just(SIGKILL.value);
    }
    ;
    if (v instanceof SIGKILL) {
      return new Just(SIGSEGV.value);
    }
    ;
    if (v instanceof SIGSEGV) {
      return new Just(SIGPIPE.value);
    }
    ;
    if (v instanceof SIGPIPE) {
      return new Just(SIGALRM.value);
    }
    ;
    if (v instanceof SIGALRM) {
      return new Just(SIGTERM.value);
    }
    ;
    if (v instanceof SIGTERM) {
      return Nothing.value;
    }
    ;
    throw new Error("Failed pattern match at ExitCodes (line 87, column 1 - line 151, column 30): " + [v.constructor.name]);
  },
  pred: function(v) {
    if (v instanceof Success) {
      return Nothing.value;
    }
    ;
    if (v instanceof $$Error) {
      return new Just(Success.value);
    }
    ;
    if (v instanceof MisuseOfShellBuiltins) {
      return new Just($$Error.value);
    }
    ;
    if (v instanceof CLIUsageError) {
      return new Just(MisuseOfShellBuiltins.value);
    }
    ;
    if (v instanceof DataFormatError) {
      return new Just(CLIUsageError.value);
    }
    ;
    if (v instanceof CannotOpenInput) {
      return new Just(DataFormatError.value);
    }
    ;
    if (v instanceof AddresseeUnknown) {
      return new Just(CannotOpenInput.value);
    }
    ;
    if (v instanceof HostNameUnknown) {
      return new Just(AddresseeUnknown.value);
    }
    ;
    if (v instanceof ServiceUnavailable) {
      return new Just(HostNameUnknown.value);
    }
    ;
    if (v instanceof InternalSoftwareError) {
      return new Just(ServiceUnavailable.value);
    }
    ;
    if (v instanceof SystemError) {
      return new Just(InternalSoftwareError.value);
    }
    ;
    if (v instanceof CriticalOSFileMissing) {
      return new Just(SystemError.value);
    }
    ;
    if (v instanceof CannotCreateOutputFile) {
      return new Just(CriticalOSFileMissing.value);
    }
    ;
    if (v instanceof IOError) {
      return new Just(CannotCreateOutputFile.value);
    }
    ;
    if (v instanceof TemporaryFailure) {
      return new Just(IOError.value);
    }
    ;
    if (v instanceof RemoteError) {
      return new Just(TemporaryFailure.value);
    }
    ;
    if (v instanceof PermissionDenied) {
      return new Just(RemoteError.value);
    }
    ;
    if (v instanceof ConfigurationError) {
      return new Just(PermissionDenied.value);
    }
    ;
    if (v instanceof CannotExecute) {
      return new Just(ConfigurationError.value);
    }
    ;
    if (v instanceof CommandNotFound) {
      return new Just(CannotExecute.value);
    }
    ;
    if (v instanceof InvalidExitArgument) {
      return new Just(CommandNotFound.value);
    }
    ;
    if (v instanceof SIGHUP) {
      return new Just(InvalidExitArgument.value);
    }
    ;
    if (v instanceof SIGINT) {
      return new Just(SIGHUP.value);
    }
    ;
    if (v instanceof SIGQUIT) {
      return new Just(SIGINT.value);
    }
    ;
    if (v instanceof SIGILL) {
      return new Just(SIGQUIT.value);
    }
    ;
    if (v instanceof SIGABRT) {
      return new Just(SIGILL.value);
    }
    ;
    if (v instanceof SIGFPE) {
      return new Just(SIGABRT.value);
    }
    ;
    if (v instanceof SIGKILL) {
      return new Just(SIGFPE.value);
    }
    ;
    if (v instanceof SIGSEGV) {
      return new Just(SIGKILL.value);
    }
    ;
    if (v instanceof SIGPIPE) {
      return new Just(SIGSEGV.value);
    }
    ;
    if (v instanceof SIGALRM) {
      return new Just(SIGPIPE.value);
    }
    ;
    if (v instanceof SIGTERM) {
      return new Just(SIGALRM.value);
    }
    ;
    throw new Error("Failed pattern match at ExitCodes (line 87, column 1 - line 151, column 30): " + [v.constructor.name]);
  },
  Ord0: function() {
    return ordExitCode;
  }
};
var boundedExitCode = /* @__PURE__ */ function() {
  return {
    bottom: Success.value,
    top: SIGTERM.value,
    Ord0: function() {
      return ordExitCode;
    }
  };
}();
var boundedEnumExitCode = {
  cardinality: 32,
  toEnum: function(v) {
    if (v === 0) {
      return new Just(Success.value);
    }
    ;
    if (v === 1) {
      return new Just($$Error.value);
    }
    ;
    if (v === 2) {
      return new Just(MisuseOfShellBuiltins.value);
    }
    ;
    if (v === 64) {
      return new Just(CLIUsageError.value);
    }
    ;
    if (v === 65) {
      return new Just(DataFormatError.value);
    }
    ;
    if (v === 66) {
      return new Just(CannotOpenInput.value);
    }
    ;
    if (v === 67) {
      return new Just(AddresseeUnknown.value);
    }
    ;
    if (v === 68) {
      return new Just(HostNameUnknown.value);
    }
    ;
    if (v === 69) {
      return new Just(ServiceUnavailable.value);
    }
    ;
    if (v === 70) {
      return new Just(InternalSoftwareError.value);
    }
    ;
    if (v === 71) {
      return new Just(SystemError.value);
    }
    ;
    if (v === 72) {
      return new Just(CriticalOSFileMissing.value);
    }
    ;
    if (v === 73) {
      return new Just(CannotCreateOutputFile.value);
    }
    ;
    if (v === 74) {
      return new Just(IOError.value);
    }
    ;
    if (v === 75) {
      return new Just(TemporaryFailure.value);
    }
    ;
    if (v === 76) {
      return new Just(RemoteError.value);
    }
    ;
    if (v === 77) {
      return new Just(PermissionDenied.value);
    }
    ;
    if (v === 78) {
      return new Just(ConfigurationError.value);
    }
    ;
    if (v === 126) {
      return new Just(CannotExecute.value);
    }
    ;
    if (v === 127) {
      return new Just(CommandNotFound.value);
    }
    ;
    if (v === 128) {
      return new Just(InvalidExitArgument.value);
    }
    ;
    if (v === 129) {
      return new Just(SIGHUP.value);
    }
    ;
    if (v === 130) {
      return new Just(SIGINT.value);
    }
    ;
    if (v === 131) {
      return new Just(SIGQUIT.value);
    }
    ;
    if (v === 132) {
      return new Just(SIGILL.value);
    }
    ;
    if (v === 134) {
      return new Just(SIGABRT.value);
    }
    ;
    if (v === 136) {
      return new Just(SIGFPE.value);
    }
    ;
    if (v === 137) {
      return new Just(SIGKILL.value);
    }
    ;
    if (v === 139) {
      return new Just(SIGSEGV.value);
    }
    ;
    if (v === 141) {
      return new Just(SIGPIPE.value);
    }
    ;
    if (v === 142) {
      return new Just(SIGALRM.value);
    }
    ;
    if (v === 143) {
      return new Just(SIGTERM.value);
    }
    ;
    return Nothing.value;
  },
  fromEnum: function(v) {
    if (v instanceof Success) {
      return 0;
    }
    ;
    if (v instanceof $$Error) {
      return 1;
    }
    ;
    if (v instanceof MisuseOfShellBuiltins) {
      return 2;
    }
    ;
    if (v instanceof CLIUsageError) {
      return 64;
    }
    ;
    if (v instanceof DataFormatError) {
      return 65;
    }
    ;
    if (v instanceof CannotOpenInput) {
      return 66;
    }
    ;
    if (v instanceof AddresseeUnknown) {
      return 67;
    }
    ;
    if (v instanceof HostNameUnknown) {
      return 68;
    }
    ;
    if (v instanceof ServiceUnavailable) {
      return 69;
    }
    ;
    if (v instanceof InternalSoftwareError) {
      return 70;
    }
    ;
    if (v instanceof SystemError) {
      return 71;
    }
    ;
    if (v instanceof CriticalOSFileMissing) {
      return 72;
    }
    ;
    if (v instanceof CannotCreateOutputFile) {
      return 73;
    }
    ;
    if (v instanceof IOError) {
      return 74;
    }
    ;
    if (v instanceof TemporaryFailure) {
      return 75;
    }
    ;
    if (v instanceof RemoteError) {
      return 76;
    }
    ;
    if (v instanceof PermissionDenied) {
      return 77;
    }
    ;
    if (v instanceof ConfigurationError) {
      return 78;
    }
    ;
    if (v instanceof CannotExecute) {
      return 126;
    }
    ;
    if (v instanceof CommandNotFound) {
      return 127;
    }
    ;
    if (v instanceof InvalidExitArgument) {
      return 128;
    }
    ;
    if (v instanceof SIGHUP) {
      return 128 + 1 | 0;
    }
    ;
    if (v instanceof SIGINT) {
      return 128 + 2 | 0;
    }
    ;
    if (v instanceof SIGQUIT) {
      return 128 + 3 | 0;
    }
    ;
    if (v instanceof SIGILL) {
      return 128 + 4 | 0;
    }
    ;
    if (v instanceof SIGABRT) {
      return 128 + 6 | 0;
    }
    ;
    if (v instanceof SIGFPE) {
      return 128 + 8 | 0;
    }
    ;
    if (v instanceof SIGKILL) {
      return 128 + 9 | 0;
    }
    ;
    if (v instanceof SIGSEGV) {
      return 128 + 11 | 0;
    }
    ;
    if (v instanceof SIGPIPE) {
      return 128 + 13 | 0;
    }
    ;
    if (v instanceof SIGALRM) {
      return 128 + 14 | 0;
    }
    ;
    if (v instanceof SIGTERM) {
      return 128 + 15 | 0;
    }
    ;
    throw new Error("Failed pattern match at ExitCodes (line 153, column 1 - line 219, column 30): " + [v.constructor.name]);
  },
  Bounded0: function() {
    return boundedExitCode;
  },
  Enum1: function() {
    return enumExitCode;
  }
};

// output/Options.Applicative.Internal.Utils/index.js
var eq6 = /* @__PURE__ */ eq(/* @__PURE__ */ eqMaybe(eqInt));
var whitespaceRegex = /* @__PURE__ */ function() {
  var v = regex("\\s+")(noFlags);
  if (v instanceof Left) {
    return unsafeCrashWith("whitespaceRegex: `\\s+` seems to be invlaid, err: " + v.value0);
  }
  ;
  if (v instanceof Right) {
    return v.value0;
  }
  ;
  throw new Error("Failed pattern match at Options.Applicative.Internal.Utils (line 39, column 19 - line 41, column 15): " + [v.constructor.name]);
}();
var words2 = function(v) {
  if (v === "") {
    return [];
  }
  ;
  return split2(whitespaceRegex)(v);
};
var unWords = function(dictFoldable) {
  return intercalate(dictFoldable)(monoidString)(" ");
};
var unLines = function(dictFoldable) {
  return intercalate(dictFoldable)(monoidString)("\n");
};
var startsWith = function(p) {
  return function(s) {
    return eq6(indexOf2(p)(s))(new Just(0));
  };
};
var lines2 = function(v) {
  if (v === "") {
    return [];
  }
  ;
  return split("\n")(v);
};
var apApplyFlipped = function(dictApply) {
  return lift2(dictApply)(applyFlipped);
};

// output/Data.CatQueue/index.js
var CatQueue = /* @__PURE__ */ function() {
  function CatQueue2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  CatQueue2.create = function(value0) {
    return function(value12) {
      return new CatQueue2(value0, value12);
    };
  };
  return CatQueue2;
}();
var uncons5 = function($copy_v) {
  var $tco_done = false;
  var $tco_result;
  function $tco_loop(v) {
    if (v.value0 instanceof Nil && v.value1 instanceof Nil) {
      $tco_done = true;
      return Nothing.value;
    }
    ;
    if (v.value0 instanceof Nil) {
      $copy_v = new CatQueue(reverse2(v.value1), Nil.value);
      return;
    }
    ;
    if (v.value0 instanceof Cons) {
      $tco_done = true;
      return new Just(new Tuple(v.value0.value0, new CatQueue(v.value0.value1, v.value1)));
    }
    ;
    throw new Error("Failed pattern match at Data.CatQueue (line 82, column 1 - line 82, column 63): " + [v.constructor.name]);
  }
  ;
  while (!$tco_done) {
    $tco_result = $tco_loop($copy_v);
  }
  ;
  return $tco_result;
};
var snoc4 = function(v) {
  return function(a) {
    return new CatQueue(v.value0, new Cons(a, v.value1));
  };
};
var $$null5 = function(v) {
  if (v.value0 instanceof Nil && v.value1 instanceof Nil) {
    return true;
  }
  ;
  return false;
};
var empty5 = /* @__PURE__ */ function() {
  return new CatQueue(Nil.value, Nil.value);
}();

// output/Data.CatList/index.js
var CatNil = /* @__PURE__ */ function() {
  function CatNil2() {
  }
  ;
  CatNil2.value = new CatNil2();
  return CatNil2;
}();
var CatCons = /* @__PURE__ */ function() {
  function CatCons2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  CatCons2.create = function(value0) {
    return function(value12) {
      return new CatCons2(value0, value12);
    };
  };
  return CatCons2;
}();
var link = function(v) {
  return function(v1) {
    if (v instanceof CatNil) {
      return v1;
    }
    ;
    if (v1 instanceof CatNil) {
      return v;
    }
    ;
    if (v instanceof CatCons) {
      return new CatCons(v.value0, snoc4(v.value1)(v1));
    }
    ;
    throw new Error("Failed pattern match at Data.CatList (line 108, column 1 - line 108, column 54): " + [v.constructor.name, v1.constructor.name]);
  };
};
var foldr6 = function(k) {
  return function(b) {
    return function(q) {
      var foldl16 = function($copy_v) {
        return function($copy_v1) {
          return function($copy_v2) {
            var $tco_var_v = $copy_v;
            var $tco_var_v1 = $copy_v1;
            var $tco_done = false;
            var $tco_result;
            function $tco_loop(v, v1, v2) {
              if (v2 instanceof Nil) {
                $tco_done = true;
                return v1;
              }
              ;
              if (v2 instanceof Cons) {
                $tco_var_v = v;
                $tco_var_v1 = v(v1)(v2.value0);
                $copy_v2 = v2.value1;
                return;
              }
              ;
              throw new Error("Failed pattern match at Data.CatList (line 124, column 3 - line 124, column 59): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
            }
            ;
            while (!$tco_done) {
              $tco_result = $tco_loop($tco_var_v, $tco_var_v1, $copy_v2);
            }
            ;
            return $tco_result;
          };
        };
      };
      var go = function($copy_xs) {
        return function($copy_ys) {
          var $tco_var_xs = $copy_xs;
          var $tco_done1 = false;
          var $tco_result;
          function $tco_loop(xs, ys) {
            var v = uncons5(xs);
            if (v instanceof Nothing) {
              $tco_done1 = true;
              return foldl16(function(x) {
                return function(i) {
                  return i(x);
                };
              })(b)(ys);
            }
            ;
            if (v instanceof Just) {
              $tco_var_xs = v.value0.value1;
              $copy_ys = new Cons(k(v.value0.value0), ys);
              return;
            }
            ;
            throw new Error("Failed pattern match at Data.CatList (line 120, column 14 - line 122, column 67): " + [v.constructor.name]);
          }
          ;
          while (!$tco_done1) {
            $tco_result = $tco_loop($tco_var_xs, $copy_ys);
          }
          ;
          return $tco_result;
        };
      };
      return go(q)(Nil.value);
    };
  };
};
var uncons6 = function(v) {
  if (v instanceof CatNil) {
    return Nothing.value;
  }
  ;
  if (v instanceof CatCons) {
    return new Just(new Tuple(v.value0, function() {
      var $66 = $$null5(v.value1);
      if ($66) {
        return CatNil.value;
      }
      ;
      return foldr6(link)(CatNil.value)(v.value1);
    }()));
  }
  ;
  throw new Error("Failed pattern match at Data.CatList (line 99, column 1 - line 99, column 61): " + [v.constructor.name]);
};
var empty6 = /* @__PURE__ */ function() {
  return CatNil.value;
}();
var append4 = link;
var semigroupCatList = {
  append: append4
};
var snoc5 = function(cat) {
  return function(a) {
    return append4(cat)(new CatCons(a, empty5));
  };
};

// output/Control.Monad.Free/index.js
var $runtime_lazy7 = function(name4, moduleName2, init4) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2)
      return val;
    if (state2 === 1)
      throw new ReferenceError(name4 + " was needed before it finished initializing (module " + moduleName2 + ", line " + lineNumber + ")", moduleName2, lineNumber);
    state2 = 1;
    val = init4();
    state2 = 2;
    return val;
  };
};
var append5 = /* @__PURE__ */ append(semigroupCatList);
var Free = /* @__PURE__ */ function() {
  function Free2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Free2.create = function(value0) {
    return function(value12) {
      return new Free2(value0, value12);
    };
  };
  return Free2;
}();
var Return = /* @__PURE__ */ function() {
  function Return2(value0) {
    this.value0 = value0;
  }
  ;
  Return2.create = function(value0) {
    return new Return2(value0);
  };
  return Return2;
}();
var Bind = /* @__PURE__ */ function() {
  function Bind2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Bind2.create = function(value0) {
    return function(value12) {
      return new Bind2(value0, value12);
    };
  };
  return Bind2;
}();
var toView = function($copy_v) {
  var $tco_done = false;
  var $tco_result;
  function $tco_loop(v) {
    var runExpF = function(v22) {
      return v22;
    };
    var concatF = function(v22) {
      return function(r) {
        return new Free(v22.value0, append5(v22.value1)(r));
      };
    };
    if (v.value0 instanceof Return) {
      var v2 = uncons6(v.value1);
      if (v2 instanceof Nothing) {
        $tco_done = true;
        return new Return(v.value0.value0);
      }
      ;
      if (v2 instanceof Just) {
        $copy_v = concatF(runExpF(v2.value0.value0)(v.value0.value0))(v2.value0.value1);
        return;
      }
      ;
      throw new Error("Failed pattern match at Control.Monad.Free (line 227, column 7 - line 231, column 64): " + [v2.constructor.name]);
    }
    ;
    if (v.value0 instanceof Bind) {
      $tco_done = true;
      return new Bind(v.value0.value0, function(a) {
        return concatF(v.value0.value1(a))(v.value1);
      });
    }
    ;
    throw new Error("Failed pattern match at Control.Monad.Free (line 225, column 3 - line 233, column 56): " + [v.value0.constructor.name]);
  }
  ;
  while (!$tco_done) {
    $tco_result = $tco_loop($copy_v);
  }
  ;
  return $tco_result;
};
var resume$prime = function(k) {
  return function(j) {
    return function(f) {
      var v = toView(f);
      if (v instanceof Return) {
        return j(v.value0);
      }
      ;
      if (v instanceof Bind) {
        return k(v.value0)(v.value1);
      }
      ;
      throw new Error("Failed pattern match at Control.Monad.Free (line 213, column 17 - line 215, column 20): " + [v.constructor.name]);
    };
  };
};
var fromView = function(f) {
  return new Free(f, empty6);
};
var freeMonad = {
  Applicative0: function() {
    return freeApplicative;
  },
  Bind1: function() {
    return freeBind;
  }
};
var freeFunctor = {
  map: function(k) {
    return function(f) {
      return bindFlipped(freeBind)(function() {
        var $189 = pure(freeApplicative);
        return function($190) {
          return $189(k($190));
        };
      }())(f);
    };
  }
};
var freeBind = {
  bind: function(v) {
    return function(k) {
      return new Free(v.value0, snoc5(v.value1)(k));
    };
  },
  Apply0: function() {
    return $lazy_freeApply(0);
  }
};
var freeApplicative = {
  pure: function($191) {
    return fromView(Return.create($191));
  },
  Apply0: function() {
    return $lazy_freeApply(0);
  }
};
var $lazy_freeApply = /* @__PURE__ */ $runtime_lazy7("freeApply", "Control.Monad.Free", function() {
  return {
    apply: ap(freeMonad),
    Functor0: function() {
      return freeFunctor;
    }
  };
});
var bind4 = /* @__PURE__ */ bind(freeBind);
var pure7 = /* @__PURE__ */ pure(freeApplicative);
var freeMonadRec = {
  tailRecM: function(k) {
    return function(a) {
      return bind4(k(a))(function(v) {
        if (v instanceof Loop) {
          return tailRecM(freeMonadRec)(k)(v.value0);
        }
        ;
        if (v instanceof Done) {
          return pure7(v.value0);
        }
        ;
        throw new Error("Failed pattern match at Control.Monad.Free (line 86, column 26 - line 88, column 21): " + [v.constructor.name]);
      });
    };
  },
  Monad0: function() {
    return freeMonad;
  }
};
var liftF = function(f) {
  return fromView(new Bind(f, function($192) {
    return pure7($192);
  }));
};

// output/Data.Exists/index.js
var runExists = unsafeCoerce2;
var mkExists = unsafeCoerce2;

// output/Text.PrettyPrint.Leijen/index.js
var max4 = /* @__PURE__ */ max(ordInt);
var min4 = /* @__PURE__ */ min(ordInt);
var foldr7 = /* @__PURE__ */ foldr(foldableArray);
var SFail = /* @__PURE__ */ function() {
  function SFail2() {
  }
  ;
  SFail2.value = new SFail2();
  return SFail2;
}();
var SEmpty = /* @__PURE__ */ function() {
  function SEmpty2() {
  }
  ;
  SEmpty2.value = new SEmpty2();
  return SEmpty2;
}();
var SChar = /* @__PURE__ */ function() {
  function SChar2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  SChar2.create = function(value0) {
    return function(value12) {
      return new SChar2(value0, value12);
    };
  };
  return SChar2;
}();
var SText = /* @__PURE__ */ function() {
  function SText2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  SText2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new SText2(value0, value12, value22);
      };
    };
  };
  return SText2;
}();
var SLine = /* @__PURE__ */ function() {
  function SLine2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  SLine2.create = function(value0) {
    return function(value12) {
      return new SLine2(value0, value12);
    };
  };
  return SLine2;
}();
var SFail$prime = /* @__PURE__ */ function() {
  function SFail$prime2() {
  }
  ;
  SFail$prime2.value = new SFail$prime2();
  return SFail$prime2;
}();
var SEmpty$prime = /* @__PURE__ */ function() {
  function SEmpty$prime2() {
  }
  ;
  SEmpty$prime2.value = new SEmpty$prime2();
  return SEmpty$prime2;
}();
var SChar$prime = /* @__PURE__ */ function() {
  function SChar$prime2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  SChar$prime2.create = function(value0) {
    return function(value12) {
      return new SChar$prime2(value0, value12);
    };
  };
  return SChar$prime2;
}();
var SText$prime = /* @__PURE__ */ function() {
  function SText$prime2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  SText$prime2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new SText$prime2(value0, value12, value22);
      };
    };
  };
  return SText$prime2;
}();
var SLine$prime = /* @__PURE__ */ function() {
  function SLine$prime2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  SLine$prime2.create = function(value0) {
    return function(value12) {
      return new SLine$prime2(value0, value12);
    };
  };
  return SLine$prime2;
}();
var Fail = /* @__PURE__ */ function() {
  function Fail3() {
  }
  ;
  Fail3.value = new Fail3();
  return Fail3;
}();
var Empty2 = /* @__PURE__ */ function() {
  function Empty3() {
  }
  ;
  Empty3.value = new Empty3();
  return Empty3;
}();
var Char = /* @__PURE__ */ function() {
  function Char2(value0) {
    this.value0 = value0;
  }
  ;
  Char2.create = function(value0) {
    return new Char2(value0);
  };
  return Char2;
}();
var Text2 = /* @__PURE__ */ function() {
  function Text3(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Text3.create = function(value0) {
    return function(value12) {
      return new Text3(value0, value12);
    };
  };
  return Text3;
}();
var Line = /* @__PURE__ */ function() {
  function Line3() {
  }
  ;
  Line3.value = new Line3();
  return Line3;
}();
var FlatAlt = /* @__PURE__ */ function() {
  function FlatAlt2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  FlatAlt2.create = function(value0) {
    return function(value12) {
      return new FlatAlt2(value0, value12);
    };
  };
  return FlatAlt2;
}();
var Cat = /* @__PURE__ */ function() {
  function Cat2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Cat2.create = function(value0) {
    return function(value12) {
      return new Cat2(value0, value12);
    };
  };
  return Cat2;
}();
var Nest = /* @__PURE__ */ function() {
  function Nest2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Nest2.create = function(value0) {
    return function(value12) {
      return new Nest2(value0, value12);
    };
  };
  return Nest2;
}();
var Union = /* @__PURE__ */ function() {
  function Union2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Union2.create = function(value0) {
    return function(value12) {
      return new Union2(value0, value12);
    };
  };
  return Union2;
}();
var Column = /* @__PURE__ */ function() {
  function Column2(value0) {
    this.value0 = value0;
  }
  ;
  Column2.create = function(value0) {
    return new Column2(value0);
  };
  return Column2;
}();
var Columns = /* @__PURE__ */ function() {
  function Columns2(value0) {
    this.value0 = value0;
  }
  ;
  Columns2.create = function(value0) {
    return new Columns2(value0);
  };
  return Columns2;
}();
var Nesting = /* @__PURE__ */ function() {
  function Nesting2(value0) {
    this.value0 = value0;
  }
  ;
  Nesting2.create = function(value0) {
    return new Nesting2(value0);
  };
  return Nesting2;
}();
var Nil3 = /* @__PURE__ */ function() {
  function Nil4() {
  }
  ;
  Nil4.value = new Nil4();
  return Nil4;
}();
var Cons3 = /* @__PURE__ */ function() {
  function Cons4(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  Cons4.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new Cons4(value0, value12, value22);
      };
    };
  };
  return Cons4;
}();
var text2 = function(v) {
  if (v === "") {
    return Empty2.value;
  }
  ;
  return new Text2(length4(v), v);
};
var spaces = function(n) {
  if (n <= 0) {
    return "";
  }
  ;
  if (otherwise) {
    return fromCharArray(replicate(n)(" "));
  }
  ;
  throw new Error("Failed pattern match at Text.PrettyPrint.Leijen (line 908, column 1 - line 908, column 24): " + [n.constructor.name]);
};
var space2 = /* @__PURE__ */ function() {
  return new Char(" ");
}();
var rparen = /* @__PURE__ */ function() {
  return new Char(")");
}();
var rbracket = /* @__PURE__ */ function() {
  return new Char("]");
}();
var nesting = function(f) {
  return new Nesting(f);
};
var nest = function(i) {
  return function(x) {
    return new Nest(i, x);
  };
};
var lparen = /* @__PURE__ */ function() {
  return new Char("(");
}();
var line = /* @__PURE__ */ function() {
  return new FlatAlt(Line.value, space2);
}();
var lbracket = /* @__PURE__ */ function() {
  return new Char("[");
}();
var indentation = function(n) {
  return spaces(n);
};
var forceSimpleDoc = function(v) {
  if (v instanceof SFail$prime) {
    return SFail.value;
  }
  ;
  if (v instanceof SEmpty$prime) {
    return SEmpty.value;
  }
  ;
  if (v instanceof SChar$prime) {
    return new SChar(v.value0, forceSimpleDoc(force(v.value1)));
  }
  ;
  if (v instanceof SText$prime) {
    return new SText(v.value0, v.value1, forceSimpleDoc(force(v.value2)));
  }
  ;
  if (v instanceof SLine$prime) {
    return new SLine(v.value0, forceSimpleDoc(force(v.value1)));
  }
  ;
  throw new Error("Failed pattern match at Text.PrettyPrint.Leijen (line 600, column 18 - line 605, column 51): " + [v.constructor.name]);
};
var renderFits = function(fits) {
  return function(rfrac) {
    return function(w) {
      return function(headNode) {
        var r = max4(0)(min4(w)(round2(toNumber2(w) * rfrac)));
        var nicest$prime = function(n) {
          return function(k) {
            return function(i) {
              return function(ds) {
                return function(x) {
                  return function(y) {
                    var x$prime = best(n)(k)(new Cons3(i, x, ds));
                    var width$prime = min4(w - k | 0)((r - k | 0) + n | 0);
                    var $221 = fits(w)(min4(n)(k))(width$prime)(x$prime);
                    if ($221) {
                      return x$prime;
                    }
                    ;
                    var y$prime = best(n)(k)(new Cons3(i, y, ds));
                    return y$prime;
                  };
                };
              };
            };
          };
        };
        var best = function(v) {
          return function(v1) {
            return function(v2) {
              if (v2 instanceof Nil3) {
                return SEmpty$prime.value;
              }
              ;
              if (v2 instanceof Cons3) {
                if (v2.value1 instanceof Fail) {
                  return SFail$prime.value;
                }
                ;
                if (v2.value1 instanceof Empty2) {
                  return best(v)(v1)(v2.value2);
                }
                ;
                if (v2.value1 instanceof Char) {
                  var k$prime = v1 + 1 | 0;
                  return new SChar$prime(v2.value1.value0, defer2(function(v3) {
                    return best(v)(k$prime)(v2.value2);
                  }));
                }
                ;
                if (v2.value1 instanceof Text2) {
                  var k$prime = v1 + v2.value1.value0 | 0;
                  return new SText$prime(v2.value1.value0, v2.value1.value1, defer2(function(v3) {
                    return best(v)(k$prime)(v2.value2);
                  }));
                }
                ;
                if (v2.value1 instanceof Line) {
                  return new SLine$prime(v2.value0, defer2(function(v3) {
                    return best(v2.value0)(v2.value0)(v2.value2);
                  }));
                }
                ;
                if (v2.value1 instanceof FlatAlt) {
                  return best(v)(v1)(new Cons3(v2.value0, v2.value1.value0, v2.value2));
                }
                ;
                if (v2.value1 instanceof Cat) {
                  return best(v)(v1)(new Cons3(v2.value0, v2.value1.value0, new Cons3(v2.value0, v2.value1.value1, v2.value2)));
                }
                ;
                if (v2.value1 instanceof Nest) {
                  var i$prime = v2.value0 + v2.value1.value0 | 0;
                  return best(v)(v1)(new Cons3(i$prime, v2.value1.value1, v2.value2));
                }
                ;
                if (v2.value1 instanceof Union) {
                  return nicest$prime(v)(v1)(v2.value0)(v2.value2)(v2.value1.value0)(v2.value1.value1);
                }
                ;
                if (v2.value1 instanceof Column) {
                  return best(v)(v1)(new Cons3(v2.value0, v2.value1.value0(v1), v2.value2));
                }
                ;
                if (v2.value1 instanceof Columns) {
                  return best(v)(v1)(new Cons3(v2.value0, v2.value1.value0(new Just(w)), v2.value2));
                }
                ;
                if (v2.value1 instanceof Nesting) {
                  return best(v)(v1)(new Cons3(v2.value0, v2.value1.value0(v2.value0), v2.value2));
                }
                ;
                throw new Error("Failed pattern match at Text.PrettyPrint.Leijen (line 788, column 11 - line 802, column 56): " + [v2.value1.constructor.name]);
              }
              ;
              throw new Error("Failed pattern match at Text.PrettyPrint.Leijen (line 785, column 7 - line 785, column 50): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
            };
          };
        };
        return forceSimpleDoc(best(0)(0)(new Cons3(0, headNode, Nil3.value)));
      };
    };
  };
};
var foldr13 = function(dictMonoid) {
  var mempty27 = mempty(dictMonoid);
  return function(f) {
    return function($297) {
      return function(v) {
        if (v instanceof Nothing) {
          return mempty27;
        }
        ;
        if (v instanceof Just) {
          return foldr7(f)(v.value0.last)(v.value0.init);
        }
        ;
        throw new Error("Failed pattern match at Text.PrettyPrint.Leijen (line 122, column 29 - line 124, column 43): " + [v.constructor.name]);
      }(unsnoc($297));
    };
  };
};
var flatten = function(v) {
  if (v instanceof FlatAlt) {
    return v.value1;
  }
  ;
  if (v instanceof Cat) {
    return new Cat(flatten(v.value0), flatten(v.value1));
  }
  ;
  if (v instanceof Nest) {
    return new Nest(v.value0, flatten(v.value1));
  }
  ;
  if (v instanceof Line) {
    return Fail.value;
  }
  ;
  if (v instanceof Union) {
    return flatten(v.value0);
  }
  ;
  if (v instanceof Column) {
    return new Column(function($298) {
      return flatten(v.value0($298));
    });
  }
  ;
  if (v instanceof Columns) {
    return new Columns(function($299) {
      return flatten(v.value0($299));
    });
  }
  ;
  if (v instanceof Nesting) {
    return new Nesting(function($300) {
      return flatten(v.value0($300));
    });
  }
  ;
  return v;
};
var group3 = function(x) {
  return new Union(flatten(x), x);
};
var softline = /* @__PURE__ */ group3(line);
var fits1 = function($copy_v) {
  return function($copy_v1) {
    return function($copy_v2) {
      return function($copy_v3) {
        var $tco_var_v = $copy_v;
        var $tco_var_v1 = $copy_v1;
        var $tco_var_v2 = $copy_v2;
        var $tco_done = false;
        var $tco_result;
        function $tco_loop(v, v1, v2, v3) {
          if (v2 < 0) {
            $tco_done = true;
            return false;
          }
          ;
          if (v3 instanceof SFail$prime) {
            $tco_done = true;
            return false;
          }
          ;
          if (v3 instanceof SEmpty$prime) {
            $tco_done = true;
            return true;
          }
          ;
          if (v3 instanceof SChar$prime) {
            $tco_var_v = v;
            $tco_var_v1 = v1;
            $tco_var_v2 = v2 - 1 | 0;
            $copy_v3 = force(v3.value1);
            return;
          }
          ;
          if (v3 instanceof SText$prime) {
            $tco_var_v = v;
            $tco_var_v1 = v1;
            $tco_var_v2 = v2 - v3.value0 | 0;
            $copy_v3 = force(v3.value2);
            return;
          }
          ;
          if (v3 instanceof SLine$prime) {
            $tco_done = true;
            return true;
          }
          ;
          throw new Error("Failed pattern match at Text.PrettyPrint.Leijen (line 819, column 1 - line 819, column 55): " + [v.constructor.name, v1.constructor.name, v2.constructor.name, v3.constructor.name]);
        }
        ;
        while (!$tco_done) {
          $tco_result = $tco_loop($tco_var_v, $tco_var_v1, $tco_var_v2, $copy_v3);
        }
        ;
        return $tco_result;
      };
    };
  };
};
var renderPretty = /* @__PURE__ */ renderFits(fits1);
var empty7 = /* @__PURE__ */ function() {
  return Empty2.value;
}();
var linebreak = /* @__PURE__ */ function() {
  return new FlatAlt(Line.value, empty7);
}();
var displayS = function(v) {
  if (v instanceof SFail) {
    return unsafeCrashWith("@SFail@ can not appear uncaught in a rendered @SimpleDoc@");
  }
  ;
  if (v instanceof SEmpty) {
    return "";
  }
  ;
  if (v instanceof SChar) {
    return fromCharArray([v.value0]) + displayS(v.value1);
  }
  ;
  if (v instanceof SText) {
    return v.value1 + displayS(v.value2);
  }
  ;
  if (v instanceof SLine) {
    return "\n" + (indentation(v.value0) + displayS(v.value1));
  }
  ;
  throw new Error("Failed pattern match at Text.PrettyPrint.Leijen (line 893, column 1 - line 893, column 32): " + [v.constructor.name]);
};
var column = function(f) {
  return new Column(f);
};
var $$char2 = function(v) {
  if (v === "\n") {
    return line;
  }
  ;
  return new Char(v);
};
var beside = function(x) {
  return function(y) {
    return new Cat(x, y);
  };
};
var docSemigroup = {
  append: beside
};
var append13 = /* @__PURE__ */ append(docSemigroup);
var docMonoid = {
  mempty: empty7,
  Semigroup0: function() {
    return docSemigroup;
  }
};
var foldr11 = /* @__PURE__ */ foldr13(docMonoid);
var string2 = /* @__PURE__ */ function() {
  var $303 = intercalate(foldableArray)(docMonoid)(line);
  var $304 = map(functorArray)(text2);
  var $305 = split("\n");
  return function($306) {
    return $303($304($305($306)));
  };
}();
var enclose = function(l) {
  return function(r) {
    return function(x) {
      return append13(l)(append13(x)(r));
    };
  };
};
var brackets = /* @__PURE__ */ enclose(lbracket)(rbracket);
var parens = /* @__PURE__ */ enclose(lparen)(rparen);
var width = function(d) {
  return function(f) {
    return column(function(k1) {
      return append13(d)(column(function(k2) {
        return f(k2 - k1 | 0);
      }));
    });
  };
};
var fillBreak = function(f) {
  return function(x) {
    return width(x)(function(w) {
      var $292 = w > f;
      if ($292) {
        return nest(f)(linebreak);
      }
      ;
      return text2(spaces(f - w | 0));
    });
  };
};
var appendWithSpace = function(x) {
  return function(y) {
    return append13(x)(append13(space2)(y));
  };
};
var hsep = /* @__PURE__ */ foldr11(appendWithSpace);
var appendWithSoftline = function(x) {
  return function(y) {
    return append13(x)(append13(softline)(y));
  };
};
var appendWithLinebreak = function(x) {
  return function(y) {
    return append13(x)(append13(linebreak)(y));
  };
};
var vcat = /* @__PURE__ */ foldr11(appendWithLinebreak);
var appendWithLine = function(x) {
  return function(y) {
    return append13(x)(append13(line)(y));
  };
};
var align = function(d) {
  return column(function(k) {
    return nesting(function(i) {
      return nest(k - i | 0)(d);
    });
  });
};
var hang = function(i) {
  return function(d) {
    return align(nest(i)(d));
  };
};
var indent2 = function(i) {
  return function(d) {
    return hang(i)(append13(text2(spaces(i)))(d));
  };
};

// output/Options.Applicative.Help.Chunk/index.js
var un2 = /* @__PURE__ */ un();
var foldr9 = /* @__PURE__ */ foldr(foldableArray);
var mempty4 = /* @__PURE__ */ mempty(docMonoid);
var fold4 = /* @__PURE__ */ fold(foldableArray);
var mapFlipped2 = /* @__PURE__ */ mapFlipped(functorArray);
var Chunk = function(x) {
  return x;
};
var chunked = function(v) {
  return function(v1) {
    return function(v2) {
      if (v1 instanceof Nothing) {
        return v2;
      }
      ;
      if (v2 instanceof Nothing) {
        return v1;
      }
      ;
      if (v1 instanceof Just && v2 instanceof Just) {
        return new Just(v(v1.value0)(v2.value0));
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Help.Chunk (line 57, column 1 - line 58, column 41): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
    };
  };
};
var chunkSemigroup = function(dictSemigroup) {
  return {
    append: chunked(append(dictSemigroup))
  };
};
var extractChunk = function(dictMonoid) {
  var $56 = fromMaybe(mempty(dictMonoid));
  var $57 = un2(Chunk);
  return function($58) {
    return $56($57($58));
  };
};
var isEmpty5 = /* @__PURE__ */ function() {
  var $59 = un2(Chunk);
  return function($60) {
    return isNothing($59($60));
  };
}();
var chunkMonoid = function(dictSemigroup) {
  var chunkSemigroup1 = chunkSemigroup(dictSemigroup);
  return {
    mempty: Nothing.value,
    Semigroup0: function() {
      return chunkSemigroup1;
    }
  };
};
var mempty1 = /* @__PURE__ */ mempty(/* @__PURE__ */ chunkMonoid(docSemigroup));
var vcatChunks = /* @__PURE__ */ foldr9(/* @__PURE__ */ chunked(appendWithLine))(mempty1);
var vsepChunks = /* @__PURE__ */ foldr9(/* @__PURE__ */ chunked(function(x) {
  return function(y) {
    return appendWithLine(x)(appendWithLine(mempty4)(y));
  };
}))(mempty1);
var chunkFunctor = functorMaybe;
var chunkBesideOrBelow = /* @__PURE__ */ chunked(appendWithSoftline);
var chunkBeside = /* @__PURE__ */ chunked(appendWithSpace);
var chunkApply = applyMaybe;
var chunkApplicative = applicativeMaybe;
var pure8 = /* @__PURE__ */ pure(chunkApplicative);
var listToChunk = function(dictMonoid) {
  var mempty27 = mempty(chunkMonoid(dictMonoid.Semigroup0()));
  var fold112 = fold4(dictMonoid);
  return function(v) {
    if (v.length === 0) {
      return mempty27;
    }
    ;
    return pure8(fold112(v));
  };
};
var stringChunk = function(v) {
  if (v === "") {
    return mempty1;
  }
  ;
  return pure8(text2(v));
};
var paragraph = /* @__PURE__ */ function() {
  var $61 = foldr9(function() {
    var $63 = chunked(appendWithSoftline);
    return function($64) {
      return $63(stringChunk($64));
    };
  }())(mempty1);
  return function($62) {
    return $61(words2($62));
  };
}();
var tabulate$prime = function(v) {
  return function(v1) {
    if (v1.length === 0) {
      return mempty1;
    }
    ;
    return pure8(vcat(mapFlipped2(v1)(function(v2) {
      return indent2(2)(appendWithSpace(fillBreak(v)(v2.value0))(v2.value1));
    })));
  };
};
var tabulate = /* @__PURE__ */ tabulate$prime(24);

// output/Options.Applicative.Help.Types/index.js
var helpBodyIsSymbol = {
  reflectSymbol: function() {
    return "helpBody";
  }
};
var helpErrorIsSymbol = {
  reflectSymbol: function() {
    return "helpError";
  }
};
var helpFooterIsSymbol = {
  reflectSymbol: function() {
    return "helpFooter";
  }
};
var helpHeaderIsSymbol = {
  reflectSymbol: function() {
    return "helpHeader";
  }
};
var helpSuggestionsIsSymbol = {
  reflectSymbol: function() {
    return "helpSuggestions";
  }
};
var helpUsageIsSymbol = {
  reflectSymbol: function() {
    return "helpUsage";
  }
};
var chunkMonoid2 = /* @__PURE__ */ chunkMonoid(docSemigroup);
var extractChunk2 = /* @__PURE__ */ extractChunk(docMonoid);
var ParserHelp = function(x) {
  return x;
};
var parserHelpMonoid = /* @__PURE__ */ monoidRecord()(/* @__PURE__ */ monoidRecordCons(helpBodyIsSymbol)(chunkMonoid2)()(/* @__PURE__ */ monoidRecordCons(helpErrorIsSymbol)(chunkMonoid2)()(/* @__PURE__ */ monoidRecordCons(helpFooterIsSymbol)(chunkMonoid2)()(/* @__PURE__ */ monoidRecordCons(helpHeaderIsSymbol)(chunkMonoid2)()(/* @__PURE__ */ monoidRecordCons(helpSuggestionsIsSymbol)(chunkMonoid2)()(/* @__PURE__ */ monoidRecordCons(helpUsageIsSymbol)(chunkMonoid2)()(monoidRecordNil)))))));
var helpText = function(v) {
  return extractChunk2(vsepChunks([v.helpError, v.helpSuggestions, v.helpHeader, v.helpUsage, v.helpBody, v.helpFooter]));
};
var renderHelp = function(cols) {
  var $65 = renderPretty(1)(cols);
  return function($66) {
    return displayS($65(helpText($66)));
  };
};

// output/Options.Applicative.Types/index.js
var monadExceptT2 = /* @__PURE__ */ monadExceptT(monadIdentity);
var map21 = /* @__PURE__ */ map(/* @__PURE__ */ functorReaderT(/* @__PURE__ */ functorExceptT(functorIdentity)));
var apply6 = /* @__PURE__ */ apply2(/* @__PURE__ */ applyReaderT(/* @__PURE__ */ applyExceptT(monadIdentity)));
var bind5 = /* @__PURE__ */ bind(/* @__PURE__ */ bindReaderT(/* @__PURE__ */ bindExceptT(monadIdentity)));
var un3 = /* @__PURE__ */ un();
var map111 = /* @__PURE__ */ map(functorMaybe);
var compare6 = /* @__PURE__ */ compare(ordChar);
var compare15 = /* @__PURE__ */ compare(ordString);
var apply1 = /* @__PURE__ */ apply2(applyEffect);
var map22 = /* @__PURE__ */ map(functorEffect);
var append14 = /* @__PURE__ */ append(semigroupArray);
var pure9 = /* @__PURE__ */ pure(applicativeEffect);
var over2 = /* @__PURE__ */ over()();
var map32 = /* @__PURE__ */ map(freeFunctor);
var bimap2 = /* @__PURE__ */ bimap(bifunctorStep);
var ParserFailure = function(x) {
  return x;
};
var Internal = /* @__PURE__ */ function() {
  function Internal2() {
  }
  ;
  Internal2.value = new Internal2();
  return Internal2;
}();
var Hidden = /* @__PURE__ */ function() {
  function Hidden2() {
  }
  ;
  Hidden2.value = new Hidden2();
  return Hidden2;
}();
var Visible = /* @__PURE__ */ function() {
  function Visible2() {
  }
  ;
  Visible2.value = new Visible2();
  return Visible2;
}();
var Leaf2 = /* @__PURE__ */ function() {
  function Leaf3(value0) {
    this.value0 = value0;
  }
  ;
  Leaf3.create = function(value0) {
    return new Leaf3(value0);
  };
  return Leaf3;
}();
var MultNode = /* @__PURE__ */ function() {
  function MultNode2(value0) {
    this.value0 = value0;
  }
  ;
  MultNode2.create = function(value0) {
    return new MultNode2(value0);
  };
  return MultNode2;
}();
var AltNode = /* @__PURE__ */ function() {
  function AltNode2(value0) {
    this.value0 = value0;
  }
  ;
  AltNode2.create = function(value0) {
    return new AltNode2(value0);
  };
  return AltNode2;
}();
var OptProperties = function(x) {
  return x;
};
var OptShort = /* @__PURE__ */ function() {
  function OptShort2(value0) {
    this.value0 = value0;
  }
  ;
  OptShort2.create = function(value0) {
    return new OptShort2(value0);
  };
  return OptShort2;
}();
var OptLong = /* @__PURE__ */ function() {
  function OptLong2(value0) {
    this.value0 = value0;
  }
  ;
  OptLong2.create = function(value0) {
    return new OptLong2(value0);
  };
  return OptLong2;
}();
var OptHelpInfo = function(x) {
  return x;
};
var CmdStart = /* @__PURE__ */ function() {
  function CmdStart2() {
  }
  ;
  CmdStart2.value = new CmdStart2();
  return CmdStart2;
}();
var CmdCont = /* @__PURE__ */ function() {
  function CmdCont2() {
  }
  ;
  CmdCont2.value = new CmdCont2();
  return CmdCont2;
}();
var CompletionResult = function(x) {
  return x;
};
var Success2 = /* @__PURE__ */ function() {
  function Success4(value0) {
    this.value0 = value0;
  }
  ;
  Success4.create = function(value0) {
    return new Success4(value0);
  };
  return Success4;
}();
var Failure = /* @__PURE__ */ function() {
  function Failure2(value0) {
    this.value0 = value0;
  }
  ;
  Failure2.create = function(value0) {
    return new Failure2(value0);
  };
  return Failure2;
}();
var CompletionInvoked = /* @__PURE__ */ function() {
  function CompletionInvoked2(value0) {
    this.value0 = value0;
  }
  ;
  CompletionInvoked2.create = function(value0) {
    return new CompletionInvoked2(value0);
  };
  return CompletionInvoked2;
}();
var Completer = function(x) {
  return x;
};
var Backtrack = /* @__PURE__ */ function() {
  function Backtrack2() {
  }
  ;
  Backtrack2.value = new Backtrack2();
  return Backtrack2;
}();
var NoBacktrack = /* @__PURE__ */ function() {
  function NoBacktrack2() {
  }
  ;
  NoBacktrack2.value = new NoBacktrack2();
  return NoBacktrack2;
}();
var SubparserInline = /* @__PURE__ */ function() {
  function SubparserInline2() {
  }
  ;
  SubparserInline2.value = new SubparserInline2();
  return SubparserInline2;
}();
var ParserPrefs = function(x) {
  return x;
};
var Intersperse = /* @__PURE__ */ function() {
  function Intersperse2() {
  }
  ;
  Intersperse2.value = new Intersperse2();
  return Intersperse2;
}();
var NoIntersperse = /* @__PURE__ */ function() {
  function NoIntersperse2() {
  }
  ;
  NoIntersperse2.value = new NoIntersperse2();
  return NoIntersperse2;
}();
var AllPositionals = /* @__PURE__ */ function() {
  function AllPositionals2() {
  }
  ;
  AllPositionals2.value = new AllPositionals2();
  return AllPositionals2;
}();
var ForwardOptions = /* @__PURE__ */ function() {
  function ForwardOptions2() {
  }
  ;
  ForwardOptions2.value = new ForwardOptions2();
  return ForwardOptions2;
}();
var ParserInfo = function(x) {
  return x;
};
var NilP = /* @__PURE__ */ function() {
  function NilP2(value0) {
    this.value0 = value0;
  }
  ;
  NilP2.create = function(value0) {
    return new NilP2(value0);
  };
  return NilP2;
}();
var OptP = /* @__PURE__ */ function() {
  function OptP2(value0) {
    this.value0 = value0;
  }
  ;
  OptP2.create = function(value0) {
    return new OptP2(value0);
  };
  return OptP2;
}();
var MultP = /* @__PURE__ */ function() {
  function MultP2(value0) {
    this.value0 = value0;
  }
  ;
  MultP2.create = function(value0) {
    return new MultP2(value0);
  };
  return MultP2;
}();
var AltP = /* @__PURE__ */ function() {
  function AltP2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  AltP2.create = function(value0) {
    return function(value12) {
      return new AltP2(value0, value12);
    };
  };
  return AltP2;
}();
var BindP = /* @__PURE__ */ function() {
  function BindP2(value0) {
    this.value0 = value0;
  }
  ;
  BindP2.create = function(value0) {
    return new BindP2(value0);
  };
  return BindP2;
}();
var Option = function(x) {
  return x;
};
var OptReader = /* @__PURE__ */ function() {
  function OptReader2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  OptReader2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new OptReader2(value0, value12, value22);
      };
    };
  };
  return OptReader2;
}();
var FlagReader = /* @__PURE__ */ function() {
  function FlagReader2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  FlagReader2.create = function(value0) {
    return function(value12) {
      return new FlagReader2(value0, value12);
    };
  };
  return FlagReader2;
}();
var ArgReader = /* @__PURE__ */ function() {
  function ArgReader2(value0) {
    this.value0 = value0;
  }
  ;
  ArgReader2.create = function(value0) {
    return new ArgReader2(value0);
  };
  return ArgReader2;
}();
var CmdReader = /* @__PURE__ */ function() {
  function CmdReader2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  CmdReader2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new CmdReader2(value0, value12, value22);
      };
    };
  };
  return CmdReader2;
}();
var CReader = function(x) {
  return x;
};
var ReadM = function(x) {
  return x;
};
var ErrorMsg = /* @__PURE__ */ function() {
  function ErrorMsg2(value0) {
    this.value0 = value0;
  }
  ;
  ErrorMsg2.create = function(value0) {
    return new ErrorMsg2(value0);
  };
  return ErrorMsg2;
}();
var InfoMsg = /* @__PURE__ */ function() {
  function InfoMsg2(value0) {
    this.value0 = value0;
  }
  ;
  InfoMsg2.create = function(value0) {
    return new InfoMsg2(value0);
  };
  return InfoMsg2;
}();
var ShowHelpText = /* @__PURE__ */ function() {
  function ShowHelpText2() {
  }
  ;
  ShowHelpText2.value = new ShowHelpText2();
  return ShowHelpText2;
}();
var MissingError = /* @__PURE__ */ function() {
  function MissingError2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  MissingError2.create = function(value0) {
    return function(value12) {
      return new MissingError2(value0, value12);
    };
  };
  return MissingError2;
}();
var ExpectsArgError = /* @__PURE__ */ function() {
  function ExpectsArgError2(value0) {
    this.value0 = value0;
  }
  ;
  ExpectsArgError2.create = function(value0) {
    return new ExpectsArgError2(value0);
  };
  return ExpectsArgError2;
}();
var UnexpectedError = /* @__PURE__ */ function() {
  function UnexpectedError2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  UnexpectedError2.create = function(value0) {
    return function(value12) {
      return new UnexpectedError2(value0, value12);
    };
  };
  return UnexpectedError2;
}();
var SomeParser = /* @__PURE__ */ function() {
  function SomeParser2(value0) {
    this.value0 = value0;
  }
  ;
  SomeParser2.create = function(value0) {
    return new SomeParser2(value0);
  };
  return SomeParser2;
}();
var MultPE = /* @__PURE__ */ function() {
  function MultPE2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  MultPE2.create = function(value0) {
    return function(value12) {
      return new MultPE2(value0, value12);
    };
  };
  return MultPE2;
}();
var Context = /* @__PURE__ */ function() {
  function Context2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Context2.create = function(value0) {
    return function(value12) {
      return new Context2(value0, value12);
    };
  };
  return Context2;
}();
var ParserM = function(x) {
  return x;
};
var readerAsk = /* @__PURE__ */ ask(/* @__PURE__ */ monadAskReaderT(monadExceptT2));
var readerAbort = /* @__PURE__ */ function() {
  var $478 = lift(monadTransReaderT)(monadExceptT2);
  var $479 = throwError(monadThrowExceptT(monadIdentity));
  return function($480) {
    return ReadM($478($479($480)));
  };
}();
var readerError = function($481) {
  return readerAbort(ErrorMsg.create($481));
};
var readMFunctor = {
  map: function(f) {
    return function(v) {
      return map21(f)(v);
    };
  }
};
var map42 = /* @__PURE__ */ map(readMFunctor);
var readMApply = {
  apply: function(v) {
    return function(v1) {
      return apply6(v)(v1);
    };
  },
  Functor0: function() {
    return readMFunctor;
  }
};
var readMBind = {
  bind: function(v) {
    return function(f) {
      return bind5(v)(function() {
        var $482 = un3(ReadM);
        return function($483) {
          return $482(f($483));
        };
      }());
    };
  },
  Apply0: function() {
    return readMApply;
  }
};
var readMApplicative = {
  pure: /* @__PURE__ */ function() {
    var $484 = pure(applicativeReaderT(applicativeExceptT(monadIdentity)));
    return function($485) {
      return ReadM($484($485));
    };
  }(),
  Apply0: function() {
    return readMApply;
  }
};
var parserMMonadRec = freeMonadRec;
var tailRecM3 = /* @__PURE__ */ tailRecM(parserMMonadRec);
var parserMBind = freeBind;
var bind1 = /* @__PURE__ */ bind(parserMBind);
var parserMApplicative = freeApplicative;
var pure12 = /* @__PURE__ */ pure(parserMApplicative);
var parseErrorSemigroup = {
  append: function(v) {
    return function(m) {
      return m;
    };
  }
};
var optional = function(dictAlt) {
  var alt210 = alt(dictAlt);
  var map102 = map(dictAlt.Functor0());
  return function(dictApplicative) {
    var pure311 = pure(dictApplicative);
    return function(a) {
      return alt210(map102(Just.create)(a))(pure311(Nothing.value));
    };
  };
};
var optVisibilityEq = {
  eq: function(x) {
    return function(y) {
      if (x instanceof Internal && y instanceof Internal) {
        return true;
      }
      ;
      if (x instanceof Hidden && y instanceof Hidden) {
        return true;
      }
      ;
      if (x instanceof Visible && y instanceof Visible) {
        return true;
      }
      ;
      return false;
    };
  }
};
var optVisibilityOrd = {
  compare: function(x) {
    return function(y) {
      if (x instanceof Internal && y instanceof Internal) {
        return EQ.value;
      }
      ;
      if (x instanceof Internal) {
        return LT.value;
      }
      ;
      if (y instanceof Internal) {
        return GT.value;
      }
      ;
      if (x instanceof Hidden && y instanceof Hidden) {
        return EQ.value;
      }
      ;
      if (x instanceof Hidden) {
        return LT.value;
      }
      ;
      if (y instanceof Hidden) {
        return GT.value;
      }
      ;
      if (x instanceof Visible && y instanceof Visible) {
        return EQ.value;
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Types (line 0, column 0 - line 0, column 0): " + [x.constructor.name, y.constructor.name]);
    };
  },
  Eq0: function() {
    return optVisibilityEq;
  }
};
var optShowDefault = /* @__PURE__ */ function() {
  var $486 = un3(OptProperties);
  var $487 = un3(Option);
  return function($488) {
    return function(v) {
      return v.propShowDefault;
    }($486(function(v) {
      return v.optProps;
    }($487($488))));
  };
}();
var optVisibility = /* @__PURE__ */ function() {
  var $489 = un3(OptProperties);
  var $490 = un3(Option);
  return function($491) {
    return function(v) {
      return v.propVisibility;
    }($489(function(v) {
      return v.optProps;
    }($490($491))));
  };
}();
var optNameEq = {
  eq: function(x) {
    return function(y) {
      if (x instanceof OptShort && y instanceof OptShort) {
        return x.value0 === y.value0;
      }
      ;
      if (x instanceof OptLong && y instanceof OptLong) {
        return x.value0 === y.value0;
      }
      ;
      return false;
    };
  }
};
var optNameOrd = {
  compare: function(x) {
    return function(y) {
      if (x instanceof OptShort && y instanceof OptShort) {
        return compare6(x.value0)(y.value0);
      }
      ;
      if (x instanceof OptShort) {
        return LT.value;
      }
      ;
      if (y instanceof OptShort) {
        return GT.value;
      }
      ;
      if (x instanceof OptLong && y instanceof OptLong) {
        return compare15(x.value0)(y.value0);
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Types (line 0, column 0 - line 0, column 0): " + [x.constructor.name, y.constructor.name]);
    };
  },
  Eq0: function() {
    return optNameEq;
  }
};
var optMetaVar = /* @__PURE__ */ function() {
  var $492 = un3(OptProperties);
  var $493 = un3(Option);
  return function($494) {
    return function(v) {
      return v.propMetaVar;
    }($492(function(v) {
      return v.optProps;
    }($493($494))));
  };
}();
var optHelp = /* @__PURE__ */ function() {
  var $495 = un3(OptProperties);
  var $496 = un3(Option);
  return function($497) {
    return function(v) {
      return v.propHelp;
    }($495(function(v) {
      return v.optProps;
    }($496($497))));
  };
}();
var optDescMod = /* @__PURE__ */ function() {
  var $498 = un3(OptProperties);
  var $499 = un3(Option);
  return function($500) {
    return function(v) {
      return v.propDescMod;
    }($498(function(v) {
      return v.optProps;
    }($499($500))));
  };
}();
var oneM = function($501) {
  return ParserM(liftF($501));
};
var fromM = function(v) {
  return new BindP(v);
};
var completerSemigroup = {
  append: function(v) {
    return function(v1) {
      return function(s) {
        return apply1(map22(append14)(v(s)))(v1(s));
      };
    };
  }
};
var completerMonoid = {
  mempty: function(v) {
    return pure9([]);
  },
  Semigroup0: function() {
    return completerSemigroup;
  }
};
var cReaderFunctor = {
  map: function(f) {
    return over2(CReader)(function(r) {
      return {
        crReader: map42(f)(r.crReader),
        crCompleter: r.crCompleter
      };
    });
  }
};
var map82 = /* @__PURE__ */ map(cReaderFunctor);
var parserInfoFunctor = {
  map: function(f) {
    return over2(ParserInfo)(function(i) {
      return {
        infoParser: map(parserFunctor)(f)(i.infoParser),
        infoFailureCode: i.infoFailureCode,
        infoFooter: i.infoFooter,
        infoFullDesc: i.infoFullDesc,
        infoHeader: i.infoHeader,
        infoPolicy: i.infoPolicy,
        infoProgDesc: i.infoProgDesc
      };
    });
  }
};
var parserFunctor = {
  map: function(v) {
    return function(v1) {
      if (v1 instanceof NilP) {
        return new NilP(v(v1.value0));
      }
      ;
      if (v1 instanceof OptP) {
        return new OptP(map(optionFunctor)(v)(v1.value0));
      }
      ;
      if (v1 instanceof MultP) {
        return runExists(function(v2) {
          return new MultP(mkExists(new MultPE(map(parserFunctor)(function(v3) {
            return function($502) {
              return v(v3($502));
            };
          })(v2.value0), v2.value1)));
        })(v1.value0);
      }
      ;
      if (v1 instanceof AltP) {
        return new AltP(map(parserFunctor)(v)(v1.value0), map(parserFunctor)(v)(v1.value1));
      }
      ;
      if (v1 instanceof BindP) {
        return new BindP(map32(v)(v1.value0));
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Types (line 317, column 1 - line 322, column 36): " + [v.constructor.name, v1.constructor.name]);
    };
  }
};
var optionFunctor = {
  map: function(f) {
    return over2(Option)(function(o) {
      return {
        optMain: map(optReaderFunctor)(f)(o.optMain),
        optProps: o.optProps
      };
    });
  }
};
var optReaderFunctor = {
  map: function(v) {
    return function(v1) {
      if (v1 instanceof OptReader) {
        return new OptReader(v1.value0, map82(v)(v1.value1), v1.value2);
      }
      ;
      if (v1 instanceof FlagReader) {
        return new FlagReader(v1.value0, v(v1.value1));
      }
      ;
      if (v1 instanceof ArgReader) {
        return new ArgReader(map82(v)(v1.value0));
      }
      ;
      if (v1 instanceof CmdReader) {
        return new CmdReader(v1.value0, v1.value1, function() {
          var $503 = map111(map(parserInfoFunctor)(v));
          return function($504) {
            return $503(v1.value2($504));
          };
        }());
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Types (line 264, column 1 - line 268, column 68): " + [v.constructor.name, v1.constructor.name]);
    };
  }
};
var map92 = /* @__PURE__ */ map(parserFunctor);
var parserAlt = /* @__PURE__ */ function() {
  return {
    alt: AltP.create,
    Functor0: function() {
      return parserFunctor;
    }
  };
}();
var alt1 = /* @__PURE__ */ alt(parserAlt);
var parserApply = {
  apply: function(a) {
    return function(b) {
      return new MultP(mkExists(new MultPE(a, b)));
    };
  },
  Functor0: function() {
    return parserFunctor;
  }
};
var parserApplicative = /* @__PURE__ */ function() {
  return {
    pure: NilP.create,
    Apply0: function() {
      return parserApply;
    }
  };
}();
var pure23 = /* @__PURE__ */ pure(parserApplicative);
var manyM = function(p) {
  var go = function(acc) {
    return bind1(oneM(alt1(map92(Loop.create)(p))(pure23(new Done(unit)))))(function(aa) {
      return pure12(bimap2(function(v) {
        return new Cons(v, acc);
      })(function(v) {
        return reverse2(acc);
      })(aa));
    });
  };
  return tailRecM3(go)(Nil.value);
};
var many3 = function($505) {
  return fromM(manyM($505));
};
var argPolicyEq = {
  eq: function(x) {
    return function(y) {
      if (x instanceof Intersperse && y instanceof Intersperse) {
        return true;
      }
      ;
      if (x instanceof NoIntersperse && y instanceof NoIntersperse) {
        return true;
      }
      ;
      if (x instanceof AllPositionals && y instanceof AllPositionals) {
        return true;
      }
      ;
      if (x instanceof ForwardOptions && y instanceof ForwardOptions) {
        return true;
      }
      ;
      return false;
    };
  }
};

// output/Control.Monad.Except/index.js
var unwrap7 = /* @__PURE__ */ unwrap();
var withExcept = /* @__PURE__ */ withExceptT(functorIdentity);
var runExcept = function($3) {
  return unwrap7(runExceptT($3));
};

// output/Control.Monad.Reader/index.js
var unwrap8 = /* @__PURE__ */ unwrap();
var runReader = function(v) {
  return function($4) {
    return unwrap8(v($4));
  };
};

// output/Options.Applicative.Internal/index.js
var $runtime_lazy8 = function(name4, moduleName2, init4) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2)
      return val;
    if (state2 === 1)
      throw new ReferenceError(name4 + " was needed before it finished initializing (module " + moduleName2 + ", line " + lineNumber + ")", moduleName2, lineNumber);
    state2 = 1;
    val = init4();
    state2 = 2;
    return val;
  };
};
var un4 = /* @__PURE__ */ un();
var map23 = /* @__PURE__ */ map(/* @__PURE__ */ functorExceptT(/* @__PURE__ */ functorStateT(/* @__PURE__ */ functorReaderT(functorIdentity))));
var monadReaderT2 = /* @__PURE__ */ monadReaderT(monadIdentity);
var monadStateT2 = /* @__PURE__ */ monadStateT(monadReaderT2);
var apply7 = /* @__PURE__ */ apply2(/* @__PURE__ */ applyExceptT(monadStateT2));
var bind6 = /* @__PURE__ */ bind(/* @__PURE__ */ bindExceptT(monadStateT2));
var pure10 = /* @__PURE__ */ pure(/* @__PURE__ */ applicativeExceptT(monadStateT2));
var altExceptT2 = /* @__PURE__ */ altExceptT(parseErrorSemigroup);
var alt2 = /* @__PURE__ */ alt(/* @__PURE__ */ altExceptT2(monadStateT2));
var lift5 = /* @__PURE__ */ lift(monadTransExceptT);
var lift1 = /* @__PURE__ */ lift5(monadStateT2);
var modify_3 = /* @__PURE__ */ modify_2(/* @__PURE__ */ monadStateStateT(monadReaderT2));
var lift23 = /* @__PURE__ */ lift(monadTransStateT);
var throwError2 = /* @__PURE__ */ throwError(/* @__PURE__ */ monadThrowExceptT(monadStateT2));
var map112 = /* @__PURE__ */ map(functorArray);
var pure13 = /* @__PURE__ */ pure(applicativeArray);
var discard2 = /* @__PURE__ */ discard(discardUnit);
var identity13 = /* @__PURE__ */ identity(categoryFn);
var TNil = /* @__PURE__ */ function() {
  function TNil2() {
  }
  ;
  TNil2.value = new TNil2();
  return TNil2;
}();
var TCons = /* @__PURE__ */ function() {
  function TCons2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TCons2.create = function(value0) {
    return function(value12) {
      return new TCons2(value0, value12);
    };
  };
  return TCons2;
}();
var P = function(x) {
  return x;
};
var ListT = function(x) {
  return x;
};
var NondetT = function(x) {
  return x;
};
var ComplParser = /* @__PURE__ */ function() {
  function ComplParser2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ComplParser2.create = function(value0) {
    return function(value12) {
      return new ComplParser2(value0, value12);
    };
  };
  return ComplParser2;
}();
var ComplOption = /* @__PURE__ */ function() {
  function ComplOption2(value0) {
    this.value0 = value0;
  }
  ;
  ComplOption2.create = function(value0) {
    return new ComplOption2(value0);
  };
  return ComplOption2;
}();
var ComplResult = /* @__PURE__ */ function() {
  function ComplResult2(value0) {
    this.value0 = value0;
  }
  ;
  ComplResult2.create = function(value0) {
    return new ComplResult2(value0);
  };
  return ComplResult2;
}();
var Completion = function(x) {
  return x;
};
var withReadM = function(f) {
  var f$prime = function(v) {
    if (v instanceof ErrorMsg) {
      return new ErrorMsg(f(v.value0));
    }
    ;
    return v;
  };
  var $298 = mapReaderT(withExcept(f$prime));
  var $299 = un4(ReadM);
  return function($300) {
    return ReadM($298($299($300)));
  };
};
var stepListT = function(v) {
  return v;
};
var runP = function(v) {
  return runReader(flip(runStateT)([])(runExceptT(v)));
};
var runNondetT = function(v) {
  return v;
};
var runListT = function(dictMonad) {
  var bind215 = bind(dictMonad.Bind1());
  var pure410 = pure(dictMonad.Applicative0());
  var liftM12 = liftM1(dictMonad);
  return function(xs) {
    return bind215(stepListT(xs))(function(s) {
      if (s instanceof TNil) {
        return pure410(Nil.value);
      }
      ;
      if (s instanceof TCons) {
        return liftM12(Cons.create(s.value0))(runListT(dictMonad)(s.value1));
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Internal (line 200, column 3 - line 202, column 53): " + [s.constructor.name]);
    });
  };
};
var runCompletion = function(v) {
  return function(prefs2) {
    var v1 = runReaderT(runExceptT(v))(prefs2);
    if (v1 instanceof ComplResult) {
      return Nothing.value;
    }
    ;
    if (v1 instanceof ComplParser) {
      return new Just(new Left(new Tuple(v1.value0, v1.value1)));
    }
    ;
    if (v1 instanceof ComplOption) {
      return new Just(new Right(v1.value0));
    }
    ;
    throw new Error("Failed pattern match at Options.Applicative.Internal (line 170, column 38 - line 173, column 42): " + [v1.constructor.name]);
  };
};
var pFunctor = {
  map: function(f) {
    return function(v) {
      return map23(f)(v);
    };
  }
};
var pApply = {
  apply: function(v) {
    return function(v1) {
      return apply7(v)(v1);
    };
  },
  Functor0: function() {
    return pFunctor;
  }
};
var pBind = {
  bind: function(v) {
    return function(k) {
      return bind6(v)(function(a) {
        var v1 = k(a);
        return v1;
      });
    };
  },
  Apply0: function() {
    return pApply;
  }
};
var pApplicative = {
  pure: function(a) {
    return pure10(a);
  },
  Apply0: function() {
    return pApply;
  }
};
var pMonad = {
  Applicative0: function() {
    return pApplicative;
  },
  Bind1: function() {
    return pBind;
  }
};
var pAlt = {
  alt: function(v) {
    return function(v1) {
      return alt2(v)(v1);
    };
  },
  Functor0: function() {
    return pFunctor;
  }
};
var missingArgP = function(dict) {
  return dict.missingArgP;
};
var getPrefs = function(dict) {
  return dict.getPrefs;
};
var exitP = function(dict) {
  return dict.exitP;
};
var exitContext = function(dict) {
  return dict.exitContext;
};
var errorP = function(dict) {
  return dict.errorP;
};
var hoistEither = function(dictMonadP) {
  return either(errorP(dictMonadP))(pure(dictMonadP.Monad0().Applicative0()));
};
var runReadM = function(dictMonadP) {
  var hoistEither1 = hoistEither(dictMonadP);
  return function(v) {
    return function(s) {
      return hoistEither1(runExcept(runReaderT(v)(s)));
    };
  };
};
var hoistMaybe = function(dictMonadP) {
  var errorP1 = errorP(dictMonadP);
  var pure410 = pure(dictMonadP.Monad0().Applicative0());
  return function(err) {
    return maybe(errorP1(err))(pure410);
  };
};
var pMonadP = {
  enterContext: function(name4) {
    return function(pinfo) {
      return lift1(modify_3(cons(new Context(name4, mkExists(pinfo)))));
    };
  },
  exitContext: /* @__PURE__ */ lift1(/* @__PURE__ */ modify_3(/* @__PURE__ */ drop(1))),
  getPrefs: /* @__PURE__ */ P(/* @__PURE__ */ lift1(/* @__PURE__ */ lift23(monadReaderT2)(/* @__PURE__ */ ask(/* @__PURE__ */ monadAskReaderT(monadIdentity))))),
  missingArgP: function(e) {
    return function(v) {
      return errorP(pMonadP)(e);
    };
  },
  exitP: function(i) {
    return function(v) {
      return function(p) {
        var $301 = maybe(throwError2(MissingError.create(i)(SomeParser.create(mkExists(p)))))(pure10);
        return function($302) {
          return P($301($302));
        };
      };
    };
  },
  errorP: function($303) {
    return P(throwError2($303));
  },
  Monad0: function() {
    return pMonad;
  },
  Alt1: function() {
    return pAlt;
  }
};
var enterContext = function(dict) {
  return dict.enterContext;
};
var contextNames = function(ns) {
  var go = function(v) {
    return v.value0;
  };
  return reverse(map112(go)(ns));
};
var complResultMonad = {
  Applicative0: function() {
    return complResultApplicative;
  },
  Bind1: function() {
    return complResultBind;
  }
};
var complResultBind = {
  bind: function(m) {
    return function(f) {
      if (m instanceof ComplResult) {
        return f(m.value0);
      }
      ;
      if (m instanceof ComplParser) {
        return new ComplParser(m.value0, m.value1);
      }
      ;
      if (m instanceof ComplOption) {
        return new ComplOption(m.value0);
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Internal (line 134, column 14 - line 137, column 35): " + [m.constructor.name]);
    };
  },
  Apply0: function() {
    return $lazy_complResultApply(0);
  }
};
var complResultApplicative = /* @__PURE__ */ function() {
  return {
    pure: ComplResult.create,
    Apply0: function() {
      return $lazy_complResultApply(0);
    }
  };
}();
var $lazy_complResultFunctor = /* @__PURE__ */ $runtime_lazy8("complResultFunctor", "Options.Applicative.Internal", function() {
  return {
    map: liftM1(complResultMonad)
  };
});
var $lazy_complResultApply = /* @__PURE__ */ $runtime_lazy8("complResultApply", "Options.Applicative.Internal", function() {
  return {
    apply: ap(complResultMonad),
    Functor0: function() {
      return $lazy_complResultFunctor(0);
    }
  };
});
var complResultFunctor = /* @__PURE__ */ $lazy_complResultFunctor(124);
var map24 = /* @__PURE__ */ map(/* @__PURE__ */ functorExceptT(/* @__PURE__ */ functorReaderT(complResultFunctor)));
var monadReaderT1 = /* @__PURE__ */ monadReaderT(complResultMonad);
var alt12 = /* @__PURE__ */ alt(/* @__PURE__ */ altExceptT2(monadReaderT1));
var apply12 = /* @__PURE__ */ apply2(/* @__PURE__ */ applyExceptT(monadReaderT1));
var pure24 = /* @__PURE__ */ pure(/* @__PURE__ */ applicativeExceptT(monadReaderT1));
var bind12 = /* @__PURE__ */ bind(/* @__PURE__ */ bindExceptT(monadReaderT1));
var lift32 = /* @__PURE__ */ lift5(monadReaderT1);
var lift42 = /* @__PURE__ */ lift(monadTransReaderT)(complResultMonad);
var completionFunctor = {
  map: function(f) {
    return function(v) {
      return map24(f)(v);
    };
  }
};
var completionAlt = {
  alt: function(v) {
    return function(v1) {
      return alt12(v)(v1);
    };
  },
  Functor0: function() {
    return completionFunctor;
  }
};
var completionApply = {
  apply: function(v) {
    return function(v1) {
      return apply12(v)(v1);
    };
  },
  Functor0: function() {
    return completionFunctor;
  }
};
var completionApplicative = {
  pure: function(a) {
    return pure24(a);
  },
  Apply0: function() {
    return completionApply;
  }
};
var pure32 = /* @__PURE__ */ pure(completionApplicative);
var completionBind = {
  bind: function(v) {
    return function(k) {
      return bind12(v)(function(a) {
        var v1 = k(a);
        return v1;
      });
    };
  },
  Apply0: function() {
    return completionApply;
  }
};
var completionMonad = {
  Applicative0: function() {
    return completionApplicative;
  },
  Bind1: function() {
    return completionBind;
  }
};
var completionMonadP = {
  enterContext: function(v) {
    return function(v1) {
      return pure32(unit);
    };
  },
  exitContext: /* @__PURE__ */ pure32(unit),
  getPrefs: /* @__PURE__ */ lift32(/* @__PURE__ */ ask(/* @__PURE__ */ monadAskReaderT(complResultMonad))),
  missingArgP: function(v) {
    return function($304) {
      return Completion(lift32(lift42(ComplOption.create($304))));
    };
  },
  exitP: function(v) {
    return function(a) {
      return function(p) {
        return function(v1) {
          return Completion(lift32(lift42(new ComplParser(new SomeParser(mkExists(p)), a))));
        };
      };
    };
  },
  errorP: /* @__PURE__ */ function() {
    var $305 = throwError(monadThrowExceptT(monadReaderT1));
    return function($306) {
      return Completion($305($306));
    };
  }(),
  Monad0: function() {
    return completionMonad;
  },
  Alt1: function() {
    return completionAlt;
  }
};
var bimapTStep = function(v) {
  return function(v1) {
    return function(v2) {
      if (v2 instanceof TNil) {
        return TNil.value;
      }
      ;
      if (v2 instanceof TCons) {
        return new TCons(v(v2.value0), v1(v2.value1));
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Internal (line 186, column 1 - line 186, column 77): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
    };
  };
};
var listTFunctor = function(dictMonad) {
  var liftM12 = liftM1(dictMonad);
  return {
    map: function(f) {
      return function(v) {
        return liftM12(bimapTStep(f)(map(listTFunctor(dictMonad))(f)))(stepListT(v));
      };
    }
  };
};
var listTAlt = function(dictMonad) {
  var bind215 = bind(dictMonad.Bind1());
  var pure410 = pure(dictMonad.Applicative0());
  var listTFunctor1 = listTFunctor(dictMonad);
  return {
    alt: function(xs) {
      return function(ys) {
        return bind215(stepListT(xs))(function(s) {
          if (s instanceof TNil) {
            return stepListT(ys);
          }
          ;
          if (s instanceof TCons) {
            return pure410(new TCons(s.value0, alt(listTAlt(dictMonad))(s.value1)(ys)));
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Internal (line 227, column 5 - line 229, column 49): " + [s.constructor.name]);
        });
      };
    },
    Functor0: function() {
      return listTFunctor1;
    }
  };
};
var listTPlus = function(dictMonad) {
  var listTAlt1 = listTAlt(dictMonad);
  return {
    empty: pure(dictMonad.Applicative0())(TNil.value),
    Alt0: function() {
      return listTAlt1;
    }
  };
};
var hoistList = function(dictMonad) {
  var pure410 = pure(dictMonad.Applicative0());
  return foldr2(function(x) {
    return function(xt) {
      return pure410(new TCons(x, xt));
    };
  })(empty(listTPlus(dictMonad)));
};
var listTMonadTrans = {
  lift: function(dictMonad) {
    var empty9 = empty(listTPlus(dictMonad));
    var $307 = liftM1(dictMonad)(function(v) {
      return new TCons(v, empty9);
    });
    return function($308) {
      return ListT($307($308));
    };
  }
};
var lift52 = /* @__PURE__ */ lift(listTMonadTrans);
var cut = function(dictMonad) {
  return lift52(monadStateT(dictMonad))(put(monadStateStateT(dictMonad))(true));
};
var nondetTMonadTrans = {
  lift: function(dictMonad) {
    var $309 = lift52(monadStateT(dictMonad));
    var $310 = lift23(dictMonad);
    return function($311) {
      return NondetT($309($310($311)));
    };
  }
};
var listTMonad = function(dictMonad) {
  return {
    Applicative0: function() {
      return listTApplicative(dictMonad);
    },
    Bind1: function() {
      return listTBind(dictMonad);
    }
  };
};
var listTBind = function(dictMonad) {
  var bind215 = bind(dictMonad.Bind1());
  var pure410 = pure(dictMonad.Applicative0());
  var alt210 = alt(listTAlt(dictMonad));
  return {
    bind: function(xs) {
      return function(f) {
        return bind215(stepListT(xs))(function(s) {
          if (s instanceof TNil) {
            return pure410(TNil.value);
          }
          ;
          if (s instanceof TCons) {
            return stepListT(alt210(f(s.value0))(bind(listTBind(dictMonad))(s.value1)(f)));
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Internal (line 218, column 5 - line 220, column 53): " + [s.constructor.name]);
        });
      };
    },
    Apply0: function() {
      return listTApply(dictMonad);
    }
  };
};
var listTApply = function(dictMonad) {
  var listTFunctor1 = listTFunctor(dictMonad);
  return {
    apply: ap(listTMonad(dictMonad)),
    Functor0: function() {
      return listTFunctor1;
    }
  };
};
var listTApplicative = function(dictMonad) {
  return {
    pure: function() {
      var $312 = hoistList(dictMonad);
      return function($313) {
        return $312(pure13($313));
      };
    }(),
    Apply0: function() {
      return listTApply(dictMonad);
    }
  };
};
var listTAlternative = function(dictMonad) {
  var listTApplicative1 = listTApplicative(dictMonad);
  var listTPlus1 = listTPlus(dictMonad);
  return {
    Applicative0: function() {
      return listTApplicative1;
    },
    Plus1: function() {
      return listTPlus1;
    }
  };
};
var nondetTAltOp = function(dictMonad) {
  var monadStateT1 = monadStateT(dictMonad);
  var alt210 = alt(listTAlt(monadStateT1));
  var listTBind1 = listTBind(monadStateT1);
  var bind215 = bind(listTBind1);
  var lift62 = lift52(monadStateT1);
  var get7 = get(monadStateStateT(dictMonad));
  var discard113 = discard2(listTBind1);
  var guard12 = guard2(listTAlternative(monadStateT1));
  return function(m1) {
    return function(m2) {
      return NondetT(alt210(runNondetT(m1))(bind215(lift62(get7))(function(s) {
        return discard113(guard12(!s))(function() {
          return runNondetT(m2);
        });
      })));
    };
  };
};
var nondetTFunctor = function(dictMonad) {
  var map315 = map(listTFunctor(monadStateT(dictMonad)));
  return {
    map: function(f) {
      var $314 = map315(f);
      return function($315) {
        return NondetT($314(runNondetT($315)));
      };
    }
  };
};
var nondetTAlt = function(dictMonad) {
  var alt210 = alt(listTAlt(monadStateT(dictMonad)));
  var nondetTFunctor1 = nondetTFunctor(dictMonad);
  return {
    alt: function(v) {
      return function(v1) {
        return alt210(v)(v1);
      };
    },
    Functor0: function() {
      return nondetTFunctor1;
    }
  };
};
var nondetTPlus = function(dictMonad) {
  var nondetTAlt1 = nondetTAlt(dictMonad);
  return {
    empty: empty(listTPlus(monadStateT(dictMonad))),
    Alt0: function() {
      return nondetTAlt1;
    }
  };
};
var nondetTApply = function(dictMonad) {
  var apply25 = apply2(listTApply(monadStateT(dictMonad)));
  var nondetTFunctor1 = nondetTFunctor(dictMonad);
  return {
    apply: function(v) {
      return function(v1) {
        return apply25(v)(v1);
      };
    },
    Functor0: function() {
      return nondetTFunctor1;
    }
  };
};
var nondetTApplicative = function(dictMonad) {
  var nondetTApply1 = nondetTApply(dictMonad);
  return {
    pure: function() {
      var $316 = pure(listTApplicative(monadStateT(dictMonad)));
      return function($317) {
        return NondetT($316($317));
      };
    }(),
    Apply0: function() {
      return nondetTApply1;
    }
  };
};
var nondetTBind = function(dictMonad) {
  var bind215 = bind(listTBind(monadStateT(dictMonad)));
  var nondetTApply1 = nondetTApply(dictMonad);
  return {
    bind: function(v) {
      return function(f) {
        return bind215(v)(function($318) {
          return runNondetT(f($318));
        });
      };
    },
    Apply0: function() {
      return nondetTApply1;
    }
  };
};
var takeListT = function(dictMonad) {
  var empty9 = empty(listTPlus(dictMonad));
  var liftM12 = liftM1(dictMonad);
  return function(v) {
    if (v === 0) {
      return $$const(empty9);
    }
    ;
    var $319 = liftM12(bimapTStep(identity13)(takeListT(dictMonad)(v - 1 | 0)));
    return function($320) {
      return ListT($319(stepListT($320)));
    };
  };
};
var disamb = function(dictMonad) {
  var Bind1 = dictMonad.Bind1();
  var bind215 = bind(Bind1);
  var evalStateT3 = evalStateT(Bind1.Apply0().Functor0());
  var monadStateT1 = monadStateT(dictMonad);
  var runListT1 = runListT(monadStateT1);
  var takeListT1 = takeListT(monadStateT1);
  var pure410 = pure(dictMonad.Applicative0());
  return function(allow_amb) {
    return function(xs) {
      return bind215(function(v) {
        return evalStateT3(v)(false);
      }(runListT1(takeListT1(function() {
        if (allow_amb) {
          return 1;
        }
        ;
        return 2;
      }())(runNondetT(xs)))))(function(xs$prime) {
        return pure410(function() {
          if (xs$prime instanceof Cons && xs$prime.value1 instanceof Nil) {
            return new Just(xs$prime.value0);
          }
          ;
          return Nothing.value;
        }());
      });
    };
  };
};

// output/Options.Applicative.Common/index.js
var bind7 = /* @__PURE__ */ bind(bindArray);
var fromFoldable11 = /* @__PURE__ */ fromFoldable(foldableList);
var map25 = /* @__PURE__ */ map(functorMaybe);
var voidRight2 = /* @__PURE__ */ voidRight(functorMaybe);
var guard3 = /* @__PURE__ */ guard2(alternativeMaybe);
var any3 = /* @__PURE__ */ any2(foldableArray)(heytingAlgebraBoolean);
var elem3 = /* @__PURE__ */ elem(foldableArray)(optNameEq);
var discard3 = /* @__PURE__ */ discard(discardUnit);
var discard1 = /* @__PURE__ */ discard3(bindMaybe);
var un5 = /* @__PURE__ */ un();
var lift6 = /* @__PURE__ */ lift(monadTransStateT);
var apply8 = /* @__PURE__ */ apply2(applyMaybe);
var alt3 = /* @__PURE__ */ alt(altMaybe);
var bind13 = /* @__PURE__ */ bind(bindMaybe);
var apply13 = /* @__PURE__ */ apply2(parserApply);
var oneOf2 = /* @__PURE__ */ oneOf(foldableArray);
var bind22 = /* @__PURE__ */ bind(freeBind);
var greaterThan2 = /* @__PURE__ */ greaterThan(optVisibilityOrd);
var lift12 = /* @__PURE__ */ lift(nondetTMonadTrans);
var pure11 = /* @__PURE__ */ pure(parserApplicative);
var pure14 = /* @__PURE__ */ pure(applicativeMaybe);
var notEq1 = /* @__PURE__ */ notEq(argPolicyEq);
var OptWord = /* @__PURE__ */ function() {
  function OptWord2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  OptWord2.create = function(value0) {
    return function(value12) {
      return new OptWord2(value0, value12);
    };
  };
  return OptWord2;
}();
var unexpectedError = function(arg) {
  return function(p) {
    return new UnexpectedError(arg, new SomeParser(mkExists(p)));
  };
};
var simplify = function(v) {
  if (v instanceof Leaf2) {
    return new Leaf2(v.value0);
  }
  ;
  if (v instanceof MultNode) {
    var remove_mult = function(v12) {
      if (v12 instanceof MultNode) {
        return v12.value0;
      }
      ;
      return [v12];
    };
    var v1 = bind7(v.value0)(function($340) {
      return remove_mult(simplify($340));
    });
    if (v1.length === 1) {
      return v1[0];
    }
    ;
    return new MultNode(v1);
  }
  ;
  if (v instanceof AltNode) {
    var remove_alt = function(v12) {
      if (v12 instanceof AltNode) {
        return v12.value0;
      }
      ;
      if (v12 instanceof MultNode && v12.value0.length === 0) {
        return [];
      }
      ;
      return [v12];
    };
    var v1 = bind7(v.value0)(function($341) {
      return remove_alt(simplify($341));
    });
    if (v1.length === 0) {
      return new MultNode([]);
    }
    ;
    if (v1.length === 1) {
      return v1[0];
    }
    ;
    return new AltNode(v1);
  }
  ;
  throw new Error("Failed pattern match at Options.Applicative.Common (line 280, column 1 - line 280, column 45): " + [v.constructor.name]);
};
var showOption = function(v) {
  if (v instanceof OptLong) {
    return "--" + v.value0;
  }
  ;
  if (v instanceof OptShort) {
    return fromCharArray(["-", v.value0]);
  }
  ;
  throw new Error("Failed pattern match at Options.Applicative.Common (line 43, column 1 - line 43, column 32): " + [v.constructor.name]);
};
var parseWord = /* @__PURE__ */ function() {
  var go = function(v) {
    if (v instanceof Cons && (v.value0 === "-" && (v.value1 instanceof Cons && v.value1.value0 === "-"))) {
      return new Just(function() {
        var v1 = function() {
          var v2 = span2(function(v3) {
            return v3 !== "=";
          })(v.value1.value1);
          if (v2.rest instanceof Nil) {
            return new Tuple(v.value1.value1, Nothing.value);
          }
          ;
          if (v2.rest instanceof Cons) {
            return new Tuple(v2.init, new Just(v2.rest.value1));
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Common (line 107, column 23 - line 109, column 70): " + [v2.constructor.name]);
        }();
        return new OptWord(new OptLong(fromCharArray(fromFoldable11(v1.value0))), map25(function($342) {
          return fromCharArray(fromFoldable11($342));
        })(v1.value1));
      }());
    }
    ;
    if (v instanceof Cons && v.value0 === "-") {
      if (v.value1 instanceof Nil) {
        return Nothing.value;
      }
      ;
      if (v.value1 instanceof Cons) {
        return new Just(function() {
          var arg = voidRight2(v.value1.value1)(guard3(!$$null3(v.value1.value1)));
          return new OptWord(new OptShort(v.value1.value0), map25(function($343) {
            return fromCharArray(fromFoldable11($343));
          })(arg));
        }());
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Common (line 111, column 25 - line 115, column 79): " + [v.value1.constructor.name]);
    }
    ;
    return Nothing.value;
  };
  var $344 = fromFoldable5(foldableArray);
  return function($345) {
    return go($344(toCharArray($345)));
  };
}();
var optionNames = function(v) {
  if (v instanceof OptReader) {
    return v.value0;
  }
  ;
  if (v instanceof FlagReader) {
    return v.value0;
  }
  ;
  return [];
};
var liftOpt = /* @__PURE__ */ function() {
  return OptP.create;
}();
var isOptionPrefix = function(v) {
  return function(v1) {
    if (v instanceof OptShort && v1 instanceof OptShort) {
      return v.value0 === v1.value0;
    }
    ;
    if (v instanceof OptLong && v1 instanceof OptLong) {
      return startsWith(v.value0)(v1.value0);
    }
    ;
    return false;
  };
};
var optMatches = function(dictMonadP) {
  var Monad0 = dictMonadP.Monad0();
  var bindStateT3 = bindStateT(Monad0);
  var bind310 = bind(bindStateT3);
  var monadStateStateT4 = monadStateStateT(Monad0);
  var get7 = get(monadStateStateT4);
  var missingArgP2 = missingArgP(dictMonadP);
  var lift26 = lift6(Monad0);
  var pure211 = pure(applicativeStateT(Monad0));
  var discard210 = discard3(bindStateT3);
  var put5 = put(monadStateStateT4);
  var runReadM2 = runReadM(dictMonadP);
  return function(disambiguate) {
    return function(opt) {
      return function(v) {
        var is_short = function(v1) {
          if (v1 instanceof OptShort) {
            return true;
          }
          ;
          if (v1 instanceof OptLong) {
            return false;
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Common (line 90, column 5 - line 90, column 33): " + [v1.constructor.name]);
        };
        var has_name = function(a) {
          if (disambiguate) {
            return any3(isOptionPrefix(a));
          }
          ;
          if (otherwise) {
            return elem3(a);
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Common (line 93, column 5 - line 95, column 27): " + [a.constructor.name]);
        };
        var errorFor = function(name4) {
          return function(msg) {
            return "option " + (showOption(name4) + (": " + msg));
          };
        };
        if (opt instanceof OptReader) {
          return discard1(guard3(has_name(v.value0)(opt.value0)))(function() {
            return new Just(bind310(get7)(function(args) {
              var missing_arg = missingArgP2(opt.value2(showOption(v.value0)))(un5(CReader)(opt.value1).crCompleter);
              return bind310(function() {
                var v1 = maybe(args)(function(v2) {
                  return new Cons(v2, args);
                })(v.value1);
                if (v1 instanceof Nil) {
                  return lift26(missing_arg);
                }
                ;
                if (v1 instanceof Cons) {
                  return pure211(new Tuple(v1.value0, v1.value1));
                }
                ;
                throw new Error("Failed pattern match at Options.Applicative.Common (line 68, column 27 - line 70, column 56): " + [v1.constructor.name]);
              }())(function(v1) {
                return discard210(put5(v1.value1))(function() {
                  return lift26(runReadM2(withReadM(errorFor(v.value0))(un5(CReader)(opt.value1).crReader))(v1.value0));
                });
              });
            }));
          });
        }
        ;
        if (opt instanceof FlagReader) {
          return discard1(guard3(has_name(v.value0)(opt.value0)))(function() {
            return discard1(guard3(is_short(v.value0) || isNothing(v.value1)))(function() {
              return new Just(bind310(get7)(function(args) {
                var val$prime = map25(function($346) {
                  return function(s) {
                    return cons("-")(s);
                  }(toCharArray($346));
                })(v.value1);
                return discard210(put5(maybe(args)(function() {
                  var $347 = flip(Cons.create)(args);
                  return function($348) {
                    return $347(fromCharArray($348));
                  };
                }())(val$prime)))(function() {
                  return pure211(opt.value1);
                });
              }));
            });
          });
        }
        ;
        return Nothing.value;
      };
    };
  };
};
var isArg = function(v) {
  if (v instanceof ArgReader) {
    return true;
  }
  ;
  return false;
};
var evalParser = function(v) {
  if (v instanceof NilP) {
    return new Just(v.value0);
  }
  ;
  if (v instanceof OptP) {
    return Nothing.value;
  }
  ;
  if (v instanceof MultP) {
    return runExists(function(v1) {
      return apply8(evalParser(v1.value0))(evalParser(v1.value1));
    })(v.value0);
  }
  ;
  if (v instanceof AltP) {
    return alt3(evalParser(v.value0))(evalParser(v.value1));
  }
  ;
  if (v instanceof BindP) {
    return resume$prime(function(p) {
      return function(k) {
        return bind13(evalParser(p))(function($349) {
          return evalParser(BindP.create(k($349)));
        });
      };
    })(Just.create)(v.value0);
  }
  ;
  throw new Error("Failed pattern match at Options.Applicative.Common (line 220, column 1 - line 220, column 44): " + [v.constructor.name]);
};
var searchParser = function(dictMonad) {
  var nondetTPlus2 = nondetTPlus(dictMonad);
  var empty9 = empty(nondetTPlus2);
  var mapFlipped10 = mapFlipped(nondetTFunctor(dictMonad));
  var nondetTAltOp2 = nondetTAltOp(dictMonad);
  var oneOf1 = oneOf2(nondetTPlus2);
  return function(v) {
    return function(v1) {
      if (v1 instanceof NilP) {
        return empty9;
      }
      ;
      if (v1 instanceof OptP) {
        return v(v1.value0);
      }
      ;
      if (v1 instanceof MultP) {
        return runExists(function(v2) {
          var b = mapFlipped10(searchParser(dictMonad)(v)(v2.value1))(function(p2$prime) {
            return apply13(v2.value0)(p2$prime);
          });
          var a = mapFlipped10(searchParser(dictMonad)(v)(v2.value0))(function(p1$prime) {
            return apply13(p1$prime)(v2.value1);
          });
          return nondetTAltOp2(a)(b);
        })(v1.value0);
      }
      ;
      if (v1 instanceof AltP) {
        return oneOf1([searchParser(dictMonad)(v)(v1.value0), searchParser(dictMonad)(v)(v1.value1)]);
      }
      ;
      if (v1 instanceof BindP) {
        return resume$prime(function(p) {
          return function(k) {
            return oneOf1([mapFlipped10(searchParser(dictMonad)(v)(p))(function(p$prime) {
              return new BindP(bind22(liftF(p$prime))(k));
            }), function() {
              var v2 = evalParser(p);
              if (v2 instanceof Nothing) {
                return empty9;
              }
              ;
              if (v2 instanceof Just) {
                return searchParser(dictMonad)(v)(new BindP(k(v2.value0)));
              }
              ;
              throw new Error("Failed pattern match at Options.Applicative.Common (line 135, column 7 - line 137, column 49): " + [v2.constructor.name]);
            }()]);
          };
        })($$const(empty9))(v1.value0);
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Common (line 118, column 1 - line 120, column 49): " + [v.constructor.name, v1.constructor.name]);
    };
  };
};
var searchOpt = function(dictMonadP) {
  var monadStateT4 = monadStateT(dictMonadP.Monad0());
  var searchParser1 = searchParser(monadStateT4);
  var optMatches1 = optMatches(dictMonadP);
  var lift26 = lift12(monadStateT4);
  var map136 = map(functorStateT(dictMonadP.Alt1().Functor0()));
  var empty9 = empty(nondetTPlus(monadStateT4));
  return function(pprefs) {
    return function(w) {
      return searchParser1(function(opt) {
        var disambiguate = un5(ParserPrefs)(pprefs).prefDisambiguate && greaterThan2(optVisibility(opt))(Internal.value);
        var v = optMatches1(disambiguate)(un5(Option)(opt).optMain)(w);
        if (v instanceof Just) {
          return lift26(map136(pure11)(v.value0));
        }
        ;
        if (v instanceof Nothing) {
          return empty9;
        }
        ;
        throw new Error("Failed pattern match at Options.Applicative.Common (line 144, column 3 - line 146, column 21): " + [v.constructor.name]);
      });
    };
  };
};
var stepParser = function(dictMonadP) {
  var alt111 = alt(nondetTAlt(monadStateT(dictMonadP.Monad0())));
  var searchOpt1 = searchOpt(dictMonadP);
  return function(v) {
    return function(v1) {
      return function(v2) {
        return function(v3) {
          if (v1 instanceof AllPositionals) {
            return searchArg(dictMonadP)(v)(v2)(v3);
          }
          ;
          if (v1 instanceof ForwardOptions) {
            var v4 = parseWord(v2);
            if (v4 instanceof Just) {
              return alt111(searchOpt1(v)(v4.value0)(v3))(searchArg(dictMonadP)(v)(v2)(v3));
            }
            ;
            if (v4 instanceof Nothing) {
              return searchArg(dictMonadP)(v)(v2)(v3);
            }
            ;
            throw new Error("Failed pattern match at Options.Applicative.Common (line 174, column 42 - line 176, column 36): " + [v4.constructor.name]);
          }
          ;
          var v4 = parseWord(v2);
          if (v4 instanceof Just) {
            return searchOpt1(v)(v4.value0)(v3);
          }
          ;
          if (v4 instanceof Nothing) {
            return searchArg(dictMonadP)(v)(v2)(v3);
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Common (line 177, column 29 - line 179, column 36): " + [v4.constructor.name]);
        };
      };
    };
  };
};
var searchArg = function(dictMonadP) {
  var Monad0 = dictMonadP.Monad0();
  var monadStateT4 = monadStateT(Monad0);
  var searchParser1 = searchParser(monadStateT4);
  var discard210 = discard3(nondetTBind(monadStateT4));
  var when15 = when(nondetTApplicative(monadStateT4));
  var cut2 = cut(monadStateT4);
  var lift26 = lift12(monadStateT4);
  var bindStateT3 = bindStateT(Monad0);
  var bind310 = bind(bindStateT3);
  var applyFirst6 = applyFirst(applyStateT(Monad0));
  var monadStateStateT4 = monadStateStateT(Monad0);
  var get7 = get(monadStateStateT4);
  var put5 = put(monadStateStateT4);
  var map136 = map(functorStateT(dictMonadP.Alt1().Functor0()));
  var lift33 = lift6(Monad0);
  var Apply0 = Monad0.Bind1().Apply0();
  var applyFirst1 = applyFirst(Apply0);
  var applySecond9 = applySecond(Apply0);
  var enterContext2 = enterContext(dictMonadP);
  var exitContext2 = exitContext(dictMonadP);
  var map222 = map(nondetTFunctor(monadStateT4));
  var discard39 = discard3(bindStateT3);
  var pure211 = pure(applicativeStateT(Monad0));
  var empty9 = empty(nondetTPlus(monadStateT4));
  var runReadM2 = runReadM(dictMonadP);
  return function(prefs2) {
    return function(arg) {
      return searchParser1(function(opt) {
        return discard210(when15(isArg(un5(Option)(opt).optMain))(cut2))(function() {
          var v = un5(Option)(opt).optMain;
          if (v instanceof CmdReader) {
            var v1 = new Tuple(v.value2(arg), un5(ParserPrefs)(prefs2).prefBacktrack);
            if (v1.value0 instanceof Just && v1.value1 instanceof NoBacktrack) {
              return lift26(bind310(applyFirst6(get7)(put5(Nil.value)))(function(args) {
                return map136(pure11)(lift33(applyFirst1(applySecond9(enterContext2(arg)(v1.value0.value0))(runParserInfo(dictMonadP)(v1.value0.value0)(args)))(exitContext2)));
              }));
            }
            ;
            if (v1.value0 instanceof Just && v1.value1 instanceof Backtrack) {
              return map222(pure11)(lift26(StateT(function(args) {
                return applyFirst1(applySecond9(enterContext2(arg)(v1.value0.value0))(runParser(dictMonadP)(un5(ParserInfo)(v1.value0.value0).infoPolicy)(CmdStart.value)(un5(ParserInfo)(v1.value0.value0).infoParser)(args)))(exitContext2);
              })));
            }
            ;
            if (v1.value0 instanceof Just && v1.value1 instanceof SubparserInline) {
              return lift26(discard39(lift33(enterContext2(arg)(v1.value0.value0)))(function() {
                return pure211(un5(ParserInfo)(v1.value0.value0).infoParser);
              }));
            }
            ;
            if (v1.value0 instanceof Nothing) {
              return empty9;
            }
            ;
            throw new Error("Failed pattern match at Options.Applicative.Common (line 154, column 7 - line 166, column 38): " + [v1.constructor.name]);
          }
          ;
          if (v instanceof ArgReader) {
            return map222(pure11)(lift26(lift33(runReadM2(un5(CReader)(v.value0).crReader)(arg))));
          }
          ;
          return empty9;
        });
      });
    };
  };
};
var runParserInfo = function(dictMonadP) {
  return function(i) {
    return runParserFully(dictMonadP)(un5(ParserInfo)(i).infoPolicy)(un5(ParserInfo)(i).infoParser);
  };
};
var runParserFully = function(dictMonadP) {
  var Monad0 = dictMonadP.Monad0();
  var bind310 = bind(Monad0.Bind1());
  var pure211 = pure(Monad0.Applicative0());
  var errorP2 = errorP(dictMonadP);
  return function(policy) {
    return function(p) {
      return function(args) {
        return bind310(runParser(dictMonadP)(policy)(CmdStart.value)(p)(args))(function(v) {
          if (v.value1 instanceof Nil) {
            return pure211(v.value0);
          }
          ;
          if (v.value1 instanceof Cons) {
            return errorP2(unexpectedError(v.value1.value0)(pure11(unit)));
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Common (line 214, column 3 - line 216, column 66): " + [v.value1.constructor.name]);
        });
      };
    };
  };
};
var runParser = function(dictMonadP) {
  var Monad0 = dictMonadP.Monad0();
  var disamb2 = disamb(monadStateT(Monad0));
  var exitP2 = exitP(dictMonadP);
  var bind310 = bind(Monad0.Bind1());
  var getPrefs2 = getPrefs(dictMonadP);
  var hoistMaybe2 = hoistMaybe(dictMonadP);
  return function(policy) {
    return function(isCmdStart) {
      return function(p) {
        return function(args) {
          var result = apply8(map25(Tuple.create)(evalParser(p)))(pure14(args));
          var newPolicy = function(a) {
            if (policy instanceof NoIntersperse) {
              var $299 = isJust(parseWord(a));
              if ($299) {
                return NoIntersperse.value;
              }
              ;
              return AllPositionals.value;
            }
            ;
            return policy;
          };
          var do_step = function(prefs2) {
            return function(arg) {
              return function(argt) {
                return function(v) {
                  return runStateT(v)(argt);
                }(disamb2(!un5(ParserPrefs)(prefs2).prefDisambiguate)(stepParser(dictMonadP)(prefs2)(policy)(arg)(p)));
              };
            };
          };
          if (args instanceof Nil) {
            return exitP2(isCmdStart)(policy)(p)(result);
          }
          ;
          if (args instanceof Cons && (args.value0 === "--" && notEq1(policy)(AllPositionals.value))) {
            return runParser(dictMonadP)(AllPositionals.value)(CmdCont.value)(p)(args.value1);
          }
          ;
          if (args instanceof Cons) {
            return bind310(getPrefs2)(function(prefs2) {
              return bind310(do_step(prefs2)(args.value0)(args.value1))(function(v) {
                if (v.value0 instanceof Nothing) {
                  return hoistMaybe2(unexpectedError(args.value0)(p))(result);
                }
                ;
                if (v.value0 instanceof Just) {
                  return runParser(dictMonadP)(newPolicy(args.value0))(CmdCont.value)(v.value0.value0)(v.value1);
                }
                ;
                throw new Error("Failed pattern match at Options.Applicative.Common (line 192, column 5 - line 194, column 60): " + [v.value0.constructor.name]);
              });
            });
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Common (line 186, column 38 - line 194, column 60): " + [args.constructor.name]);
        };
      };
    };
  };
};
var treeMapParser = function(g) {
  var has_default = function(p) {
    return isJust(evalParser(p));
  };
  var hasArg = function(v) {
    if (v instanceof NilP) {
      return false;
    }
    ;
    if (v instanceof OptP) {
      return isArg(un5(Option)(v.value0).optMain);
    }
    ;
    if (v instanceof MultP) {
      return runExists(function(v1) {
        return hasArg(v1.value0) || hasArg(v1.value1);
      })(v.value0);
    }
    ;
    if (v instanceof AltP) {
      return hasArg(v.value0) || hasArg(v.value1);
    }
    ;
    if (v instanceof BindP) {
      return resume$prime(function(p) {
        return function(v1) {
          return hasArg(p);
        };
      })($$const(false))(v.value0);
    }
    ;
    throw new Error("Failed pattern match at Options.Applicative.Common (line 272, column 5 - line 272, column 44): " + [v.constructor.name]);
  };
  var go = function(v) {
    return function(v1) {
      return function(v2) {
        return function(v3) {
          return function(v4) {
            if (v4 instanceof NilP) {
              return new MultNode([]);
            }
            ;
            if (v4 instanceof OptP) {
              if (greaterThan2(optVisibility(v4.value0))(Internal.value)) {
                return new Leaf2(v3({
                  hinfoMulti: v,
                  hinfoDefault: v1,
                  hinfoUnreachableArgs: v2
                })(v4.value0));
              }
              ;
              if (otherwise) {
                return new MultNode([]);
              }
              ;
            }
            ;
            if (v4 instanceof MultP) {
              return runExists(function(v5) {
                var r$prime = v2 || hasArg(v5.value0);
                return new MultNode([go(v)(v1)(v2)(v3)(v5.value0), go(v)(v1)(r$prime)(v3)(v5.value1)]);
              })(v4.value0);
            }
            ;
            if (v4 instanceof AltP) {
              var d$prime = v1 || (has_default(v4.value0) || has_default(v4.value1));
              return new AltNode([go(v)(d$prime)(v2)(v3)(v4.value0), go(v)(d$prime)(v2)(v3)(v4.value1)]);
            }
            ;
            if (v4 instanceof BindP) {
              return resume$prime(function(p) {
                return function(k) {
                  var go$prime = go(true)(v1)(v2)(v3)(p);
                  var v5 = evalParser(p);
                  if (v5 instanceof Nothing) {
                    return go$prime;
                  }
                  ;
                  if (v5 instanceof Just) {
                    return new MultNode([go$prime, go(true)(v1)(v2)(v3)(new BindP(k(v5.value0)))]);
                  }
                  ;
                  throw new Error("Failed pattern match at Options.Applicative.Common (line 267, column 12 - line 269, column 68): " + [v5.constructor.name]);
                };
              })($$const(new MultNode([])))(v4.value0);
            }
            ;
            throw new Error("Failed pattern match at Options.Applicative.Common (line 248, column 5 - line 251, column 21): " + [v.constructor.name, v1.constructor.name, v2.constructor.name, v3.constructor.name, v4.constructor.name]);
          };
        };
      };
    };
  };
  var $350 = go(false)(false)(false)(g);
  return function($351) {
    return simplify($350($351));
  };
};
var mapParser = function(f) {
  var flatten2 = function(v) {
    if (v instanceof Leaf2) {
      return [v.value0];
    }
    ;
    if (v instanceof MultNode) {
      return bind7(v.value0)(flatten2);
    }
    ;
    if (v instanceof AltNode) {
      return bind7(v.value0)(flatten2);
    }
    ;
    throw new Error("Failed pattern match at Options.Applicative.Common (line 235, column 5 - line 235, column 27): " + [v.constructor.name]);
  };
  var $352 = treeMapParser(f);
  return function($353) {
    return flatten2($352($353));
  };
};

// output/Options.Applicative.Builder.Internal/index.js
var over3 = /* @__PURE__ */ over()();
var append6 = /* @__PURE__ */ append(semigroupArray);
var map26 = /* @__PURE__ */ map(functorArray);
var lookup4 = /* @__PURE__ */ lookup(foldableArray)(eqString);
var alt4 = /* @__PURE__ */ alt(altMaybe);
var identity14 = /* @__PURE__ */ identity(categoryFn);
var apply9 = /* @__PURE__ */ apply2(applyMaybe);
var alt13 = /* @__PURE__ */ alt(parserAlt);
var pure15 = /* @__PURE__ */ pure(parserApplicative);
var OptionFields = function(x) {
  return x;
};
var FlagFields = function(x) {
  return x;
};
var DefaultProp = /* @__PURE__ */ function() {
  function DefaultProp2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  DefaultProp2.create = function(value0) {
    return function(value12) {
      return new DefaultProp2(value0, value12);
    };
  };
  return DefaultProp2;
}();
var Mod = /* @__PURE__ */ function() {
  function Mod2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  Mod2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new Mod2(value0, value12, value22);
      };
    };
  };
  return Mod2;
}();
var CommandFields = function(x) {
  return x;
};
var optionFieldsHasValue = {
  hasValueDummy: function(v) {
    return unit;
  }
};
var optionFieldsHasMetavar = {
  hasMetavarDummy: function(v) {
    return unit;
  }
};
var optionFieldsHasName = {
  name: function(n) {
    return over3(OptionFields)(function(fields) {
      return {
        optNames: append6([n])(fields.optNames),
        optCompleter: fields.optCompleter,
        optNoArgError: fields.optNoArgError
      };
    });
  }
};
var name2 = function(dict) {
  return dict.name;
};
var mkCommand = function(m) {
  var v = m.value0({
    cmdCommands: [],
    cmdGroup: Nothing.value
  });
  return new Tuple(v.cmdGroup, new Tuple(map26(fst)(v.cmdCommands), new Tuple(function(v1) {
    return lookup4(v1)(v.cmdCommands);
  }, unit)));
};
var flagFieldsHasName = {
  name: function(n) {
    return over3(FlagFields)(function(fields) {
      return {
        flagNames: append6([n])(fields.flagNames),
        flagActive: fields.flagActive
      };
    });
  }
};
var defaultPropSemigroup = {
  append: function(v) {
    return function(v1) {
      return new DefaultProp(alt4(v.value0)(v1.value0), alt4(v.value1)(v1.value1));
    };
  }
};
var append15 = /* @__PURE__ */ append(defaultPropSemigroup);
var modSemigroup = {
  append: function(v) {
    return function(v1) {
      return new Mod(function($69) {
        return v1.value0(v.value0($69));
      }, append15(v1.value1)(v.value1), function($70) {
        return v1.value2(v.value2($70));
      });
    };
  }
};
var defaultPropMonoid = /* @__PURE__ */ function() {
  return {
    mempty: new DefaultProp(Nothing.value, Nothing.value),
    Semigroup0: function() {
      return defaultPropSemigroup;
    }
  };
}();
var mempty5 = /* @__PURE__ */ mempty(defaultPropMonoid);
var fieldMod = function(f) {
  return new Mod(f, mempty5, identity14);
};
var modMonoid = /* @__PURE__ */ function() {
  return {
    mempty: new Mod(identity14, mempty5, identity14),
    Semigroup0: function() {
      return modSemigroup;
    }
  };
}();
var optionMod = /* @__PURE__ */ function() {
  return Mod.create(identity14)(mempty5);
}();
var internal = /* @__PURE__ */ optionMod(/* @__PURE__ */ over3(OptProperties)(function(p) {
  return {
    propVisibility: Internal.value,
    propDescMod: p.propDescMod,
    propHelp: p.propHelp,
    propMetaVar: p.propMetaVar,
    propShowDefault: p.propShowDefault
  };
}));
var commandFieldsHasMetavar = {
  hasMetavarDummy: function(v) {
    return unit;
  }
};
var baseProps = /* @__PURE__ */ function() {
  return {
    propMetaVar: "",
    propVisibility: Visible.value,
    propHelp: mempty(chunkMonoid(docSemigroup)),
    propShowDefault: Nothing.value,
    propDescMod: Nothing.value
  };
}();
var mkProps = function(v) {
  return function(g) {
    var props = over3(OptProperties)(function(r) {
      return {
        propShowDefault: apply9(v.value1)(v.value0),
        propDescMod: r.propDescMod,
        propHelp: r.propHelp,
        propMetaVar: r.propMetaVar,
        propVisibility: r.propVisibility
      };
    })(g(baseProps));
    return props;
  };
};
var mkOption = function(d) {
  return function(g) {
    return function(rdr) {
      return {
        optMain: rdr,
        optProps: mkProps(d)(g)
      };
    };
  };
};
var mkParser = function(v) {
  return function(g) {
    return function(rdr) {
      var o = liftOpt(mkOption(v)(g)(rdr));
      return maybe(o)(function(a) {
        return alt13(o)(pure15(a));
      })(v.value0);
    };
  };
};
var argumentFieldsHasMetavar = {
  hasMetavarDummy: function(v) {
    return unit;
  }
};

// output/Options.Applicative.Builder/index.js
var identity15 = /* @__PURE__ */ identity(categoryFn);
var over4 = /* @__PURE__ */ over()();
var un6 = /* @__PURE__ */ un();
var append7 = /* @__PURE__ */ append(modSemigroup);
var mempty6 = /* @__PURE__ */ mempty(completerMonoid);
var bind8 = /* @__PURE__ */ bind(readMBind);
var pure16 = /* @__PURE__ */ pure(readMApplicative);
var mempty12 = /* @__PURE__ */ mempty(/* @__PURE__ */ chunkMonoid(docSemigroup));
var min5 = /* @__PURE__ */ min(optVisibilityOrd);
var alt5 = /* @__PURE__ */ alt(parserAlt);
var pure17 = /* @__PURE__ */ pure(parserApplicative);
var show6 = /* @__PURE__ */ show(showString);
var append32 = /* @__PURE__ */ append(semigroupArray);
var mempty22 = /* @__PURE__ */ mempty(/* @__PURE__ */ monoidRecord()(/* @__PURE__ */ monoidRecordCons({
  reflectSymbol: function() {
    return "argCompleter";
  }
})(completerMonoid)()(monoidRecordNil)));
var fold5 = /* @__PURE__ */ fold(foldableArray)(modMonoid);
var PrefsMod = function(x) {
  return x;
};
var InfoMod = function(x) {
  return x;
};
var value = function(dictHasValue) {
  return function(x) {
    return new Mod(identity15, new DefaultProp(new Just(x), Nothing.value), identity15);
  };
};
var value1 = /* @__PURE__ */ value(optionFieldsHasValue);
var str = readerAsk;
var $$short = function(dictHasName) {
  var $121 = name2(dictHasName);
  return function($122) {
    return fieldMod($121(OptShort.create($122)));
  };
};
var progDesc = function(s) {
  return over4(ParserInfo)(function(i) {
    return {
      infoProgDesc: paragraph(s),
      infoFailureCode: i.infoFailureCode,
      infoFooter: i.infoFooter,
      infoFullDesc: i.infoFullDesc,
      infoHeader: i.infoHeader,
      infoParser: i.infoParser,
      infoPolicy: i.infoPolicy
    };
  });
};
var noArgError = function(e) {
  return fieldMod(over4(OptionFields)(function(p) {
    return {
      optNoArgError: $$const(e),
      optCompleter: p.optCompleter,
      optNames: p.optNames
    };
  }));
};
var prefs = function(m) {
  var base = {
    prefMultiSuffix: "",
    prefDisambiguate: false,
    prefShowHelpOnError: false,
    prefShowHelpOnEmpty: false,
    prefBacktrack: Backtrack.value,
    prefColumns: 80
  };
  return un6(PrefsMod)(m)(base);
};
var prefsModSemigroup = {
  append: function(m1) {
    return function(m2) {
      var $123 = un6(PrefsMod)(m2);
      var $124 = un6(PrefsMod)(m1);
      return function($125) {
        return $123($124($125));
      };
    };
  }
};
var prefsModMonoid = {
  mempty: identity15,
  Semigroup0: function() {
    return prefsModSemigroup;
  }
};
var metavar = function(dictHasMetavar) {
  return function($$var) {
    return optionMod(over4(OptProperties)(function(p) {
      return {
        propMetaVar: $$var,
        propDescMod: p.propDescMod,
        propHelp: p.propHelp,
        propShowDefault: p.propShowDefault,
        propVisibility: p.propVisibility
      };
    }));
  };
};
var metavar1 = /* @__PURE__ */ metavar(optionFieldsHasMetavar);
var option = function(r) {
  return function(m) {
    var v = append7(metavar1("ARG"))(m);
    var v1 = v.value0({
      optNames: [],
      optCompleter: mempty6,
      optNoArgError: ExpectsArgError.create
    });
    var crdr = {
      crCompleter: v1.optCompleter,
      crReader: r
    };
    var rdr = new OptReader(v1.optNames, crdr, v1.optNoArgError);
    return mkParser(v.value1)(v.value2)(rdr);
  };
};
var strOption = /* @__PURE__ */ option(str);
var $$long = function(dictHasName) {
  var $126 = name2(dictHasName);
  return function($127) {
    return fieldMod($126(OptLong.create($127)));
  };
};
var info = function(parser5) {
  return function(m) {
    var base = {
      infoParser: parser5,
      infoFullDesc: true,
      infoProgDesc: mempty12,
      infoHeader: mempty12,
      infoFooter: mempty12,
      infoFailureCode: $$Error.value,
      infoPolicy: Intersperse.value
    };
    return un6(InfoMod)(m)(base);
  };
};
var idm = function(dictMonoid) {
  return mempty(dictMonoid);
};
var hidden = /* @__PURE__ */ optionMod(/* @__PURE__ */ over4(OptProperties)(function(p) {
  return {
    propVisibility: min5(Hidden.value)(p.propVisibility),
    propDescMod: p.propDescMod,
    propHelp: p.propHelp,
    propMetaVar: p.propMetaVar,
    propShowDefault: p.propShowDefault
  };
}));
var help = function(s) {
  return optionMod(over4(OptProperties)(function(p) {
    return {
      propHelp: paragraph(s),
      propDescMod: p.propDescMod,
      propMetaVar: p.propMetaVar,
      propShowDefault: p.propShowDefault,
      propVisibility: p.propVisibility
    };
  }));
};
var flag$prime = function(actv) {
  return function(v) {
    var rdr = function() {
      var v1 = v.value0({
        flagNames: [],
        flagActive: actv
      });
      return new FlagReader(v1.flagNames, v1.flagActive);
    }();
    return mkParser(v.value1)(v.value2)(rdr);
  };
};
var flag = function(defv) {
  return function(actv) {
    return function(m) {
      return alt5(flag$prime(actv)(m))(pure17(defv));
    };
  };
};
var $$switch = /* @__PURE__ */ flag(false)(true);
var eitherReader = function(f) {
  return bind8(readerAsk)(function() {
    var $131 = either(readerError)(pure16);
    return function($132) {
      return $131(f($132));
    };
  }());
};
var $$int2 = /* @__PURE__ */ eitherReader(function(s) {
  var v = fromString2(s);
  if (v instanceof Nothing) {
    return new Left("Can't parse as Int: `" + (show6(s) + "`"));
  }
  ;
  if (v instanceof Just) {
    return new Right(v.value0);
  }
  ;
  throw new Error("Failed pattern match at Options.Applicative.Builder (line 124, column 28 - line 126, column 20): " + [v.constructor.name]);
});
var defaultPrefs = /* @__PURE__ */ prefs(/* @__PURE__ */ idm(prefsModMonoid));
var command = function(cmd) {
  return function(pinfo) {
    return fieldMod(over4(CommandFields)(function(p) {
      return {
        cmdCommands: append32([new Tuple(cmd, pinfo)])(p.cmdCommands),
        cmdGroup: p.cmdGroup
      };
    }));
  };
};
var argument = function(p) {
  return function(v) {
    var v1 = v.value0(mempty22);
    var rdr = {
      crCompleter: v1.argCompleter,
      crReader: p
    };
    return mkParser(v.value1)(v.value2)(new ArgReader(rdr));
  };
};
var strArgument = /* @__PURE__ */ argument(str);
var abortOption = function(err) {
  return function(m) {
    return option(readerAbort(err))(function(v) {
      return append7(v)(m);
    }(fold5([noArgError(err), value1(identity15), metavar1("")])));
  };
};

// output/Node.Encoding/index.js
var ASCII = /* @__PURE__ */ function() {
  function ASCII3() {
  }
  ;
  ASCII3.value = new ASCII3();
  return ASCII3;
}();
var UTF8 = /* @__PURE__ */ function() {
  function UTF82() {
  }
  ;
  UTF82.value = new UTF82();
  return UTF82;
}();
var UTF16LE = /* @__PURE__ */ function() {
  function UTF16LE2() {
  }
  ;
  UTF16LE2.value = new UTF16LE2();
  return UTF16LE2;
}();
var UCS2 = /* @__PURE__ */ function() {
  function UCS22() {
  }
  ;
  UCS22.value = new UCS22();
  return UCS22;
}();
var Base64 = /* @__PURE__ */ function() {
  function Base642() {
  }
  ;
  Base642.value = new Base642();
  return Base642;
}();
var Latin1 = /* @__PURE__ */ function() {
  function Latin12() {
  }
  ;
  Latin12.value = new Latin12();
  return Latin12;
}();
var Binary = /* @__PURE__ */ function() {
  function Binary2() {
  }
  ;
  Binary2.value = new Binary2();
  return Binary2;
}();
var Hex = /* @__PURE__ */ function() {
  function Hex2() {
  }
  ;
  Hex2.value = new Hex2();
  return Hex2;
}();
var showEncoding = {
  show: function(v) {
    if (v instanceof ASCII) {
      return "ASCII";
    }
    ;
    if (v instanceof UTF8) {
      return "UTF8";
    }
    ;
    if (v instanceof UTF16LE) {
      return "UTF16LE";
    }
    ;
    if (v instanceof UCS2) {
      return "UCS2";
    }
    ;
    if (v instanceof Base64) {
      return "Base64";
    }
    ;
    if (v instanceof Latin1) {
      return "Latin1";
    }
    ;
    if (v instanceof Binary) {
      return "Binary";
    }
    ;
    if (v instanceof Hex) {
      return "Hex";
    }
    ;
    throw new Error("Failed pattern match at Node.Encoding (line 19, column 1 - line 27, column 23): " + [v.constructor.name]);
  }
};
var encodingToNode = function(v) {
  if (v instanceof ASCII) {
    return "ascii";
  }
  ;
  if (v instanceof UTF8) {
    return "utf8";
  }
  ;
  if (v instanceof UTF16LE) {
    return "utf16le";
  }
  ;
  if (v instanceof UCS2) {
    return "ucs2";
  }
  ;
  if (v instanceof Base64) {
    return "base64";
  }
  ;
  if (v instanceof Latin1) {
    return "latin1";
  }
  ;
  if (v instanceof Binary) {
    return "binary";
  }
  ;
  if (v instanceof Hex) {
    return "hex";
  }
  ;
  throw new Error("Failed pattern match at Node.Encoding (line 31, column 1 - line 31, column 37): " + [v.constructor.name]);
};

// output/Node.Stream/foreign.js
function readChunkImpl(Left2) {
  return (Right2) => (chunk) => {
    if (chunk instanceof Buffer) {
      return Right2(chunk);
    } else if (typeof chunk === "string") {
      return Left2(chunk);
    } else {
      throw new Error(
        "Node.Stream.readChunkImpl: Unrecognised chunk type; expected String or Buffer, got: " + chunk
      );
    }
  };
}
function onDataEitherImpl(readChunk2) {
  return (r) => (f) => () => {
    r.on("data", (data) => {
      f(readChunk2(data))();
    });
  };
}
function onError(s) {
  return (f) => () => {
    s.on("error", (e) => {
      f(e)();
    });
  };
}
function pipe(r) {
  return (w) => () => r.pipe(w);
}
function writeImpl(w) {
  return (chunk) => (done) => () => w.write(chunk, null, done);
}
function writeStringImpl(w) {
  return (enc) => (s) => (done) => () => w.write(s, enc, done);
}
function endImpl(w) {
  return (done) => () => {
    w.end(null, null, done);
  };
}
function destroy(strm) {
  return () => {
    strm.destroy(null);
  };
}

// output/Data.Nullable/foreign.js
var nullImpl = null;
function nullable(a, r, f) {
  return a == null ? r : f(a);
}
function notNull(x) {
  return x;
}

// output/Data.Nullable/index.js
var toNullable = /* @__PURE__ */ maybe(nullImpl)(notNull);
var toMaybe = function(n) {
  return nullable(n, Nothing.value, Just.create);
};

// output/Node.Buffer.Class/index.js
var unsafeThaw2 = function(dict) {
  return dict.unsafeThaw;
};
var unsafeFreeze2 = function(dict) {
  return dict.unsafeFreeze;
};
var toString4 = function(dict) {
  return dict.toString;
};
var slice3 = function(dict) {
  return dict.slice;
};
var size4 = function(dict) {
  return dict.size;
};
var fromString5 = function(dict) {
  return dict.fromString;
};
var fromArrayBuffer = function(dict) {
  return dict.fromArrayBuffer;
};
var create = function(dict) {
  return dict.create;
};
var concat$prime = function(dict) {
  return dict["concat'"];
};

// output/Node.Buffer.Internal/foreign.js
function copyAll(a) {
  return () => {
    return Buffer.from(a);
  };
}
function writeInternal(ty) {
  return (value4) => {
    return (offset) => {
      return (buf) => {
        return () => {
          buf["write" + ty](value4, offset);
        };
      };
    };
  };
}
function writeStringInternal(encoding) {
  return (offset) => {
    return (length7) => {
      return (value4) => {
        return (buff) => {
          return () => {
            return buff.write(value4, offset, length7, encoding);
          };
        };
      };
    };
  };
}
function setAtOffset(value4) {
  return (offset) => {
    return (buff) => {
      return () => {
        buff[offset] = value4;
      };
    };
  };
}
function copy(srcStart) {
  return (srcEnd) => {
    return (src) => {
      return (targStart) => {
        return (targ) => {
          return () => {
            return src.copy(targ, targStart, srcStart, srcEnd);
          };
        };
      };
    };
  };
}
function fill(octet) {
  return (start) => {
    return (end4) => {
      return (buf) => {
        return () => {
          buf.fill(octet, start, end4);
        };
      };
    };
  };
}

// output/Node.Buffer.Immutable/foreign.js
function create2(size10) {
  return Buffer.alloc(size10);
}
function fromArray2(octets) {
  return Buffer.from(octets);
}
function size5(buff) {
  return buff.length;
}
function toArray3(buff) {
  var json4 = buff.toJSON();
  return json4.data || json4;
}
function toArrayBuffer(buff) {
  return buff.buffer.slice(buff.byteOffset, buff.byteOffset + buff.byteLength);
}
function fromArrayBuffer2(ab) {
  return Buffer.from(ab);
}
function fromStringImpl2(str2) {
  return (encoding) => {
    return Buffer.from(str2, encoding);
  };
}
function readImpl(ty) {
  return (offset) => {
    return (buf) => {
      return buf["read" + ty](offset);
    };
  };
}
function readStringImpl(enc) {
  return (start) => {
    return (end4) => {
      return (buff) => {
        return buff.toString(enc, start, end4);
      };
    };
  };
}
function getAtOffsetImpl(just) {
  return (nothing) => {
    return (offset) => {
      return (buff) => {
        var octet = buff[offset];
        return octet == null ? nothing : just(octet);
      };
    };
  };
}
function toStringImpl(enc) {
  return (buff) => {
    return buff.toString(enc);
  };
}
function slice4(start) {
  return (end4) => {
    return (buff) => {
      return buff.slice(start, end4);
    };
  };
}
function concat3(buffs) {
  return Buffer.concat(buffs);
}
function concatToLength(buffs) {
  return (totalLength) => {
    return Buffer.concat(buffs, totalLength);
  };
}

// output/Node.Buffer.Types/index.js
var UInt8 = /* @__PURE__ */ function() {
  function UInt82() {
  }
  ;
  UInt82.value = new UInt82();
  return UInt82;
}();
var UInt16LE = /* @__PURE__ */ function() {
  function UInt16LE2() {
  }
  ;
  UInt16LE2.value = new UInt16LE2();
  return UInt16LE2;
}();
var UInt16BE = /* @__PURE__ */ function() {
  function UInt16BE2() {
  }
  ;
  UInt16BE2.value = new UInt16BE2();
  return UInt16BE2;
}();
var UInt32LE = /* @__PURE__ */ function() {
  function UInt32LE2() {
  }
  ;
  UInt32LE2.value = new UInt32LE2();
  return UInt32LE2;
}();
var UInt32BE = /* @__PURE__ */ function() {
  function UInt32BE2() {
  }
  ;
  UInt32BE2.value = new UInt32BE2();
  return UInt32BE2;
}();
var Int8 = /* @__PURE__ */ function() {
  function Int82() {
  }
  ;
  Int82.value = new Int82();
  return Int82;
}();
var Int16LE = /* @__PURE__ */ function() {
  function Int16LE2() {
  }
  ;
  Int16LE2.value = new Int16LE2();
  return Int16LE2;
}();
var Int16BE = /* @__PURE__ */ function() {
  function Int16BE2() {
  }
  ;
  Int16BE2.value = new Int16BE2();
  return Int16BE2;
}();
var Int32LE = /* @__PURE__ */ function() {
  function Int32LE2() {
  }
  ;
  Int32LE2.value = new Int32LE2();
  return Int32LE2;
}();
var Int32BE = /* @__PURE__ */ function() {
  function Int32BE2() {
  }
  ;
  Int32BE2.value = new Int32BE2();
  return Int32BE2;
}();
var FloatLE = /* @__PURE__ */ function() {
  function FloatLE2() {
  }
  ;
  FloatLE2.value = new FloatLE2();
  return FloatLE2;
}();
var FloatBE = /* @__PURE__ */ function() {
  function FloatBE2() {
  }
  ;
  FloatBE2.value = new FloatBE2();
  return FloatBE2;
}();
var DoubleLE = /* @__PURE__ */ function() {
  function DoubleLE2() {
  }
  ;
  DoubleLE2.value = new DoubleLE2();
  return DoubleLE2;
}();
var DoubleBE = /* @__PURE__ */ function() {
  function DoubleBE2() {
  }
  ;
  DoubleBE2.value = new DoubleBE2();
  return DoubleBE2;
}();
var showBufferValueType = {
  show: function(v) {
    if (v instanceof UInt8) {
      return "UInt8";
    }
    ;
    if (v instanceof UInt16LE) {
      return "UInt16LE";
    }
    ;
    if (v instanceof UInt16BE) {
      return "UInt16BE";
    }
    ;
    if (v instanceof UInt32LE) {
      return "UInt32LE";
    }
    ;
    if (v instanceof UInt32BE) {
      return "UInt32BE";
    }
    ;
    if (v instanceof Int8) {
      return "Int8";
    }
    ;
    if (v instanceof Int16LE) {
      return "Int16LE";
    }
    ;
    if (v instanceof Int16BE) {
      return "Int16BE";
    }
    ;
    if (v instanceof Int32LE) {
      return "Int32LE";
    }
    ;
    if (v instanceof Int32BE) {
      return "Int32BE";
    }
    ;
    if (v instanceof FloatLE) {
      return "FloatLE";
    }
    ;
    if (v instanceof FloatBE) {
      return "FloatBE";
    }
    ;
    if (v instanceof DoubleLE) {
      return "DoubleLE";
    }
    ;
    if (v instanceof DoubleBE) {
      return "DoubleBE";
    }
    ;
    throw new Error("Failed pattern match at Node.Buffer.Types (line 33, column 1 - line 47, column 29): " + [v.constructor.name]);
  }
};

// output/Node.Buffer.Immutable/index.js
var toString5 = function($7) {
  return toStringImpl(encodingToNode($7));
};
var readString2 = function($8) {
  return readStringImpl(encodingToNode($8));
};
var read3 = /* @__PURE__ */ function() {
  var $9 = show(showBufferValueType);
  return function($10) {
    return readImpl($9($10));
  };
}();
var getAtOffset = /* @__PURE__ */ function() {
  return getAtOffsetImpl(Just.create)(Nothing.value);
}();
var fromString6 = function(str2) {
  var $11 = fromStringImpl2(str2);
  return function($12) {
    return $11(encodingToNode($12));
  };
};
var concat$prime2 = concatToLength;

// output/Node.Buffer.Internal/index.js
var show7 = /* @__PURE__ */ show(showBufferValueType);
var writeString = function(dictMonad) {
  return function($43) {
    return writeStringInternal(encodingToNode($43));
  };
};
var write3 = function(dictMonad) {
  return function($44) {
    return writeInternal(show7($44));
  };
};
var unsafeThaw3 = function(dictMonad) {
  var $45 = pure(dictMonad.Applicative0());
  return function($46) {
    return $45($46);
  };
};
var usingToImmutable = function(dictMonad) {
  var unsafeThaw1 = unsafeThaw3(dictMonad);
  return function(f) {
    return function(x) {
      return unsafeThaw1(f(x));
    };
  };
};
var unsafeFreeze3 = function(dictMonad) {
  var $47 = pure(dictMonad.Applicative0());
  return function($48) {
    return $47($48);
  };
};
var usingFromImmutable = function(dictMonad) {
  var map86 = map(dictMonad.Bind1().Apply0().Functor0());
  var unsafeFreeze1 = unsafeFreeze3(dictMonad);
  return function(f) {
    return function(buf) {
      return map86(f)(unsafeFreeze1(buf));
    };
  };
};
var toString6 = function(dictMonad) {
  var usingFromImmutable1 = usingFromImmutable(dictMonad);
  return function(m) {
    return usingFromImmutable1(toString5(m));
  };
};
var toArrayBuffer2 = function(dictMonad) {
  return usingFromImmutable(dictMonad)(toArrayBuffer);
};
var toArray4 = function(dictMonad) {
  return usingFromImmutable(dictMonad)(toArray3);
};
var slice5 = slice4;
var size6 = function(dictMonad) {
  return usingFromImmutable(dictMonad)(size5);
};
var readString3 = function(dictMonad) {
  var usingFromImmutable1 = usingFromImmutable(dictMonad);
  return function(m) {
    return function(o) {
      return function(o$prime) {
        return usingFromImmutable1(readString2(m)(o)(o$prime));
      };
    };
  };
};
var read4 = function(dictMonad) {
  var usingFromImmutable1 = usingFromImmutable(dictMonad);
  return function(t) {
    return function(o) {
      return usingFromImmutable1(read3(t)(o));
    };
  };
};
var getAtOffset2 = function(dictMonad) {
  var usingFromImmutable1 = usingFromImmutable(dictMonad);
  return function(o) {
    return usingFromImmutable1(getAtOffset(o));
  };
};
var fromString7 = function(dictMonad) {
  var usingToImmutable1 = usingToImmutable(dictMonad);
  return function(s) {
    return usingToImmutable1(fromString6(s));
  };
};
var fromArrayBuffer3 = function(dictMonad) {
  return usingToImmutable(dictMonad)(fromArrayBuffer2);
};
var fromArray3 = function(dictMonad) {
  return usingToImmutable(dictMonad)(fromArray2);
};
var create3 = function(dictMonad) {
  return usingToImmutable(dictMonad)(create2);
};
var concat$prime3 = function(dictMonad) {
  return function(arrs) {
    return function(n) {
      return function(v) {
        return concat$prime2(arrs)(n);
      };
    };
  };
};
var concat4 = function(arrs) {
  return function(v) {
    return concat3(arrs);
  };
};

// output/Node.Buffer/index.js
var mutableBufferEffect = {
  create: /* @__PURE__ */ create3(monadEffect),
  freeze: copyAll,
  unsafeFreeze: /* @__PURE__ */ unsafeFreeze3(monadEffect),
  thaw: copyAll,
  unsafeThaw: /* @__PURE__ */ unsafeThaw3(monadEffect),
  fromArray: /* @__PURE__ */ fromArray3(monadEffect),
  fromString: /* @__PURE__ */ fromString7(monadEffect),
  fromArrayBuffer: /* @__PURE__ */ fromArrayBuffer3(monadEffect),
  toArrayBuffer: /* @__PURE__ */ toArrayBuffer2(monadEffect),
  read: /* @__PURE__ */ read4(monadEffect),
  readString: /* @__PURE__ */ readString3(monadEffect),
  toString: /* @__PURE__ */ toString6(monadEffect),
  write: /* @__PURE__ */ write3(monadEffect),
  writeString: /* @__PURE__ */ writeString(monadEffect),
  toArray: /* @__PURE__ */ toArray4(monadEffect),
  getAtOffset: /* @__PURE__ */ getAtOffset2(monadEffect),
  setAtOffset,
  slice: slice5,
  size: /* @__PURE__ */ size6(monadEffect),
  concat: concat4,
  "concat'": /* @__PURE__ */ concat$prime3(monadEffect),
  copy,
  fill,
  Monad0: function() {
    return monadEffect;
  }
};

// output/Node.Stream/index.js
var show8 = /* @__PURE__ */ show(showEncoding);
var pure18 = /* @__PURE__ */ pure(applicativeEffect);
var composeKleisliFlipped3 = /* @__PURE__ */ composeKleisliFlipped(bindEffect);
var writeString3 = function(w) {
  return function(enc) {
    return function(s) {
      return function(cb) {
        return writeStringImpl(w)(show8(enc))(s)(function($20) {
          return cb(toMaybe($20))();
        });
      };
    };
  };
};
var write5 = function(w) {
  return function(b) {
    return function(cb) {
      return writeImpl(w)(b)(function($21) {
        return cb(toMaybe($21))();
      });
    };
  };
};
var readChunk = /* @__PURE__ */ function() {
  return readChunkImpl(Left.create)(Right.create);
}();
var onDataEither = function(r) {
  return function(cb) {
    return onDataEitherImpl(readChunk)(r)(cb);
  };
};
var onData = function(r) {
  return function(cb) {
    var fromEither = function(x) {
      if (x instanceof Left) {
        return $$throw("Stream encoding should not be set");
      }
      ;
      if (x instanceof Right) {
        return pure18(x.value0);
      }
      ;
      throw new Error("Failed pattern match at Node.Stream (line 97, column 5 - line 101, column 17): " + [x.constructor.name]);
    };
    return onDataEither(r)(composeKleisliFlipped3(cb)(fromEither));
  };
};
var end = function(w) {
  return function(cb) {
    return endImpl(w)(function($22) {
      return cb(toMaybe($22))();
    });
  };
};

// output/Options.Applicative.BashCompletion/index.js
var pure19 = /* @__PURE__ */ pure(applicativeEffect);
var un7 = /* @__PURE__ */ un();
var map27 = /* @__PURE__ */ map(functorMaybe);
var map113 = /* @__PURE__ */ map(functorArray);
var runParserInfo2 = /* @__PURE__ */ runParserInfo(completionMonadP);
var fromFoldable12 = /* @__PURE__ */ fromFoldable5(foldableArray);
var identity16 = /* @__PURE__ */ identity(categoryFn);
var bind9 = /* @__PURE__ */ bind(bindMaybe);
var notEq3 = /* @__PURE__ */ notEq(argPolicyEq);
var map28 = /* @__PURE__ */ map(functorEffect);
var fold6 = /* @__PURE__ */ fold(foldableArray)(monoidArray);
var sequence2 = /* @__PURE__ */ sequence(traversableArray)(applicativeEffect);
var unLines2 = /* @__PURE__ */ unLines(foldableArray);
var alt6 = /* @__PURE__ */ alt(parserAlt);
var map33 = /* @__PURE__ */ map(parserFunctor);
var apply10 = /* @__PURE__ */ apply2(parserApply);
var append16 = /* @__PURE__ */ append(modSemigroup);
var $$long2 = /* @__PURE__ */ $$long(flagFieldsHasName);
var long1 = /* @__PURE__ */ $$long(optionFieldsHasName);
var value2 = /* @__PURE__ */ value(optionFieldsHasValue);
var pure110 = /* @__PURE__ */ pure(parserApplicative);
var fromFoldable1 = /* @__PURE__ */ fromFoldable(foldableList);
var Standard = /* @__PURE__ */ function() {
  function Standard2() {
  }
  ;
  Standard2.value = new Standard2();
  return Standard2;
}();
var Enriched = /* @__PURE__ */ function() {
  function Enriched2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Enriched2.create = function(value0) {
    return function(value12) {
      return new Enriched2(value0, value12);
    };
  };
  return Enriched2;
}();
var zshCompletionScript = function(prog) {
  return function(progn) {
    return pure19(["#compdef " + progn, "", "local request", "local completions", "local word", "local index=$((CURRENT - 1))", "", "request=(--bash-completion-enriched --bash-completion-index $index)", "for arg in ${words[@]}; do", "  request=(${request[@]} --bash-completion-word $arg)", "done", "", "IFS=$'\\n' completions=($( " + (prog + ' "${request[@]}" ))'), "", "for word in $completions; do", "  local -a parts", "", "  # Split the line at a tab if there is one.", "  IFS=$'\\t' parts=($( echo $word ))", "", "  if [[ -n $parts[2] ]]; then", '     if [[ $word[1] == "-" ]]; then', '       local desc=("$parts[1] ($parts[2])")', "       compadd -d desc -- $parts[1]", "     else", '       local desc=($(print -f  "%-019s -- %s" $parts[1] $parts[2]))', "       compadd -l -d desc -- $parts[1]", "     fi", "  else", "    compadd -f -- $word", "  fi", "done"]);
  };
};
var fishCompletionScript = function(prog) {
  return function(progn) {
    return pure19([" function _" + progn, "    set -l cl (commandline --tokenize --current-process)", "    # Hack around fish issue #3934", "    set -l cn (commandline --tokenize --cut-at-cursor --current-process)", "    set -l cn (count $cn)", "    set -l tmpline --bash-completion-enriched --bash-completion-index $cn", "    for arg in $cl", "      set tmpline $tmpline --bash-completion-word $arg", "    end", "    for opt in (" + (prog + " $tmpline)"), "      if test -d $opt", '        echo -E "$opt/"', "      else", '        echo -E "$opt"', "      end", "    end", "end", "", "complete --no-files --command " + (progn + (" --arguments '(_" + (progn + ")'")))]);
  };
};
var bashCompletionScript = function(prog) {
  return function(progn) {
    return pure19(["_" + (progn + "()"), "{", "    local CMDLINE", "    local IFS=$'\\n'", "    CMDLINE=(--bash-completion-index $COMP_CWORD)", "", "    for arg in ${COMP_WORDS[@]}; do", "        CMDLINE=(${CMDLINE[@]} --bash-completion-word $arg)", "    done", "", "    COMPREPLY=( $(" + (prog + ' "${CMDLINE[@]}") )'), "}", "", "complete -o filenames -F _" + (progn + (" " + progn))]);
  };
};
var arraySplitAt = function(idx) {
  return function(arr) {
    if (idx === 0) {
      return {
        init: [],
        rest: arr
      };
    }
    ;
    return {
      init: slice(0)(idx)(arr),
      rest: slice(idx)(length(arr))(arr)
    };
  };
};
var bashCompletionQuery = function(pinfo) {
  return function(pprefs) {
    return function(richness) {
      return function(ws) {
        return function(i) {
          return function(v) {
            var v1 = arraySplitAt(i)(ws);
            var run_completer = function(c) {
              return un7(Completer)(c)(fromMaybe("")(head(v1.rest)));
            };
            var render_line = function(len) {
              return function(doc) {
                var v22 = map27(uncons2)(fromArray(lines2(displayS(renderPretty(1)(len)(doc)))));
                if (v22 instanceof Nothing) {
                  return "";
                }
                ;
                if (v22 instanceof Just && v22.value0.tail.length === 0) {
                  return v22.value0.head;
                }
                ;
                if (v22 instanceof Just) {
                  return v22.value0.head + "...";
                }
                ;
                throw new Error("Failed pattern match at Options.Applicative.BashCompletion (line 162, column 27 - line 165, column 43): " + [v22.constructor.name]);
              };
            };
            var is_completion = function() {
              var v22 = head(v1.rest);
              if (v22 instanceof Just) {
                return startsWith(v22.value0);
              }
              ;
              if (v22 instanceof Nothing) {
                return $$const(true);
              }
              ;
              throw new Error("Failed pattern match at Options.Applicative.BashCompletion (line 175, column 7 - line 177, column 30): " + [v22.constructor.name]);
            }();
            var filter_names = filter(is_completion);
            var show_names = function() {
              var $129 = map113(showOption);
              return function($130) {
                return filter_names($129($130));
              };
            }();
            var compl = runParserInfo2(pinfo)(fromFoldable12(drop(1)(v1.init)));
            var add_opt_help = function(dictFunctor) {
              var map414 = map(dictFunctor);
              return function(opt) {
                if (richness instanceof Standard) {
                  return identity16;
                }
                ;
                if (richness instanceof Enriched) {
                  return map414(function(o) {
                    var h = un7(Chunk)(optHelp(opt));
                    return maybe(o)(function(h$prime) {
                      return o + ("	" + render_line(richness.value0)(h$prime));
                    })(h);
                  });
                }
                ;
                throw new Error("Failed pattern match at Options.Applicative.BashCompletion (line 138, column 24 - line 143, column 79): " + [richness.constructor.name]);
              };
            };
            var add_opt_help1 = add_opt_help(functorArray);
            var add_cmd_help = function(dictFunctor) {
              var map414 = map(dictFunctor);
              return function(p) {
                if (richness instanceof Standard) {
                  return identity16;
                }
                ;
                if (richness instanceof Enriched) {
                  return map414(function(cmd) {
                    var h = bind9(p(cmd))(function() {
                      var $131 = un7(Chunk);
                      var $132 = un7(ParserInfo);
                      return function($133) {
                        return $131(function(v22) {
                          return v22.infoProgDesc;
                        }($132($133)));
                      };
                    }());
                    return maybe(cmd)(function(h$prime) {
                      return cmd + ("	" + render_line(richness.value1)(h$prime));
                    })(h);
                  });
                }
                ;
                throw new Error("Failed pattern match at Options.Applicative.BashCompletion (line 148, column 22 - line 153, column 85): " + [richness.constructor.name]);
              };
            };
            var add_cmd_help1 = add_cmd_help(functorArray);
            var opt_completions = function(argPolicy) {
              return function(hinfo) {
                return function(opt) {
                  var v22 = un7(Option)(opt).optMain;
                  if (v22 instanceof OptReader) {
                    if (notEq3(argPolicy)(AllPositionals.value)) {
                      return pure19(add_opt_help1(opt)(show_names(v22.value0)));
                    }
                    ;
                    if (otherwise) {
                      return pure19([]);
                    }
                    ;
                  }
                  ;
                  if (v22 instanceof FlagReader) {
                    if (notEq3(argPolicy)(AllPositionals.value)) {
                      return pure19(add_opt_help1(opt)(show_names(v22.value0)));
                    }
                    ;
                    if (otherwise) {
                      return pure19([]);
                    }
                    ;
                  }
                  ;
                  if (v22 instanceof ArgReader) {
                    if (un7(OptHelpInfo)(hinfo).hinfoUnreachableArgs) {
                      return pure19([]);
                    }
                    ;
                    if (otherwise) {
                      return run_completer(un7(CReader)(v22.value0).crCompleter);
                    }
                    ;
                  }
                  ;
                  if (v22 instanceof CmdReader) {
                    if (un7(OptHelpInfo)(hinfo).hinfoUnreachableArgs) {
                      return pure19([]);
                    }
                    ;
                    if (otherwise) {
                      return pure19(add_cmd_help1(v22.value2)(filter_names(v22.value1)));
                    }
                    ;
                  }
                  ;
                  throw new Error("Failed pattern match at Options.Applicative.BashCompletion (line 113, column 43 - line 133, column 53): " + [v22.constructor.name]);
                };
              };
            };
            var list_options = function(a) {
              var $134 = map28(fold6);
              var $135 = mapParser(opt_completions(a));
              return function($136) {
                return $134(sequence2($135($136)));
              };
            };
            var v2 = runCompletion(compl)(pprefs);
            if (v2 instanceof Just && v2.value0 instanceof Left) {
              return runExists(function(p) {
                return list_options(v2.value0.value0.value1)(p);
              })(v2.value0.value0.value0.value0);
            }
            ;
            if (v2 instanceof Just && v2.value0 instanceof Right) {
              return run_completer(v2.value0.value0);
            }
            ;
            if (v2 instanceof Nothing) {
              return pure19([]);
            }
            ;
            throw new Error("Failed pattern match at Options.Applicative.BashCompletion (line 83, column 52 - line 89, column 15): " + [v2.constructor.name]);
          };
        };
      };
    };
  };
};
var bashCompletionParser = function(pinfo) {
  return function(pprefs) {
    var failure = function(opts) {
      return {
        execCompletion: function(progn) {
          return map28(unLines2)(opts(progn));
        }
      };
    };
    var complParser = alt6(map33(failure)(apply10(apply10(map33(bashCompletionQuery(pinfo)(pprefs))(alt6(apply10(apply10(flag$prime(Enriched.create)(append16($$long2("bash-completion-enriched"))(internal)))(option($$int2)(append16(append16(long1("bash-completion-option-desc-length"))(internal))(value2(40)))))(option($$int2)(append16(append16(long1("bash-completion-command-desc-length"))(internal))(value2(40)))))(pure110(Standard.value))))(map33(fromFoldable1)(many3(strOption(append16(long1("bash-completion-word"))(internal))))))(option($$int2)(append16(long1("bash-completion-index"))(internal)))))(alt6(map33(failure)(map33(bashCompletionScript)(strOption(append16(long1("bash-completion-script"))(internal)))))(alt6(map33(failure)(map33(fishCompletionScript)(strOption(append16(long1("fish-completion-script"))(internal)))))(map33(failure)(map33(zshCompletionScript)(strOption(append16(long1("zsh-completion-script"))(internal)))))));
    return complParser;
  };
};

// output/Options.Applicative.Help.Core/index.js
var over5 = /* @__PURE__ */ over()();
var mempty7 = /* @__PURE__ */ mempty(parserHelpMonoid);
var fold7 = /* @__PURE__ */ fold2(monoidArray);
var un8 = /* @__PURE__ */ un();
var chunkMonoid3 = /* @__PURE__ */ chunkMonoid(docSemigroup);
var mempty13 = /* @__PURE__ */ mempty(chunkMonoid3);
var eq16 = /* @__PURE__ */ eq(optVisibilityEq);
var map29 = /* @__PURE__ */ map(functorArray);
var sort2 = /* @__PURE__ */ sort(optNameOrd);
var append8 = /* @__PURE__ */ append(/* @__PURE__ */ chunkSemigroup(docSemigroup));
var map114 = /* @__PURE__ */ map(chunkFunctor);
var listToChunk2 = /* @__PURE__ */ listToChunk(docMonoid);
var identity17 = /* @__PURE__ */ identity(categoryFn);
var map210 = /* @__PURE__ */ map(functorMaybe);
var discard4 = /* @__PURE__ */ discard(discardUnit)(bindMaybe);
var guard4 = /* @__PURE__ */ guard2(alternativeMaybe);
var pure20 = /* @__PURE__ */ pure(applicativeMaybe);
var extractChunk3 = /* @__PURE__ */ extractChunk(docMonoid);
var bind10 = /* @__PURE__ */ bind(bindArray);
var pure111 = /* @__PURE__ */ pure(applicativeArray);
var mempty23 = /* @__PURE__ */ mempty(/* @__PURE__ */ monoidTuple(/* @__PURE__ */ monoidMaybe(semigroupString))(chunkMonoid3));
var append17 = /* @__PURE__ */ append(semigroupArray);
var eq24 = /* @__PURE__ */ eq(/* @__PURE__ */ eqMaybe(eqString));
var OptDescStyle = function(x) {
  return x;
};
var usageHelp = function(chunk) {
  return over5(ParserHelp)(function(v) {
    return {
      helpUsage: chunk,
      helpBody: v.helpBody,
      helpError: v.helpError,
      helpFooter: v.helpFooter,
      helpHeader: v.helpHeader,
      helpSuggestions: v.helpSuggestions
    };
  })(mempty7);
};
var suggestionsHelp = function(chunk) {
  return over5(ParserHelp)(function(v) {
    return {
      helpSuggestions: chunk,
      helpBody: v.helpBody,
      helpError: v.helpError,
      helpFooter: v.helpFooter,
      helpHeader: v.helpHeader,
      helpUsage: v.helpUsage
    };
  })(mempty7);
};
var intersperse2 = function(sep2) {
  var $64 = mapWithIndex2(function(idx) {
    return function(e) {
      var $49 = idx === 0;
      if ($49) {
        return [e];
      }
      ;
      return [sep2, e];
    };
  });
  return function($65) {
    return fold7($64($65));
  };
};
var optDesc = function(pprefs) {
  return function(style) {
    return function(info4) {
      return function(opt) {
        var suffix2 = function() {
          if (un8(OptHelpInfo)(info4).hinfoMulti) {
            return stringChunk(un8(ParserPrefs)(pprefs).prefMultiSuffix);
          }
          ;
          if (otherwise) {
            return mempty13;
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Help.Core (line 58, column 7 - line 62, column 17): " + []);
        }();
        var show_opt = function() {
          if (un8(OptHelpInfo)(info4).hinfoDefault && !un8(OptDescStyle)(style).descOptional) {
            return false;
          }
          ;
          if (eq16(optVisibility(opt))(Hidden.value)) {
            return un8(OptDescStyle)(style).descHidden;
          }
          ;
          if (otherwise) {
            return eq16(optVisibility(opt))(Visible.value);
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Help.Core (line 51, column 7 - line 57, column 39): " + []);
        }();
        var ns = optionNames(un8(Option)(opt).optMain);
        var mv = stringChunk(optMetaVar(opt));
        var descs = map29(function($66) {
          return string2(showOption($66));
        })(sort2(ns));
        var render = function(chunk) {
          if (!show_opt) {
            return mempty13;
          }
          ;
          if (isEmpty5(chunk) || !un8(OptDescStyle)(style).descSurround) {
            return append8(chunk)(suffix2);
          }
          ;
          if (un8(OptHelpInfo)(info4).hinfoDefault) {
            return append8(map114(brackets)(chunk))(suffix2);
          }
          ;
          if ($$null(drop(1)(descs))) {
            return append8(chunk)(suffix2);
          }
          ;
          if (otherwise) {
            return append8(map114(parens)(chunk))(suffix2);
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Help.Core (line 63, column 7 - line 73, column 43): " + [chunk.constructor.name]);
        };
        var desc$prime = chunkBeside(listToChunk2(intersperse2(un8(OptDescStyle)(style).descSep)(descs)))(mv);
        return maybe(identity17)(map114)(optDescMod(opt))(render(desc$prime));
      };
    };
  };
};
var headerHelp = function(chunk) {
  return over5(ParserHelp)(function(v) {
    return {
      helpHeader: chunk,
      helpBody: v.helpBody,
      helpError: v.helpError,
      helpFooter: v.helpFooter,
      helpSuggestions: v.helpSuggestions,
      helpUsage: v.helpUsage
    };
  })(mempty7);
};
var fullDesc = function(pprefs) {
  var style = {
    descSep: string2(","),
    descHidden: true,
    descOptional: true,
    descSurround: false
  };
  var doc = function(info4) {
    return function(opt) {
      var show_def = function(s) {
        return parens(appendWithSpace(string2("default:"))(string2(s)));
      };
      var n = optDesc(pprefs)(style)(info4)(opt);
      var hdef = map210(show_def)(optShowDefault(opt));
      var h = optHelp(opt);
      return discard4(guard4(!isEmpty5(n)))(function() {
        return discard4(guard4(!isEmpty5(h)))(function() {
          return pure20(new Tuple(extractChunk3(n), align(extractChunk3(chunkBeside(h)(hdef)))));
        });
      });
    };
  };
  var $67 = mapParser(doc);
  return function($68) {
    return tabulate(catMaybes($67($68)));
  };
};
var footerHelp = function(chunk) {
  return over5(ParserHelp)(function(v) {
    return {
      helpFooter: chunk,
      helpBody: v.helpBody,
      helpError: v.helpError,
      helpHeader: v.helpHeader,
      helpSuggestions: v.helpSuggestions,
      helpUsage: v.helpUsage
    };
  })(mempty7);
};
var fold_tree = function(v) {
  if (v instanceof Leaf2) {
    return v.value0;
  }
  ;
  if (v instanceof MultNode) {
    return foldr2(function($69) {
      return chunkBesideOrBelow(fold_tree($69));
    })(mempty13)(v.value0);
  }
  ;
  if (v instanceof AltNode) {
    var alt_node = function(v1) {
      if (v1.length === 1) {
        return v1[0];
      }
      ;
      return map114(parens)(foldr2(chunked(function(x) {
        return function(y) {
          return appendWithSoftline(x)(appendWithSoftline($$char2("|"))(y));
        };
      }))(mempty13)(v1));
    };
    return alt_node(filter(function($70) {
      return !isEmpty5($70);
    })(map29(fold_tree)(v.value0)));
  }
  ;
  throw new Error("Failed pattern match at Options.Applicative.Help.Core (line 116, column 1 - line 116, column 46): " + [v.constructor.name]);
};
var errorHelp = function(chunk) {
  return over5(ParserHelp)(function(v) {
    return {
      helpError: chunk,
      helpBody: v.helpBody,
      helpFooter: v.helpFooter,
      helpHeader: v.helpHeader,
      helpSuggestions: v.helpSuggestions,
      helpUsage: v.helpUsage
    };
  })(mempty7);
};
var cmdDesc = /* @__PURE__ */ function() {
  var desc = function(v) {
    return function(opt) {
      var v1 = un8(Option)(opt).optMain;
      if (v1 instanceof CmdReader) {
        return new Tuple(v1.value0, tabulate(bind10(reverse(v1.value1))(function(cmd) {
          return bind10(maybe([])(pure111)(map210(function() {
            var $71 = un8(ParserInfo);
            return function($72) {
              return function(v2) {
                return v2.infoProgDesc;
              }($71($72));
            };
          }())(v1.value2(cmd))))(function(d) {
            return pure111(new Tuple(string2(cmd), align(extractChunk3(d))));
          });
        })));
      }
      ;
      return mempty23;
    };
  };
  return mapParser(desc);
}();
var briefDesc$prime = function(showOptional) {
  return function(pprefs) {
    var style = {
      descSep: string2("|"),
      descHidden: false,
      descOptional: showOptional,
      descSurround: true
    };
    var $73 = treeMapParser(optDesc(pprefs)(style));
    return function($74) {
      return fold_tree($73($74));
    };
  };
};
var missingDesc = /* @__PURE__ */ briefDesc$prime(false);
var briefDesc = /* @__PURE__ */ briefDesc$prime(true);
var parserUsage = function(pprefs) {
  return function(p) {
    return function(progn) {
      return hsep([string2("Usage:"), string2(progn), align(extractChunk3(briefDesc(pprefs)(p)))]);
    };
  };
};
var bodyHelp = function(chunk) {
  return over5(ParserHelp)(function(v) {
    return {
      helpBody: chunk,
      helpError: v.helpError,
      helpFooter: v.helpFooter,
      helpHeader: v.helpHeader,
      helpSuggestions: v.helpSuggestions,
      helpUsage: v.helpUsage
    };
  })(mempty7);
};
var parserHelp = function(pprefs) {
  return function(p) {
    var with_title = function(title2) {
      return map114(function(v) {
        return appendWithLine(string2(title2))(v);
      });
    };
    var group_title = function(arr) {
      var v = uncons2(arr);
      return with_title(fromMaybe("Available commands:")(fst(v.head)))(vcatChunks(append17([snd(v.head)])(map29(snd)(v.tail))));
    };
    var cs = groupBy(on(eq24)(fst))(cmdDesc(p));
    return bodyHelp(vsepChunks(append17([with_title("Available options:")(fullDesc(pprefs)(p))])(map29(group_title)(cs))));
  };
};

// output/Data.Char/index.js
var toCharCode2 = /* @__PURE__ */ fromEnum(boundedEnumChar);
var fromCharCode3 = /* @__PURE__ */ toEnum(boundedEnumChar);

// output/Data.Function.Memoize/index.js
var bind11 = /* @__PURE__ */ bind(bindLazy);
var NatTrie = /* @__PURE__ */ function() {
  function NatTrie2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  NatTrie2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new NatTrie2(value0, value12, value22);
      };
    };
  };
  return NatTrie2;
}();
var tabulateNat = {
  tabulate: /* @__PURE__ */ function() {
    var tabulateImpl = function(f) {
      var walk = function(v) {
        return function(v1) {
          if (v instanceof Nil) {
            return v1.value0;
          }
          ;
          if (v instanceof Cons && !v.value0) {
            return bind11(v1.value1)(walk(v.value1));
          }
          ;
          if (v instanceof Cons && v.value0) {
            return bind11(v1.value2)(walk(v.value1));
          }
          ;
          throw new Error("Failed pattern match at Data.Function.Memoize (line 137, column 11 - line 137, column 64): " + [v.constructor.name, v1.constructor.name]);
        };
      };
      var build3 = function(n) {
        return new NatTrie(defer2(function(v) {
          return f(n);
        }), defer2(function(v) {
          return build3(n * 2 | 0);
        }), defer2(function(v) {
          return build3((n * 2 | 0) + 1 | 0);
        }));
      };
      var trie = build3(0);
      var bits = function() {
        var bits$prime = function($copy_v) {
          return function($copy_v1) {
            var $tco_var_v = $copy_v;
            var $tco_done = false;
            var $tco_result;
            function $tco_loop(v, v1) {
              if (v1 === 0) {
                $tco_done = true;
                return v;
              }
              ;
              $tco_var_v = new Cons((v1 & 1) !== 0, v);
              $copy_v1 = v1 >>> 1;
              return;
            }
            ;
            while (!$tco_done) {
              $tco_result = $tco_loop($tco_var_v, $copy_v1);
            }
            ;
            return $tco_result;
          };
        };
        return bits$prime(Nil.value);
      }();
      var go = function(n) {
        return walk(bits(n))(trie);
      };
      return go;
    };
    return tabulateImpl;
  }()
};
var tabulate2 = function(dict) {
  return dict.tabulate;
};
var tabulateTuple = function(dictTabulate) {
  var tabulate3 = tabulate2(dictTabulate);
  return function(dictTabulate1) {
    var tabulate4 = tabulate2(dictTabulate1);
    return {
      tabulate: function(f) {
        var f$prime = tabulate3(function(a) {
          return tabulate4(function(b) {
            return f(new Tuple(a, b));
          });
        });
        return function(v) {
          return bind11(f$prime(v.value0))(function(g) {
            return g(v.value1);
          });
        };
      }
    };
  };
};
var memoize = function(dictTabulate) {
  var tabulate3 = tabulate2(dictTabulate);
  return function(f) {
    var f1 = tabulate3(f);
    return function($141) {
      return force(f1($141));
    };
  };
};
var memoize2 = function(dictTabulate) {
  var tabulateTuple1 = tabulateTuple(dictTabulate);
  return function(dictTabulate1) {
    var memoize1 = memoize(tabulateTuple1(dictTabulate1));
    return function(f) {
      var f1 = memoize1(uncurry(f));
      return curry(f1);
    };
  };
};

// output/Options.Applicative.Help.Levenshtein/index.js
var $runtime_lazy9 = function(name4, moduleName2, init4) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2)
      return val;
    if (state2 === 1)
      throw new ReferenceError(name4 + " was needed before it finished initializing (module " + moduleName2 + ", line " + lineNumber + ")", moduleName2, lineNumber);
    state2 = 1;
    val = init4();
    state2 = 2;
    return val;
  };
};
var memoize22 = /* @__PURE__ */ memoize2(tabulateNat)(tabulateNat);
var minimum3 = /* @__PURE__ */ minimum2(ordInt)(/* @__PURE__ */ foldable1NonEmpty(foldableArray));
var unsafeIndex2 = /* @__PURE__ */ unsafeIndex();
var editDistance = function(dictEq) {
  var eq31 = eq(dictEq);
  return function(xs) {
    return function(ys) {
      var dist = function(v) {
        return function(v1) {
          if (v === 0) {
            return v1;
          }
          ;
          if (v1 === 0) {
            return v;
          }
          ;
          return minimum3(new NonEmpty($lazy_dist$prime(37)(v - 1 | 0)(v1) + 1 | 0, [$lazy_dist$prime(38)(v)(v1 - 1 | 0) + 1 | 0, function() {
            var $14 = eq31(unsafeIndex2(xs)(v - 1 | 0))(unsafeIndex2(ys)(v1 - 1 | 0));
            if ($14) {
              return $lazy_dist$prime(40)(v - 1 | 0)(v1 - 1 | 0);
            }
            ;
            return 1 + $lazy_dist$prime(41)(v - 1 | 0)(v1 - 1 | 0) | 0;
          }()]));
        };
      };
      var $lazy_dist$prime = $runtime_lazy9("dist'", "Options.Applicative.Help.Levenshtein", function() {
        return memoize22(function(a) {
          return function(b) {
            return dist(a)(b);
          };
        });
      });
      var dist$prime = $lazy_dist$prime(31);
      return dist$prime(length(xs))(length(ys));
    };
  };
};

// output/Options.Applicative.Extra/index.js
var un9 = /* @__PURE__ */ un();
var mempty8 = /* @__PURE__ */ mempty(parserHelpMonoid);
var pure21 = /* @__PURE__ */ pure(chunkApplicative);
var unWords2 = /* @__PURE__ */ unWords(foldableArray);
var append9 = /* @__PURE__ */ append(semigroupArray);
var map30 = /* @__PURE__ */ map(chunkFunctor);
var map115 = /* @__PURE__ */ map(functorArray);
var fold8 = /* @__PURE__ */ fold2(monoidArray);
var editDistance2 = /* @__PURE__ */ editDistance(eqChar);
var apply11 = /* @__PURE__ */ apply2(chunkApply);
var mempty14 = /* @__PURE__ */ mempty(/* @__PURE__ */ chunkMonoid(docSemigroup));
var fold13 = /* @__PURE__ */ fold2(parserHelpMonoid);
var append22 = /* @__PURE__ */ append(modSemigroup);
var metavar2 = /* @__PURE__ */ metavar(commandFieldsHasMetavar);
var over6 = /* @__PURE__ */ over()();
var apApplyFlipped2 = /* @__PURE__ */ apApplyFlipped(parserApply);
var map211 = /* @__PURE__ */ map(functorMaybe);
var mapFlipped3 = /* @__PURE__ */ mapFlipped(functorEffect);
var bind14 = /* @__PURE__ */ bind(bindMaybe);
var fromEnum5 = /* @__PURE__ */ fromEnum(boundedEnumExitCode);
var pure112 = /* @__PURE__ */ pure(applicativeEffect);
var bind15 = /* @__PURE__ */ bind(bindEffect);
var $$void9 = /* @__PURE__ */ $$void(functorEffect);
var mempty24 = /* @__PURE__ */ mempty(/* @__PURE__ */ monoidFn(/* @__PURE__ */ monoidEffect(monoidUnit)));
var alt7 = /* @__PURE__ */ alt(parserAlt);
var map34 = /* @__PURE__ */ map(parserFunctor);
var runParserInfo3 = /* @__PURE__ */ runParserInfo(pMonadP);
var fromFoldable13 = /* @__PURE__ */ fromFoldable5(foldableArray);
var map43 = /* @__PURE__ */ map(functorEffect);
var renderFailure = function(failure) {
  return function(progn) {
    var v = un9(ParserFailure)(failure)(progn);
    return new Tuple(renderHelp(v.value1.value1.value0)(v.value0), v.value1.value0);
  };
};
var parserFailure = function(pprefs) {
  return function(pinfo) {
    return function(msg) {
      return function(ctx) {
        var with_context = function(arr) {
          return function(i) {
            return function(f) {
              var v = head(arr);
              if (v instanceof Nothing) {
                return f([])(i);
              }
              ;
              if (v instanceof Just) {
                return runExists(function(i$prime) {
                  return f(contextNames(arr))(i$prime);
                })(v.value0.value1);
              }
              ;
              throw new Error("Failed pattern match at Options.Applicative.Extra (line 183, column 28 - line 185, column 73): " + [v.constructor.name]);
            };
          };
        };
        var usage_help = function(progn) {
          return function(names) {
            return function(v) {
              if (msg instanceof InfoMsg) {
                return mempty8;
              }
              ;
              return usageHelp(vcatChunks([pure21(parserUsage(pprefs)(v.infoParser)(unWords2(append9([progn])(names)))), map30(indent2(2))(v.infoProgDesc)]));
            };
          };
        };
        var suggestion_help = suggestionsHelp(function() {
          if (msg instanceof UnexpectedError) {
            var opt_completions = function(v) {
              return function(v1) {
                if (v1.optMain instanceof OptReader) {
                  return map115(showOption)(v1.optMain.value0);
                }
                ;
                if (v1.optMain instanceof FlagReader) {
                  return map115(showOption)(v1.optMain.value0);
                }
                ;
                if (v1.optMain instanceof ArgReader) {
                  return [];
                }
                ;
                if (v1.optMain instanceof CmdReader) {
                  if (v.hinfoUnreachableArgs) {
                    return [];
                  }
                  ;
                  if (otherwise) {
                    return v1.optMain.value1;
                  }
                  ;
                }
                ;
                throw new Error("Failed pattern match at Options.Applicative.Extra (line 273, column 64 - line 280, column 37): " + [v1.optMain.constructor.name]);
              };
            };
            var possibles = fold8(runExists(function(zz) {
              return mapParser(opt_completions)(zz);
            })(msg.value1.value0));
            var isClose = function(a) {
              return on(editDistance2)(toCharArray)(a)(msg.value0) < 3;
            };
            var good2 = filter(isClose)(possibles);
            var prose = function() {
              var $84 = length(good2) < 2;
              if ($84) {
                return stringChunk("Did you mean this?");
              }
              ;
              return stringChunk("Did you mean one of these?");
            }();
            var suggestions = apply11(map30(appendWithLine)(prose))(map30(indent2(4))(vcatChunks(map115(stringChunk)(good2))));
            return suggestions;
          }
          ;
          return mempty14;
        }());
        var show_full_help = function() {
          if (msg instanceof ShowHelpText) {
            return true;
          }
          ;
          if (msg instanceof MissingError && (msg.value0 instanceof CmdStart && un9(ParserPrefs)(pprefs).prefShowHelpOnEmpty)) {
            return true;
          }
          ;
          return un9(ParserPrefs)(pprefs).prefShowHelpOnError;
        }();
        var exit_code = function() {
          if (msg instanceof ErrorMsg) {
            return un9(ParserInfo)(pinfo).infoFailureCode;
          }
          ;
          if (msg instanceof MissingError) {
            return un9(ParserInfo)(pinfo).infoFailureCode;
          }
          ;
          if (msg instanceof ExpectsArgError) {
            return un9(ParserInfo)(pinfo).infoFailureCode;
          }
          ;
          if (msg instanceof UnexpectedError) {
            return un9(ParserInfo)(pinfo).infoFailureCode;
          }
          ;
          if (msg instanceof ShowHelpText) {
            return Success.value;
          }
          ;
          if (msg instanceof InfoMsg) {
            return Success.value;
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Extra (line 171, column 17 - line 177, column 44): " + [msg.constructor.name]);
        }();
        var error_help = errorHelp(function() {
          if (msg instanceof ShowHelpText) {
            return mempty14;
          }
          ;
          if (msg instanceof ErrorMsg) {
            return stringChunk(msg.value0);
          }
          ;
          if (msg instanceof InfoMsg) {
            return stringChunk(msg.value0);
          }
          ;
          if (msg instanceof MissingError && (msg.value0 instanceof CmdStart && un9(ParserPrefs)(pprefs).prefShowHelpOnEmpty)) {
            return mempty14;
          }
          ;
          if (msg instanceof MissingError) {
            return runExists(function(x) {
              return chunkBeside(stringChunk("Missing:"))(missingDesc(pprefs)(x));
            })(msg.value1.value0);
          }
          ;
          if (msg instanceof ExpectsArgError) {
            return stringChunk("The option `" + (msg.value0 + "` expects an argument."));
          }
          ;
          if (msg instanceof UnexpectedError) {
            var msg$prime = function() {
              var $108 = startsWith("-")(msg.value0);
              if ($108) {
                return "Invalid option `" + (msg.value0 + "'");
              }
              ;
              return "Invalid argument `" + (msg.value0 + "'");
            }();
            return stringChunk(msg$prime);
          }
          ;
          throw new Error("Failed pattern match at Options.Applicative.Extra (line 196, column 30 - line 225, column 30): " + [msg.constructor.name]);
        }());
        var base_help = function(v) {
          var h = headerHelp(v.infoHeader);
          var f = footerHelp(v.infoFooter);
          if (show_full_help) {
            return fold13([h, f, parserHelp(pprefs)(v.infoParser)]);
          }
          ;
          return mempty8;
        };
        return function(progn) {
          var h = with_context(ctx)(pinfo)(function(names) {
            return function(pinfo$prime) {
              return fold13([base_help(pinfo$prime), usage_help(progn)(names)(pinfo$prime), suggestion_help, error_help]);
            };
          });
          return new Tuple(h, new Tuple(exit_code, new Tuple(un9(ParserPrefs)(pprefs).prefColumns, unit)));
        };
      };
    };
  };
};
var helper = /* @__PURE__ */ function() {
  return abortOption(ShowHelpText.value)(fold2(modMonoid)([$$long(optionFieldsHasName)("help"), $$short(optionFieldsHasName)("h"), help("Show this help text"), hidden]));
}();
var hsubparser = function(m) {
  var v = append22(metavar2("COMMAND"))(m);
  var v1 = mkCommand(m);
  var add_helper = over6(ParserInfo)(function(pinfo) {
    return {
      infoParser: apApplyFlipped2(pinfo.infoParser)(helper),
      infoFailureCode: pinfo.infoFailureCode,
      infoFooter: pinfo.infoFooter,
      infoFullDesc: pinfo.infoFullDesc,
      infoHeader: pinfo.infoHeader,
      infoPolicy: pinfo.infoPolicy,
      infoProgDesc: pinfo.infoProgDesc
    };
  });
  var rdr = new CmdReader(v1.value0, v1.value1.value0, function() {
    var $146 = map211(add_helper);
    return function($147) {
      return $146(v1.value1.value1.value0($147));
    };
  }());
  return mkParser(v.value1)(v.value2)(rdr);
};
var getProgName = /* @__PURE__ */ mapFlipped3(argv)(function(args) {
  return fromMaybe("")(bind14(index(args)(1))(function(executablePath) {
    return last(split("/")(executablePath));
  }));
});
var getArgs = /* @__PURE__ */ mapFlipped3(argv)(/* @__PURE__ */ drop(2));
var exitWith = function(c) {
  return exit(fromEnum5(c));
};
var exitSuccess = /* @__PURE__ */ function() {
  return exit(fromEnum5(Success.value));
}();
var handleParseResult = function(v) {
  if (v instanceof Success2) {
    return pure112(v.value0);
  }
  ;
  if (v instanceof Failure) {
    return function __do3() {
      var progn = getProgName();
      var v1 = renderFailure(v.value0)(progn);
      var stream3 = function() {
        if (v1.value1 instanceof Success) {
          return stdout;
        }
        ;
        return stderr;
      }();
      $$void9(writeString3(stream3)(UTF8.value)(v1.value0 + "\n")(mempty24))();
      return exitWith(v1.value1)();
    };
  }
  ;
  if (v instanceof CompletionInvoked) {
    return function __do3() {
      var progn = getProgName();
      var msg = un9(CompletionResult)(v.value0).execCompletion(progn)();
      $$void9(writeString3(stdout)(UTF8.value)(msg)(mempty24))();
      return exitSuccess();
    };
  }
  ;
  throw new Error("Failed pattern match at Options.Applicative.Extra (line 110, column 1 - line 110, column 58): " + [v.constructor.name]);
};
var execParserPure = function(pprefs) {
  return function(pinfo) {
    return function(args) {
      var pinfo$prime = over6(ParserInfo)(function(i) {
        return {
          infoParser: alt7(map34(Left.create)(bashCompletionParser(pinfo)(pprefs)))(map34(Right.create)(i.infoParser)),
          infoFailureCode: i.infoFailureCode,
          infoFooter: i.infoFooter,
          infoFullDesc: i.infoFullDesc,
          infoHeader: i.infoHeader,
          infoPolicy: i.infoPolicy,
          infoProgDesc: i.infoProgDesc
        };
      })(pinfo);
      var p = runParserInfo3(pinfo$prime)(fromFoldable13(args));
      var v = runP(p)(pprefs);
      if (v.value0 instanceof Right && v.value0.value0 instanceof Right) {
        return new Success2(v.value0.value0.value0);
      }
      ;
      if (v.value0 instanceof Right && v.value0.value0 instanceof Left) {
        return new CompletionInvoked(v.value0.value0.value0);
      }
      ;
      if (v.value0 instanceof Left) {
        return new Failure(parserFailure(pprefs)(pinfo)(v.value0.value0)(v.value1));
      }
      ;
      throw new Error("Failed pattern match at Options.Applicative.Extra (line 144, column 3 - line 147, column 73): " + [v.constructor.name]);
    };
  };
};
var customExecParser = function(pprefs) {
  return function(pinfo) {
    return bind15(map43(execParserPure(pprefs)(pinfo))(getArgs))(handleParseResult);
  };
};

// output/Record.Unsafe.Union/foreign.js
function unsafeUnionFn(r1, r2) {
  var copy3 = {};
  for (var k1 in r2) {
    if ({}.hasOwnProperty.call(r2, k1)) {
      copy3[k1] = r2[k1];
    }
  }
  for (var k2 in r1) {
    if ({}.hasOwnProperty.call(r1, k2)) {
      copy3[k2] = r1[k2];
    }
  }
  return copy3;
}

// output/Record/index.js
var union5 = function() {
  return function(l) {
    return function(r) {
      return unsafeUnionFn(l, r);
    };
  };
};
var merge = function() {
  return function() {
    return function(l) {
      return function(r) {
        return unsafeUnionFn(l, r);
      };
    };
  };
};
var insert5 = function(dictIsSymbol) {
  var reflectSymbol3 = reflectSymbol(dictIsSymbol);
  return function() {
    return function() {
      return function(l) {
        return function(a) {
          return function(r) {
            return unsafeSet(reflectSymbol3(l))(a)(r);
          };
        };
      };
    };
  };
};
var get3 = function(dictIsSymbol) {
  var reflectSymbol3 = reflectSymbol(dictIsSymbol);
  return function() {
    return function(l) {
      return function(r) {
        return unsafeGet(reflectSymbol3(l))(r);
      };
    };
  };
};
var $$delete5 = function(dictIsSymbol) {
  var reflectSymbol3 = reflectSymbol(dictIsSymbol);
  return function() {
    return function() {
      return function(l) {
        return function(r) {
          return unsafeDelete(reflectSymbol3(l))(r);
        };
      };
    };
  };
};

// output/Record.Builder/foreign.js
function copyRecord(rec) {
  var copy3 = {};
  for (var key in rec) {
    if ({}.hasOwnProperty.call(rec, key)) {
      copy3[key] = rec[key];
    }
  }
  return copy3;
}
function unsafeInsert(l) {
  return function(a) {
    return function(rec) {
      rec[l] = a;
      return rec;
    };
  };
}

// output/Record.Builder/index.js
var semigroupoidBuilder = semigroupoidFn;
var insert6 = function() {
  return function() {
    return function(dictIsSymbol) {
      var reflectSymbol3 = reflectSymbol(dictIsSymbol);
      return function(l) {
        return function(a) {
          return function(r1) {
            return unsafeInsert(reflectSymbol3(l))(a)(r1);
          };
        };
      };
    };
  };
};
var categoryBuilder = categoryFn;
var build = function(v) {
  return function(r1) {
    return v(copyRecord(r1));
  };
};
var buildFromScratch = /* @__PURE__ */ flip(build)({});

// output/Optparse/index.js
var identity18 = /* @__PURE__ */ identity(categoryBuilder);
var map31 = /* @__PURE__ */ map(parserFunctor);
var apply14 = /* @__PURE__ */ apply2(parserApply);
var composeFlipped2 = /* @__PURE__ */ composeFlipped(semigroupoidBuilder);
var insert7 = /* @__PURE__ */ insert6()();
var buildRecordArgsNil = {
  buildRecordArgs: function(v) {
    return function(v1) {
      return new NilP(identity18);
    };
  }
};
var buildRecordArgs = function(dict) {
  return dict.buildRecordArgs;
};
var fromRecord = function() {
  return function(dictBuildRecordArgs) {
    var $19 = map31(buildFromScratch);
    var $20 = buildRecordArgs(dictBuildRecordArgs)($$Proxy.value);
    return function($21) {
      return $19($20($21));
    };
  };
};
var buildArgsCons = function(dictIsSymbol) {
  var insert110 = insert7(dictIsSymbol);
  var get7 = get3(dictIsSymbol)();
  return function() {
    return function() {
      return function() {
        return function(dictBuildRecordArgs) {
          var buildRecordArgs1 = buildRecordArgs(dictBuildRecordArgs);
          return {
            buildRecordArgs: function(v) {
              return function(rs) {
                return apply14(map31(function(a) {
                  return function(b) {
                    return composeFlipped2(insert110($$Proxy.value)(a))(b);
                  };
                })(get7($$Proxy.value)(rs)))(buildRecordArgs1($$Proxy.value)(rs));
              };
            }
          };
        };
      };
    };
  };
};

// output/Registry.Constants/index.js
var metadataDirectory = "metadata";

// output/Data.Argonaut.Parser/foreign.js
function _jsonParser(fail5, succ2, s) {
  try {
    return succ2(JSON.parse(s));
  } catch (e) {
    return fail5(e.message);
  }
}

// output/Data.Argonaut.Parser/index.js
var jsonParser = function(j) {
  return _jsonParser(Left.create, Right.create, j);
};

// output/Node.FS.Async/foreign.js
import {
  access,
  copyFile,
  mkdtemp,
  rename,
  truncate,
  chown,
  chmod,
  stat,
  lstat,
  link as link2,
  symlink,
  readlink,
  realpath,
  unlink,
  rmdir,
  rm,
  mkdir,
  readdir,
  utimes,
  readFile,
  writeFile,
  appendFile,
  open,
  read as read6,
  write as write6,
  close
} from "node:fs";

// output/Node.FS.Constants/foreign.js
import { constants } from "node:fs";
var f_OK = constants.F_OK;
var r_OK = constants.R_OK;
var w_OK = constants.W_OK;
var x_OK = constants.X_OK;
var copyFile_EXCL = constants.COPYFILE_EXCL;
var copyFile_FICLONE = constants.COPYFILE_FICLONE;
var copyFile_FICLONE_FORCE = constants.COPYFILE_FICLONE_FORCE;

// output/Node.FS.Constants/index.js
var R = /* @__PURE__ */ function() {
  function R2() {
  }
  ;
  R2.value = new R2();
  return R2;
}();
var R_PLUS = /* @__PURE__ */ function() {
  function R_PLUS2() {
  }
  ;
  R_PLUS2.value = new R_PLUS2();
  return R_PLUS2;
}();
var RS = /* @__PURE__ */ function() {
  function RS2() {
  }
  ;
  RS2.value = new RS2();
  return RS2;
}();
var RS_PLUS = /* @__PURE__ */ function() {
  function RS_PLUS2() {
  }
  ;
  RS_PLUS2.value = new RS_PLUS2();
  return RS_PLUS2;
}();
var W = /* @__PURE__ */ function() {
  function W2() {
  }
  ;
  W2.value = new W2();
  return W2;
}();
var WX = /* @__PURE__ */ function() {
  function WX2() {
  }
  ;
  WX2.value = new WX2();
  return WX2;
}();
var W_PLUS = /* @__PURE__ */ function() {
  function W_PLUS2() {
  }
  ;
  W_PLUS2.value = new W_PLUS2();
  return W_PLUS2;
}();
var WX_PLUS = /* @__PURE__ */ function() {
  function WX_PLUS2() {
  }
  ;
  WX_PLUS2.value = new WX_PLUS2();
  return WX_PLUS2;
}();
var A = /* @__PURE__ */ function() {
  function A2() {
  }
  ;
  A2.value = new A2();
  return A2;
}();
var AX = /* @__PURE__ */ function() {
  function AX2() {
  }
  ;
  AX2.value = new AX2();
  return AX2;
}();
var A_PLUS = /* @__PURE__ */ function() {
  function A_PLUS2() {
  }
  ;
  A_PLUS2.value = new A_PLUS2();
  return A_PLUS2;
}();
var AX_PLUS = /* @__PURE__ */ function() {
  function AX_PLUS2() {
  }
  ;
  AX_PLUS2.value = new AX_PLUS2();
  return AX_PLUS2;
}();
var fileFlagsToNode = function(ff2) {
  if (ff2 instanceof R) {
    return "r";
  }
  ;
  if (ff2 instanceof R_PLUS) {
    return "r+";
  }
  ;
  if (ff2 instanceof RS) {
    return "rs";
  }
  ;
  if (ff2 instanceof RS_PLUS) {
    return "rs+";
  }
  ;
  if (ff2 instanceof W) {
    return "w";
  }
  ;
  if (ff2 instanceof WX) {
    return "wx";
  }
  ;
  if (ff2 instanceof W_PLUS) {
    return "w+";
  }
  ;
  if (ff2 instanceof WX_PLUS) {
    return "wx+";
  }
  ;
  if (ff2 instanceof A) {
    return "a";
  }
  ;
  if (ff2 instanceof AX) {
    return "ax";
  }
  ;
  if (ff2 instanceof A_PLUS) {
    return "a+";
  }
  ;
  if (ff2 instanceof AX_PLUS) {
    return "ax+";
  }
  ;
  throw new Error("Failed pattern match at Node.FS.Constants (line 78, column 22 - line 90, column 19): " + [ff2.constructor.name]);
};

// output/Node.FS.Perms/index.js
var semiringPerm = {
  add: function(v) {
    return function(v1) {
      return {
        r: v.r || v1.r,
        w: v.w || v1.w,
        x: v.x || v1.x
      };
    };
  },
  zero: {
    r: false,
    w: false,
    x: false
  },
  mul: function(v) {
    return function(v1) {
      return {
        r: v.r && v1.r,
        w: v.w && v1.w,
        x: v.x && v1.x
      };
    };
  },
  one: {
    r: true,
    w: true,
    x: true
  }
};
var permToInt = function(v) {
  return (function() {
    if (v.r) {
      return 4;
    }
    ;
    return 0;
  }() + function() {
    if (v.w) {
      return 2;
    }
    ;
    return 0;
  }() | 0) + function() {
    if (v.x) {
      return 1;
    }
    ;
    return 0;
  }() | 0;
};
var permToString = /* @__PURE__ */ function() {
  var $119 = show(showInt);
  return function($120) {
    return $119(permToInt($120));
  };
}();
var permsToString = function(v) {
  return "0" + (permToString(v.u) + (permToString(v.g) + permToString(v.o)));
};
var mkPerms = function(u) {
  return function(g) {
    return function(o) {
      return {
        u,
        g,
        o
      };
    };
  };
};
var all4 = /* @__PURE__ */ one(semiringPerm);
var permsAll = /* @__PURE__ */ mkPerms(all4)(all4)(all4);

// output/Node.FS.Stats/foreign.js
function statsMethod(m, s) {
  return s[m]();
}

// output/Node.FS.Stats/index.js
var fromJust7 = /* @__PURE__ */ fromJust();
var Stats = /* @__PURE__ */ function() {
  function Stats2(value0) {
    this.value0 = value0;
  }
  ;
  Stats2.create = function(value0) {
    return new Stats2(value0);
  };
  return Stats2;
}();
var modifiedTime = function(v) {
  return fromJust7(toDateTime2(v.value0.mtime));
};
var isSymbolicLink = function(v) {
  return statsMethod("isSymbolicLink", v.value0);
};
var isFile = function(v) {
  return statsMethod("isFile", v.value0);
};
var isDirectory = function(v) {
  return statsMethod("isDirectory", v.value0);
};

// output/Node.FS.Async/index.js
var map35 = /* @__PURE__ */ map(functorEither);
var show9 = /* @__PURE__ */ show(showEncoding);
var handleCallback = function(cb) {
  return function(err, a) {
    var v = toMaybe(err);
    if (v instanceof Nothing) {
      return cb(new Right(a))();
    }
    ;
    if (v instanceof Just) {
      return cb(new Left(v.value0))();
    }
    ;
    throw new Error("Failed pattern match at Node.FS.Async (line 66, column 43 - line 68, column 30): " + [v.constructor.name]);
  };
};
var mkdir$prime = function(file) {
  return function(v) {
    return function(cb) {
      return function() {
        return mkdir(file, {
          recursive: v.recursive,
          mode: permsToString(v.mode)
        }, handleCallback(cb));
      };
    };
  };
};
var readTextFile = function(encoding) {
  return function(file) {
    return function(cb) {
      return function() {
        return readFile(file, {
          encoding: show9(encoding)
        }, handleCallback(cb));
      };
    };
  };
};
var readdir2 = function(file) {
  return function(cb) {
    return function() {
      return readdir(file, handleCallback(cb));
    };
  };
};
var realpath2 = function(path5) {
  return function(cb) {
    return function() {
      return realpath(path5, {}, handleCallback(cb));
    };
  };
};
var stat2 = function(file) {
  return function(cb) {
    return function() {
      return stat(file, handleCallback(function() {
        var $19 = map35(Stats.create);
        return function($20) {
          return cb($19($20));
        };
      }()));
    };
  };
};
var writeFile2 = function(file) {
  return function(buff) {
    return function(cb) {
      return function() {
        return writeFile(file, buff, {}, handleCallback(cb));
      };
    };
  };
};
var writeTextFile = function(encoding) {
  return function(file) {
    return function(buff) {
      return function(cb) {
        return function() {
          return writeFile(file, buff, {
            encoding: show9(encoding)
          }, handleCallback(cb));
        };
      };
    };
  };
};
var chmod2 = function(file) {
  return function(perms) {
    return function(cb) {
      return function() {
        return chmod(file, permsToString(perms), handleCallback(cb));
      };
    };
  };
};

// output/Node.FS.Aff/index.js
var voidLeft2 = /* @__PURE__ */ voidLeft(functorEffect);
var toAff = function(p) {
  return makeAff(function(k) {
    return voidLeft2(p(k))(nonCanceler);
  });
};
var toAff1 = function(f) {
  return function(a) {
    return toAff(f(a));
  };
};
var toAff2 = function(f) {
  return function(a) {
    return function(b) {
      return toAff(f(a)(b));
    };
  };
};
var writeFile3 = /* @__PURE__ */ toAff2(writeFile2);
var toAff3 = function(f) {
  return function(a) {
    return function(b) {
      return function(c) {
        return toAff(f(a)(b)(c));
      };
    };
  };
};
var writeTextFile2 = /* @__PURE__ */ toAff3(writeTextFile);
var stat3 = /* @__PURE__ */ toAff1(stat2);
var realpath3 = /* @__PURE__ */ toAff1(realpath2);
var readdir3 = /* @__PURE__ */ toAff1(readdir2);
var readTextFile2 = /* @__PURE__ */ toAff2(readTextFile);
var mkdir$prime2 = /* @__PURE__ */ toAff2(mkdir$prime);
var chmod3 = /* @__PURE__ */ toAff2(chmod2);

// output/Node.FS.Sync/foreign.js
import {
  accessSync,
  copyFileSync,
  mkdtempSync,
  renameSync,
  truncateSync,
  chownSync,
  chmodSync,
  statSync,
  lstatSync,
  linkSync,
  symlinkSync,
  readlinkSync,
  realpathSync,
  unlinkSync,
  rmdirSync,
  rmSync,
  mkdirSync,
  readdirSync,
  utimesSync,
  readFileSync,
  writeFileSync,
  appendFileSync,
  existsSync,
  openSync,
  readSync,
  writeSync,
  fsyncSync,
  closeSync
} from "node:fs";

// output/Node.FS.Sync/index.js
var map36 = /* @__PURE__ */ map(functorEffect);
var stat4 = function(file) {
  return map36(Stats.create)(function() {
    return statSync(file);
  });
};
var lstat2 = function(file) {
  return map36(Stats.create)(function() {
    return lstatSync(file);
  });
};
var fdRead2 = function(fd) {
  return function(buff) {
    return function(off) {
      return function(len) {
        return function(pos) {
          return function() {
            return readSync(fd, buff, off, len, toNullable(pos));
          };
        };
      };
    };
  };
};
var fdOpen2 = function(file) {
  return function(flags) {
    return function(mode) {
      return function() {
        return openSync(file, fileFlagsToNode(flags), toNullable(mode));
      };
    };
  };
};
var fdClose2 = function(fd) {
  return function() {
    return closeSync(fd);
  };
};
var exists = function(file) {
  return function() {
    return existsSync(file);
  };
};

// output/Control.Monad.State/index.js
var unwrap9 = /* @__PURE__ */ unwrap();
var runState = function(v) {
  return function($18) {
    return unwrap9(v($18));
  };
};

// output/Data.Formatter.Internal/index.js
var foldDigits = function(dictFoldable) {
  return foldl(dictFoldable)(function(acc) {
    return function(d) {
      return (acc * 10 | 0) + d | 0;
    };
  })(0);
};

// output/Parsing/index.js
var $runtime_lazy10 = function(name4, moduleName2, init4) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2)
      return val;
    if (state2 === 1)
      throw new ReferenceError(name4 + " was needed before it finished initializing (module " + moduleName2 + ", line " + lineNumber + ")", moduleName2, lineNumber);
    state2 = 1;
    val = init4();
    state2 = 2;
    return val;
  };
};
var unwrap10 = /* @__PURE__ */ unwrap();
var ParseState = /* @__PURE__ */ function() {
  function ParseState2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  ParseState2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new ParseState2(value0, value12, value22);
      };
    };
  };
  return ParseState2;
}();
var ParseError = /* @__PURE__ */ function() {
  function ParseError2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ParseError2.create = function(value0) {
    return function(value12) {
      return new ParseError2(value0, value12);
    };
  };
  return ParseError2;
}();
var More = /* @__PURE__ */ function() {
  function More3(value0) {
    this.value0 = value0;
  }
  ;
  More3.create = function(value0) {
    return new More3(value0);
  };
  return More3;
}();
var Lift = /* @__PURE__ */ function() {
  function Lift2(value0) {
    this.value0 = value0;
  }
  ;
  Lift2.create = function(value0) {
    return new Lift2(value0);
  };
  return Lift2;
}();
var Stop = /* @__PURE__ */ function() {
  function Stop2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Stop2.create = function(value0) {
    return function(value12) {
      return new Stop2(value0, value12);
    };
  };
  return Stop2;
}();
var monadTransParserT = {
  lift: function(dictMonad) {
    var map86 = map(dictMonad.Bind1().Apply0().Functor0());
    return function(m) {
      return function(state1, v, lift$prime, v1, done) {
        return lift$prime(map86(function(a) {
          return function(v2) {
            return done(state1, a);
          };
        })(m));
      };
    };
  }
};
var lazyParserT = {
  defer: function(f) {
    var m = defer2(f);
    return function(state1, more, lift14, $$throw2, done) {
      var v = force(m);
      return v(state1, more, lift14, $$throw2, done);
    };
  }
};
var functorParserT = {
  map: function(f) {
    return function(v) {
      return function(state1, more, lift14, $$throw2, done) {
        return more(function(v1) {
          return v(state1, more, lift14, $$throw2, function(state2, a) {
            return more(function(v2) {
              return done(state2, f(a));
            });
          });
        });
      };
    };
  }
};
var applyParserT = {
  apply: function(v) {
    return function(v1) {
      return function(state1, more, lift14, $$throw2, done) {
        return more(function(v2) {
          return v(state1, more, lift14, $$throw2, function(state2, f) {
            return more(function(v3) {
              return v1(state2, more, lift14, $$throw2, function(state3, a) {
                return more(function(v4) {
                  return done(state3, f(a));
                });
              });
            });
          });
        });
      };
    };
  },
  Functor0: function() {
    return functorParserT;
  }
};
var lift24 = /* @__PURE__ */ lift2(applyParserT);
var bindParserT = {
  bind: function(v) {
    return function(next2) {
      return function(state1, more, lift14, $$throw2, done) {
        return more(function(v1) {
          return v(state1, more, lift14, $$throw2, function(state2, a) {
            return more(function(v2) {
              var v3 = next2(a);
              return v3(state2, more, lift14, $$throw2, done);
            });
          });
        });
      };
    };
  },
  Apply0: function() {
    return applyParserT;
  }
};
var bindFlipped5 = /* @__PURE__ */ bindFlipped(bindParserT);
var semigroupParserT = function(dictSemigroup) {
  return {
    append: lift24(append(dictSemigroup))
  };
};
var applicativeParserT = {
  pure: function(a) {
    return function(state1, v, v1, v2, done) {
      return done(state1, a);
    };
  },
  Apply0: function() {
    return applyParserT;
  }
};
var pure25 = /* @__PURE__ */ pure(applicativeParserT);
var monadParserT = {
  Applicative0: function() {
    return applicativeParserT;
  },
  Bind1: function() {
    return bindParserT;
  }
};
var monadRecParserT = {
  tailRecM: function(next2) {
    return function(initArg) {
      return function(state1, more, lift14, $$throw2, done) {
        var $lazy_loop = $runtime_lazy10("loop", "Parsing", function() {
          return function(state2, arg, gas) {
            var v = next2(arg);
            return v(state2, more, lift14, $$throw2, function(state3, step3) {
              if (step3 instanceof Loop) {
                var $206 = gas === 0;
                if ($206) {
                  return more(function(v1) {
                    return $lazy_loop(277)(state3, step3.value0, 30);
                  });
                }
                ;
                return $lazy_loop(279)(state3, step3.value0, gas - 1 | 0);
              }
              ;
              if (step3 instanceof Done) {
                return done(state3, step3.value0);
              }
              ;
              throw new Error("Failed pattern match at Parsing (line 273, column 39 - line 281, column 43): " + [step3.constructor.name]);
            });
          };
        });
        var loop = $lazy_loop(270);
        return loop(state1, initArg, 30);
      };
    };
  },
  Monad0: function() {
    return monadParserT;
  }
};
var monadThrowParseErrorParse = {
  throwError: function(err) {
    return function(state1, v, v1, $$throw2, v2) {
      return $$throw2(state1, err);
    };
  },
  Monad0: function() {
    return monadParserT;
  }
};
var throwError3 = /* @__PURE__ */ throwError(monadThrowParseErrorParse);
var monoidParserT = function(dictMonoid) {
  var semigroupParserT1 = semigroupParserT(dictMonoid.Semigroup0());
  return {
    mempty: pure25(mempty(dictMonoid)),
    Semigroup0: function() {
      return semigroupParserT1;
    }
  };
};
var altParserT = {
  alt: function(v) {
    return function(v1) {
      return function(v2, more, lift14, $$throw2, done) {
        return more(function(v3) {
          return v(new ParseState(v2.value0, v2.value1, false), more, lift14, function(v4, err) {
            return more(function(v5) {
              if (v4.value2) {
                return $$throw2(v4, err);
              }
              ;
              return v1(v2, more, lift14, $$throw2, done);
            });
          }, done);
        });
      };
    };
  },
  Functor0: function() {
    return functorParserT;
  }
};
var stateParserT = function(k) {
  return function(state1, v, v1, v2, done) {
    var v3 = k(state1);
    return done(v3.value1, v3.value0);
  };
};
var runParserT$prime = function(dictMonadRec) {
  var Monad0 = dictMonadRec.Monad0();
  var map86 = map(Monad0.Bind1().Apply0().Functor0());
  var pure122 = pure(Monad0.Applicative0());
  var tailRecM6 = tailRecM(dictMonadRec);
  return function(state1) {
    return function(v) {
      var go = function($copy_step) {
        var $tco_done = false;
        var $tco_result;
        function $tco_loop(step3) {
          var v1 = step3(unit);
          if (v1 instanceof More) {
            $copy_step = v1.value0;
            return;
          }
          ;
          if (v1 instanceof Lift) {
            $tco_done = true;
            return map86(Loop.create)(v1.value0);
          }
          ;
          if (v1 instanceof Stop) {
            $tco_done = true;
            return pure122(new Done(new Tuple(v1.value1, v1.value0)));
          }
          ;
          throw new Error("Failed pattern match at Parsing (line 152, column 13 - line 158, column 32): " + [v1.constructor.name]);
        }
        ;
        while (!$tco_done) {
          $tco_result = $tco_loop($copy_step);
        }
        ;
        return $tco_result;
      };
      return tailRecM6(go)(function(v1) {
        return v(state1, More.create, Lift.create, function(state2, err) {
          return new Stop(state2, new Left(err));
        }, function(state2, res) {
          return new Stop(state2, new Right(res));
        });
      });
    };
  };
};
var position = /* @__PURE__ */ stateParserT(function(v) {
  return new Tuple(v.value1, v);
});
var parseErrorPosition = function(v) {
  return v.value1;
};
var parseErrorMessage = function(v) {
  return v.value0;
};
var mapParserT = function(dictMonadRec) {
  var runParserT$prime1 = runParserT$prime(dictMonadRec);
  return function(dictFunctor) {
    var map86 = map(dictFunctor);
    return function(f) {
      return function(p) {
        return function(state1, v, lift14, $$throw2, done) {
          return lift14(map86(function(v1) {
            return function(v2) {
              if (v1.value0 instanceof Left) {
                return $$throw2(v1.value1, v1.value0.value0);
              }
              ;
              if (v1.value0 instanceof Right) {
                return done(v1.value1, v1.value0.value0);
              }
              ;
              throw new Error("Failed pattern match at Parsing (line 192, column 13 - line 196, column 37): " + [v1.value0.constructor.name]);
            };
          })(f(runParserT$prime1(state1)(p))));
        };
      };
    };
  };
};
var initialPos = {
  index: 0,
  line: 1,
  column: 1
};
var runParserT = function(dictMonadRec) {
  var map86 = map(dictMonadRec.Monad0().Bind1().Apply0().Functor0());
  var runParserT$prime1 = runParserT$prime(dictMonadRec);
  return function(s) {
    return function(p) {
      var initialState = new ParseState(s, initialPos, false);
      return map86(fst)(runParserT$prime1(initialState)(p));
    };
  };
};
var runParserT1 = /* @__PURE__ */ runParserT(monadRecIdentity);
var runParser2 = function(s) {
  var $281 = runParserT1(s);
  return function($282) {
    return unwrap10($281($282));
  };
};
var getParserT = function(state1, v, v1, v2, done) {
  return done(state1, state1);
};
var failWithPosition = function(message2) {
  return function(pos) {
    return throwError3(new ParseError(message2, pos));
  };
};
var fail2 = function(message2) {
  return bindFlipped5(failWithPosition(message2))(position);
};
var plusParserT = {
  empty: /* @__PURE__ */ fail2("No alternative"),
  Alt0: function() {
    return altParserT;
  }
};
var alternativeParserT = {
  Applicative0: function() {
    return applicativeParserT;
  },
  Plus1: function() {
    return plusParserT;
  }
};

// output/Parsing.Combinators/index.js
var alt8 = /* @__PURE__ */ alt(altParserT);
var defer4 = /* @__PURE__ */ defer(lazyParserT);
var pure26 = /* @__PURE__ */ pure(applicativeParserT);
var map37 = /* @__PURE__ */ map(functorParserT);
var $$void10 = /* @__PURE__ */ $$void(functorParserT);
var empty8 = /* @__PURE__ */ empty(plusParserT);
var withLazyErrorMessage = function(p) {
  return function(msg) {
    return alt8(p)(defer4(function(v) {
      return fail2("Expected " + msg(unit));
    }));
  };
};
var withErrorMessage = function(p) {
  return function(msg) {
    return alt8(p)(fail2("Expected " + msg));
  };
};
var $$try4 = function(v) {
  return function(v1, more, lift9, $$throw2, done) {
    return v(v1, more, lift9, function(v2, err) {
      return $$throw2(new ParseState(v2.value0, v2.value1, v1.value2), err);
    }, done);
  };
};
var optional2 = function(p) {
  return alt8($$void10(p))(pure26(unit));
};
var option2 = function(a) {
  return function(p) {
    return alt8(p)(pure26(a));
  };
};
var optionMaybe = function(p) {
  return option2(Nothing.value)(map37(Just.create)(p));
};
var lookAhead = function(v) {
  return function(state1, more, lift9, $$throw2, done) {
    return v(state1, more, lift9, function(v1, err) {
      return $$throw2(state1, err);
    }, function(v1, res) {
      return done(state1, res);
    });
  };
};
var choice = function(dictFoldable) {
  var go = function(p1) {
    return function(v) {
      if (v instanceof Nothing) {
        return new Just(p1);
      }
      ;
      if (v instanceof Just) {
        return new Just(alt8(p1)(v.value0));
      }
      ;
      throw new Error("Failed pattern match at Parsing.Combinators (line 358, column 11 - line 360, column 32): " + [v.constructor.name]);
    };
  };
  var $95 = fromMaybe(empty8);
  var $96 = foldr(dictFoldable)(go)(Nothing.value);
  return function($97) {
    return $95($96($97));
  };
};

// output/Parsing.String/index.js
var fromEnum6 = /* @__PURE__ */ fromEnum(boundedEnumCodePoint);
var mod4 = /* @__PURE__ */ mod(euclideanRingInt);
var fromJust8 = /* @__PURE__ */ fromJust();
var toEnum4 = /* @__PURE__ */ toEnum(boundedEnumChar);
var show10 = /* @__PURE__ */ show(showInt);
var show13 = /* @__PURE__ */ show(showString);
var show22 = /* @__PURE__ */ show(showChar);
var updatePosSingle = function(v) {
  return function(cp) {
    return function(after) {
      var v1 = fromEnum6(cp);
      if (v1 === 10) {
        return {
          index: v.index + 1 | 0,
          line: v.line + 1 | 0,
          column: 1
        };
      }
      ;
      if (v1 === 13) {
        var v2 = codePointAt(0)(after);
        if (v2 instanceof Just && fromEnum6(v2.value0) === 10) {
          return {
            index: v.index + 1 | 0,
            line: v.line,
            column: v.column
          };
        }
        ;
        return {
          index: v.index + 1 | 0,
          line: v.line + 1 | 0,
          column: 1
        };
      }
      ;
      if (v1 === 9) {
        return {
          index: v.index + 1 | 0,
          line: v.line,
          column: (v.column + 8 | 0) - mod4(v.column - 1 | 0)(8) | 0
        };
      }
      ;
      return {
        index: v.index + 1 | 0,
        line: v.line,
        column: v.column + 1 | 0
      };
    };
  };
};
var updatePosString = function($copy_pos) {
  return function($copy_before) {
    return function($copy_after) {
      var $tco_var_pos = $copy_pos;
      var $tco_var_before = $copy_before;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(pos, before, after) {
        var v = uncons3(before);
        if (v instanceof Nothing) {
          $tco_done = true;
          return pos;
        }
        ;
        if (v instanceof Just) {
          var newPos = function() {
            if ($$null2(v.value0.tail)) {
              return updatePosSingle(pos)(v.value0.head)(after);
            }
            ;
            if (otherwise) {
              return updatePosSingle(pos)(v.value0.head)(v.value0.tail);
            }
            ;
            throw new Error("Failed pattern match at Parsing.String (line 165, column 7 - line 167, column 52): " + []);
          }();
          $tco_var_pos = newPos;
          $tco_var_before = v.value0.tail;
          $copy_after = after;
          return;
        }
        ;
        throw new Error("Failed pattern match at Parsing.String (line 161, column 36 - line 168, column 38): " + [v.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_pos, $tco_var_before, $copy_after);
      }
      ;
      return $tco_result;
    };
  };
};
var satisfy = function(f) {
  return mkFn5(function(v) {
    return function(v1) {
      return function(v2) {
        return function($$throw2) {
          return function(done) {
            var v3 = uncons3(v.value0);
            if (v3 instanceof Nothing) {
              return $$throw2(v, new ParseError("Unexpected EOF", v.value1));
            }
            ;
            if (v3 instanceof Just) {
              var cp = fromEnum6(v3.value0.head);
              var $85 = cp < 0 || cp > 65535;
              if ($85) {
                return $$throw2(v, new ParseError("Expected Char", v.value1));
              }
              ;
              var ch = fromJust8(toEnum4(cp));
              var $86 = f(ch);
              if ($86) {
                return done(new ParseState(v3.value0.tail, updatePosSingle(v.value1)(v3.value0.head)(v3.value0.tail), true), ch);
              }
              ;
              return $$throw2(v, new ParseError("Predicate unsatisfied", v.value1));
            }
            ;
            throw new Error("Failed pattern match at Parsing.String (line 114, column 7 - line 129, column 75): " + [v3.constructor.name]);
          };
        };
      };
    };
  });
};
var eof = /* @__PURE__ */ mkFn5(function(v) {
  return function(v1) {
    return function(v2) {
      return function($$throw2) {
        return function(done) {
          var $133 = $$null2(v.value0);
          if ($133) {
            return done(new ParseState(v.value0, v.value1, true), unit);
          }
          ;
          return $$throw2(v, new ParseError("Expected EOF", v.value1));
        };
      };
    };
  };
});
var consumeWith = function(f) {
  return mkFn5(function(v) {
    return function(v1) {
      return function(v2) {
        return function($$throw2) {
          return function(done) {
            var v3 = f(v.value0);
            if (v3 instanceof Left) {
              return $$throw2(v, new ParseError(v3.value0, v.value1));
            }
            ;
            if (v3 instanceof Right) {
              return done(new ParseState(v3.value0.remainder, updatePosString(v.value1)(v3.value0.consumed)(v3.value0.remainder), !$$null2(v3.value0.consumed)), v3.value0.value);
            }
            ;
            throw new Error("Failed pattern match at Parsing.String (line 286, column 7 - line 290, column 121): " + [v3.constructor.name]);
          };
        };
      };
    };
  });
};
var string3 = function(str2) {
  return consumeWith(function(input) {
    var v = stripPrefix(str2)(input);
    if (v instanceof Just) {
      return new Right({
        value: str2,
        consumed: str2,
        remainder: v.value0
      });
    }
    ;
    return new Left("Expected " + show13(str2));
  });
};
var takeN = function(n) {
  return consumeWith(function(input) {
    var v = splitAt3(n)(input);
    var $153 = length4(v.before) === n;
    if ($153) {
      return new Right({
        value: v.before,
        consumed: v.before,
        remainder: v.after
      });
    }
    ;
    return new Left("Could not take " + (show10(n) + " characters"));
  });
};
var $$char3 = function(c) {
  return withErrorMessage(satisfy(function(v) {
    return v === c;
  }))(show22(c));
};
var anyChar = /* @__PURE__ */ satisfy(/* @__PURE__ */ $$const(true));

// output/Data.Formatter.Parser.Utils/index.js
var show11 = /* @__PURE__ */ show(showInt);
var lmap3 = /* @__PURE__ */ lmap(bifunctorEither);
var applyFirst2 = /* @__PURE__ */ applyFirst(applyParserT);
var voidLeft3 = /* @__PURE__ */ voidLeft(functorParserT);
var printPosition = function(v) {
  return "(line " + (show11(v.line) + (", col " + (show11(v.column) + ")")));
};
var printError = function(err) {
  return parseErrorMessage(err) + (" " + printPosition(parseErrorPosition(err)));
};
var runP2 = function(p) {
  return function(s) {
    return lmap3(printError)(runParser2(s)(applyFirst2(p)(eof)));
  };
};
var oneOfAs = function(dictFunctor) {
  var map86 = map(dictFunctor);
  return function(dictFoldable) {
    var choice3 = choice(dictFoldable);
    return function(dictMonad) {
      return function(p) {
        return function(xs) {
          return choice3(map86(function(v) {
            return voidLeft3(p(v.value0))(v.value1);
          })(xs));
        };
      };
    };
  };
};

// output/Data.CodePoint.Unicode.Internal/index.js
var unsafeIndex3 = /* @__PURE__ */ unsafeIndex();
var elemIndex2 = /* @__PURE__ */ elemIndex(eqInt);
var NUMCAT_LU = /* @__PURE__ */ function() {
  function NUMCAT_LU2() {
  }
  ;
  NUMCAT_LU2.value = new NUMCAT_LU2();
  return NUMCAT_LU2;
}();
var NUMCAT_LL = /* @__PURE__ */ function() {
  function NUMCAT_LL2() {
  }
  ;
  NUMCAT_LL2.value = new NUMCAT_LL2();
  return NUMCAT_LL2;
}();
var NUMCAT_LT = /* @__PURE__ */ function() {
  function NUMCAT_LT2() {
  }
  ;
  NUMCAT_LT2.value = new NUMCAT_LT2();
  return NUMCAT_LT2;
}();
var NUMCAT_LM = /* @__PURE__ */ function() {
  function NUMCAT_LM2() {
  }
  ;
  NUMCAT_LM2.value = new NUMCAT_LM2();
  return NUMCAT_LM2;
}();
var NUMCAT_LO = /* @__PURE__ */ function() {
  function NUMCAT_LO2() {
  }
  ;
  NUMCAT_LO2.value = new NUMCAT_LO2();
  return NUMCAT_LO2;
}();
var NUMCAT_MN = /* @__PURE__ */ function() {
  function NUMCAT_MN2() {
  }
  ;
  NUMCAT_MN2.value = new NUMCAT_MN2();
  return NUMCAT_MN2;
}();
var NUMCAT_MC = /* @__PURE__ */ function() {
  function NUMCAT_MC2() {
  }
  ;
  NUMCAT_MC2.value = new NUMCAT_MC2();
  return NUMCAT_MC2;
}();
var NUMCAT_ME = /* @__PURE__ */ function() {
  function NUMCAT_ME2() {
  }
  ;
  NUMCAT_ME2.value = new NUMCAT_ME2();
  return NUMCAT_ME2;
}();
var NUMCAT_ND = /* @__PURE__ */ function() {
  function NUMCAT_ND2() {
  }
  ;
  NUMCAT_ND2.value = new NUMCAT_ND2();
  return NUMCAT_ND2;
}();
var NUMCAT_NL = /* @__PURE__ */ function() {
  function NUMCAT_NL2() {
  }
  ;
  NUMCAT_NL2.value = new NUMCAT_NL2();
  return NUMCAT_NL2;
}();
var NUMCAT_NO = /* @__PURE__ */ function() {
  function NUMCAT_NO2() {
  }
  ;
  NUMCAT_NO2.value = new NUMCAT_NO2();
  return NUMCAT_NO2;
}();
var NUMCAT_PC = /* @__PURE__ */ function() {
  function NUMCAT_PC2() {
  }
  ;
  NUMCAT_PC2.value = new NUMCAT_PC2();
  return NUMCAT_PC2;
}();
var NUMCAT_PD = /* @__PURE__ */ function() {
  function NUMCAT_PD2() {
  }
  ;
  NUMCAT_PD2.value = new NUMCAT_PD2();
  return NUMCAT_PD2;
}();
var NUMCAT_PS = /* @__PURE__ */ function() {
  function NUMCAT_PS2() {
  }
  ;
  NUMCAT_PS2.value = new NUMCAT_PS2();
  return NUMCAT_PS2;
}();
var NUMCAT_PE = /* @__PURE__ */ function() {
  function NUMCAT_PE2() {
  }
  ;
  NUMCAT_PE2.value = new NUMCAT_PE2();
  return NUMCAT_PE2;
}();
var NUMCAT_PI = /* @__PURE__ */ function() {
  function NUMCAT_PI2() {
  }
  ;
  NUMCAT_PI2.value = new NUMCAT_PI2();
  return NUMCAT_PI2;
}();
var NUMCAT_PF = /* @__PURE__ */ function() {
  function NUMCAT_PF2() {
  }
  ;
  NUMCAT_PF2.value = new NUMCAT_PF2();
  return NUMCAT_PF2;
}();
var NUMCAT_PO = /* @__PURE__ */ function() {
  function NUMCAT_PO2() {
  }
  ;
  NUMCAT_PO2.value = new NUMCAT_PO2();
  return NUMCAT_PO2;
}();
var NUMCAT_SM = /* @__PURE__ */ function() {
  function NUMCAT_SM2() {
  }
  ;
  NUMCAT_SM2.value = new NUMCAT_SM2();
  return NUMCAT_SM2;
}();
var NUMCAT_SC = /* @__PURE__ */ function() {
  function NUMCAT_SC2() {
  }
  ;
  NUMCAT_SC2.value = new NUMCAT_SC2();
  return NUMCAT_SC2;
}();
var NUMCAT_SK = /* @__PURE__ */ function() {
  function NUMCAT_SK2() {
  }
  ;
  NUMCAT_SK2.value = new NUMCAT_SK2();
  return NUMCAT_SK2;
}();
var NUMCAT_SO = /* @__PURE__ */ function() {
  function NUMCAT_SO2() {
  }
  ;
  NUMCAT_SO2.value = new NUMCAT_SO2();
  return NUMCAT_SO2;
}();
var NUMCAT_ZS = /* @__PURE__ */ function() {
  function NUMCAT_ZS2() {
  }
  ;
  NUMCAT_ZS2.value = new NUMCAT_ZS2();
  return NUMCAT_ZS2;
}();
var NUMCAT_ZL = /* @__PURE__ */ function() {
  function NUMCAT_ZL2() {
  }
  ;
  NUMCAT_ZL2.value = new NUMCAT_ZL2();
  return NUMCAT_ZL2;
}();
var NUMCAT_ZP = /* @__PURE__ */ function() {
  function NUMCAT_ZP2() {
  }
  ;
  NUMCAT_ZP2.value = new NUMCAT_ZP2();
  return NUMCAT_ZP2;
}();
var NUMCAT_CC = /* @__PURE__ */ function() {
  function NUMCAT_CC2() {
  }
  ;
  NUMCAT_CC2.value = new NUMCAT_CC2();
  return NUMCAT_CC2;
}();
var NUMCAT_CF = /* @__PURE__ */ function() {
  function NUMCAT_CF2() {
  }
  ;
  NUMCAT_CF2.value = new NUMCAT_CF2();
  return NUMCAT_CF2;
}();
var NUMCAT_CS = /* @__PURE__ */ function() {
  function NUMCAT_CS2() {
  }
  ;
  NUMCAT_CS2.value = new NUMCAT_CS2();
  return NUMCAT_CS2;
}();
var NUMCAT_CO = /* @__PURE__ */ function() {
  function NUMCAT_CO2() {
  }
  ;
  NUMCAT_CO2.value = new NUMCAT_CO2();
  return NUMCAT_CO2;
}();
var NUMCAT_CN = /* @__PURE__ */ function() {
  function NUMCAT_CN2() {
  }
  ;
  NUMCAT_CN2.value = new NUMCAT_CN2();
  return NUMCAT_CN2;
}();
var numLat1Blocks = 63;
var numBlocks = 3396;
var gencatZS = 2;
var rule1 = /* @__PURE__ */ function() {
  return {
    category: gencatZS,
    unicodeCat: NUMCAT_ZS.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatZP = 67108864;
var rule162 = /* @__PURE__ */ function() {
  return {
    category: gencatZP,
    unicodeCat: NUMCAT_ZP.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatZL = 33554432;
var rule161 = /* @__PURE__ */ function() {
  return {
    category: gencatZL,
    unicodeCat: NUMCAT_ZL.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatSO = 8192;
var rule13 = /* @__PURE__ */ function() {
  return {
    category: gencatSO,
    unicodeCat: NUMCAT_SO.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var rule170 = /* @__PURE__ */ function() {
  return {
    category: gencatSO,
    unicodeCat: NUMCAT_SO.value,
    possible: 1,
    updist: 0,
    lowdist: 26,
    titledist: 0
  };
}();
var rule171 = /* @__PURE__ */ function() {
  return {
    category: gencatSO,
    unicodeCat: NUMCAT_SO.value,
    possible: 1,
    updist: -26 | 0,
    lowdist: 0,
    titledist: -26 | 0
  };
}();
var gencatSM = 64;
var rule6 = /* @__PURE__ */ function() {
  return {
    category: gencatSM,
    unicodeCat: NUMCAT_SM.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatSK = 1024;
var rule10 = /* @__PURE__ */ function() {
  return {
    category: gencatSK,
    unicodeCat: NUMCAT_SK.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatSC = 8;
var rule3 = /* @__PURE__ */ function() {
  return {
    category: gencatSC,
    unicodeCat: NUMCAT_SC.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatPS = 16;
var rule4 = /* @__PURE__ */ function() {
  return {
    category: gencatPS,
    unicodeCat: NUMCAT_PS.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatPO = 4;
var rule2 = /* @__PURE__ */ function() {
  return {
    category: gencatPO,
    unicodeCat: NUMCAT_PO.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatPI = 32768;
var rule15 = /* @__PURE__ */ function() {
  return {
    category: gencatPI,
    unicodeCat: NUMCAT_PI.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatPF = 262144;
var rule19 = /* @__PURE__ */ function() {
  return {
    category: gencatPF,
    unicodeCat: NUMCAT_PF.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatPE = 32;
var rule5 = /* @__PURE__ */ function() {
  return {
    category: gencatPE,
    unicodeCat: NUMCAT_PE.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatPD = 128;
var rule7 = /* @__PURE__ */ function() {
  return {
    category: gencatPD,
    unicodeCat: NUMCAT_PD.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatPC = 2048;
var rule11 = /* @__PURE__ */ function() {
  return {
    category: gencatPC,
    unicodeCat: NUMCAT_PC.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatNO = 131072;
var rule17 = /* @__PURE__ */ function() {
  return {
    category: gencatNO,
    unicodeCat: NUMCAT_NO.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatNL = 16777216;
var rule128 = /* @__PURE__ */ function() {
  return {
    category: gencatNL,
    unicodeCat: NUMCAT_NL.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var rule168 = /* @__PURE__ */ function() {
  return {
    category: gencatNL,
    unicodeCat: NUMCAT_NL.value,
    possible: 1,
    updist: 0,
    lowdist: 16,
    titledist: 0
  };
}();
var rule169 = /* @__PURE__ */ function() {
  return {
    category: gencatNL,
    unicodeCat: NUMCAT_NL.value,
    possible: 1,
    updist: -16 | 0,
    lowdist: 0,
    titledist: -16 | 0
  };
}();
var gencatND = 256;
var rule8 = /* @__PURE__ */ function() {
  return {
    category: gencatND,
    unicodeCat: NUMCAT_ND.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatMN = 2097152;
var rule92 = /* @__PURE__ */ function() {
  return {
    category: gencatMN,
    unicodeCat: NUMCAT_MN.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var rule93 = /* @__PURE__ */ function() {
  return {
    category: gencatMN,
    unicodeCat: NUMCAT_MN.value,
    possible: 1,
    updist: 84,
    lowdist: 0,
    titledist: 84
  };
}();
var gencatME = 4194304;
var rule119 = /* @__PURE__ */ function() {
  return {
    category: gencatME,
    unicodeCat: NUMCAT_ME.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatMC = 8388608;
var rule124 = /* @__PURE__ */ function() {
  return {
    category: gencatMC,
    unicodeCat: NUMCAT_MC.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatLU = 512;
var nullrule = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_CN.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var rule104 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 8,
    titledist: 0
  };
}();
var rule107 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var rule115 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -60 | 0,
    titledist: 0
  };
}();
var rule117 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -7 | 0,
    titledist: 0
  };
}();
var rule118 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 80,
    titledist: 0
  };
}();
var rule120 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 15,
    titledist: 0
  };
}();
var rule122 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 48,
    titledist: 0
  };
}();
var rule125 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 7264,
    titledist: 0
  };
}();
var rule127 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 38864,
    titledist: 0
  };
}();
var rule137 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -3008 | 0,
    titledist: 0
  };
}();
var rule142 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -7615 | 0,
    titledist: 0
  };
}();
var rule144 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -8 | 0,
    titledist: 0
  };
}();
var rule153 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -74 | 0,
    titledist: 0
  };
}();
var rule156 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -86 | 0,
    titledist: 0
  };
}();
var rule157 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -100 | 0,
    titledist: 0
  };
}();
var rule158 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -112 | 0,
    titledist: 0
  };
}();
var rule159 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -128 | 0,
    titledist: 0
  };
}();
var rule160 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -126 | 0,
    titledist: 0
  };
}();
var rule163 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -7517 | 0,
    titledist: 0
  };
}();
var rule164 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -8383 | 0,
    titledist: 0
  };
}();
var rule165 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -8262 | 0,
    titledist: 0
  };
}();
var rule166 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 28,
    titledist: 0
  };
}();
var rule172 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -10743 | 0,
    titledist: 0
  };
}();
var rule173 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -3814 | 0,
    titledist: 0
  };
}();
var rule174 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -10727 | 0,
    titledist: 0
  };
}();
var rule177 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -10780 | 0,
    titledist: 0
  };
}();
var rule178 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -10749 | 0,
    titledist: 0
  };
}();
var rule179 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -10783 | 0,
    titledist: 0
  };
}();
var rule180 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -10782 | 0,
    titledist: 0
  };
}();
var rule181 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -10815 | 0,
    titledist: 0
  };
}();
var rule183 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -35332 | 0,
    titledist: 0
  };
}();
var rule184 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -42280 | 0,
    titledist: 0
  };
}();
var rule186 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -42308 | 0,
    titledist: 0
  };
}();
var rule187 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -42319 | 0,
    titledist: 0
  };
}();
var rule188 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -42315 | 0,
    titledist: 0
  };
}();
var rule189 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -42305 | 0,
    titledist: 0
  };
}();
var rule190 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -42258 | 0,
    titledist: 0
  };
}();
var rule191 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -42282 | 0,
    titledist: 0
  };
}();
var rule192 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -42261 | 0,
    titledist: 0
  };
}();
var rule193 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 928,
    titledist: 0
  };
}();
var rule194 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -48 | 0,
    titledist: 0
  };
}();
var rule195 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -42307 | 0,
    titledist: 0
  };
}();
var rule196 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -35384 | 0,
    titledist: 0
  };
}();
var rule201 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 40,
    titledist: 0
  };
}();
var rule203 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 34,
    titledist: 0
  };
}();
var rule22 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 1,
    titledist: 0
  };
}();
var rule24 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -199 | 0,
    titledist: 0
  };
}();
var rule26 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -121 | 0,
    titledist: 0
  };
}();
var rule29 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 210,
    titledist: 0
  };
}();
var rule30 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 206,
    titledist: 0
  };
}();
var rule31 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 205,
    titledist: 0
  };
}();
var rule32 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 79,
    titledist: 0
  };
}();
var rule33 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 202,
    titledist: 0
  };
}();
var rule34 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 203,
    titledist: 0
  };
}();
var rule35 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 207,
    titledist: 0
  };
}();
var rule37 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 211,
    titledist: 0
  };
}();
var rule38 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 209,
    titledist: 0
  };
}();
var rule40 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 213,
    titledist: 0
  };
}();
var rule42 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 214,
    titledist: 0
  };
}();
var rule43 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 218,
    titledist: 0
  };
}();
var rule44 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 217,
    titledist: 0
  };
}();
var rule45 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 219,
    titledist: 0
  };
}();
var rule47 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 2,
    titledist: 1
  };
}();
var rule51 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -97 | 0,
    titledist: 0
  };
}();
var rule52 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -56 | 0,
    titledist: 0
  };
}();
var rule53 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -130 | 0,
    titledist: 0
  };
}();
var rule54 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 10795,
    titledist: 0
  };
}();
var rule55 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -163 | 0,
    titledist: 0
  };
}();
var rule56 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 10792,
    titledist: 0
  };
}();
var rule58 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: -195 | 0,
    titledist: 0
  };
}();
var rule59 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 69,
    titledist: 0
  };
}();
var rule60 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 71,
    titledist: 0
  };
}();
var rule9 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 32,
    titledist: 0
  };
}();
var rule94 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 116,
    titledist: 0
  };
}();
var rule95 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 38,
    titledist: 0
  };
}();
var rule96 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 37,
    titledist: 0
  };
}();
var rule97 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 64,
    titledist: 0
  };
}();
var rule98 = /* @__PURE__ */ function() {
  return {
    category: gencatLU,
    unicodeCat: NUMCAT_LU.value,
    possible: 1,
    updist: 0,
    lowdist: 63,
    titledist: 0
  };
}();
var gencatLT = 524288;
var rule151 = /* @__PURE__ */ function() {
  return {
    category: gencatLT,
    unicodeCat: NUMCAT_LT.value,
    possible: 1,
    updist: 0,
    lowdist: -8 | 0,
    titledist: 0
  };
}();
var rule154 = /* @__PURE__ */ function() {
  return {
    category: gencatLT,
    unicodeCat: NUMCAT_LT.value,
    possible: 1,
    updist: 0,
    lowdist: -9 | 0,
    titledist: 0
  };
}();
var rule48 = /* @__PURE__ */ function() {
  return {
    category: gencatLT,
    unicodeCat: NUMCAT_LT.value,
    possible: 1,
    updist: -1 | 0,
    lowdist: 1,
    titledist: 0
  };
}();
var gencatLO = 16384;
var rule14 = /* @__PURE__ */ function() {
  return {
    category: gencatLO,
    unicodeCat: NUMCAT_LO.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatLM = 1048576;
var rule91 = /* @__PURE__ */ function() {
  return {
    category: gencatLM,
    unicodeCat: NUMCAT_LM.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatLL = 4096;
var rule100 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -37 | 0,
    lowdist: 0,
    titledist: -37 | 0
  };
}();
var rule101 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -31 | 0,
    lowdist: 0,
    titledist: -31 | 0
  };
}();
var rule102 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -64 | 0,
    lowdist: 0,
    titledist: -64 | 0
  };
}();
var rule103 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -63 | 0,
    lowdist: 0,
    titledist: -63 | 0
  };
}();
var rule105 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -62 | 0,
    lowdist: 0,
    titledist: -62 | 0
  };
}();
var rule106 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -57 | 0,
    lowdist: 0,
    titledist: -57 | 0
  };
}();
var rule108 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -47 | 0,
    lowdist: 0,
    titledist: -47 | 0
  };
}();
var rule109 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -54 | 0,
    lowdist: 0,
    titledist: -54 | 0
  };
}();
var rule110 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -8 | 0,
    lowdist: 0,
    titledist: -8 | 0
  };
}();
var rule111 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -86 | 0,
    lowdist: 0,
    titledist: -86 | 0
  };
}();
var rule112 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -80 | 0,
    lowdist: 0,
    titledist: -80 | 0
  };
}();
var rule113 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 7,
    lowdist: 0,
    titledist: 7
  };
}();
var rule114 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -116 | 0,
    lowdist: 0,
    titledist: -116 | 0
  };
}();
var rule116 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -96 | 0,
    lowdist: 0,
    titledist: -96 | 0
  };
}();
var rule12 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -32 | 0,
    lowdist: 0,
    titledist: -32 | 0
  };
}();
var rule121 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -15 | 0,
    lowdist: 0,
    titledist: -15 | 0
  };
}();
var rule123 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -48 | 0,
    lowdist: 0,
    titledist: -48 | 0
  };
}();
var rule126 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 3008,
    lowdist: 0,
    titledist: 0
  };
}();
var rule129 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -6254 | 0,
    lowdist: 0,
    titledist: -6254 | 0
  };
}();
var rule130 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -6253 | 0,
    lowdist: 0,
    titledist: -6253 | 0
  };
}();
var rule131 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -6244 | 0,
    lowdist: 0,
    titledist: -6244 | 0
  };
}();
var rule132 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -6242 | 0,
    lowdist: 0,
    titledist: -6242 | 0
  };
}();
var rule133 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -6243 | 0,
    lowdist: 0,
    titledist: -6243 | 0
  };
}();
var rule134 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -6236 | 0,
    lowdist: 0,
    titledist: -6236 | 0
  };
}();
var rule135 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -6181 | 0,
    lowdist: 0,
    titledist: -6181 | 0
  };
}();
var rule136 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 35266,
    lowdist: 0,
    titledist: 35266
  };
}();
var rule138 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 35332,
    lowdist: 0,
    titledist: 35332
  };
}();
var rule139 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 3814,
    lowdist: 0,
    titledist: 3814
  };
}();
var rule140 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 35384,
    lowdist: 0,
    titledist: 35384
  };
}();
var rule141 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -59 | 0,
    lowdist: 0,
    titledist: -59 | 0
  };
}();
var rule143 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 8,
    lowdist: 0,
    titledist: 8
  };
}();
var rule145 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 74,
    lowdist: 0,
    titledist: 74
  };
}();
var rule146 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 86,
    lowdist: 0,
    titledist: 86
  };
}();
var rule147 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 100,
    lowdist: 0,
    titledist: 100
  };
}();
var rule148 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 128,
    lowdist: 0,
    titledist: 128
  };
}();
var rule149 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 112,
    lowdist: 0,
    titledist: 112
  };
}();
var rule150 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 126,
    lowdist: 0,
    titledist: 126
  };
}();
var rule152 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 9,
    lowdist: 0,
    titledist: 9
  };
}();
var rule155 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -7205 | 0,
    lowdist: 0,
    titledist: -7205 | 0
  };
}();
var rule167 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -28 | 0,
    lowdist: 0,
    titledist: -28 | 0
  };
}();
var rule175 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -10795 | 0,
    lowdist: 0,
    titledist: -10795 | 0
  };
}();
var rule176 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -10792 | 0,
    lowdist: 0,
    titledist: -10792 | 0
  };
}();
var rule18 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 743,
    lowdist: 0,
    titledist: 743
  };
}();
var rule182 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -7264 | 0,
    lowdist: 0,
    titledist: -7264 | 0
  };
}();
var rule185 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 48,
    lowdist: 0,
    titledist: 48
  };
}();
var rule197 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -928 | 0,
    lowdist: 0,
    titledist: -928 | 0
  };
}();
var rule198 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -38864 | 0,
    lowdist: 0,
    titledist: -38864 | 0
  };
}();
var rule20 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var rule202 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -40 | 0,
    lowdist: 0,
    titledist: -40 | 0
  };
}();
var rule204 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -34 | 0,
    lowdist: 0,
    titledist: -34 | 0
  };
}();
var rule21 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 121,
    lowdist: 0,
    titledist: 121
  };
}();
var rule23 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -1 | 0,
    lowdist: 0,
    titledist: -1 | 0
  };
}();
var rule25 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -232 | 0,
    lowdist: 0,
    titledist: -232 | 0
  };
}();
var rule27 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -300 | 0,
    lowdist: 0,
    titledist: -300 | 0
  };
}();
var rule28 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 195,
    lowdist: 0,
    titledist: 195
  };
}();
var rule36 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 97,
    lowdist: 0,
    titledist: 97
  };
}();
var rule39 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 163,
    lowdist: 0,
    titledist: 163
  };
}();
var rule41 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 130,
    lowdist: 0,
    titledist: 130
  };
}();
var rule46 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 56,
    lowdist: 0,
    titledist: 56
  };
}();
var rule49 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -2 | 0,
    lowdist: 0,
    titledist: -1 | 0
  };
}();
var rule50 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -79 | 0,
    lowdist: 0,
    titledist: -79 | 0
  };
}();
var rule57 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 10815,
    lowdist: 0,
    titledist: 10815
  };
}();
var rule61 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 10783,
    lowdist: 0,
    titledist: 10783
  };
}();
var rule62 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 10780,
    lowdist: 0,
    titledist: 10780
  };
}();
var rule63 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 10782,
    lowdist: 0,
    titledist: 10782
  };
}();
var rule64 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -210 | 0,
    lowdist: 0,
    titledist: -210 | 0
  };
}();
var rule65 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -206 | 0,
    lowdist: 0,
    titledist: -206 | 0
  };
}();
var rule66 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -205 | 0,
    lowdist: 0,
    titledist: -205 | 0
  };
}();
var rule67 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -202 | 0,
    lowdist: 0,
    titledist: -202 | 0
  };
}();
var rule68 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -203 | 0,
    lowdist: 0,
    titledist: -203 | 0
  };
}();
var rule69 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 42319,
    lowdist: 0,
    titledist: 42319
  };
}();
var rule70 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 42315,
    lowdist: 0,
    titledist: 42315
  };
}();
var rule71 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -207 | 0,
    lowdist: 0,
    titledist: -207 | 0
  };
}();
var rule72 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 42280,
    lowdist: 0,
    titledist: 42280
  };
}();
var rule73 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 42308,
    lowdist: 0,
    titledist: 42308
  };
}();
var rule74 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -209 | 0,
    lowdist: 0,
    titledist: -209 | 0
  };
}();
var rule75 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -211 | 0,
    lowdist: 0,
    titledist: -211 | 0
  };
}();
var rule76 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 10743,
    lowdist: 0,
    titledist: 10743
  };
}();
var rule77 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 42305,
    lowdist: 0,
    titledist: 42305
  };
}();
var rule78 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 10749,
    lowdist: 0,
    titledist: 10749
  };
}();
var rule79 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -213 | 0,
    lowdist: 0,
    titledist: -213 | 0
  };
}();
var rule80 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -214 | 0,
    lowdist: 0,
    titledist: -214 | 0
  };
}();
var rule81 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 10727,
    lowdist: 0,
    titledist: 10727
  };
}();
var rule82 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -218 | 0,
    lowdist: 0,
    titledist: -218 | 0
  };
}();
var rule83 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 42307,
    lowdist: 0,
    titledist: 42307
  };
}();
var rule84 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 42282,
    lowdist: 0,
    titledist: 42282
  };
}();
var rule85 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -69 | 0,
    lowdist: 0,
    titledist: -69 | 0
  };
}();
var rule86 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -217 | 0,
    lowdist: 0,
    titledist: -217 | 0
  };
}();
var rule87 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -71 | 0,
    lowdist: 0,
    titledist: -71 | 0
  };
}();
var rule88 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -219 | 0,
    lowdist: 0,
    titledist: -219 | 0
  };
}();
var rule89 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 42261,
    lowdist: 0,
    titledist: 42261
  };
}();
var rule90 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: 42258,
    lowdist: 0,
    titledist: 42258
  };
}();
var rule99 = /* @__PURE__ */ function() {
  return {
    category: gencatLL,
    unicodeCat: NUMCAT_LL.value,
    possible: 1,
    updist: -38 | 0,
    lowdist: 0,
    titledist: -38 | 0
  };
}();
var gencatCS = 134217728;
var rule199 = /* @__PURE__ */ function() {
  return {
    category: gencatCS,
    unicodeCat: NUMCAT_CS.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatCO = 268435456;
var rule200 = /* @__PURE__ */ function() {
  return {
    category: gencatCO,
    unicodeCat: NUMCAT_CO.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatCF = 65536;
var rule16 = /* @__PURE__ */ function() {
  return {
    category: gencatCF,
    unicodeCat: NUMCAT_CF.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var gencatCC = 1;
var rule0 = /* @__PURE__ */ function() {
  return {
    category: gencatCC,
    unicodeCat: NUMCAT_CC.value,
    possible: 0,
    updist: 0,
    lowdist: 0,
    titledist: 0
  };
}();
var bsearch = function(a) {
  return function(array2) {
    return function(size10) {
      return function(compare10) {
        var go = function($copy_i) {
          return function($copy_k) {
            var $tco_var_i = $copy_i;
            var $tco_done = false;
            var $tco_result;
            function $tco_loop(i, k) {
              if (i > k || i >= length(array2)) {
                $tco_done = true;
                return Nothing.value;
              }
              ;
              if (otherwise) {
                var j = floor2(toNumber2(i + k | 0) / 2);
                var b = unsafeIndex3(array2)(j);
                var v = compare10(a)(b);
                if (v instanceof EQ) {
                  $tco_done = true;
                  return new Just(b);
                }
                ;
                if (v instanceof GT) {
                  $tco_var_i = j + 1 | 0;
                  $copy_k = k;
                  return;
                }
                ;
                $tco_var_i = i;
                $copy_k = j - 1 | 0;
                return;
              }
              ;
              throw new Error("Failed pattern match at Data.CodePoint.Unicode.Internal (line 5622, column 3 - line 5632, column 30): " + [i.constructor.name, k.constructor.name]);
            }
            ;
            while (!$tco_done) {
              $tco_result = $tco_loop($tco_var_i, $copy_k);
            }
            ;
            return $tco_result;
          };
        };
        return go(0)(size10);
      };
    };
  };
};
var blkCmp = function(v) {
  return function(v1) {
    if (v.start >= v1.start && v.start < (v1.start + v1.length | 0)) {
      return EQ.value;
    }
    ;
    if (v.start > v1.start) {
      return GT.value;
    }
    ;
    if (otherwise) {
      return LT.value;
    }
    ;
    throw new Error("Failed pattern match at Data.CodePoint.Unicode.Internal (line 5598, column 1 - line 5598, column 45): " + [v.constructor.name, v1.constructor.name]);
  };
};
var getRule = function(blocks) {
  return function(unichar) {
    return function(size10) {
      var key = {
        start: unichar,
        length: 1,
        convRule: nullrule
      };
      var maybeCharBlock = bsearch(key)(blocks)(size10)(blkCmp);
      if (maybeCharBlock instanceof Nothing) {
        return Nothing.value;
      }
      ;
      if (maybeCharBlock instanceof Just) {
        return new Just(maybeCharBlock.value0.convRule);
      }
      ;
      throw new Error("Failed pattern match at Data.CodePoint.Unicode.Internal (line 5612, column 5 - line 5614, column 60): " + [maybeCharBlock.constructor.name]);
    };
  };
};
var allchars = [{
  start: 0,
  length: 32,
  convRule: rule0
}, {
  start: 32,
  length: 1,
  convRule: rule1
}, {
  start: 33,
  length: 3,
  convRule: rule2
}, {
  start: 36,
  length: 1,
  convRule: rule3
}, {
  start: 37,
  length: 3,
  convRule: rule2
}, {
  start: 40,
  length: 1,
  convRule: rule4
}, {
  start: 41,
  length: 1,
  convRule: rule5
}, {
  start: 42,
  length: 1,
  convRule: rule2
}, {
  start: 43,
  length: 1,
  convRule: rule6
}, {
  start: 44,
  length: 1,
  convRule: rule2
}, {
  start: 45,
  length: 1,
  convRule: rule7
}, {
  start: 46,
  length: 2,
  convRule: rule2
}, {
  start: 48,
  length: 10,
  convRule: rule8
}, {
  start: 58,
  length: 2,
  convRule: rule2
}, {
  start: 60,
  length: 3,
  convRule: rule6
}, {
  start: 63,
  length: 2,
  convRule: rule2
}, {
  start: 65,
  length: 26,
  convRule: rule9
}, {
  start: 91,
  length: 1,
  convRule: rule4
}, {
  start: 92,
  length: 1,
  convRule: rule2
}, {
  start: 93,
  length: 1,
  convRule: rule5
}, {
  start: 94,
  length: 1,
  convRule: rule10
}, {
  start: 95,
  length: 1,
  convRule: rule11
}, {
  start: 96,
  length: 1,
  convRule: rule10
}, {
  start: 97,
  length: 26,
  convRule: rule12
}, {
  start: 123,
  length: 1,
  convRule: rule4
}, {
  start: 124,
  length: 1,
  convRule: rule6
}, {
  start: 125,
  length: 1,
  convRule: rule5
}, {
  start: 126,
  length: 1,
  convRule: rule6
}, {
  start: 127,
  length: 33,
  convRule: rule0
}, {
  start: 160,
  length: 1,
  convRule: rule1
}, {
  start: 161,
  length: 1,
  convRule: rule2
}, {
  start: 162,
  length: 4,
  convRule: rule3
}, {
  start: 166,
  length: 1,
  convRule: rule13
}, {
  start: 167,
  length: 1,
  convRule: rule2
}, {
  start: 168,
  length: 1,
  convRule: rule10
}, {
  start: 169,
  length: 1,
  convRule: rule13
}, {
  start: 170,
  length: 1,
  convRule: rule14
}, {
  start: 171,
  length: 1,
  convRule: rule15
}, {
  start: 172,
  length: 1,
  convRule: rule6
}, {
  start: 173,
  length: 1,
  convRule: rule16
}, {
  start: 174,
  length: 1,
  convRule: rule13
}, {
  start: 175,
  length: 1,
  convRule: rule10
}, {
  start: 176,
  length: 1,
  convRule: rule13
}, {
  start: 177,
  length: 1,
  convRule: rule6
}, {
  start: 178,
  length: 2,
  convRule: rule17
}, {
  start: 180,
  length: 1,
  convRule: rule10
}, {
  start: 181,
  length: 1,
  convRule: rule18
}, {
  start: 182,
  length: 2,
  convRule: rule2
}, {
  start: 184,
  length: 1,
  convRule: rule10
}, {
  start: 185,
  length: 1,
  convRule: rule17
}, {
  start: 186,
  length: 1,
  convRule: rule14
}, {
  start: 187,
  length: 1,
  convRule: rule19
}, {
  start: 188,
  length: 3,
  convRule: rule17
}, {
  start: 191,
  length: 1,
  convRule: rule2
}, {
  start: 192,
  length: 23,
  convRule: rule9
}, {
  start: 215,
  length: 1,
  convRule: rule6
}, {
  start: 216,
  length: 7,
  convRule: rule9
}, {
  start: 223,
  length: 1,
  convRule: rule20
}, {
  start: 224,
  length: 23,
  convRule: rule12
}, {
  start: 247,
  length: 1,
  convRule: rule6
}, {
  start: 248,
  length: 7,
  convRule: rule12
}, {
  start: 255,
  length: 1,
  convRule: rule21
}, {
  start: 256,
  length: 1,
  convRule: rule22
}, {
  start: 257,
  length: 1,
  convRule: rule23
}, {
  start: 258,
  length: 1,
  convRule: rule22
}, {
  start: 259,
  length: 1,
  convRule: rule23
}, {
  start: 260,
  length: 1,
  convRule: rule22
}, {
  start: 261,
  length: 1,
  convRule: rule23
}, {
  start: 262,
  length: 1,
  convRule: rule22
}, {
  start: 263,
  length: 1,
  convRule: rule23
}, {
  start: 264,
  length: 1,
  convRule: rule22
}, {
  start: 265,
  length: 1,
  convRule: rule23
}, {
  start: 266,
  length: 1,
  convRule: rule22
}, {
  start: 267,
  length: 1,
  convRule: rule23
}, {
  start: 268,
  length: 1,
  convRule: rule22
}, {
  start: 269,
  length: 1,
  convRule: rule23
}, {
  start: 270,
  length: 1,
  convRule: rule22
}, {
  start: 271,
  length: 1,
  convRule: rule23
}, {
  start: 272,
  length: 1,
  convRule: rule22
}, {
  start: 273,
  length: 1,
  convRule: rule23
}, {
  start: 274,
  length: 1,
  convRule: rule22
}, {
  start: 275,
  length: 1,
  convRule: rule23
}, {
  start: 276,
  length: 1,
  convRule: rule22
}, {
  start: 277,
  length: 1,
  convRule: rule23
}, {
  start: 278,
  length: 1,
  convRule: rule22
}, {
  start: 279,
  length: 1,
  convRule: rule23
}, {
  start: 280,
  length: 1,
  convRule: rule22
}, {
  start: 281,
  length: 1,
  convRule: rule23
}, {
  start: 282,
  length: 1,
  convRule: rule22
}, {
  start: 283,
  length: 1,
  convRule: rule23
}, {
  start: 284,
  length: 1,
  convRule: rule22
}, {
  start: 285,
  length: 1,
  convRule: rule23
}, {
  start: 286,
  length: 1,
  convRule: rule22
}, {
  start: 287,
  length: 1,
  convRule: rule23
}, {
  start: 288,
  length: 1,
  convRule: rule22
}, {
  start: 289,
  length: 1,
  convRule: rule23
}, {
  start: 290,
  length: 1,
  convRule: rule22
}, {
  start: 291,
  length: 1,
  convRule: rule23
}, {
  start: 292,
  length: 1,
  convRule: rule22
}, {
  start: 293,
  length: 1,
  convRule: rule23
}, {
  start: 294,
  length: 1,
  convRule: rule22
}, {
  start: 295,
  length: 1,
  convRule: rule23
}, {
  start: 296,
  length: 1,
  convRule: rule22
}, {
  start: 297,
  length: 1,
  convRule: rule23
}, {
  start: 298,
  length: 1,
  convRule: rule22
}, {
  start: 299,
  length: 1,
  convRule: rule23
}, {
  start: 300,
  length: 1,
  convRule: rule22
}, {
  start: 301,
  length: 1,
  convRule: rule23
}, {
  start: 302,
  length: 1,
  convRule: rule22
}, {
  start: 303,
  length: 1,
  convRule: rule23
}, {
  start: 304,
  length: 1,
  convRule: rule24
}, {
  start: 305,
  length: 1,
  convRule: rule25
}, {
  start: 306,
  length: 1,
  convRule: rule22
}, {
  start: 307,
  length: 1,
  convRule: rule23
}, {
  start: 308,
  length: 1,
  convRule: rule22
}, {
  start: 309,
  length: 1,
  convRule: rule23
}, {
  start: 310,
  length: 1,
  convRule: rule22
}, {
  start: 311,
  length: 1,
  convRule: rule23
}, {
  start: 312,
  length: 1,
  convRule: rule20
}, {
  start: 313,
  length: 1,
  convRule: rule22
}, {
  start: 314,
  length: 1,
  convRule: rule23
}, {
  start: 315,
  length: 1,
  convRule: rule22
}, {
  start: 316,
  length: 1,
  convRule: rule23
}, {
  start: 317,
  length: 1,
  convRule: rule22
}, {
  start: 318,
  length: 1,
  convRule: rule23
}, {
  start: 319,
  length: 1,
  convRule: rule22
}, {
  start: 320,
  length: 1,
  convRule: rule23
}, {
  start: 321,
  length: 1,
  convRule: rule22
}, {
  start: 322,
  length: 1,
  convRule: rule23
}, {
  start: 323,
  length: 1,
  convRule: rule22
}, {
  start: 324,
  length: 1,
  convRule: rule23
}, {
  start: 325,
  length: 1,
  convRule: rule22
}, {
  start: 326,
  length: 1,
  convRule: rule23
}, {
  start: 327,
  length: 1,
  convRule: rule22
}, {
  start: 328,
  length: 1,
  convRule: rule23
}, {
  start: 329,
  length: 1,
  convRule: rule20
}, {
  start: 330,
  length: 1,
  convRule: rule22
}, {
  start: 331,
  length: 1,
  convRule: rule23
}, {
  start: 332,
  length: 1,
  convRule: rule22
}, {
  start: 333,
  length: 1,
  convRule: rule23
}, {
  start: 334,
  length: 1,
  convRule: rule22
}, {
  start: 335,
  length: 1,
  convRule: rule23
}, {
  start: 336,
  length: 1,
  convRule: rule22
}, {
  start: 337,
  length: 1,
  convRule: rule23
}, {
  start: 338,
  length: 1,
  convRule: rule22
}, {
  start: 339,
  length: 1,
  convRule: rule23
}, {
  start: 340,
  length: 1,
  convRule: rule22
}, {
  start: 341,
  length: 1,
  convRule: rule23
}, {
  start: 342,
  length: 1,
  convRule: rule22
}, {
  start: 343,
  length: 1,
  convRule: rule23
}, {
  start: 344,
  length: 1,
  convRule: rule22
}, {
  start: 345,
  length: 1,
  convRule: rule23
}, {
  start: 346,
  length: 1,
  convRule: rule22
}, {
  start: 347,
  length: 1,
  convRule: rule23
}, {
  start: 348,
  length: 1,
  convRule: rule22
}, {
  start: 349,
  length: 1,
  convRule: rule23
}, {
  start: 350,
  length: 1,
  convRule: rule22
}, {
  start: 351,
  length: 1,
  convRule: rule23
}, {
  start: 352,
  length: 1,
  convRule: rule22
}, {
  start: 353,
  length: 1,
  convRule: rule23
}, {
  start: 354,
  length: 1,
  convRule: rule22
}, {
  start: 355,
  length: 1,
  convRule: rule23
}, {
  start: 356,
  length: 1,
  convRule: rule22
}, {
  start: 357,
  length: 1,
  convRule: rule23
}, {
  start: 358,
  length: 1,
  convRule: rule22
}, {
  start: 359,
  length: 1,
  convRule: rule23
}, {
  start: 360,
  length: 1,
  convRule: rule22
}, {
  start: 361,
  length: 1,
  convRule: rule23
}, {
  start: 362,
  length: 1,
  convRule: rule22
}, {
  start: 363,
  length: 1,
  convRule: rule23
}, {
  start: 364,
  length: 1,
  convRule: rule22
}, {
  start: 365,
  length: 1,
  convRule: rule23
}, {
  start: 366,
  length: 1,
  convRule: rule22
}, {
  start: 367,
  length: 1,
  convRule: rule23
}, {
  start: 368,
  length: 1,
  convRule: rule22
}, {
  start: 369,
  length: 1,
  convRule: rule23
}, {
  start: 370,
  length: 1,
  convRule: rule22
}, {
  start: 371,
  length: 1,
  convRule: rule23
}, {
  start: 372,
  length: 1,
  convRule: rule22
}, {
  start: 373,
  length: 1,
  convRule: rule23
}, {
  start: 374,
  length: 1,
  convRule: rule22
}, {
  start: 375,
  length: 1,
  convRule: rule23
}, {
  start: 376,
  length: 1,
  convRule: rule26
}, {
  start: 377,
  length: 1,
  convRule: rule22
}, {
  start: 378,
  length: 1,
  convRule: rule23
}, {
  start: 379,
  length: 1,
  convRule: rule22
}, {
  start: 380,
  length: 1,
  convRule: rule23
}, {
  start: 381,
  length: 1,
  convRule: rule22
}, {
  start: 382,
  length: 1,
  convRule: rule23
}, {
  start: 383,
  length: 1,
  convRule: rule27
}, {
  start: 384,
  length: 1,
  convRule: rule28
}, {
  start: 385,
  length: 1,
  convRule: rule29
}, {
  start: 386,
  length: 1,
  convRule: rule22
}, {
  start: 387,
  length: 1,
  convRule: rule23
}, {
  start: 388,
  length: 1,
  convRule: rule22
}, {
  start: 389,
  length: 1,
  convRule: rule23
}, {
  start: 390,
  length: 1,
  convRule: rule30
}, {
  start: 391,
  length: 1,
  convRule: rule22
}, {
  start: 392,
  length: 1,
  convRule: rule23
}, {
  start: 393,
  length: 2,
  convRule: rule31
}, {
  start: 395,
  length: 1,
  convRule: rule22
}, {
  start: 396,
  length: 1,
  convRule: rule23
}, {
  start: 397,
  length: 1,
  convRule: rule20
}, {
  start: 398,
  length: 1,
  convRule: rule32
}, {
  start: 399,
  length: 1,
  convRule: rule33
}, {
  start: 400,
  length: 1,
  convRule: rule34
}, {
  start: 401,
  length: 1,
  convRule: rule22
}, {
  start: 402,
  length: 1,
  convRule: rule23
}, {
  start: 403,
  length: 1,
  convRule: rule31
}, {
  start: 404,
  length: 1,
  convRule: rule35
}, {
  start: 405,
  length: 1,
  convRule: rule36
}, {
  start: 406,
  length: 1,
  convRule: rule37
}, {
  start: 407,
  length: 1,
  convRule: rule38
}, {
  start: 408,
  length: 1,
  convRule: rule22
}, {
  start: 409,
  length: 1,
  convRule: rule23
}, {
  start: 410,
  length: 1,
  convRule: rule39
}, {
  start: 411,
  length: 1,
  convRule: rule20
}, {
  start: 412,
  length: 1,
  convRule: rule37
}, {
  start: 413,
  length: 1,
  convRule: rule40
}, {
  start: 414,
  length: 1,
  convRule: rule41
}, {
  start: 415,
  length: 1,
  convRule: rule42
}, {
  start: 416,
  length: 1,
  convRule: rule22
}, {
  start: 417,
  length: 1,
  convRule: rule23
}, {
  start: 418,
  length: 1,
  convRule: rule22
}, {
  start: 419,
  length: 1,
  convRule: rule23
}, {
  start: 420,
  length: 1,
  convRule: rule22
}, {
  start: 421,
  length: 1,
  convRule: rule23
}, {
  start: 422,
  length: 1,
  convRule: rule43
}, {
  start: 423,
  length: 1,
  convRule: rule22
}, {
  start: 424,
  length: 1,
  convRule: rule23
}, {
  start: 425,
  length: 1,
  convRule: rule43
}, {
  start: 426,
  length: 2,
  convRule: rule20
}, {
  start: 428,
  length: 1,
  convRule: rule22
}, {
  start: 429,
  length: 1,
  convRule: rule23
}, {
  start: 430,
  length: 1,
  convRule: rule43
}, {
  start: 431,
  length: 1,
  convRule: rule22
}, {
  start: 432,
  length: 1,
  convRule: rule23
}, {
  start: 433,
  length: 2,
  convRule: rule44
}, {
  start: 435,
  length: 1,
  convRule: rule22
}, {
  start: 436,
  length: 1,
  convRule: rule23
}, {
  start: 437,
  length: 1,
  convRule: rule22
}, {
  start: 438,
  length: 1,
  convRule: rule23
}, {
  start: 439,
  length: 1,
  convRule: rule45
}, {
  start: 440,
  length: 1,
  convRule: rule22
}, {
  start: 441,
  length: 1,
  convRule: rule23
}, {
  start: 442,
  length: 1,
  convRule: rule20
}, {
  start: 443,
  length: 1,
  convRule: rule14
}, {
  start: 444,
  length: 1,
  convRule: rule22
}, {
  start: 445,
  length: 1,
  convRule: rule23
}, {
  start: 446,
  length: 1,
  convRule: rule20
}, {
  start: 447,
  length: 1,
  convRule: rule46
}, {
  start: 448,
  length: 4,
  convRule: rule14
}, {
  start: 452,
  length: 1,
  convRule: rule47
}, {
  start: 453,
  length: 1,
  convRule: rule48
}, {
  start: 454,
  length: 1,
  convRule: rule49
}, {
  start: 455,
  length: 1,
  convRule: rule47
}, {
  start: 456,
  length: 1,
  convRule: rule48
}, {
  start: 457,
  length: 1,
  convRule: rule49
}, {
  start: 458,
  length: 1,
  convRule: rule47
}, {
  start: 459,
  length: 1,
  convRule: rule48
}, {
  start: 460,
  length: 1,
  convRule: rule49
}, {
  start: 461,
  length: 1,
  convRule: rule22
}, {
  start: 462,
  length: 1,
  convRule: rule23
}, {
  start: 463,
  length: 1,
  convRule: rule22
}, {
  start: 464,
  length: 1,
  convRule: rule23
}, {
  start: 465,
  length: 1,
  convRule: rule22
}, {
  start: 466,
  length: 1,
  convRule: rule23
}, {
  start: 467,
  length: 1,
  convRule: rule22
}, {
  start: 468,
  length: 1,
  convRule: rule23
}, {
  start: 469,
  length: 1,
  convRule: rule22
}, {
  start: 470,
  length: 1,
  convRule: rule23
}, {
  start: 471,
  length: 1,
  convRule: rule22
}, {
  start: 472,
  length: 1,
  convRule: rule23
}, {
  start: 473,
  length: 1,
  convRule: rule22
}, {
  start: 474,
  length: 1,
  convRule: rule23
}, {
  start: 475,
  length: 1,
  convRule: rule22
}, {
  start: 476,
  length: 1,
  convRule: rule23
}, {
  start: 477,
  length: 1,
  convRule: rule50
}, {
  start: 478,
  length: 1,
  convRule: rule22
}, {
  start: 479,
  length: 1,
  convRule: rule23
}, {
  start: 480,
  length: 1,
  convRule: rule22
}, {
  start: 481,
  length: 1,
  convRule: rule23
}, {
  start: 482,
  length: 1,
  convRule: rule22
}, {
  start: 483,
  length: 1,
  convRule: rule23
}, {
  start: 484,
  length: 1,
  convRule: rule22
}, {
  start: 485,
  length: 1,
  convRule: rule23
}, {
  start: 486,
  length: 1,
  convRule: rule22
}, {
  start: 487,
  length: 1,
  convRule: rule23
}, {
  start: 488,
  length: 1,
  convRule: rule22
}, {
  start: 489,
  length: 1,
  convRule: rule23
}, {
  start: 490,
  length: 1,
  convRule: rule22
}, {
  start: 491,
  length: 1,
  convRule: rule23
}, {
  start: 492,
  length: 1,
  convRule: rule22
}, {
  start: 493,
  length: 1,
  convRule: rule23
}, {
  start: 494,
  length: 1,
  convRule: rule22
}, {
  start: 495,
  length: 1,
  convRule: rule23
}, {
  start: 496,
  length: 1,
  convRule: rule20
}, {
  start: 497,
  length: 1,
  convRule: rule47
}, {
  start: 498,
  length: 1,
  convRule: rule48
}, {
  start: 499,
  length: 1,
  convRule: rule49
}, {
  start: 500,
  length: 1,
  convRule: rule22
}, {
  start: 501,
  length: 1,
  convRule: rule23
}, {
  start: 502,
  length: 1,
  convRule: rule51
}, {
  start: 503,
  length: 1,
  convRule: rule52
}, {
  start: 504,
  length: 1,
  convRule: rule22
}, {
  start: 505,
  length: 1,
  convRule: rule23
}, {
  start: 506,
  length: 1,
  convRule: rule22
}, {
  start: 507,
  length: 1,
  convRule: rule23
}, {
  start: 508,
  length: 1,
  convRule: rule22
}, {
  start: 509,
  length: 1,
  convRule: rule23
}, {
  start: 510,
  length: 1,
  convRule: rule22
}, {
  start: 511,
  length: 1,
  convRule: rule23
}, {
  start: 512,
  length: 1,
  convRule: rule22
}, {
  start: 513,
  length: 1,
  convRule: rule23
}, {
  start: 514,
  length: 1,
  convRule: rule22
}, {
  start: 515,
  length: 1,
  convRule: rule23
}, {
  start: 516,
  length: 1,
  convRule: rule22
}, {
  start: 517,
  length: 1,
  convRule: rule23
}, {
  start: 518,
  length: 1,
  convRule: rule22
}, {
  start: 519,
  length: 1,
  convRule: rule23
}, {
  start: 520,
  length: 1,
  convRule: rule22
}, {
  start: 521,
  length: 1,
  convRule: rule23
}, {
  start: 522,
  length: 1,
  convRule: rule22
}, {
  start: 523,
  length: 1,
  convRule: rule23
}, {
  start: 524,
  length: 1,
  convRule: rule22
}, {
  start: 525,
  length: 1,
  convRule: rule23
}, {
  start: 526,
  length: 1,
  convRule: rule22
}, {
  start: 527,
  length: 1,
  convRule: rule23
}, {
  start: 528,
  length: 1,
  convRule: rule22
}, {
  start: 529,
  length: 1,
  convRule: rule23
}, {
  start: 530,
  length: 1,
  convRule: rule22
}, {
  start: 531,
  length: 1,
  convRule: rule23
}, {
  start: 532,
  length: 1,
  convRule: rule22
}, {
  start: 533,
  length: 1,
  convRule: rule23
}, {
  start: 534,
  length: 1,
  convRule: rule22
}, {
  start: 535,
  length: 1,
  convRule: rule23
}, {
  start: 536,
  length: 1,
  convRule: rule22
}, {
  start: 537,
  length: 1,
  convRule: rule23
}, {
  start: 538,
  length: 1,
  convRule: rule22
}, {
  start: 539,
  length: 1,
  convRule: rule23
}, {
  start: 540,
  length: 1,
  convRule: rule22
}, {
  start: 541,
  length: 1,
  convRule: rule23
}, {
  start: 542,
  length: 1,
  convRule: rule22
}, {
  start: 543,
  length: 1,
  convRule: rule23
}, {
  start: 544,
  length: 1,
  convRule: rule53
}, {
  start: 545,
  length: 1,
  convRule: rule20
}, {
  start: 546,
  length: 1,
  convRule: rule22
}, {
  start: 547,
  length: 1,
  convRule: rule23
}, {
  start: 548,
  length: 1,
  convRule: rule22
}, {
  start: 549,
  length: 1,
  convRule: rule23
}, {
  start: 550,
  length: 1,
  convRule: rule22
}, {
  start: 551,
  length: 1,
  convRule: rule23
}, {
  start: 552,
  length: 1,
  convRule: rule22
}, {
  start: 553,
  length: 1,
  convRule: rule23
}, {
  start: 554,
  length: 1,
  convRule: rule22
}, {
  start: 555,
  length: 1,
  convRule: rule23
}, {
  start: 556,
  length: 1,
  convRule: rule22
}, {
  start: 557,
  length: 1,
  convRule: rule23
}, {
  start: 558,
  length: 1,
  convRule: rule22
}, {
  start: 559,
  length: 1,
  convRule: rule23
}, {
  start: 560,
  length: 1,
  convRule: rule22
}, {
  start: 561,
  length: 1,
  convRule: rule23
}, {
  start: 562,
  length: 1,
  convRule: rule22
}, {
  start: 563,
  length: 1,
  convRule: rule23
}, {
  start: 564,
  length: 6,
  convRule: rule20
}, {
  start: 570,
  length: 1,
  convRule: rule54
}, {
  start: 571,
  length: 1,
  convRule: rule22
}, {
  start: 572,
  length: 1,
  convRule: rule23
}, {
  start: 573,
  length: 1,
  convRule: rule55
}, {
  start: 574,
  length: 1,
  convRule: rule56
}, {
  start: 575,
  length: 2,
  convRule: rule57
}, {
  start: 577,
  length: 1,
  convRule: rule22
}, {
  start: 578,
  length: 1,
  convRule: rule23
}, {
  start: 579,
  length: 1,
  convRule: rule58
}, {
  start: 580,
  length: 1,
  convRule: rule59
}, {
  start: 581,
  length: 1,
  convRule: rule60
}, {
  start: 582,
  length: 1,
  convRule: rule22
}, {
  start: 583,
  length: 1,
  convRule: rule23
}, {
  start: 584,
  length: 1,
  convRule: rule22
}, {
  start: 585,
  length: 1,
  convRule: rule23
}, {
  start: 586,
  length: 1,
  convRule: rule22
}, {
  start: 587,
  length: 1,
  convRule: rule23
}, {
  start: 588,
  length: 1,
  convRule: rule22
}, {
  start: 589,
  length: 1,
  convRule: rule23
}, {
  start: 590,
  length: 1,
  convRule: rule22
}, {
  start: 591,
  length: 1,
  convRule: rule23
}, {
  start: 592,
  length: 1,
  convRule: rule61
}, {
  start: 593,
  length: 1,
  convRule: rule62
}, {
  start: 594,
  length: 1,
  convRule: rule63
}, {
  start: 595,
  length: 1,
  convRule: rule64
}, {
  start: 596,
  length: 1,
  convRule: rule65
}, {
  start: 597,
  length: 1,
  convRule: rule20
}, {
  start: 598,
  length: 2,
  convRule: rule66
}, {
  start: 600,
  length: 1,
  convRule: rule20
}, {
  start: 601,
  length: 1,
  convRule: rule67
}, {
  start: 602,
  length: 1,
  convRule: rule20
}, {
  start: 603,
  length: 1,
  convRule: rule68
}, {
  start: 604,
  length: 1,
  convRule: rule69
}, {
  start: 605,
  length: 3,
  convRule: rule20
}, {
  start: 608,
  length: 1,
  convRule: rule66
}, {
  start: 609,
  length: 1,
  convRule: rule70
}, {
  start: 610,
  length: 1,
  convRule: rule20
}, {
  start: 611,
  length: 1,
  convRule: rule71
}, {
  start: 612,
  length: 1,
  convRule: rule20
}, {
  start: 613,
  length: 1,
  convRule: rule72
}, {
  start: 614,
  length: 1,
  convRule: rule73
}, {
  start: 615,
  length: 1,
  convRule: rule20
}, {
  start: 616,
  length: 1,
  convRule: rule74
}, {
  start: 617,
  length: 1,
  convRule: rule75
}, {
  start: 618,
  length: 1,
  convRule: rule73
}, {
  start: 619,
  length: 1,
  convRule: rule76
}, {
  start: 620,
  length: 1,
  convRule: rule77
}, {
  start: 621,
  length: 2,
  convRule: rule20
}, {
  start: 623,
  length: 1,
  convRule: rule75
}, {
  start: 624,
  length: 1,
  convRule: rule20
}, {
  start: 625,
  length: 1,
  convRule: rule78
}, {
  start: 626,
  length: 1,
  convRule: rule79
}, {
  start: 627,
  length: 2,
  convRule: rule20
}, {
  start: 629,
  length: 1,
  convRule: rule80
}, {
  start: 630,
  length: 7,
  convRule: rule20
}, {
  start: 637,
  length: 1,
  convRule: rule81
}, {
  start: 638,
  length: 2,
  convRule: rule20
}, {
  start: 640,
  length: 1,
  convRule: rule82
}, {
  start: 641,
  length: 1,
  convRule: rule20
}, {
  start: 642,
  length: 1,
  convRule: rule83
}, {
  start: 643,
  length: 1,
  convRule: rule82
}, {
  start: 644,
  length: 3,
  convRule: rule20
}, {
  start: 647,
  length: 1,
  convRule: rule84
}, {
  start: 648,
  length: 1,
  convRule: rule82
}, {
  start: 649,
  length: 1,
  convRule: rule85
}, {
  start: 650,
  length: 2,
  convRule: rule86
}, {
  start: 652,
  length: 1,
  convRule: rule87
}, {
  start: 653,
  length: 5,
  convRule: rule20
}, {
  start: 658,
  length: 1,
  convRule: rule88
}, {
  start: 659,
  length: 1,
  convRule: rule20
}, {
  start: 660,
  length: 1,
  convRule: rule14
}, {
  start: 661,
  length: 8,
  convRule: rule20
}, {
  start: 669,
  length: 1,
  convRule: rule89
}, {
  start: 670,
  length: 1,
  convRule: rule90
}, {
  start: 671,
  length: 17,
  convRule: rule20
}, {
  start: 688,
  length: 18,
  convRule: rule91
}, {
  start: 706,
  length: 4,
  convRule: rule10
}, {
  start: 710,
  length: 12,
  convRule: rule91
}, {
  start: 722,
  length: 14,
  convRule: rule10
}, {
  start: 736,
  length: 5,
  convRule: rule91
}, {
  start: 741,
  length: 7,
  convRule: rule10
}, {
  start: 748,
  length: 1,
  convRule: rule91
}, {
  start: 749,
  length: 1,
  convRule: rule10
}, {
  start: 750,
  length: 1,
  convRule: rule91
}, {
  start: 751,
  length: 17,
  convRule: rule10
}, {
  start: 768,
  length: 69,
  convRule: rule92
}, {
  start: 837,
  length: 1,
  convRule: rule93
}, {
  start: 838,
  length: 42,
  convRule: rule92
}, {
  start: 880,
  length: 1,
  convRule: rule22
}, {
  start: 881,
  length: 1,
  convRule: rule23
}, {
  start: 882,
  length: 1,
  convRule: rule22
}, {
  start: 883,
  length: 1,
  convRule: rule23
}, {
  start: 884,
  length: 1,
  convRule: rule91
}, {
  start: 885,
  length: 1,
  convRule: rule10
}, {
  start: 886,
  length: 1,
  convRule: rule22
}, {
  start: 887,
  length: 1,
  convRule: rule23
}, {
  start: 890,
  length: 1,
  convRule: rule91
}, {
  start: 891,
  length: 3,
  convRule: rule41
}, {
  start: 894,
  length: 1,
  convRule: rule2
}, {
  start: 895,
  length: 1,
  convRule: rule94
}, {
  start: 900,
  length: 2,
  convRule: rule10
}, {
  start: 902,
  length: 1,
  convRule: rule95
}, {
  start: 903,
  length: 1,
  convRule: rule2
}, {
  start: 904,
  length: 3,
  convRule: rule96
}, {
  start: 908,
  length: 1,
  convRule: rule97
}, {
  start: 910,
  length: 2,
  convRule: rule98
}, {
  start: 912,
  length: 1,
  convRule: rule20
}, {
  start: 913,
  length: 17,
  convRule: rule9
}, {
  start: 931,
  length: 9,
  convRule: rule9
}, {
  start: 940,
  length: 1,
  convRule: rule99
}, {
  start: 941,
  length: 3,
  convRule: rule100
}, {
  start: 944,
  length: 1,
  convRule: rule20
}, {
  start: 945,
  length: 17,
  convRule: rule12
}, {
  start: 962,
  length: 1,
  convRule: rule101
}, {
  start: 963,
  length: 9,
  convRule: rule12
}, {
  start: 972,
  length: 1,
  convRule: rule102
}, {
  start: 973,
  length: 2,
  convRule: rule103
}, {
  start: 975,
  length: 1,
  convRule: rule104
}, {
  start: 976,
  length: 1,
  convRule: rule105
}, {
  start: 977,
  length: 1,
  convRule: rule106
}, {
  start: 978,
  length: 3,
  convRule: rule107
}, {
  start: 981,
  length: 1,
  convRule: rule108
}, {
  start: 982,
  length: 1,
  convRule: rule109
}, {
  start: 983,
  length: 1,
  convRule: rule110
}, {
  start: 984,
  length: 1,
  convRule: rule22
}, {
  start: 985,
  length: 1,
  convRule: rule23
}, {
  start: 986,
  length: 1,
  convRule: rule22
}, {
  start: 987,
  length: 1,
  convRule: rule23
}, {
  start: 988,
  length: 1,
  convRule: rule22
}, {
  start: 989,
  length: 1,
  convRule: rule23
}, {
  start: 990,
  length: 1,
  convRule: rule22
}, {
  start: 991,
  length: 1,
  convRule: rule23
}, {
  start: 992,
  length: 1,
  convRule: rule22
}, {
  start: 993,
  length: 1,
  convRule: rule23
}, {
  start: 994,
  length: 1,
  convRule: rule22
}, {
  start: 995,
  length: 1,
  convRule: rule23
}, {
  start: 996,
  length: 1,
  convRule: rule22
}, {
  start: 997,
  length: 1,
  convRule: rule23
}, {
  start: 998,
  length: 1,
  convRule: rule22
}, {
  start: 999,
  length: 1,
  convRule: rule23
}, {
  start: 1e3,
  length: 1,
  convRule: rule22
}, {
  start: 1001,
  length: 1,
  convRule: rule23
}, {
  start: 1002,
  length: 1,
  convRule: rule22
}, {
  start: 1003,
  length: 1,
  convRule: rule23
}, {
  start: 1004,
  length: 1,
  convRule: rule22
}, {
  start: 1005,
  length: 1,
  convRule: rule23
}, {
  start: 1006,
  length: 1,
  convRule: rule22
}, {
  start: 1007,
  length: 1,
  convRule: rule23
}, {
  start: 1008,
  length: 1,
  convRule: rule111
}, {
  start: 1009,
  length: 1,
  convRule: rule112
}, {
  start: 1010,
  length: 1,
  convRule: rule113
}, {
  start: 1011,
  length: 1,
  convRule: rule114
}, {
  start: 1012,
  length: 1,
  convRule: rule115
}, {
  start: 1013,
  length: 1,
  convRule: rule116
}, {
  start: 1014,
  length: 1,
  convRule: rule6
}, {
  start: 1015,
  length: 1,
  convRule: rule22
}, {
  start: 1016,
  length: 1,
  convRule: rule23
}, {
  start: 1017,
  length: 1,
  convRule: rule117
}, {
  start: 1018,
  length: 1,
  convRule: rule22
}, {
  start: 1019,
  length: 1,
  convRule: rule23
}, {
  start: 1020,
  length: 1,
  convRule: rule20
}, {
  start: 1021,
  length: 3,
  convRule: rule53
}, {
  start: 1024,
  length: 16,
  convRule: rule118
}, {
  start: 1040,
  length: 32,
  convRule: rule9
}, {
  start: 1072,
  length: 32,
  convRule: rule12
}, {
  start: 1104,
  length: 16,
  convRule: rule112
}, {
  start: 1120,
  length: 1,
  convRule: rule22
}, {
  start: 1121,
  length: 1,
  convRule: rule23
}, {
  start: 1122,
  length: 1,
  convRule: rule22
}, {
  start: 1123,
  length: 1,
  convRule: rule23
}, {
  start: 1124,
  length: 1,
  convRule: rule22
}, {
  start: 1125,
  length: 1,
  convRule: rule23
}, {
  start: 1126,
  length: 1,
  convRule: rule22
}, {
  start: 1127,
  length: 1,
  convRule: rule23
}, {
  start: 1128,
  length: 1,
  convRule: rule22
}, {
  start: 1129,
  length: 1,
  convRule: rule23
}, {
  start: 1130,
  length: 1,
  convRule: rule22
}, {
  start: 1131,
  length: 1,
  convRule: rule23
}, {
  start: 1132,
  length: 1,
  convRule: rule22
}, {
  start: 1133,
  length: 1,
  convRule: rule23
}, {
  start: 1134,
  length: 1,
  convRule: rule22
}, {
  start: 1135,
  length: 1,
  convRule: rule23
}, {
  start: 1136,
  length: 1,
  convRule: rule22
}, {
  start: 1137,
  length: 1,
  convRule: rule23
}, {
  start: 1138,
  length: 1,
  convRule: rule22
}, {
  start: 1139,
  length: 1,
  convRule: rule23
}, {
  start: 1140,
  length: 1,
  convRule: rule22
}, {
  start: 1141,
  length: 1,
  convRule: rule23
}, {
  start: 1142,
  length: 1,
  convRule: rule22
}, {
  start: 1143,
  length: 1,
  convRule: rule23
}, {
  start: 1144,
  length: 1,
  convRule: rule22
}, {
  start: 1145,
  length: 1,
  convRule: rule23
}, {
  start: 1146,
  length: 1,
  convRule: rule22
}, {
  start: 1147,
  length: 1,
  convRule: rule23
}, {
  start: 1148,
  length: 1,
  convRule: rule22
}, {
  start: 1149,
  length: 1,
  convRule: rule23
}, {
  start: 1150,
  length: 1,
  convRule: rule22
}, {
  start: 1151,
  length: 1,
  convRule: rule23
}, {
  start: 1152,
  length: 1,
  convRule: rule22
}, {
  start: 1153,
  length: 1,
  convRule: rule23
}, {
  start: 1154,
  length: 1,
  convRule: rule13
}, {
  start: 1155,
  length: 5,
  convRule: rule92
}, {
  start: 1160,
  length: 2,
  convRule: rule119
}, {
  start: 1162,
  length: 1,
  convRule: rule22
}, {
  start: 1163,
  length: 1,
  convRule: rule23
}, {
  start: 1164,
  length: 1,
  convRule: rule22
}, {
  start: 1165,
  length: 1,
  convRule: rule23
}, {
  start: 1166,
  length: 1,
  convRule: rule22
}, {
  start: 1167,
  length: 1,
  convRule: rule23
}, {
  start: 1168,
  length: 1,
  convRule: rule22
}, {
  start: 1169,
  length: 1,
  convRule: rule23
}, {
  start: 1170,
  length: 1,
  convRule: rule22
}, {
  start: 1171,
  length: 1,
  convRule: rule23
}, {
  start: 1172,
  length: 1,
  convRule: rule22
}, {
  start: 1173,
  length: 1,
  convRule: rule23
}, {
  start: 1174,
  length: 1,
  convRule: rule22
}, {
  start: 1175,
  length: 1,
  convRule: rule23
}, {
  start: 1176,
  length: 1,
  convRule: rule22
}, {
  start: 1177,
  length: 1,
  convRule: rule23
}, {
  start: 1178,
  length: 1,
  convRule: rule22
}, {
  start: 1179,
  length: 1,
  convRule: rule23
}, {
  start: 1180,
  length: 1,
  convRule: rule22
}, {
  start: 1181,
  length: 1,
  convRule: rule23
}, {
  start: 1182,
  length: 1,
  convRule: rule22
}, {
  start: 1183,
  length: 1,
  convRule: rule23
}, {
  start: 1184,
  length: 1,
  convRule: rule22
}, {
  start: 1185,
  length: 1,
  convRule: rule23
}, {
  start: 1186,
  length: 1,
  convRule: rule22
}, {
  start: 1187,
  length: 1,
  convRule: rule23
}, {
  start: 1188,
  length: 1,
  convRule: rule22
}, {
  start: 1189,
  length: 1,
  convRule: rule23
}, {
  start: 1190,
  length: 1,
  convRule: rule22
}, {
  start: 1191,
  length: 1,
  convRule: rule23
}, {
  start: 1192,
  length: 1,
  convRule: rule22
}, {
  start: 1193,
  length: 1,
  convRule: rule23
}, {
  start: 1194,
  length: 1,
  convRule: rule22
}, {
  start: 1195,
  length: 1,
  convRule: rule23
}, {
  start: 1196,
  length: 1,
  convRule: rule22
}, {
  start: 1197,
  length: 1,
  convRule: rule23
}, {
  start: 1198,
  length: 1,
  convRule: rule22
}, {
  start: 1199,
  length: 1,
  convRule: rule23
}, {
  start: 1200,
  length: 1,
  convRule: rule22
}, {
  start: 1201,
  length: 1,
  convRule: rule23
}, {
  start: 1202,
  length: 1,
  convRule: rule22
}, {
  start: 1203,
  length: 1,
  convRule: rule23
}, {
  start: 1204,
  length: 1,
  convRule: rule22
}, {
  start: 1205,
  length: 1,
  convRule: rule23
}, {
  start: 1206,
  length: 1,
  convRule: rule22
}, {
  start: 1207,
  length: 1,
  convRule: rule23
}, {
  start: 1208,
  length: 1,
  convRule: rule22
}, {
  start: 1209,
  length: 1,
  convRule: rule23
}, {
  start: 1210,
  length: 1,
  convRule: rule22
}, {
  start: 1211,
  length: 1,
  convRule: rule23
}, {
  start: 1212,
  length: 1,
  convRule: rule22
}, {
  start: 1213,
  length: 1,
  convRule: rule23
}, {
  start: 1214,
  length: 1,
  convRule: rule22
}, {
  start: 1215,
  length: 1,
  convRule: rule23
}, {
  start: 1216,
  length: 1,
  convRule: rule120
}, {
  start: 1217,
  length: 1,
  convRule: rule22
}, {
  start: 1218,
  length: 1,
  convRule: rule23
}, {
  start: 1219,
  length: 1,
  convRule: rule22
}, {
  start: 1220,
  length: 1,
  convRule: rule23
}, {
  start: 1221,
  length: 1,
  convRule: rule22
}, {
  start: 1222,
  length: 1,
  convRule: rule23
}, {
  start: 1223,
  length: 1,
  convRule: rule22
}, {
  start: 1224,
  length: 1,
  convRule: rule23
}, {
  start: 1225,
  length: 1,
  convRule: rule22
}, {
  start: 1226,
  length: 1,
  convRule: rule23
}, {
  start: 1227,
  length: 1,
  convRule: rule22
}, {
  start: 1228,
  length: 1,
  convRule: rule23
}, {
  start: 1229,
  length: 1,
  convRule: rule22
}, {
  start: 1230,
  length: 1,
  convRule: rule23
}, {
  start: 1231,
  length: 1,
  convRule: rule121
}, {
  start: 1232,
  length: 1,
  convRule: rule22
}, {
  start: 1233,
  length: 1,
  convRule: rule23
}, {
  start: 1234,
  length: 1,
  convRule: rule22
}, {
  start: 1235,
  length: 1,
  convRule: rule23
}, {
  start: 1236,
  length: 1,
  convRule: rule22
}, {
  start: 1237,
  length: 1,
  convRule: rule23
}, {
  start: 1238,
  length: 1,
  convRule: rule22
}, {
  start: 1239,
  length: 1,
  convRule: rule23
}, {
  start: 1240,
  length: 1,
  convRule: rule22
}, {
  start: 1241,
  length: 1,
  convRule: rule23
}, {
  start: 1242,
  length: 1,
  convRule: rule22
}, {
  start: 1243,
  length: 1,
  convRule: rule23
}, {
  start: 1244,
  length: 1,
  convRule: rule22
}, {
  start: 1245,
  length: 1,
  convRule: rule23
}, {
  start: 1246,
  length: 1,
  convRule: rule22
}, {
  start: 1247,
  length: 1,
  convRule: rule23
}, {
  start: 1248,
  length: 1,
  convRule: rule22
}, {
  start: 1249,
  length: 1,
  convRule: rule23
}, {
  start: 1250,
  length: 1,
  convRule: rule22
}, {
  start: 1251,
  length: 1,
  convRule: rule23
}, {
  start: 1252,
  length: 1,
  convRule: rule22
}, {
  start: 1253,
  length: 1,
  convRule: rule23
}, {
  start: 1254,
  length: 1,
  convRule: rule22
}, {
  start: 1255,
  length: 1,
  convRule: rule23
}, {
  start: 1256,
  length: 1,
  convRule: rule22
}, {
  start: 1257,
  length: 1,
  convRule: rule23
}, {
  start: 1258,
  length: 1,
  convRule: rule22
}, {
  start: 1259,
  length: 1,
  convRule: rule23
}, {
  start: 1260,
  length: 1,
  convRule: rule22
}, {
  start: 1261,
  length: 1,
  convRule: rule23
}, {
  start: 1262,
  length: 1,
  convRule: rule22
}, {
  start: 1263,
  length: 1,
  convRule: rule23
}, {
  start: 1264,
  length: 1,
  convRule: rule22
}, {
  start: 1265,
  length: 1,
  convRule: rule23
}, {
  start: 1266,
  length: 1,
  convRule: rule22
}, {
  start: 1267,
  length: 1,
  convRule: rule23
}, {
  start: 1268,
  length: 1,
  convRule: rule22
}, {
  start: 1269,
  length: 1,
  convRule: rule23
}, {
  start: 1270,
  length: 1,
  convRule: rule22
}, {
  start: 1271,
  length: 1,
  convRule: rule23
}, {
  start: 1272,
  length: 1,
  convRule: rule22
}, {
  start: 1273,
  length: 1,
  convRule: rule23
}, {
  start: 1274,
  length: 1,
  convRule: rule22
}, {
  start: 1275,
  length: 1,
  convRule: rule23
}, {
  start: 1276,
  length: 1,
  convRule: rule22
}, {
  start: 1277,
  length: 1,
  convRule: rule23
}, {
  start: 1278,
  length: 1,
  convRule: rule22
}, {
  start: 1279,
  length: 1,
  convRule: rule23
}, {
  start: 1280,
  length: 1,
  convRule: rule22
}, {
  start: 1281,
  length: 1,
  convRule: rule23
}, {
  start: 1282,
  length: 1,
  convRule: rule22
}, {
  start: 1283,
  length: 1,
  convRule: rule23
}, {
  start: 1284,
  length: 1,
  convRule: rule22
}, {
  start: 1285,
  length: 1,
  convRule: rule23
}, {
  start: 1286,
  length: 1,
  convRule: rule22
}, {
  start: 1287,
  length: 1,
  convRule: rule23
}, {
  start: 1288,
  length: 1,
  convRule: rule22
}, {
  start: 1289,
  length: 1,
  convRule: rule23
}, {
  start: 1290,
  length: 1,
  convRule: rule22
}, {
  start: 1291,
  length: 1,
  convRule: rule23
}, {
  start: 1292,
  length: 1,
  convRule: rule22
}, {
  start: 1293,
  length: 1,
  convRule: rule23
}, {
  start: 1294,
  length: 1,
  convRule: rule22
}, {
  start: 1295,
  length: 1,
  convRule: rule23
}, {
  start: 1296,
  length: 1,
  convRule: rule22
}, {
  start: 1297,
  length: 1,
  convRule: rule23
}, {
  start: 1298,
  length: 1,
  convRule: rule22
}, {
  start: 1299,
  length: 1,
  convRule: rule23
}, {
  start: 1300,
  length: 1,
  convRule: rule22
}, {
  start: 1301,
  length: 1,
  convRule: rule23
}, {
  start: 1302,
  length: 1,
  convRule: rule22
}, {
  start: 1303,
  length: 1,
  convRule: rule23
}, {
  start: 1304,
  length: 1,
  convRule: rule22
}, {
  start: 1305,
  length: 1,
  convRule: rule23
}, {
  start: 1306,
  length: 1,
  convRule: rule22
}, {
  start: 1307,
  length: 1,
  convRule: rule23
}, {
  start: 1308,
  length: 1,
  convRule: rule22
}, {
  start: 1309,
  length: 1,
  convRule: rule23
}, {
  start: 1310,
  length: 1,
  convRule: rule22
}, {
  start: 1311,
  length: 1,
  convRule: rule23
}, {
  start: 1312,
  length: 1,
  convRule: rule22
}, {
  start: 1313,
  length: 1,
  convRule: rule23
}, {
  start: 1314,
  length: 1,
  convRule: rule22
}, {
  start: 1315,
  length: 1,
  convRule: rule23
}, {
  start: 1316,
  length: 1,
  convRule: rule22
}, {
  start: 1317,
  length: 1,
  convRule: rule23
}, {
  start: 1318,
  length: 1,
  convRule: rule22
}, {
  start: 1319,
  length: 1,
  convRule: rule23
}, {
  start: 1320,
  length: 1,
  convRule: rule22
}, {
  start: 1321,
  length: 1,
  convRule: rule23
}, {
  start: 1322,
  length: 1,
  convRule: rule22
}, {
  start: 1323,
  length: 1,
  convRule: rule23
}, {
  start: 1324,
  length: 1,
  convRule: rule22
}, {
  start: 1325,
  length: 1,
  convRule: rule23
}, {
  start: 1326,
  length: 1,
  convRule: rule22
}, {
  start: 1327,
  length: 1,
  convRule: rule23
}, {
  start: 1329,
  length: 38,
  convRule: rule122
}, {
  start: 1369,
  length: 1,
  convRule: rule91
}, {
  start: 1370,
  length: 6,
  convRule: rule2
}, {
  start: 1376,
  length: 1,
  convRule: rule20
}, {
  start: 1377,
  length: 38,
  convRule: rule123
}, {
  start: 1415,
  length: 2,
  convRule: rule20
}, {
  start: 1417,
  length: 1,
  convRule: rule2
}, {
  start: 1418,
  length: 1,
  convRule: rule7
}, {
  start: 1421,
  length: 2,
  convRule: rule13
}, {
  start: 1423,
  length: 1,
  convRule: rule3
}, {
  start: 1425,
  length: 45,
  convRule: rule92
}, {
  start: 1470,
  length: 1,
  convRule: rule7
}, {
  start: 1471,
  length: 1,
  convRule: rule92
}, {
  start: 1472,
  length: 1,
  convRule: rule2
}, {
  start: 1473,
  length: 2,
  convRule: rule92
}, {
  start: 1475,
  length: 1,
  convRule: rule2
}, {
  start: 1476,
  length: 2,
  convRule: rule92
}, {
  start: 1478,
  length: 1,
  convRule: rule2
}, {
  start: 1479,
  length: 1,
  convRule: rule92
}, {
  start: 1488,
  length: 27,
  convRule: rule14
}, {
  start: 1519,
  length: 4,
  convRule: rule14
}, {
  start: 1523,
  length: 2,
  convRule: rule2
}, {
  start: 1536,
  length: 6,
  convRule: rule16
}, {
  start: 1542,
  length: 3,
  convRule: rule6
}, {
  start: 1545,
  length: 2,
  convRule: rule2
}, {
  start: 1547,
  length: 1,
  convRule: rule3
}, {
  start: 1548,
  length: 2,
  convRule: rule2
}, {
  start: 1550,
  length: 2,
  convRule: rule13
}, {
  start: 1552,
  length: 11,
  convRule: rule92
}, {
  start: 1563,
  length: 1,
  convRule: rule2
}, {
  start: 1564,
  length: 1,
  convRule: rule16
}, {
  start: 1566,
  length: 2,
  convRule: rule2
}, {
  start: 1568,
  length: 32,
  convRule: rule14
}, {
  start: 1600,
  length: 1,
  convRule: rule91
}, {
  start: 1601,
  length: 10,
  convRule: rule14
}, {
  start: 1611,
  length: 21,
  convRule: rule92
}, {
  start: 1632,
  length: 10,
  convRule: rule8
}, {
  start: 1642,
  length: 4,
  convRule: rule2
}, {
  start: 1646,
  length: 2,
  convRule: rule14
}, {
  start: 1648,
  length: 1,
  convRule: rule92
}, {
  start: 1649,
  length: 99,
  convRule: rule14
}, {
  start: 1748,
  length: 1,
  convRule: rule2
}, {
  start: 1749,
  length: 1,
  convRule: rule14
}, {
  start: 1750,
  length: 7,
  convRule: rule92
}, {
  start: 1757,
  length: 1,
  convRule: rule16
}, {
  start: 1758,
  length: 1,
  convRule: rule13
}, {
  start: 1759,
  length: 6,
  convRule: rule92
}, {
  start: 1765,
  length: 2,
  convRule: rule91
}, {
  start: 1767,
  length: 2,
  convRule: rule92
}, {
  start: 1769,
  length: 1,
  convRule: rule13
}, {
  start: 1770,
  length: 4,
  convRule: rule92
}, {
  start: 1774,
  length: 2,
  convRule: rule14
}, {
  start: 1776,
  length: 10,
  convRule: rule8
}, {
  start: 1786,
  length: 3,
  convRule: rule14
}, {
  start: 1789,
  length: 2,
  convRule: rule13
}, {
  start: 1791,
  length: 1,
  convRule: rule14
}, {
  start: 1792,
  length: 14,
  convRule: rule2
}, {
  start: 1807,
  length: 1,
  convRule: rule16
}, {
  start: 1808,
  length: 1,
  convRule: rule14
}, {
  start: 1809,
  length: 1,
  convRule: rule92
}, {
  start: 1810,
  length: 30,
  convRule: rule14
}, {
  start: 1840,
  length: 27,
  convRule: rule92
}, {
  start: 1869,
  length: 89,
  convRule: rule14
}, {
  start: 1958,
  length: 11,
  convRule: rule92
}, {
  start: 1969,
  length: 1,
  convRule: rule14
}, {
  start: 1984,
  length: 10,
  convRule: rule8
}, {
  start: 1994,
  length: 33,
  convRule: rule14
}, {
  start: 2027,
  length: 9,
  convRule: rule92
}, {
  start: 2036,
  length: 2,
  convRule: rule91
}, {
  start: 2038,
  length: 1,
  convRule: rule13
}, {
  start: 2039,
  length: 3,
  convRule: rule2
}, {
  start: 2042,
  length: 1,
  convRule: rule91
}, {
  start: 2045,
  length: 1,
  convRule: rule92
}, {
  start: 2046,
  length: 2,
  convRule: rule3
}, {
  start: 2048,
  length: 22,
  convRule: rule14
}, {
  start: 2070,
  length: 4,
  convRule: rule92
}, {
  start: 2074,
  length: 1,
  convRule: rule91
}, {
  start: 2075,
  length: 9,
  convRule: rule92
}, {
  start: 2084,
  length: 1,
  convRule: rule91
}, {
  start: 2085,
  length: 3,
  convRule: rule92
}, {
  start: 2088,
  length: 1,
  convRule: rule91
}, {
  start: 2089,
  length: 5,
  convRule: rule92
}, {
  start: 2096,
  length: 15,
  convRule: rule2
}, {
  start: 2112,
  length: 25,
  convRule: rule14
}, {
  start: 2137,
  length: 3,
  convRule: rule92
}, {
  start: 2142,
  length: 1,
  convRule: rule2
}, {
  start: 2144,
  length: 11,
  convRule: rule14
}, {
  start: 2208,
  length: 21,
  convRule: rule14
}, {
  start: 2230,
  length: 18,
  convRule: rule14
}, {
  start: 2259,
  length: 15,
  convRule: rule92
}, {
  start: 2274,
  length: 1,
  convRule: rule16
}, {
  start: 2275,
  length: 32,
  convRule: rule92
}, {
  start: 2307,
  length: 1,
  convRule: rule124
}, {
  start: 2308,
  length: 54,
  convRule: rule14
}, {
  start: 2362,
  length: 1,
  convRule: rule92
}, {
  start: 2363,
  length: 1,
  convRule: rule124
}, {
  start: 2364,
  length: 1,
  convRule: rule92
}, {
  start: 2365,
  length: 1,
  convRule: rule14
}, {
  start: 2366,
  length: 3,
  convRule: rule124
}, {
  start: 2369,
  length: 8,
  convRule: rule92
}, {
  start: 2377,
  length: 4,
  convRule: rule124
}, {
  start: 2381,
  length: 1,
  convRule: rule92
}, {
  start: 2382,
  length: 2,
  convRule: rule124
}, {
  start: 2384,
  length: 1,
  convRule: rule14
}, {
  start: 2385,
  length: 7,
  convRule: rule92
}, {
  start: 2392,
  length: 10,
  convRule: rule14
}, {
  start: 2402,
  length: 2,
  convRule: rule92
}, {
  start: 2404,
  length: 2,
  convRule: rule2
}, {
  start: 2406,
  length: 10,
  convRule: rule8
}, {
  start: 2416,
  length: 1,
  convRule: rule2
}, {
  start: 2417,
  length: 1,
  convRule: rule91
}, {
  start: 2418,
  length: 15,
  convRule: rule14
}, {
  start: 2433,
  length: 1,
  convRule: rule92
}, {
  start: 2434,
  length: 2,
  convRule: rule124
}, {
  start: 2437,
  length: 8,
  convRule: rule14
}, {
  start: 2447,
  length: 2,
  convRule: rule14
}, {
  start: 2451,
  length: 22,
  convRule: rule14
}, {
  start: 2474,
  length: 7,
  convRule: rule14
}, {
  start: 2482,
  length: 1,
  convRule: rule14
}, {
  start: 2486,
  length: 4,
  convRule: rule14
}, {
  start: 2492,
  length: 1,
  convRule: rule92
}, {
  start: 2493,
  length: 1,
  convRule: rule14
}, {
  start: 2494,
  length: 3,
  convRule: rule124
}, {
  start: 2497,
  length: 4,
  convRule: rule92
}, {
  start: 2503,
  length: 2,
  convRule: rule124
}, {
  start: 2507,
  length: 2,
  convRule: rule124
}, {
  start: 2509,
  length: 1,
  convRule: rule92
}, {
  start: 2510,
  length: 1,
  convRule: rule14
}, {
  start: 2519,
  length: 1,
  convRule: rule124
}, {
  start: 2524,
  length: 2,
  convRule: rule14
}, {
  start: 2527,
  length: 3,
  convRule: rule14
}, {
  start: 2530,
  length: 2,
  convRule: rule92
}, {
  start: 2534,
  length: 10,
  convRule: rule8
}, {
  start: 2544,
  length: 2,
  convRule: rule14
}, {
  start: 2546,
  length: 2,
  convRule: rule3
}, {
  start: 2548,
  length: 6,
  convRule: rule17
}, {
  start: 2554,
  length: 1,
  convRule: rule13
}, {
  start: 2555,
  length: 1,
  convRule: rule3
}, {
  start: 2556,
  length: 1,
  convRule: rule14
}, {
  start: 2557,
  length: 1,
  convRule: rule2
}, {
  start: 2558,
  length: 1,
  convRule: rule92
}, {
  start: 2561,
  length: 2,
  convRule: rule92
}, {
  start: 2563,
  length: 1,
  convRule: rule124
}, {
  start: 2565,
  length: 6,
  convRule: rule14
}, {
  start: 2575,
  length: 2,
  convRule: rule14
}, {
  start: 2579,
  length: 22,
  convRule: rule14
}, {
  start: 2602,
  length: 7,
  convRule: rule14
}, {
  start: 2610,
  length: 2,
  convRule: rule14
}, {
  start: 2613,
  length: 2,
  convRule: rule14
}, {
  start: 2616,
  length: 2,
  convRule: rule14
}, {
  start: 2620,
  length: 1,
  convRule: rule92
}, {
  start: 2622,
  length: 3,
  convRule: rule124
}, {
  start: 2625,
  length: 2,
  convRule: rule92
}, {
  start: 2631,
  length: 2,
  convRule: rule92
}, {
  start: 2635,
  length: 3,
  convRule: rule92
}, {
  start: 2641,
  length: 1,
  convRule: rule92
}, {
  start: 2649,
  length: 4,
  convRule: rule14
}, {
  start: 2654,
  length: 1,
  convRule: rule14
}, {
  start: 2662,
  length: 10,
  convRule: rule8
}, {
  start: 2672,
  length: 2,
  convRule: rule92
}, {
  start: 2674,
  length: 3,
  convRule: rule14
}, {
  start: 2677,
  length: 1,
  convRule: rule92
}, {
  start: 2678,
  length: 1,
  convRule: rule2
}, {
  start: 2689,
  length: 2,
  convRule: rule92
}, {
  start: 2691,
  length: 1,
  convRule: rule124
}, {
  start: 2693,
  length: 9,
  convRule: rule14
}, {
  start: 2703,
  length: 3,
  convRule: rule14
}, {
  start: 2707,
  length: 22,
  convRule: rule14
}, {
  start: 2730,
  length: 7,
  convRule: rule14
}, {
  start: 2738,
  length: 2,
  convRule: rule14
}, {
  start: 2741,
  length: 5,
  convRule: rule14
}, {
  start: 2748,
  length: 1,
  convRule: rule92
}, {
  start: 2749,
  length: 1,
  convRule: rule14
}, {
  start: 2750,
  length: 3,
  convRule: rule124
}, {
  start: 2753,
  length: 5,
  convRule: rule92
}, {
  start: 2759,
  length: 2,
  convRule: rule92
}, {
  start: 2761,
  length: 1,
  convRule: rule124
}, {
  start: 2763,
  length: 2,
  convRule: rule124
}, {
  start: 2765,
  length: 1,
  convRule: rule92
}, {
  start: 2768,
  length: 1,
  convRule: rule14
}, {
  start: 2784,
  length: 2,
  convRule: rule14
}, {
  start: 2786,
  length: 2,
  convRule: rule92
}, {
  start: 2790,
  length: 10,
  convRule: rule8
}, {
  start: 2800,
  length: 1,
  convRule: rule2
}, {
  start: 2801,
  length: 1,
  convRule: rule3
}, {
  start: 2809,
  length: 1,
  convRule: rule14
}, {
  start: 2810,
  length: 6,
  convRule: rule92
}, {
  start: 2817,
  length: 1,
  convRule: rule92
}, {
  start: 2818,
  length: 2,
  convRule: rule124
}, {
  start: 2821,
  length: 8,
  convRule: rule14
}, {
  start: 2831,
  length: 2,
  convRule: rule14
}, {
  start: 2835,
  length: 22,
  convRule: rule14
}, {
  start: 2858,
  length: 7,
  convRule: rule14
}, {
  start: 2866,
  length: 2,
  convRule: rule14
}, {
  start: 2869,
  length: 5,
  convRule: rule14
}, {
  start: 2876,
  length: 1,
  convRule: rule92
}, {
  start: 2877,
  length: 1,
  convRule: rule14
}, {
  start: 2878,
  length: 1,
  convRule: rule124
}, {
  start: 2879,
  length: 1,
  convRule: rule92
}, {
  start: 2880,
  length: 1,
  convRule: rule124
}, {
  start: 2881,
  length: 4,
  convRule: rule92
}, {
  start: 2887,
  length: 2,
  convRule: rule124
}, {
  start: 2891,
  length: 2,
  convRule: rule124
}, {
  start: 2893,
  length: 1,
  convRule: rule92
}, {
  start: 2901,
  length: 2,
  convRule: rule92
}, {
  start: 2903,
  length: 1,
  convRule: rule124
}, {
  start: 2908,
  length: 2,
  convRule: rule14
}, {
  start: 2911,
  length: 3,
  convRule: rule14
}, {
  start: 2914,
  length: 2,
  convRule: rule92
}, {
  start: 2918,
  length: 10,
  convRule: rule8
}, {
  start: 2928,
  length: 1,
  convRule: rule13
}, {
  start: 2929,
  length: 1,
  convRule: rule14
}, {
  start: 2930,
  length: 6,
  convRule: rule17
}, {
  start: 2946,
  length: 1,
  convRule: rule92
}, {
  start: 2947,
  length: 1,
  convRule: rule14
}, {
  start: 2949,
  length: 6,
  convRule: rule14
}, {
  start: 2958,
  length: 3,
  convRule: rule14
}, {
  start: 2962,
  length: 4,
  convRule: rule14
}, {
  start: 2969,
  length: 2,
  convRule: rule14
}, {
  start: 2972,
  length: 1,
  convRule: rule14
}, {
  start: 2974,
  length: 2,
  convRule: rule14
}, {
  start: 2979,
  length: 2,
  convRule: rule14
}, {
  start: 2984,
  length: 3,
  convRule: rule14
}, {
  start: 2990,
  length: 12,
  convRule: rule14
}, {
  start: 3006,
  length: 2,
  convRule: rule124
}, {
  start: 3008,
  length: 1,
  convRule: rule92
}, {
  start: 3009,
  length: 2,
  convRule: rule124
}, {
  start: 3014,
  length: 3,
  convRule: rule124
}, {
  start: 3018,
  length: 3,
  convRule: rule124
}, {
  start: 3021,
  length: 1,
  convRule: rule92
}, {
  start: 3024,
  length: 1,
  convRule: rule14
}, {
  start: 3031,
  length: 1,
  convRule: rule124
}, {
  start: 3046,
  length: 10,
  convRule: rule8
}, {
  start: 3056,
  length: 3,
  convRule: rule17
}, {
  start: 3059,
  length: 6,
  convRule: rule13
}, {
  start: 3065,
  length: 1,
  convRule: rule3
}, {
  start: 3066,
  length: 1,
  convRule: rule13
}, {
  start: 3072,
  length: 1,
  convRule: rule92
}, {
  start: 3073,
  length: 3,
  convRule: rule124
}, {
  start: 3076,
  length: 1,
  convRule: rule92
}, {
  start: 3077,
  length: 8,
  convRule: rule14
}, {
  start: 3086,
  length: 3,
  convRule: rule14
}, {
  start: 3090,
  length: 23,
  convRule: rule14
}, {
  start: 3114,
  length: 16,
  convRule: rule14
}, {
  start: 3133,
  length: 1,
  convRule: rule14
}, {
  start: 3134,
  length: 3,
  convRule: rule92
}, {
  start: 3137,
  length: 4,
  convRule: rule124
}, {
  start: 3142,
  length: 3,
  convRule: rule92
}, {
  start: 3146,
  length: 4,
  convRule: rule92
}, {
  start: 3157,
  length: 2,
  convRule: rule92
}, {
  start: 3160,
  length: 3,
  convRule: rule14
}, {
  start: 3168,
  length: 2,
  convRule: rule14
}, {
  start: 3170,
  length: 2,
  convRule: rule92
}, {
  start: 3174,
  length: 10,
  convRule: rule8
}, {
  start: 3191,
  length: 1,
  convRule: rule2
}, {
  start: 3192,
  length: 7,
  convRule: rule17
}, {
  start: 3199,
  length: 1,
  convRule: rule13
}, {
  start: 3200,
  length: 1,
  convRule: rule14
}, {
  start: 3201,
  length: 1,
  convRule: rule92
}, {
  start: 3202,
  length: 2,
  convRule: rule124
}, {
  start: 3204,
  length: 1,
  convRule: rule2
}, {
  start: 3205,
  length: 8,
  convRule: rule14
}, {
  start: 3214,
  length: 3,
  convRule: rule14
}, {
  start: 3218,
  length: 23,
  convRule: rule14
}, {
  start: 3242,
  length: 10,
  convRule: rule14
}, {
  start: 3253,
  length: 5,
  convRule: rule14
}, {
  start: 3260,
  length: 1,
  convRule: rule92
}, {
  start: 3261,
  length: 1,
  convRule: rule14
}, {
  start: 3262,
  length: 1,
  convRule: rule124
}, {
  start: 3263,
  length: 1,
  convRule: rule92
}, {
  start: 3264,
  length: 5,
  convRule: rule124
}, {
  start: 3270,
  length: 1,
  convRule: rule92
}, {
  start: 3271,
  length: 2,
  convRule: rule124
}, {
  start: 3274,
  length: 2,
  convRule: rule124
}, {
  start: 3276,
  length: 2,
  convRule: rule92
}, {
  start: 3285,
  length: 2,
  convRule: rule124
}, {
  start: 3294,
  length: 1,
  convRule: rule14
}, {
  start: 3296,
  length: 2,
  convRule: rule14
}, {
  start: 3298,
  length: 2,
  convRule: rule92
}, {
  start: 3302,
  length: 10,
  convRule: rule8
}, {
  start: 3313,
  length: 2,
  convRule: rule14
}, {
  start: 3328,
  length: 2,
  convRule: rule92
}, {
  start: 3330,
  length: 2,
  convRule: rule124
}, {
  start: 3332,
  length: 9,
  convRule: rule14
}, {
  start: 3342,
  length: 3,
  convRule: rule14
}, {
  start: 3346,
  length: 41,
  convRule: rule14
}, {
  start: 3387,
  length: 2,
  convRule: rule92
}, {
  start: 3389,
  length: 1,
  convRule: rule14
}, {
  start: 3390,
  length: 3,
  convRule: rule124
}, {
  start: 3393,
  length: 4,
  convRule: rule92
}, {
  start: 3398,
  length: 3,
  convRule: rule124
}, {
  start: 3402,
  length: 3,
  convRule: rule124
}, {
  start: 3405,
  length: 1,
  convRule: rule92
}, {
  start: 3406,
  length: 1,
  convRule: rule14
}, {
  start: 3407,
  length: 1,
  convRule: rule13
}, {
  start: 3412,
  length: 3,
  convRule: rule14
}, {
  start: 3415,
  length: 1,
  convRule: rule124
}, {
  start: 3416,
  length: 7,
  convRule: rule17
}, {
  start: 3423,
  length: 3,
  convRule: rule14
}, {
  start: 3426,
  length: 2,
  convRule: rule92
}, {
  start: 3430,
  length: 10,
  convRule: rule8
}, {
  start: 3440,
  length: 9,
  convRule: rule17
}, {
  start: 3449,
  length: 1,
  convRule: rule13
}, {
  start: 3450,
  length: 6,
  convRule: rule14
}, {
  start: 3457,
  length: 1,
  convRule: rule92
}, {
  start: 3458,
  length: 2,
  convRule: rule124
}, {
  start: 3461,
  length: 18,
  convRule: rule14
}, {
  start: 3482,
  length: 24,
  convRule: rule14
}, {
  start: 3507,
  length: 9,
  convRule: rule14
}, {
  start: 3517,
  length: 1,
  convRule: rule14
}, {
  start: 3520,
  length: 7,
  convRule: rule14
}, {
  start: 3530,
  length: 1,
  convRule: rule92
}, {
  start: 3535,
  length: 3,
  convRule: rule124
}, {
  start: 3538,
  length: 3,
  convRule: rule92
}, {
  start: 3542,
  length: 1,
  convRule: rule92
}, {
  start: 3544,
  length: 8,
  convRule: rule124
}, {
  start: 3558,
  length: 10,
  convRule: rule8
}, {
  start: 3570,
  length: 2,
  convRule: rule124
}, {
  start: 3572,
  length: 1,
  convRule: rule2
}, {
  start: 3585,
  length: 48,
  convRule: rule14
}, {
  start: 3633,
  length: 1,
  convRule: rule92
}, {
  start: 3634,
  length: 2,
  convRule: rule14
}, {
  start: 3636,
  length: 7,
  convRule: rule92
}, {
  start: 3647,
  length: 1,
  convRule: rule3
}, {
  start: 3648,
  length: 6,
  convRule: rule14
}, {
  start: 3654,
  length: 1,
  convRule: rule91
}, {
  start: 3655,
  length: 8,
  convRule: rule92
}, {
  start: 3663,
  length: 1,
  convRule: rule2
}, {
  start: 3664,
  length: 10,
  convRule: rule8
}, {
  start: 3674,
  length: 2,
  convRule: rule2
}, {
  start: 3713,
  length: 2,
  convRule: rule14
}, {
  start: 3716,
  length: 1,
  convRule: rule14
}, {
  start: 3718,
  length: 5,
  convRule: rule14
}, {
  start: 3724,
  length: 24,
  convRule: rule14
}, {
  start: 3749,
  length: 1,
  convRule: rule14
}, {
  start: 3751,
  length: 10,
  convRule: rule14
}, {
  start: 3761,
  length: 1,
  convRule: rule92
}, {
  start: 3762,
  length: 2,
  convRule: rule14
}, {
  start: 3764,
  length: 9,
  convRule: rule92
}, {
  start: 3773,
  length: 1,
  convRule: rule14
}, {
  start: 3776,
  length: 5,
  convRule: rule14
}, {
  start: 3782,
  length: 1,
  convRule: rule91
}, {
  start: 3784,
  length: 6,
  convRule: rule92
}, {
  start: 3792,
  length: 10,
  convRule: rule8
}, {
  start: 3804,
  length: 4,
  convRule: rule14
}, {
  start: 3840,
  length: 1,
  convRule: rule14
}, {
  start: 3841,
  length: 3,
  convRule: rule13
}, {
  start: 3844,
  length: 15,
  convRule: rule2
}, {
  start: 3859,
  length: 1,
  convRule: rule13
}, {
  start: 3860,
  length: 1,
  convRule: rule2
}, {
  start: 3861,
  length: 3,
  convRule: rule13
}, {
  start: 3864,
  length: 2,
  convRule: rule92
}, {
  start: 3866,
  length: 6,
  convRule: rule13
}, {
  start: 3872,
  length: 10,
  convRule: rule8
}, {
  start: 3882,
  length: 10,
  convRule: rule17
}, {
  start: 3892,
  length: 1,
  convRule: rule13
}, {
  start: 3893,
  length: 1,
  convRule: rule92
}, {
  start: 3894,
  length: 1,
  convRule: rule13
}, {
  start: 3895,
  length: 1,
  convRule: rule92
}, {
  start: 3896,
  length: 1,
  convRule: rule13
}, {
  start: 3897,
  length: 1,
  convRule: rule92
}, {
  start: 3898,
  length: 1,
  convRule: rule4
}, {
  start: 3899,
  length: 1,
  convRule: rule5
}, {
  start: 3900,
  length: 1,
  convRule: rule4
}, {
  start: 3901,
  length: 1,
  convRule: rule5
}, {
  start: 3902,
  length: 2,
  convRule: rule124
}, {
  start: 3904,
  length: 8,
  convRule: rule14
}, {
  start: 3913,
  length: 36,
  convRule: rule14
}, {
  start: 3953,
  length: 14,
  convRule: rule92
}, {
  start: 3967,
  length: 1,
  convRule: rule124
}, {
  start: 3968,
  length: 5,
  convRule: rule92
}, {
  start: 3973,
  length: 1,
  convRule: rule2
}, {
  start: 3974,
  length: 2,
  convRule: rule92
}, {
  start: 3976,
  length: 5,
  convRule: rule14
}, {
  start: 3981,
  length: 11,
  convRule: rule92
}, {
  start: 3993,
  length: 36,
  convRule: rule92
}, {
  start: 4030,
  length: 8,
  convRule: rule13
}, {
  start: 4038,
  length: 1,
  convRule: rule92
}, {
  start: 4039,
  length: 6,
  convRule: rule13
}, {
  start: 4046,
  length: 2,
  convRule: rule13
}, {
  start: 4048,
  length: 5,
  convRule: rule2
}, {
  start: 4053,
  length: 4,
  convRule: rule13
}, {
  start: 4057,
  length: 2,
  convRule: rule2
}, {
  start: 4096,
  length: 43,
  convRule: rule14
}, {
  start: 4139,
  length: 2,
  convRule: rule124
}, {
  start: 4141,
  length: 4,
  convRule: rule92
}, {
  start: 4145,
  length: 1,
  convRule: rule124
}, {
  start: 4146,
  length: 6,
  convRule: rule92
}, {
  start: 4152,
  length: 1,
  convRule: rule124
}, {
  start: 4153,
  length: 2,
  convRule: rule92
}, {
  start: 4155,
  length: 2,
  convRule: rule124
}, {
  start: 4157,
  length: 2,
  convRule: rule92
}, {
  start: 4159,
  length: 1,
  convRule: rule14
}, {
  start: 4160,
  length: 10,
  convRule: rule8
}, {
  start: 4170,
  length: 6,
  convRule: rule2
}, {
  start: 4176,
  length: 6,
  convRule: rule14
}, {
  start: 4182,
  length: 2,
  convRule: rule124
}, {
  start: 4184,
  length: 2,
  convRule: rule92
}, {
  start: 4186,
  length: 4,
  convRule: rule14
}, {
  start: 4190,
  length: 3,
  convRule: rule92
}, {
  start: 4193,
  length: 1,
  convRule: rule14
}, {
  start: 4194,
  length: 3,
  convRule: rule124
}, {
  start: 4197,
  length: 2,
  convRule: rule14
}, {
  start: 4199,
  length: 7,
  convRule: rule124
}, {
  start: 4206,
  length: 3,
  convRule: rule14
}, {
  start: 4209,
  length: 4,
  convRule: rule92
}, {
  start: 4213,
  length: 13,
  convRule: rule14
}, {
  start: 4226,
  length: 1,
  convRule: rule92
}, {
  start: 4227,
  length: 2,
  convRule: rule124
}, {
  start: 4229,
  length: 2,
  convRule: rule92
}, {
  start: 4231,
  length: 6,
  convRule: rule124
}, {
  start: 4237,
  length: 1,
  convRule: rule92
}, {
  start: 4238,
  length: 1,
  convRule: rule14
}, {
  start: 4239,
  length: 1,
  convRule: rule124
}, {
  start: 4240,
  length: 10,
  convRule: rule8
}, {
  start: 4250,
  length: 3,
  convRule: rule124
}, {
  start: 4253,
  length: 1,
  convRule: rule92
}, {
  start: 4254,
  length: 2,
  convRule: rule13
}, {
  start: 4256,
  length: 38,
  convRule: rule125
}, {
  start: 4295,
  length: 1,
  convRule: rule125
}, {
  start: 4301,
  length: 1,
  convRule: rule125
}, {
  start: 4304,
  length: 43,
  convRule: rule126
}, {
  start: 4347,
  length: 1,
  convRule: rule2
}, {
  start: 4348,
  length: 1,
  convRule: rule91
}, {
  start: 4349,
  length: 3,
  convRule: rule126
}, {
  start: 4352,
  length: 329,
  convRule: rule14
}, {
  start: 4682,
  length: 4,
  convRule: rule14
}, {
  start: 4688,
  length: 7,
  convRule: rule14
}, {
  start: 4696,
  length: 1,
  convRule: rule14
}, {
  start: 4698,
  length: 4,
  convRule: rule14
}, {
  start: 4704,
  length: 41,
  convRule: rule14
}, {
  start: 4746,
  length: 4,
  convRule: rule14
}, {
  start: 4752,
  length: 33,
  convRule: rule14
}, {
  start: 4786,
  length: 4,
  convRule: rule14
}, {
  start: 4792,
  length: 7,
  convRule: rule14
}, {
  start: 4800,
  length: 1,
  convRule: rule14
}, {
  start: 4802,
  length: 4,
  convRule: rule14
}, {
  start: 4808,
  length: 15,
  convRule: rule14
}, {
  start: 4824,
  length: 57,
  convRule: rule14
}, {
  start: 4882,
  length: 4,
  convRule: rule14
}, {
  start: 4888,
  length: 67,
  convRule: rule14
}, {
  start: 4957,
  length: 3,
  convRule: rule92
}, {
  start: 4960,
  length: 9,
  convRule: rule2
}, {
  start: 4969,
  length: 20,
  convRule: rule17
}, {
  start: 4992,
  length: 16,
  convRule: rule14
}, {
  start: 5008,
  length: 10,
  convRule: rule13
}, {
  start: 5024,
  length: 80,
  convRule: rule127
}, {
  start: 5104,
  length: 6,
  convRule: rule104
}, {
  start: 5112,
  length: 6,
  convRule: rule110
}, {
  start: 5120,
  length: 1,
  convRule: rule7
}, {
  start: 5121,
  length: 620,
  convRule: rule14
}, {
  start: 5741,
  length: 1,
  convRule: rule13
}, {
  start: 5742,
  length: 1,
  convRule: rule2
}, {
  start: 5743,
  length: 17,
  convRule: rule14
}, {
  start: 5760,
  length: 1,
  convRule: rule1
}, {
  start: 5761,
  length: 26,
  convRule: rule14
}, {
  start: 5787,
  length: 1,
  convRule: rule4
}, {
  start: 5788,
  length: 1,
  convRule: rule5
}, {
  start: 5792,
  length: 75,
  convRule: rule14
}, {
  start: 5867,
  length: 3,
  convRule: rule2
}, {
  start: 5870,
  length: 3,
  convRule: rule128
}, {
  start: 5873,
  length: 8,
  convRule: rule14
}, {
  start: 5888,
  length: 13,
  convRule: rule14
}, {
  start: 5902,
  length: 4,
  convRule: rule14
}, {
  start: 5906,
  length: 3,
  convRule: rule92
}, {
  start: 5920,
  length: 18,
  convRule: rule14
}, {
  start: 5938,
  length: 3,
  convRule: rule92
}, {
  start: 5941,
  length: 2,
  convRule: rule2
}, {
  start: 5952,
  length: 18,
  convRule: rule14
}, {
  start: 5970,
  length: 2,
  convRule: rule92
}, {
  start: 5984,
  length: 13,
  convRule: rule14
}, {
  start: 5998,
  length: 3,
  convRule: rule14
}, {
  start: 6002,
  length: 2,
  convRule: rule92
}, {
  start: 6016,
  length: 52,
  convRule: rule14
}, {
  start: 6068,
  length: 2,
  convRule: rule92
}, {
  start: 6070,
  length: 1,
  convRule: rule124
}, {
  start: 6071,
  length: 7,
  convRule: rule92
}, {
  start: 6078,
  length: 8,
  convRule: rule124
}, {
  start: 6086,
  length: 1,
  convRule: rule92
}, {
  start: 6087,
  length: 2,
  convRule: rule124
}, {
  start: 6089,
  length: 11,
  convRule: rule92
}, {
  start: 6100,
  length: 3,
  convRule: rule2
}, {
  start: 6103,
  length: 1,
  convRule: rule91
}, {
  start: 6104,
  length: 3,
  convRule: rule2
}, {
  start: 6107,
  length: 1,
  convRule: rule3
}, {
  start: 6108,
  length: 1,
  convRule: rule14
}, {
  start: 6109,
  length: 1,
  convRule: rule92
}, {
  start: 6112,
  length: 10,
  convRule: rule8
}, {
  start: 6128,
  length: 10,
  convRule: rule17
}, {
  start: 6144,
  length: 6,
  convRule: rule2
}, {
  start: 6150,
  length: 1,
  convRule: rule7
}, {
  start: 6151,
  length: 4,
  convRule: rule2
}, {
  start: 6155,
  length: 3,
  convRule: rule92
}, {
  start: 6158,
  length: 1,
  convRule: rule16
}, {
  start: 6160,
  length: 10,
  convRule: rule8
}, {
  start: 6176,
  length: 35,
  convRule: rule14
}, {
  start: 6211,
  length: 1,
  convRule: rule91
}, {
  start: 6212,
  length: 53,
  convRule: rule14
}, {
  start: 6272,
  length: 5,
  convRule: rule14
}, {
  start: 6277,
  length: 2,
  convRule: rule92
}, {
  start: 6279,
  length: 34,
  convRule: rule14
}, {
  start: 6313,
  length: 1,
  convRule: rule92
}, {
  start: 6314,
  length: 1,
  convRule: rule14
}, {
  start: 6320,
  length: 70,
  convRule: rule14
}, {
  start: 6400,
  length: 31,
  convRule: rule14
}, {
  start: 6432,
  length: 3,
  convRule: rule92
}, {
  start: 6435,
  length: 4,
  convRule: rule124
}, {
  start: 6439,
  length: 2,
  convRule: rule92
}, {
  start: 6441,
  length: 3,
  convRule: rule124
}, {
  start: 6448,
  length: 2,
  convRule: rule124
}, {
  start: 6450,
  length: 1,
  convRule: rule92
}, {
  start: 6451,
  length: 6,
  convRule: rule124
}, {
  start: 6457,
  length: 3,
  convRule: rule92
}, {
  start: 6464,
  length: 1,
  convRule: rule13
}, {
  start: 6468,
  length: 2,
  convRule: rule2
}, {
  start: 6470,
  length: 10,
  convRule: rule8
}, {
  start: 6480,
  length: 30,
  convRule: rule14
}, {
  start: 6512,
  length: 5,
  convRule: rule14
}, {
  start: 6528,
  length: 44,
  convRule: rule14
}, {
  start: 6576,
  length: 26,
  convRule: rule14
}, {
  start: 6608,
  length: 10,
  convRule: rule8
}, {
  start: 6618,
  length: 1,
  convRule: rule17
}, {
  start: 6622,
  length: 34,
  convRule: rule13
}, {
  start: 6656,
  length: 23,
  convRule: rule14
}, {
  start: 6679,
  length: 2,
  convRule: rule92
}, {
  start: 6681,
  length: 2,
  convRule: rule124
}, {
  start: 6683,
  length: 1,
  convRule: rule92
}, {
  start: 6686,
  length: 2,
  convRule: rule2
}, {
  start: 6688,
  length: 53,
  convRule: rule14
}, {
  start: 6741,
  length: 1,
  convRule: rule124
}, {
  start: 6742,
  length: 1,
  convRule: rule92
}, {
  start: 6743,
  length: 1,
  convRule: rule124
}, {
  start: 6744,
  length: 7,
  convRule: rule92
}, {
  start: 6752,
  length: 1,
  convRule: rule92
}, {
  start: 6753,
  length: 1,
  convRule: rule124
}, {
  start: 6754,
  length: 1,
  convRule: rule92
}, {
  start: 6755,
  length: 2,
  convRule: rule124
}, {
  start: 6757,
  length: 8,
  convRule: rule92
}, {
  start: 6765,
  length: 6,
  convRule: rule124
}, {
  start: 6771,
  length: 10,
  convRule: rule92
}, {
  start: 6783,
  length: 1,
  convRule: rule92
}, {
  start: 6784,
  length: 10,
  convRule: rule8
}, {
  start: 6800,
  length: 10,
  convRule: rule8
}, {
  start: 6816,
  length: 7,
  convRule: rule2
}, {
  start: 6823,
  length: 1,
  convRule: rule91
}, {
  start: 6824,
  length: 6,
  convRule: rule2
}, {
  start: 6832,
  length: 14,
  convRule: rule92
}, {
  start: 6846,
  length: 1,
  convRule: rule119
}, {
  start: 6847,
  length: 2,
  convRule: rule92
}, {
  start: 6912,
  length: 4,
  convRule: rule92
}, {
  start: 6916,
  length: 1,
  convRule: rule124
}, {
  start: 6917,
  length: 47,
  convRule: rule14
}, {
  start: 6964,
  length: 1,
  convRule: rule92
}, {
  start: 6965,
  length: 1,
  convRule: rule124
}, {
  start: 6966,
  length: 5,
  convRule: rule92
}, {
  start: 6971,
  length: 1,
  convRule: rule124
}, {
  start: 6972,
  length: 1,
  convRule: rule92
}, {
  start: 6973,
  length: 5,
  convRule: rule124
}, {
  start: 6978,
  length: 1,
  convRule: rule92
}, {
  start: 6979,
  length: 2,
  convRule: rule124
}, {
  start: 6981,
  length: 7,
  convRule: rule14
}, {
  start: 6992,
  length: 10,
  convRule: rule8
}, {
  start: 7002,
  length: 7,
  convRule: rule2
}, {
  start: 7009,
  length: 10,
  convRule: rule13
}, {
  start: 7019,
  length: 9,
  convRule: rule92
}, {
  start: 7028,
  length: 9,
  convRule: rule13
}, {
  start: 7040,
  length: 2,
  convRule: rule92
}, {
  start: 7042,
  length: 1,
  convRule: rule124
}, {
  start: 7043,
  length: 30,
  convRule: rule14
}, {
  start: 7073,
  length: 1,
  convRule: rule124
}, {
  start: 7074,
  length: 4,
  convRule: rule92
}, {
  start: 7078,
  length: 2,
  convRule: rule124
}, {
  start: 7080,
  length: 2,
  convRule: rule92
}, {
  start: 7082,
  length: 1,
  convRule: rule124
}, {
  start: 7083,
  length: 3,
  convRule: rule92
}, {
  start: 7086,
  length: 2,
  convRule: rule14
}, {
  start: 7088,
  length: 10,
  convRule: rule8
}, {
  start: 7098,
  length: 44,
  convRule: rule14
}, {
  start: 7142,
  length: 1,
  convRule: rule92
}, {
  start: 7143,
  length: 1,
  convRule: rule124
}, {
  start: 7144,
  length: 2,
  convRule: rule92
}, {
  start: 7146,
  length: 3,
  convRule: rule124
}, {
  start: 7149,
  length: 1,
  convRule: rule92
}, {
  start: 7150,
  length: 1,
  convRule: rule124
}, {
  start: 7151,
  length: 3,
  convRule: rule92
}, {
  start: 7154,
  length: 2,
  convRule: rule124
}, {
  start: 7164,
  length: 4,
  convRule: rule2
}, {
  start: 7168,
  length: 36,
  convRule: rule14
}, {
  start: 7204,
  length: 8,
  convRule: rule124
}, {
  start: 7212,
  length: 8,
  convRule: rule92
}, {
  start: 7220,
  length: 2,
  convRule: rule124
}, {
  start: 7222,
  length: 2,
  convRule: rule92
}, {
  start: 7227,
  length: 5,
  convRule: rule2
}, {
  start: 7232,
  length: 10,
  convRule: rule8
}, {
  start: 7245,
  length: 3,
  convRule: rule14
}, {
  start: 7248,
  length: 10,
  convRule: rule8
}, {
  start: 7258,
  length: 30,
  convRule: rule14
}, {
  start: 7288,
  length: 6,
  convRule: rule91
}, {
  start: 7294,
  length: 2,
  convRule: rule2
}, {
  start: 7296,
  length: 1,
  convRule: rule129
}, {
  start: 7297,
  length: 1,
  convRule: rule130
}, {
  start: 7298,
  length: 1,
  convRule: rule131
}, {
  start: 7299,
  length: 2,
  convRule: rule132
}, {
  start: 7301,
  length: 1,
  convRule: rule133
}, {
  start: 7302,
  length: 1,
  convRule: rule134
}, {
  start: 7303,
  length: 1,
  convRule: rule135
}, {
  start: 7304,
  length: 1,
  convRule: rule136
}, {
  start: 7312,
  length: 43,
  convRule: rule137
}, {
  start: 7357,
  length: 3,
  convRule: rule137
}, {
  start: 7360,
  length: 8,
  convRule: rule2
}, {
  start: 7376,
  length: 3,
  convRule: rule92
}, {
  start: 7379,
  length: 1,
  convRule: rule2
}, {
  start: 7380,
  length: 13,
  convRule: rule92
}, {
  start: 7393,
  length: 1,
  convRule: rule124
}, {
  start: 7394,
  length: 7,
  convRule: rule92
}, {
  start: 7401,
  length: 4,
  convRule: rule14
}, {
  start: 7405,
  length: 1,
  convRule: rule92
}, {
  start: 7406,
  length: 6,
  convRule: rule14
}, {
  start: 7412,
  length: 1,
  convRule: rule92
}, {
  start: 7413,
  length: 2,
  convRule: rule14
}, {
  start: 7415,
  length: 1,
  convRule: rule124
}, {
  start: 7416,
  length: 2,
  convRule: rule92
}, {
  start: 7418,
  length: 1,
  convRule: rule14
}, {
  start: 7424,
  length: 44,
  convRule: rule20
}, {
  start: 7468,
  length: 63,
  convRule: rule91
}, {
  start: 7531,
  length: 13,
  convRule: rule20
}, {
  start: 7544,
  length: 1,
  convRule: rule91
}, {
  start: 7545,
  length: 1,
  convRule: rule138
}, {
  start: 7546,
  length: 3,
  convRule: rule20
}, {
  start: 7549,
  length: 1,
  convRule: rule139
}, {
  start: 7550,
  length: 16,
  convRule: rule20
}, {
  start: 7566,
  length: 1,
  convRule: rule140
}, {
  start: 7567,
  length: 12,
  convRule: rule20
}, {
  start: 7579,
  length: 37,
  convRule: rule91
}, {
  start: 7616,
  length: 58,
  convRule: rule92
}, {
  start: 7675,
  length: 5,
  convRule: rule92
}, {
  start: 7680,
  length: 1,
  convRule: rule22
}, {
  start: 7681,
  length: 1,
  convRule: rule23
}, {
  start: 7682,
  length: 1,
  convRule: rule22
}, {
  start: 7683,
  length: 1,
  convRule: rule23
}, {
  start: 7684,
  length: 1,
  convRule: rule22
}, {
  start: 7685,
  length: 1,
  convRule: rule23
}, {
  start: 7686,
  length: 1,
  convRule: rule22
}, {
  start: 7687,
  length: 1,
  convRule: rule23
}, {
  start: 7688,
  length: 1,
  convRule: rule22
}, {
  start: 7689,
  length: 1,
  convRule: rule23
}, {
  start: 7690,
  length: 1,
  convRule: rule22
}, {
  start: 7691,
  length: 1,
  convRule: rule23
}, {
  start: 7692,
  length: 1,
  convRule: rule22
}, {
  start: 7693,
  length: 1,
  convRule: rule23
}, {
  start: 7694,
  length: 1,
  convRule: rule22
}, {
  start: 7695,
  length: 1,
  convRule: rule23
}, {
  start: 7696,
  length: 1,
  convRule: rule22
}, {
  start: 7697,
  length: 1,
  convRule: rule23
}, {
  start: 7698,
  length: 1,
  convRule: rule22
}, {
  start: 7699,
  length: 1,
  convRule: rule23
}, {
  start: 7700,
  length: 1,
  convRule: rule22
}, {
  start: 7701,
  length: 1,
  convRule: rule23
}, {
  start: 7702,
  length: 1,
  convRule: rule22
}, {
  start: 7703,
  length: 1,
  convRule: rule23
}, {
  start: 7704,
  length: 1,
  convRule: rule22
}, {
  start: 7705,
  length: 1,
  convRule: rule23
}, {
  start: 7706,
  length: 1,
  convRule: rule22
}, {
  start: 7707,
  length: 1,
  convRule: rule23
}, {
  start: 7708,
  length: 1,
  convRule: rule22
}, {
  start: 7709,
  length: 1,
  convRule: rule23
}, {
  start: 7710,
  length: 1,
  convRule: rule22
}, {
  start: 7711,
  length: 1,
  convRule: rule23
}, {
  start: 7712,
  length: 1,
  convRule: rule22
}, {
  start: 7713,
  length: 1,
  convRule: rule23
}, {
  start: 7714,
  length: 1,
  convRule: rule22
}, {
  start: 7715,
  length: 1,
  convRule: rule23
}, {
  start: 7716,
  length: 1,
  convRule: rule22
}, {
  start: 7717,
  length: 1,
  convRule: rule23
}, {
  start: 7718,
  length: 1,
  convRule: rule22
}, {
  start: 7719,
  length: 1,
  convRule: rule23
}, {
  start: 7720,
  length: 1,
  convRule: rule22
}, {
  start: 7721,
  length: 1,
  convRule: rule23
}, {
  start: 7722,
  length: 1,
  convRule: rule22
}, {
  start: 7723,
  length: 1,
  convRule: rule23
}, {
  start: 7724,
  length: 1,
  convRule: rule22
}, {
  start: 7725,
  length: 1,
  convRule: rule23
}, {
  start: 7726,
  length: 1,
  convRule: rule22
}, {
  start: 7727,
  length: 1,
  convRule: rule23
}, {
  start: 7728,
  length: 1,
  convRule: rule22
}, {
  start: 7729,
  length: 1,
  convRule: rule23
}, {
  start: 7730,
  length: 1,
  convRule: rule22
}, {
  start: 7731,
  length: 1,
  convRule: rule23
}, {
  start: 7732,
  length: 1,
  convRule: rule22
}, {
  start: 7733,
  length: 1,
  convRule: rule23
}, {
  start: 7734,
  length: 1,
  convRule: rule22
}, {
  start: 7735,
  length: 1,
  convRule: rule23
}, {
  start: 7736,
  length: 1,
  convRule: rule22
}, {
  start: 7737,
  length: 1,
  convRule: rule23
}, {
  start: 7738,
  length: 1,
  convRule: rule22
}, {
  start: 7739,
  length: 1,
  convRule: rule23
}, {
  start: 7740,
  length: 1,
  convRule: rule22
}, {
  start: 7741,
  length: 1,
  convRule: rule23
}, {
  start: 7742,
  length: 1,
  convRule: rule22
}, {
  start: 7743,
  length: 1,
  convRule: rule23
}, {
  start: 7744,
  length: 1,
  convRule: rule22
}, {
  start: 7745,
  length: 1,
  convRule: rule23
}, {
  start: 7746,
  length: 1,
  convRule: rule22
}, {
  start: 7747,
  length: 1,
  convRule: rule23
}, {
  start: 7748,
  length: 1,
  convRule: rule22
}, {
  start: 7749,
  length: 1,
  convRule: rule23
}, {
  start: 7750,
  length: 1,
  convRule: rule22
}, {
  start: 7751,
  length: 1,
  convRule: rule23
}, {
  start: 7752,
  length: 1,
  convRule: rule22
}, {
  start: 7753,
  length: 1,
  convRule: rule23
}, {
  start: 7754,
  length: 1,
  convRule: rule22
}, {
  start: 7755,
  length: 1,
  convRule: rule23
}, {
  start: 7756,
  length: 1,
  convRule: rule22
}, {
  start: 7757,
  length: 1,
  convRule: rule23
}, {
  start: 7758,
  length: 1,
  convRule: rule22
}, {
  start: 7759,
  length: 1,
  convRule: rule23
}, {
  start: 7760,
  length: 1,
  convRule: rule22
}, {
  start: 7761,
  length: 1,
  convRule: rule23
}, {
  start: 7762,
  length: 1,
  convRule: rule22
}, {
  start: 7763,
  length: 1,
  convRule: rule23
}, {
  start: 7764,
  length: 1,
  convRule: rule22
}, {
  start: 7765,
  length: 1,
  convRule: rule23
}, {
  start: 7766,
  length: 1,
  convRule: rule22
}, {
  start: 7767,
  length: 1,
  convRule: rule23
}, {
  start: 7768,
  length: 1,
  convRule: rule22
}, {
  start: 7769,
  length: 1,
  convRule: rule23
}, {
  start: 7770,
  length: 1,
  convRule: rule22
}, {
  start: 7771,
  length: 1,
  convRule: rule23
}, {
  start: 7772,
  length: 1,
  convRule: rule22
}, {
  start: 7773,
  length: 1,
  convRule: rule23
}, {
  start: 7774,
  length: 1,
  convRule: rule22
}, {
  start: 7775,
  length: 1,
  convRule: rule23
}, {
  start: 7776,
  length: 1,
  convRule: rule22
}, {
  start: 7777,
  length: 1,
  convRule: rule23
}, {
  start: 7778,
  length: 1,
  convRule: rule22
}, {
  start: 7779,
  length: 1,
  convRule: rule23
}, {
  start: 7780,
  length: 1,
  convRule: rule22
}, {
  start: 7781,
  length: 1,
  convRule: rule23
}, {
  start: 7782,
  length: 1,
  convRule: rule22
}, {
  start: 7783,
  length: 1,
  convRule: rule23
}, {
  start: 7784,
  length: 1,
  convRule: rule22
}, {
  start: 7785,
  length: 1,
  convRule: rule23
}, {
  start: 7786,
  length: 1,
  convRule: rule22
}, {
  start: 7787,
  length: 1,
  convRule: rule23
}, {
  start: 7788,
  length: 1,
  convRule: rule22
}, {
  start: 7789,
  length: 1,
  convRule: rule23
}, {
  start: 7790,
  length: 1,
  convRule: rule22
}, {
  start: 7791,
  length: 1,
  convRule: rule23
}, {
  start: 7792,
  length: 1,
  convRule: rule22
}, {
  start: 7793,
  length: 1,
  convRule: rule23
}, {
  start: 7794,
  length: 1,
  convRule: rule22
}, {
  start: 7795,
  length: 1,
  convRule: rule23
}, {
  start: 7796,
  length: 1,
  convRule: rule22
}, {
  start: 7797,
  length: 1,
  convRule: rule23
}, {
  start: 7798,
  length: 1,
  convRule: rule22
}, {
  start: 7799,
  length: 1,
  convRule: rule23
}, {
  start: 7800,
  length: 1,
  convRule: rule22
}, {
  start: 7801,
  length: 1,
  convRule: rule23
}, {
  start: 7802,
  length: 1,
  convRule: rule22
}, {
  start: 7803,
  length: 1,
  convRule: rule23
}, {
  start: 7804,
  length: 1,
  convRule: rule22
}, {
  start: 7805,
  length: 1,
  convRule: rule23
}, {
  start: 7806,
  length: 1,
  convRule: rule22
}, {
  start: 7807,
  length: 1,
  convRule: rule23
}, {
  start: 7808,
  length: 1,
  convRule: rule22
}, {
  start: 7809,
  length: 1,
  convRule: rule23
}, {
  start: 7810,
  length: 1,
  convRule: rule22
}, {
  start: 7811,
  length: 1,
  convRule: rule23
}, {
  start: 7812,
  length: 1,
  convRule: rule22
}, {
  start: 7813,
  length: 1,
  convRule: rule23
}, {
  start: 7814,
  length: 1,
  convRule: rule22
}, {
  start: 7815,
  length: 1,
  convRule: rule23
}, {
  start: 7816,
  length: 1,
  convRule: rule22
}, {
  start: 7817,
  length: 1,
  convRule: rule23
}, {
  start: 7818,
  length: 1,
  convRule: rule22
}, {
  start: 7819,
  length: 1,
  convRule: rule23
}, {
  start: 7820,
  length: 1,
  convRule: rule22
}, {
  start: 7821,
  length: 1,
  convRule: rule23
}, {
  start: 7822,
  length: 1,
  convRule: rule22
}, {
  start: 7823,
  length: 1,
  convRule: rule23
}, {
  start: 7824,
  length: 1,
  convRule: rule22
}, {
  start: 7825,
  length: 1,
  convRule: rule23
}, {
  start: 7826,
  length: 1,
  convRule: rule22
}, {
  start: 7827,
  length: 1,
  convRule: rule23
}, {
  start: 7828,
  length: 1,
  convRule: rule22
}, {
  start: 7829,
  length: 1,
  convRule: rule23
}, {
  start: 7830,
  length: 5,
  convRule: rule20
}, {
  start: 7835,
  length: 1,
  convRule: rule141
}, {
  start: 7836,
  length: 2,
  convRule: rule20
}, {
  start: 7838,
  length: 1,
  convRule: rule142
}, {
  start: 7839,
  length: 1,
  convRule: rule20
}, {
  start: 7840,
  length: 1,
  convRule: rule22
}, {
  start: 7841,
  length: 1,
  convRule: rule23
}, {
  start: 7842,
  length: 1,
  convRule: rule22
}, {
  start: 7843,
  length: 1,
  convRule: rule23
}, {
  start: 7844,
  length: 1,
  convRule: rule22
}, {
  start: 7845,
  length: 1,
  convRule: rule23
}, {
  start: 7846,
  length: 1,
  convRule: rule22
}, {
  start: 7847,
  length: 1,
  convRule: rule23
}, {
  start: 7848,
  length: 1,
  convRule: rule22
}, {
  start: 7849,
  length: 1,
  convRule: rule23
}, {
  start: 7850,
  length: 1,
  convRule: rule22
}, {
  start: 7851,
  length: 1,
  convRule: rule23
}, {
  start: 7852,
  length: 1,
  convRule: rule22
}, {
  start: 7853,
  length: 1,
  convRule: rule23
}, {
  start: 7854,
  length: 1,
  convRule: rule22
}, {
  start: 7855,
  length: 1,
  convRule: rule23
}, {
  start: 7856,
  length: 1,
  convRule: rule22
}, {
  start: 7857,
  length: 1,
  convRule: rule23
}, {
  start: 7858,
  length: 1,
  convRule: rule22
}, {
  start: 7859,
  length: 1,
  convRule: rule23
}, {
  start: 7860,
  length: 1,
  convRule: rule22
}, {
  start: 7861,
  length: 1,
  convRule: rule23
}, {
  start: 7862,
  length: 1,
  convRule: rule22
}, {
  start: 7863,
  length: 1,
  convRule: rule23
}, {
  start: 7864,
  length: 1,
  convRule: rule22
}, {
  start: 7865,
  length: 1,
  convRule: rule23
}, {
  start: 7866,
  length: 1,
  convRule: rule22
}, {
  start: 7867,
  length: 1,
  convRule: rule23
}, {
  start: 7868,
  length: 1,
  convRule: rule22
}, {
  start: 7869,
  length: 1,
  convRule: rule23
}, {
  start: 7870,
  length: 1,
  convRule: rule22
}, {
  start: 7871,
  length: 1,
  convRule: rule23
}, {
  start: 7872,
  length: 1,
  convRule: rule22
}, {
  start: 7873,
  length: 1,
  convRule: rule23
}, {
  start: 7874,
  length: 1,
  convRule: rule22
}, {
  start: 7875,
  length: 1,
  convRule: rule23
}, {
  start: 7876,
  length: 1,
  convRule: rule22
}, {
  start: 7877,
  length: 1,
  convRule: rule23
}, {
  start: 7878,
  length: 1,
  convRule: rule22
}, {
  start: 7879,
  length: 1,
  convRule: rule23
}, {
  start: 7880,
  length: 1,
  convRule: rule22
}, {
  start: 7881,
  length: 1,
  convRule: rule23
}, {
  start: 7882,
  length: 1,
  convRule: rule22
}, {
  start: 7883,
  length: 1,
  convRule: rule23
}, {
  start: 7884,
  length: 1,
  convRule: rule22
}, {
  start: 7885,
  length: 1,
  convRule: rule23
}, {
  start: 7886,
  length: 1,
  convRule: rule22
}, {
  start: 7887,
  length: 1,
  convRule: rule23
}, {
  start: 7888,
  length: 1,
  convRule: rule22
}, {
  start: 7889,
  length: 1,
  convRule: rule23
}, {
  start: 7890,
  length: 1,
  convRule: rule22
}, {
  start: 7891,
  length: 1,
  convRule: rule23
}, {
  start: 7892,
  length: 1,
  convRule: rule22
}, {
  start: 7893,
  length: 1,
  convRule: rule23
}, {
  start: 7894,
  length: 1,
  convRule: rule22
}, {
  start: 7895,
  length: 1,
  convRule: rule23
}, {
  start: 7896,
  length: 1,
  convRule: rule22
}, {
  start: 7897,
  length: 1,
  convRule: rule23
}, {
  start: 7898,
  length: 1,
  convRule: rule22
}, {
  start: 7899,
  length: 1,
  convRule: rule23
}, {
  start: 7900,
  length: 1,
  convRule: rule22
}, {
  start: 7901,
  length: 1,
  convRule: rule23
}, {
  start: 7902,
  length: 1,
  convRule: rule22
}, {
  start: 7903,
  length: 1,
  convRule: rule23
}, {
  start: 7904,
  length: 1,
  convRule: rule22
}, {
  start: 7905,
  length: 1,
  convRule: rule23
}, {
  start: 7906,
  length: 1,
  convRule: rule22
}, {
  start: 7907,
  length: 1,
  convRule: rule23
}, {
  start: 7908,
  length: 1,
  convRule: rule22
}, {
  start: 7909,
  length: 1,
  convRule: rule23
}, {
  start: 7910,
  length: 1,
  convRule: rule22
}, {
  start: 7911,
  length: 1,
  convRule: rule23
}, {
  start: 7912,
  length: 1,
  convRule: rule22
}, {
  start: 7913,
  length: 1,
  convRule: rule23
}, {
  start: 7914,
  length: 1,
  convRule: rule22
}, {
  start: 7915,
  length: 1,
  convRule: rule23
}, {
  start: 7916,
  length: 1,
  convRule: rule22
}, {
  start: 7917,
  length: 1,
  convRule: rule23
}, {
  start: 7918,
  length: 1,
  convRule: rule22
}, {
  start: 7919,
  length: 1,
  convRule: rule23
}, {
  start: 7920,
  length: 1,
  convRule: rule22
}, {
  start: 7921,
  length: 1,
  convRule: rule23
}, {
  start: 7922,
  length: 1,
  convRule: rule22
}, {
  start: 7923,
  length: 1,
  convRule: rule23
}, {
  start: 7924,
  length: 1,
  convRule: rule22
}, {
  start: 7925,
  length: 1,
  convRule: rule23
}, {
  start: 7926,
  length: 1,
  convRule: rule22
}, {
  start: 7927,
  length: 1,
  convRule: rule23
}, {
  start: 7928,
  length: 1,
  convRule: rule22
}, {
  start: 7929,
  length: 1,
  convRule: rule23
}, {
  start: 7930,
  length: 1,
  convRule: rule22
}, {
  start: 7931,
  length: 1,
  convRule: rule23
}, {
  start: 7932,
  length: 1,
  convRule: rule22
}, {
  start: 7933,
  length: 1,
  convRule: rule23
}, {
  start: 7934,
  length: 1,
  convRule: rule22
}, {
  start: 7935,
  length: 1,
  convRule: rule23
}, {
  start: 7936,
  length: 8,
  convRule: rule143
}, {
  start: 7944,
  length: 8,
  convRule: rule144
}, {
  start: 7952,
  length: 6,
  convRule: rule143
}, {
  start: 7960,
  length: 6,
  convRule: rule144
}, {
  start: 7968,
  length: 8,
  convRule: rule143
}, {
  start: 7976,
  length: 8,
  convRule: rule144
}, {
  start: 7984,
  length: 8,
  convRule: rule143
}, {
  start: 7992,
  length: 8,
  convRule: rule144
}, {
  start: 8e3,
  length: 6,
  convRule: rule143
}, {
  start: 8008,
  length: 6,
  convRule: rule144
}, {
  start: 8016,
  length: 1,
  convRule: rule20
}, {
  start: 8017,
  length: 1,
  convRule: rule143
}, {
  start: 8018,
  length: 1,
  convRule: rule20
}, {
  start: 8019,
  length: 1,
  convRule: rule143
}, {
  start: 8020,
  length: 1,
  convRule: rule20
}, {
  start: 8021,
  length: 1,
  convRule: rule143
}, {
  start: 8022,
  length: 1,
  convRule: rule20
}, {
  start: 8023,
  length: 1,
  convRule: rule143
}, {
  start: 8025,
  length: 1,
  convRule: rule144
}, {
  start: 8027,
  length: 1,
  convRule: rule144
}, {
  start: 8029,
  length: 1,
  convRule: rule144
}, {
  start: 8031,
  length: 1,
  convRule: rule144
}, {
  start: 8032,
  length: 8,
  convRule: rule143
}, {
  start: 8040,
  length: 8,
  convRule: rule144
}, {
  start: 8048,
  length: 2,
  convRule: rule145
}, {
  start: 8050,
  length: 4,
  convRule: rule146
}, {
  start: 8054,
  length: 2,
  convRule: rule147
}, {
  start: 8056,
  length: 2,
  convRule: rule148
}, {
  start: 8058,
  length: 2,
  convRule: rule149
}, {
  start: 8060,
  length: 2,
  convRule: rule150
}, {
  start: 8064,
  length: 8,
  convRule: rule143
}, {
  start: 8072,
  length: 8,
  convRule: rule151
}, {
  start: 8080,
  length: 8,
  convRule: rule143
}, {
  start: 8088,
  length: 8,
  convRule: rule151
}, {
  start: 8096,
  length: 8,
  convRule: rule143
}, {
  start: 8104,
  length: 8,
  convRule: rule151
}, {
  start: 8112,
  length: 2,
  convRule: rule143
}, {
  start: 8114,
  length: 1,
  convRule: rule20
}, {
  start: 8115,
  length: 1,
  convRule: rule152
}, {
  start: 8116,
  length: 1,
  convRule: rule20
}, {
  start: 8118,
  length: 2,
  convRule: rule20
}, {
  start: 8120,
  length: 2,
  convRule: rule144
}, {
  start: 8122,
  length: 2,
  convRule: rule153
}, {
  start: 8124,
  length: 1,
  convRule: rule154
}, {
  start: 8125,
  length: 1,
  convRule: rule10
}, {
  start: 8126,
  length: 1,
  convRule: rule155
}, {
  start: 8127,
  length: 3,
  convRule: rule10
}, {
  start: 8130,
  length: 1,
  convRule: rule20
}, {
  start: 8131,
  length: 1,
  convRule: rule152
}, {
  start: 8132,
  length: 1,
  convRule: rule20
}, {
  start: 8134,
  length: 2,
  convRule: rule20
}, {
  start: 8136,
  length: 4,
  convRule: rule156
}, {
  start: 8140,
  length: 1,
  convRule: rule154
}, {
  start: 8141,
  length: 3,
  convRule: rule10
}, {
  start: 8144,
  length: 2,
  convRule: rule143
}, {
  start: 8146,
  length: 2,
  convRule: rule20
}, {
  start: 8150,
  length: 2,
  convRule: rule20
}, {
  start: 8152,
  length: 2,
  convRule: rule144
}, {
  start: 8154,
  length: 2,
  convRule: rule157
}, {
  start: 8157,
  length: 3,
  convRule: rule10
}, {
  start: 8160,
  length: 2,
  convRule: rule143
}, {
  start: 8162,
  length: 3,
  convRule: rule20
}, {
  start: 8165,
  length: 1,
  convRule: rule113
}, {
  start: 8166,
  length: 2,
  convRule: rule20
}, {
  start: 8168,
  length: 2,
  convRule: rule144
}, {
  start: 8170,
  length: 2,
  convRule: rule158
}, {
  start: 8172,
  length: 1,
  convRule: rule117
}, {
  start: 8173,
  length: 3,
  convRule: rule10
}, {
  start: 8178,
  length: 1,
  convRule: rule20
}, {
  start: 8179,
  length: 1,
  convRule: rule152
}, {
  start: 8180,
  length: 1,
  convRule: rule20
}, {
  start: 8182,
  length: 2,
  convRule: rule20
}, {
  start: 8184,
  length: 2,
  convRule: rule159
}, {
  start: 8186,
  length: 2,
  convRule: rule160
}, {
  start: 8188,
  length: 1,
  convRule: rule154
}, {
  start: 8189,
  length: 2,
  convRule: rule10
}, {
  start: 8192,
  length: 11,
  convRule: rule1
}, {
  start: 8203,
  length: 5,
  convRule: rule16
}, {
  start: 8208,
  length: 6,
  convRule: rule7
}, {
  start: 8214,
  length: 2,
  convRule: rule2
}, {
  start: 8216,
  length: 1,
  convRule: rule15
}, {
  start: 8217,
  length: 1,
  convRule: rule19
}, {
  start: 8218,
  length: 1,
  convRule: rule4
}, {
  start: 8219,
  length: 2,
  convRule: rule15
}, {
  start: 8221,
  length: 1,
  convRule: rule19
}, {
  start: 8222,
  length: 1,
  convRule: rule4
}, {
  start: 8223,
  length: 1,
  convRule: rule15
}, {
  start: 8224,
  length: 8,
  convRule: rule2
}, {
  start: 8232,
  length: 1,
  convRule: rule161
}, {
  start: 8233,
  length: 1,
  convRule: rule162
}, {
  start: 8234,
  length: 5,
  convRule: rule16
}, {
  start: 8239,
  length: 1,
  convRule: rule1
}, {
  start: 8240,
  length: 9,
  convRule: rule2
}, {
  start: 8249,
  length: 1,
  convRule: rule15
}, {
  start: 8250,
  length: 1,
  convRule: rule19
}, {
  start: 8251,
  length: 4,
  convRule: rule2
}, {
  start: 8255,
  length: 2,
  convRule: rule11
}, {
  start: 8257,
  length: 3,
  convRule: rule2
}, {
  start: 8260,
  length: 1,
  convRule: rule6
}, {
  start: 8261,
  length: 1,
  convRule: rule4
}, {
  start: 8262,
  length: 1,
  convRule: rule5
}, {
  start: 8263,
  length: 11,
  convRule: rule2
}, {
  start: 8274,
  length: 1,
  convRule: rule6
}, {
  start: 8275,
  length: 1,
  convRule: rule2
}, {
  start: 8276,
  length: 1,
  convRule: rule11
}, {
  start: 8277,
  length: 10,
  convRule: rule2
}, {
  start: 8287,
  length: 1,
  convRule: rule1
}, {
  start: 8288,
  length: 5,
  convRule: rule16
}, {
  start: 8294,
  length: 10,
  convRule: rule16
}, {
  start: 8304,
  length: 1,
  convRule: rule17
}, {
  start: 8305,
  length: 1,
  convRule: rule91
}, {
  start: 8308,
  length: 6,
  convRule: rule17
}, {
  start: 8314,
  length: 3,
  convRule: rule6
}, {
  start: 8317,
  length: 1,
  convRule: rule4
}, {
  start: 8318,
  length: 1,
  convRule: rule5
}, {
  start: 8319,
  length: 1,
  convRule: rule91
}, {
  start: 8320,
  length: 10,
  convRule: rule17
}, {
  start: 8330,
  length: 3,
  convRule: rule6
}, {
  start: 8333,
  length: 1,
  convRule: rule4
}, {
  start: 8334,
  length: 1,
  convRule: rule5
}, {
  start: 8336,
  length: 13,
  convRule: rule91
}, {
  start: 8352,
  length: 32,
  convRule: rule3
}, {
  start: 8400,
  length: 13,
  convRule: rule92
}, {
  start: 8413,
  length: 4,
  convRule: rule119
}, {
  start: 8417,
  length: 1,
  convRule: rule92
}, {
  start: 8418,
  length: 3,
  convRule: rule119
}, {
  start: 8421,
  length: 12,
  convRule: rule92
}, {
  start: 8448,
  length: 2,
  convRule: rule13
}, {
  start: 8450,
  length: 1,
  convRule: rule107
}, {
  start: 8451,
  length: 4,
  convRule: rule13
}, {
  start: 8455,
  length: 1,
  convRule: rule107
}, {
  start: 8456,
  length: 2,
  convRule: rule13
}, {
  start: 8458,
  length: 1,
  convRule: rule20
}, {
  start: 8459,
  length: 3,
  convRule: rule107
}, {
  start: 8462,
  length: 2,
  convRule: rule20
}, {
  start: 8464,
  length: 3,
  convRule: rule107
}, {
  start: 8467,
  length: 1,
  convRule: rule20
}, {
  start: 8468,
  length: 1,
  convRule: rule13
}, {
  start: 8469,
  length: 1,
  convRule: rule107
}, {
  start: 8470,
  length: 2,
  convRule: rule13
}, {
  start: 8472,
  length: 1,
  convRule: rule6
}, {
  start: 8473,
  length: 5,
  convRule: rule107
}, {
  start: 8478,
  length: 6,
  convRule: rule13
}, {
  start: 8484,
  length: 1,
  convRule: rule107
}, {
  start: 8485,
  length: 1,
  convRule: rule13
}, {
  start: 8486,
  length: 1,
  convRule: rule163
}, {
  start: 8487,
  length: 1,
  convRule: rule13
}, {
  start: 8488,
  length: 1,
  convRule: rule107
}, {
  start: 8489,
  length: 1,
  convRule: rule13
}, {
  start: 8490,
  length: 1,
  convRule: rule164
}, {
  start: 8491,
  length: 1,
  convRule: rule165
}, {
  start: 8492,
  length: 2,
  convRule: rule107
}, {
  start: 8494,
  length: 1,
  convRule: rule13
}, {
  start: 8495,
  length: 1,
  convRule: rule20
}, {
  start: 8496,
  length: 2,
  convRule: rule107
}, {
  start: 8498,
  length: 1,
  convRule: rule166
}, {
  start: 8499,
  length: 1,
  convRule: rule107
}, {
  start: 8500,
  length: 1,
  convRule: rule20
}, {
  start: 8501,
  length: 4,
  convRule: rule14
}, {
  start: 8505,
  length: 1,
  convRule: rule20
}, {
  start: 8506,
  length: 2,
  convRule: rule13
}, {
  start: 8508,
  length: 2,
  convRule: rule20
}, {
  start: 8510,
  length: 2,
  convRule: rule107
}, {
  start: 8512,
  length: 5,
  convRule: rule6
}, {
  start: 8517,
  length: 1,
  convRule: rule107
}, {
  start: 8518,
  length: 4,
  convRule: rule20
}, {
  start: 8522,
  length: 1,
  convRule: rule13
}, {
  start: 8523,
  length: 1,
  convRule: rule6
}, {
  start: 8524,
  length: 2,
  convRule: rule13
}, {
  start: 8526,
  length: 1,
  convRule: rule167
}, {
  start: 8527,
  length: 1,
  convRule: rule13
}, {
  start: 8528,
  length: 16,
  convRule: rule17
}, {
  start: 8544,
  length: 16,
  convRule: rule168
}, {
  start: 8560,
  length: 16,
  convRule: rule169
}, {
  start: 8576,
  length: 3,
  convRule: rule128
}, {
  start: 8579,
  length: 1,
  convRule: rule22
}, {
  start: 8580,
  length: 1,
  convRule: rule23
}, {
  start: 8581,
  length: 4,
  convRule: rule128
}, {
  start: 8585,
  length: 1,
  convRule: rule17
}, {
  start: 8586,
  length: 2,
  convRule: rule13
}, {
  start: 8592,
  length: 5,
  convRule: rule6
}, {
  start: 8597,
  length: 5,
  convRule: rule13
}, {
  start: 8602,
  length: 2,
  convRule: rule6
}, {
  start: 8604,
  length: 4,
  convRule: rule13
}, {
  start: 8608,
  length: 1,
  convRule: rule6
}, {
  start: 8609,
  length: 2,
  convRule: rule13
}, {
  start: 8611,
  length: 1,
  convRule: rule6
}, {
  start: 8612,
  length: 2,
  convRule: rule13
}, {
  start: 8614,
  length: 1,
  convRule: rule6
}, {
  start: 8615,
  length: 7,
  convRule: rule13
}, {
  start: 8622,
  length: 1,
  convRule: rule6
}, {
  start: 8623,
  length: 31,
  convRule: rule13
}, {
  start: 8654,
  length: 2,
  convRule: rule6
}, {
  start: 8656,
  length: 2,
  convRule: rule13
}, {
  start: 8658,
  length: 1,
  convRule: rule6
}, {
  start: 8659,
  length: 1,
  convRule: rule13
}, {
  start: 8660,
  length: 1,
  convRule: rule6
}, {
  start: 8661,
  length: 31,
  convRule: rule13
}, {
  start: 8692,
  length: 268,
  convRule: rule6
}, {
  start: 8960,
  length: 8,
  convRule: rule13
}, {
  start: 8968,
  length: 1,
  convRule: rule4
}, {
  start: 8969,
  length: 1,
  convRule: rule5
}, {
  start: 8970,
  length: 1,
  convRule: rule4
}, {
  start: 8971,
  length: 1,
  convRule: rule5
}, {
  start: 8972,
  length: 20,
  convRule: rule13
}, {
  start: 8992,
  length: 2,
  convRule: rule6
}, {
  start: 8994,
  length: 7,
  convRule: rule13
}, {
  start: 9001,
  length: 1,
  convRule: rule4
}, {
  start: 9002,
  length: 1,
  convRule: rule5
}, {
  start: 9003,
  length: 81,
  convRule: rule13
}, {
  start: 9084,
  length: 1,
  convRule: rule6
}, {
  start: 9085,
  length: 30,
  convRule: rule13
}, {
  start: 9115,
  length: 25,
  convRule: rule6
}, {
  start: 9140,
  length: 40,
  convRule: rule13
}, {
  start: 9180,
  length: 6,
  convRule: rule6
}, {
  start: 9186,
  length: 69,
  convRule: rule13
}, {
  start: 9280,
  length: 11,
  convRule: rule13
}, {
  start: 9312,
  length: 60,
  convRule: rule17
}, {
  start: 9372,
  length: 26,
  convRule: rule13
}, {
  start: 9398,
  length: 26,
  convRule: rule170
}, {
  start: 9424,
  length: 26,
  convRule: rule171
}, {
  start: 9450,
  length: 22,
  convRule: rule17
}, {
  start: 9472,
  length: 183,
  convRule: rule13
}, {
  start: 9655,
  length: 1,
  convRule: rule6
}, {
  start: 9656,
  length: 9,
  convRule: rule13
}, {
  start: 9665,
  length: 1,
  convRule: rule6
}, {
  start: 9666,
  length: 54,
  convRule: rule13
}, {
  start: 9720,
  length: 8,
  convRule: rule6
}, {
  start: 9728,
  length: 111,
  convRule: rule13
}, {
  start: 9839,
  length: 1,
  convRule: rule6
}, {
  start: 9840,
  length: 248,
  convRule: rule13
}, {
  start: 10088,
  length: 1,
  convRule: rule4
}, {
  start: 10089,
  length: 1,
  convRule: rule5
}, {
  start: 10090,
  length: 1,
  convRule: rule4
}, {
  start: 10091,
  length: 1,
  convRule: rule5
}, {
  start: 10092,
  length: 1,
  convRule: rule4
}, {
  start: 10093,
  length: 1,
  convRule: rule5
}, {
  start: 10094,
  length: 1,
  convRule: rule4
}, {
  start: 10095,
  length: 1,
  convRule: rule5
}, {
  start: 10096,
  length: 1,
  convRule: rule4
}, {
  start: 10097,
  length: 1,
  convRule: rule5
}, {
  start: 10098,
  length: 1,
  convRule: rule4
}, {
  start: 10099,
  length: 1,
  convRule: rule5
}, {
  start: 10100,
  length: 1,
  convRule: rule4
}, {
  start: 10101,
  length: 1,
  convRule: rule5
}, {
  start: 10102,
  length: 30,
  convRule: rule17
}, {
  start: 10132,
  length: 44,
  convRule: rule13
}, {
  start: 10176,
  length: 5,
  convRule: rule6
}, {
  start: 10181,
  length: 1,
  convRule: rule4
}, {
  start: 10182,
  length: 1,
  convRule: rule5
}, {
  start: 10183,
  length: 31,
  convRule: rule6
}, {
  start: 10214,
  length: 1,
  convRule: rule4
}, {
  start: 10215,
  length: 1,
  convRule: rule5
}, {
  start: 10216,
  length: 1,
  convRule: rule4
}, {
  start: 10217,
  length: 1,
  convRule: rule5
}, {
  start: 10218,
  length: 1,
  convRule: rule4
}, {
  start: 10219,
  length: 1,
  convRule: rule5
}, {
  start: 10220,
  length: 1,
  convRule: rule4
}, {
  start: 10221,
  length: 1,
  convRule: rule5
}, {
  start: 10222,
  length: 1,
  convRule: rule4
}, {
  start: 10223,
  length: 1,
  convRule: rule5
}, {
  start: 10224,
  length: 16,
  convRule: rule6
}, {
  start: 10240,
  length: 256,
  convRule: rule13
}, {
  start: 10496,
  length: 131,
  convRule: rule6
}, {
  start: 10627,
  length: 1,
  convRule: rule4
}, {
  start: 10628,
  length: 1,
  convRule: rule5
}, {
  start: 10629,
  length: 1,
  convRule: rule4
}, {
  start: 10630,
  length: 1,
  convRule: rule5
}, {
  start: 10631,
  length: 1,
  convRule: rule4
}, {
  start: 10632,
  length: 1,
  convRule: rule5
}, {
  start: 10633,
  length: 1,
  convRule: rule4
}, {
  start: 10634,
  length: 1,
  convRule: rule5
}, {
  start: 10635,
  length: 1,
  convRule: rule4
}, {
  start: 10636,
  length: 1,
  convRule: rule5
}, {
  start: 10637,
  length: 1,
  convRule: rule4
}, {
  start: 10638,
  length: 1,
  convRule: rule5
}, {
  start: 10639,
  length: 1,
  convRule: rule4
}, {
  start: 10640,
  length: 1,
  convRule: rule5
}, {
  start: 10641,
  length: 1,
  convRule: rule4
}, {
  start: 10642,
  length: 1,
  convRule: rule5
}, {
  start: 10643,
  length: 1,
  convRule: rule4
}, {
  start: 10644,
  length: 1,
  convRule: rule5
}, {
  start: 10645,
  length: 1,
  convRule: rule4
}, {
  start: 10646,
  length: 1,
  convRule: rule5
}, {
  start: 10647,
  length: 1,
  convRule: rule4
}, {
  start: 10648,
  length: 1,
  convRule: rule5
}, {
  start: 10649,
  length: 63,
  convRule: rule6
}, {
  start: 10712,
  length: 1,
  convRule: rule4
}, {
  start: 10713,
  length: 1,
  convRule: rule5
}, {
  start: 10714,
  length: 1,
  convRule: rule4
}, {
  start: 10715,
  length: 1,
  convRule: rule5
}, {
  start: 10716,
  length: 32,
  convRule: rule6
}, {
  start: 10748,
  length: 1,
  convRule: rule4
}, {
  start: 10749,
  length: 1,
  convRule: rule5
}, {
  start: 10750,
  length: 258,
  convRule: rule6
}, {
  start: 11008,
  length: 48,
  convRule: rule13
}, {
  start: 11056,
  length: 21,
  convRule: rule6
}, {
  start: 11077,
  length: 2,
  convRule: rule13
}, {
  start: 11079,
  length: 6,
  convRule: rule6
}, {
  start: 11085,
  length: 39,
  convRule: rule13
}, {
  start: 11126,
  length: 32,
  convRule: rule13
}, {
  start: 11159,
  length: 105,
  convRule: rule13
}, {
  start: 11264,
  length: 47,
  convRule: rule122
}, {
  start: 11312,
  length: 47,
  convRule: rule123
}, {
  start: 11360,
  length: 1,
  convRule: rule22
}, {
  start: 11361,
  length: 1,
  convRule: rule23
}, {
  start: 11362,
  length: 1,
  convRule: rule172
}, {
  start: 11363,
  length: 1,
  convRule: rule173
}, {
  start: 11364,
  length: 1,
  convRule: rule174
}, {
  start: 11365,
  length: 1,
  convRule: rule175
}, {
  start: 11366,
  length: 1,
  convRule: rule176
}, {
  start: 11367,
  length: 1,
  convRule: rule22
}, {
  start: 11368,
  length: 1,
  convRule: rule23
}, {
  start: 11369,
  length: 1,
  convRule: rule22
}, {
  start: 11370,
  length: 1,
  convRule: rule23
}, {
  start: 11371,
  length: 1,
  convRule: rule22
}, {
  start: 11372,
  length: 1,
  convRule: rule23
}, {
  start: 11373,
  length: 1,
  convRule: rule177
}, {
  start: 11374,
  length: 1,
  convRule: rule178
}, {
  start: 11375,
  length: 1,
  convRule: rule179
}, {
  start: 11376,
  length: 1,
  convRule: rule180
}, {
  start: 11377,
  length: 1,
  convRule: rule20
}, {
  start: 11378,
  length: 1,
  convRule: rule22
}, {
  start: 11379,
  length: 1,
  convRule: rule23
}, {
  start: 11380,
  length: 1,
  convRule: rule20
}, {
  start: 11381,
  length: 1,
  convRule: rule22
}, {
  start: 11382,
  length: 1,
  convRule: rule23
}, {
  start: 11383,
  length: 5,
  convRule: rule20
}, {
  start: 11388,
  length: 2,
  convRule: rule91
}, {
  start: 11390,
  length: 2,
  convRule: rule181
}, {
  start: 11392,
  length: 1,
  convRule: rule22
}, {
  start: 11393,
  length: 1,
  convRule: rule23
}, {
  start: 11394,
  length: 1,
  convRule: rule22
}, {
  start: 11395,
  length: 1,
  convRule: rule23
}, {
  start: 11396,
  length: 1,
  convRule: rule22
}, {
  start: 11397,
  length: 1,
  convRule: rule23
}, {
  start: 11398,
  length: 1,
  convRule: rule22
}, {
  start: 11399,
  length: 1,
  convRule: rule23
}, {
  start: 11400,
  length: 1,
  convRule: rule22
}, {
  start: 11401,
  length: 1,
  convRule: rule23
}, {
  start: 11402,
  length: 1,
  convRule: rule22
}, {
  start: 11403,
  length: 1,
  convRule: rule23
}, {
  start: 11404,
  length: 1,
  convRule: rule22
}, {
  start: 11405,
  length: 1,
  convRule: rule23
}, {
  start: 11406,
  length: 1,
  convRule: rule22
}, {
  start: 11407,
  length: 1,
  convRule: rule23
}, {
  start: 11408,
  length: 1,
  convRule: rule22
}, {
  start: 11409,
  length: 1,
  convRule: rule23
}, {
  start: 11410,
  length: 1,
  convRule: rule22
}, {
  start: 11411,
  length: 1,
  convRule: rule23
}, {
  start: 11412,
  length: 1,
  convRule: rule22
}, {
  start: 11413,
  length: 1,
  convRule: rule23
}, {
  start: 11414,
  length: 1,
  convRule: rule22
}, {
  start: 11415,
  length: 1,
  convRule: rule23
}, {
  start: 11416,
  length: 1,
  convRule: rule22
}, {
  start: 11417,
  length: 1,
  convRule: rule23
}, {
  start: 11418,
  length: 1,
  convRule: rule22
}, {
  start: 11419,
  length: 1,
  convRule: rule23
}, {
  start: 11420,
  length: 1,
  convRule: rule22
}, {
  start: 11421,
  length: 1,
  convRule: rule23
}, {
  start: 11422,
  length: 1,
  convRule: rule22
}, {
  start: 11423,
  length: 1,
  convRule: rule23
}, {
  start: 11424,
  length: 1,
  convRule: rule22
}, {
  start: 11425,
  length: 1,
  convRule: rule23
}, {
  start: 11426,
  length: 1,
  convRule: rule22
}, {
  start: 11427,
  length: 1,
  convRule: rule23
}, {
  start: 11428,
  length: 1,
  convRule: rule22
}, {
  start: 11429,
  length: 1,
  convRule: rule23
}, {
  start: 11430,
  length: 1,
  convRule: rule22
}, {
  start: 11431,
  length: 1,
  convRule: rule23
}, {
  start: 11432,
  length: 1,
  convRule: rule22
}, {
  start: 11433,
  length: 1,
  convRule: rule23
}, {
  start: 11434,
  length: 1,
  convRule: rule22
}, {
  start: 11435,
  length: 1,
  convRule: rule23
}, {
  start: 11436,
  length: 1,
  convRule: rule22
}, {
  start: 11437,
  length: 1,
  convRule: rule23
}, {
  start: 11438,
  length: 1,
  convRule: rule22
}, {
  start: 11439,
  length: 1,
  convRule: rule23
}, {
  start: 11440,
  length: 1,
  convRule: rule22
}, {
  start: 11441,
  length: 1,
  convRule: rule23
}, {
  start: 11442,
  length: 1,
  convRule: rule22
}, {
  start: 11443,
  length: 1,
  convRule: rule23
}, {
  start: 11444,
  length: 1,
  convRule: rule22
}, {
  start: 11445,
  length: 1,
  convRule: rule23
}, {
  start: 11446,
  length: 1,
  convRule: rule22
}, {
  start: 11447,
  length: 1,
  convRule: rule23
}, {
  start: 11448,
  length: 1,
  convRule: rule22
}, {
  start: 11449,
  length: 1,
  convRule: rule23
}, {
  start: 11450,
  length: 1,
  convRule: rule22
}, {
  start: 11451,
  length: 1,
  convRule: rule23
}, {
  start: 11452,
  length: 1,
  convRule: rule22
}, {
  start: 11453,
  length: 1,
  convRule: rule23
}, {
  start: 11454,
  length: 1,
  convRule: rule22
}, {
  start: 11455,
  length: 1,
  convRule: rule23
}, {
  start: 11456,
  length: 1,
  convRule: rule22
}, {
  start: 11457,
  length: 1,
  convRule: rule23
}, {
  start: 11458,
  length: 1,
  convRule: rule22
}, {
  start: 11459,
  length: 1,
  convRule: rule23
}, {
  start: 11460,
  length: 1,
  convRule: rule22
}, {
  start: 11461,
  length: 1,
  convRule: rule23
}, {
  start: 11462,
  length: 1,
  convRule: rule22
}, {
  start: 11463,
  length: 1,
  convRule: rule23
}, {
  start: 11464,
  length: 1,
  convRule: rule22
}, {
  start: 11465,
  length: 1,
  convRule: rule23
}, {
  start: 11466,
  length: 1,
  convRule: rule22
}, {
  start: 11467,
  length: 1,
  convRule: rule23
}, {
  start: 11468,
  length: 1,
  convRule: rule22
}, {
  start: 11469,
  length: 1,
  convRule: rule23
}, {
  start: 11470,
  length: 1,
  convRule: rule22
}, {
  start: 11471,
  length: 1,
  convRule: rule23
}, {
  start: 11472,
  length: 1,
  convRule: rule22
}, {
  start: 11473,
  length: 1,
  convRule: rule23
}, {
  start: 11474,
  length: 1,
  convRule: rule22
}, {
  start: 11475,
  length: 1,
  convRule: rule23
}, {
  start: 11476,
  length: 1,
  convRule: rule22
}, {
  start: 11477,
  length: 1,
  convRule: rule23
}, {
  start: 11478,
  length: 1,
  convRule: rule22
}, {
  start: 11479,
  length: 1,
  convRule: rule23
}, {
  start: 11480,
  length: 1,
  convRule: rule22
}, {
  start: 11481,
  length: 1,
  convRule: rule23
}, {
  start: 11482,
  length: 1,
  convRule: rule22
}, {
  start: 11483,
  length: 1,
  convRule: rule23
}, {
  start: 11484,
  length: 1,
  convRule: rule22
}, {
  start: 11485,
  length: 1,
  convRule: rule23
}, {
  start: 11486,
  length: 1,
  convRule: rule22
}, {
  start: 11487,
  length: 1,
  convRule: rule23
}, {
  start: 11488,
  length: 1,
  convRule: rule22
}, {
  start: 11489,
  length: 1,
  convRule: rule23
}, {
  start: 11490,
  length: 1,
  convRule: rule22
}, {
  start: 11491,
  length: 1,
  convRule: rule23
}, {
  start: 11492,
  length: 1,
  convRule: rule20
}, {
  start: 11493,
  length: 6,
  convRule: rule13
}, {
  start: 11499,
  length: 1,
  convRule: rule22
}, {
  start: 11500,
  length: 1,
  convRule: rule23
}, {
  start: 11501,
  length: 1,
  convRule: rule22
}, {
  start: 11502,
  length: 1,
  convRule: rule23
}, {
  start: 11503,
  length: 3,
  convRule: rule92
}, {
  start: 11506,
  length: 1,
  convRule: rule22
}, {
  start: 11507,
  length: 1,
  convRule: rule23
}, {
  start: 11513,
  length: 4,
  convRule: rule2
}, {
  start: 11517,
  length: 1,
  convRule: rule17
}, {
  start: 11518,
  length: 2,
  convRule: rule2
}, {
  start: 11520,
  length: 38,
  convRule: rule182
}, {
  start: 11559,
  length: 1,
  convRule: rule182
}, {
  start: 11565,
  length: 1,
  convRule: rule182
}, {
  start: 11568,
  length: 56,
  convRule: rule14
}, {
  start: 11631,
  length: 1,
  convRule: rule91
}, {
  start: 11632,
  length: 1,
  convRule: rule2
}, {
  start: 11647,
  length: 1,
  convRule: rule92
}, {
  start: 11648,
  length: 23,
  convRule: rule14
}, {
  start: 11680,
  length: 7,
  convRule: rule14
}, {
  start: 11688,
  length: 7,
  convRule: rule14
}, {
  start: 11696,
  length: 7,
  convRule: rule14
}, {
  start: 11704,
  length: 7,
  convRule: rule14
}, {
  start: 11712,
  length: 7,
  convRule: rule14
}, {
  start: 11720,
  length: 7,
  convRule: rule14
}, {
  start: 11728,
  length: 7,
  convRule: rule14
}, {
  start: 11736,
  length: 7,
  convRule: rule14
}, {
  start: 11744,
  length: 32,
  convRule: rule92
}, {
  start: 11776,
  length: 2,
  convRule: rule2
}, {
  start: 11778,
  length: 1,
  convRule: rule15
}, {
  start: 11779,
  length: 1,
  convRule: rule19
}, {
  start: 11780,
  length: 1,
  convRule: rule15
}, {
  start: 11781,
  length: 1,
  convRule: rule19
}, {
  start: 11782,
  length: 3,
  convRule: rule2
}, {
  start: 11785,
  length: 1,
  convRule: rule15
}, {
  start: 11786,
  length: 1,
  convRule: rule19
}, {
  start: 11787,
  length: 1,
  convRule: rule2
}, {
  start: 11788,
  length: 1,
  convRule: rule15
}, {
  start: 11789,
  length: 1,
  convRule: rule19
}, {
  start: 11790,
  length: 9,
  convRule: rule2
}, {
  start: 11799,
  length: 1,
  convRule: rule7
}, {
  start: 11800,
  length: 2,
  convRule: rule2
}, {
  start: 11802,
  length: 1,
  convRule: rule7
}, {
  start: 11803,
  length: 1,
  convRule: rule2
}, {
  start: 11804,
  length: 1,
  convRule: rule15
}, {
  start: 11805,
  length: 1,
  convRule: rule19
}, {
  start: 11806,
  length: 2,
  convRule: rule2
}, {
  start: 11808,
  length: 1,
  convRule: rule15
}, {
  start: 11809,
  length: 1,
  convRule: rule19
}, {
  start: 11810,
  length: 1,
  convRule: rule4
}, {
  start: 11811,
  length: 1,
  convRule: rule5
}, {
  start: 11812,
  length: 1,
  convRule: rule4
}, {
  start: 11813,
  length: 1,
  convRule: rule5
}, {
  start: 11814,
  length: 1,
  convRule: rule4
}, {
  start: 11815,
  length: 1,
  convRule: rule5
}, {
  start: 11816,
  length: 1,
  convRule: rule4
}, {
  start: 11817,
  length: 1,
  convRule: rule5
}, {
  start: 11818,
  length: 5,
  convRule: rule2
}, {
  start: 11823,
  length: 1,
  convRule: rule91
}, {
  start: 11824,
  length: 10,
  convRule: rule2
}, {
  start: 11834,
  length: 2,
  convRule: rule7
}, {
  start: 11836,
  length: 4,
  convRule: rule2
}, {
  start: 11840,
  length: 1,
  convRule: rule7
}, {
  start: 11841,
  length: 1,
  convRule: rule2
}, {
  start: 11842,
  length: 1,
  convRule: rule4
}, {
  start: 11843,
  length: 13,
  convRule: rule2
}, {
  start: 11856,
  length: 2,
  convRule: rule13
}, {
  start: 11858,
  length: 1,
  convRule: rule2
}, {
  start: 11904,
  length: 26,
  convRule: rule13
}, {
  start: 11931,
  length: 89,
  convRule: rule13
}, {
  start: 12032,
  length: 214,
  convRule: rule13
}, {
  start: 12272,
  length: 12,
  convRule: rule13
}, {
  start: 12288,
  length: 1,
  convRule: rule1
}, {
  start: 12289,
  length: 3,
  convRule: rule2
}, {
  start: 12292,
  length: 1,
  convRule: rule13
}, {
  start: 12293,
  length: 1,
  convRule: rule91
}, {
  start: 12294,
  length: 1,
  convRule: rule14
}, {
  start: 12295,
  length: 1,
  convRule: rule128
}, {
  start: 12296,
  length: 1,
  convRule: rule4
}, {
  start: 12297,
  length: 1,
  convRule: rule5
}, {
  start: 12298,
  length: 1,
  convRule: rule4
}, {
  start: 12299,
  length: 1,
  convRule: rule5
}, {
  start: 12300,
  length: 1,
  convRule: rule4
}, {
  start: 12301,
  length: 1,
  convRule: rule5
}, {
  start: 12302,
  length: 1,
  convRule: rule4
}, {
  start: 12303,
  length: 1,
  convRule: rule5
}, {
  start: 12304,
  length: 1,
  convRule: rule4
}, {
  start: 12305,
  length: 1,
  convRule: rule5
}, {
  start: 12306,
  length: 2,
  convRule: rule13
}, {
  start: 12308,
  length: 1,
  convRule: rule4
}, {
  start: 12309,
  length: 1,
  convRule: rule5
}, {
  start: 12310,
  length: 1,
  convRule: rule4
}, {
  start: 12311,
  length: 1,
  convRule: rule5
}, {
  start: 12312,
  length: 1,
  convRule: rule4
}, {
  start: 12313,
  length: 1,
  convRule: rule5
}, {
  start: 12314,
  length: 1,
  convRule: rule4
}, {
  start: 12315,
  length: 1,
  convRule: rule5
}, {
  start: 12316,
  length: 1,
  convRule: rule7
}, {
  start: 12317,
  length: 1,
  convRule: rule4
}, {
  start: 12318,
  length: 2,
  convRule: rule5
}, {
  start: 12320,
  length: 1,
  convRule: rule13
}, {
  start: 12321,
  length: 9,
  convRule: rule128
}, {
  start: 12330,
  length: 4,
  convRule: rule92
}, {
  start: 12334,
  length: 2,
  convRule: rule124
}, {
  start: 12336,
  length: 1,
  convRule: rule7
}, {
  start: 12337,
  length: 5,
  convRule: rule91
}, {
  start: 12342,
  length: 2,
  convRule: rule13
}, {
  start: 12344,
  length: 3,
  convRule: rule128
}, {
  start: 12347,
  length: 1,
  convRule: rule91
}, {
  start: 12348,
  length: 1,
  convRule: rule14
}, {
  start: 12349,
  length: 1,
  convRule: rule2
}, {
  start: 12350,
  length: 2,
  convRule: rule13
}, {
  start: 12353,
  length: 86,
  convRule: rule14
}, {
  start: 12441,
  length: 2,
  convRule: rule92
}, {
  start: 12443,
  length: 2,
  convRule: rule10
}, {
  start: 12445,
  length: 2,
  convRule: rule91
}, {
  start: 12447,
  length: 1,
  convRule: rule14
}, {
  start: 12448,
  length: 1,
  convRule: rule7
}, {
  start: 12449,
  length: 90,
  convRule: rule14
}, {
  start: 12539,
  length: 1,
  convRule: rule2
}, {
  start: 12540,
  length: 3,
  convRule: rule91
}, {
  start: 12543,
  length: 1,
  convRule: rule14
}, {
  start: 12549,
  length: 43,
  convRule: rule14
}, {
  start: 12593,
  length: 94,
  convRule: rule14
}, {
  start: 12688,
  length: 2,
  convRule: rule13
}, {
  start: 12690,
  length: 4,
  convRule: rule17
}, {
  start: 12694,
  length: 10,
  convRule: rule13
}, {
  start: 12704,
  length: 32,
  convRule: rule14
}, {
  start: 12736,
  length: 36,
  convRule: rule13
}, {
  start: 12784,
  length: 16,
  convRule: rule14
}, {
  start: 12800,
  length: 31,
  convRule: rule13
}, {
  start: 12832,
  length: 10,
  convRule: rule17
}, {
  start: 12842,
  length: 30,
  convRule: rule13
}, {
  start: 12872,
  length: 8,
  convRule: rule17
}, {
  start: 12880,
  length: 1,
  convRule: rule13
}, {
  start: 12881,
  length: 15,
  convRule: rule17
}, {
  start: 12896,
  length: 32,
  convRule: rule13
}, {
  start: 12928,
  length: 10,
  convRule: rule17
}, {
  start: 12938,
  length: 39,
  convRule: rule13
}, {
  start: 12977,
  length: 15,
  convRule: rule17
}, {
  start: 12992,
  length: 320,
  convRule: rule13
}, {
  start: 13312,
  length: 6592,
  convRule: rule14
}, {
  start: 19904,
  length: 64,
  convRule: rule13
}, {
  start: 19968,
  length: 20989,
  convRule: rule14
}, {
  start: 40960,
  length: 21,
  convRule: rule14
}, {
  start: 40981,
  length: 1,
  convRule: rule91
}, {
  start: 40982,
  length: 1143,
  convRule: rule14
}, {
  start: 42128,
  length: 55,
  convRule: rule13
}, {
  start: 42192,
  length: 40,
  convRule: rule14
}, {
  start: 42232,
  length: 6,
  convRule: rule91
}, {
  start: 42238,
  length: 2,
  convRule: rule2
}, {
  start: 42240,
  length: 268,
  convRule: rule14
}, {
  start: 42508,
  length: 1,
  convRule: rule91
}, {
  start: 42509,
  length: 3,
  convRule: rule2
}, {
  start: 42512,
  length: 16,
  convRule: rule14
}, {
  start: 42528,
  length: 10,
  convRule: rule8
}, {
  start: 42538,
  length: 2,
  convRule: rule14
}, {
  start: 42560,
  length: 1,
  convRule: rule22
}, {
  start: 42561,
  length: 1,
  convRule: rule23
}, {
  start: 42562,
  length: 1,
  convRule: rule22
}, {
  start: 42563,
  length: 1,
  convRule: rule23
}, {
  start: 42564,
  length: 1,
  convRule: rule22
}, {
  start: 42565,
  length: 1,
  convRule: rule23
}, {
  start: 42566,
  length: 1,
  convRule: rule22
}, {
  start: 42567,
  length: 1,
  convRule: rule23
}, {
  start: 42568,
  length: 1,
  convRule: rule22
}, {
  start: 42569,
  length: 1,
  convRule: rule23
}, {
  start: 42570,
  length: 1,
  convRule: rule22
}, {
  start: 42571,
  length: 1,
  convRule: rule23
}, {
  start: 42572,
  length: 1,
  convRule: rule22
}, {
  start: 42573,
  length: 1,
  convRule: rule23
}, {
  start: 42574,
  length: 1,
  convRule: rule22
}, {
  start: 42575,
  length: 1,
  convRule: rule23
}, {
  start: 42576,
  length: 1,
  convRule: rule22
}, {
  start: 42577,
  length: 1,
  convRule: rule23
}, {
  start: 42578,
  length: 1,
  convRule: rule22
}, {
  start: 42579,
  length: 1,
  convRule: rule23
}, {
  start: 42580,
  length: 1,
  convRule: rule22
}, {
  start: 42581,
  length: 1,
  convRule: rule23
}, {
  start: 42582,
  length: 1,
  convRule: rule22
}, {
  start: 42583,
  length: 1,
  convRule: rule23
}, {
  start: 42584,
  length: 1,
  convRule: rule22
}, {
  start: 42585,
  length: 1,
  convRule: rule23
}, {
  start: 42586,
  length: 1,
  convRule: rule22
}, {
  start: 42587,
  length: 1,
  convRule: rule23
}, {
  start: 42588,
  length: 1,
  convRule: rule22
}, {
  start: 42589,
  length: 1,
  convRule: rule23
}, {
  start: 42590,
  length: 1,
  convRule: rule22
}, {
  start: 42591,
  length: 1,
  convRule: rule23
}, {
  start: 42592,
  length: 1,
  convRule: rule22
}, {
  start: 42593,
  length: 1,
  convRule: rule23
}, {
  start: 42594,
  length: 1,
  convRule: rule22
}, {
  start: 42595,
  length: 1,
  convRule: rule23
}, {
  start: 42596,
  length: 1,
  convRule: rule22
}, {
  start: 42597,
  length: 1,
  convRule: rule23
}, {
  start: 42598,
  length: 1,
  convRule: rule22
}, {
  start: 42599,
  length: 1,
  convRule: rule23
}, {
  start: 42600,
  length: 1,
  convRule: rule22
}, {
  start: 42601,
  length: 1,
  convRule: rule23
}, {
  start: 42602,
  length: 1,
  convRule: rule22
}, {
  start: 42603,
  length: 1,
  convRule: rule23
}, {
  start: 42604,
  length: 1,
  convRule: rule22
}, {
  start: 42605,
  length: 1,
  convRule: rule23
}, {
  start: 42606,
  length: 1,
  convRule: rule14
}, {
  start: 42607,
  length: 1,
  convRule: rule92
}, {
  start: 42608,
  length: 3,
  convRule: rule119
}, {
  start: 42611,
  length: 1,
  convRule: rule2
}, {
  start: 42612,
  length: 10,
  convRule: rule92
}, {
  start: 42622,
  length: 1,
  convRule: rule2
}, {
  start: 42623,
  length: 1,
  convRule: rule91
}, {
  start: 42624,
  length: 1,
  convRule: rule22
}, {
  start: 42625,
  length: 1,
  convRule: rule23
}, {
  start: 42626,
  length: 1,
  convRule: rule22
}, {
  start: 42627,
  length: 1,
  convRule: rule23
}, {
  start: 42628,
  length: 1,
  convRule: rule22
}, {
  start: 42629,
  length: 1,
  convRule: rule23
}, {
  start: 42630,
  length: 1,
  convRule: rule22
}, {
  start: 42631,
  length: 1,
  convRule: rule23
}, {
  start: 42632,
  length: 1,
  convRule: rule22
}, {
  start: 42633,
  length: 1,
  convRule: rule23
}, {
  start: 42634,
  length: 1,
  convRule: rule22
}, {
  start: 42635,
  length: 1,
  convRule: rule23
}, {
  start: 42636,
  length: 1,
  convRule: rule22
}, {
  start: 42637,
  length: 1,
  convRule: rule23
}, {
  start: 42638,
  length: 1,
  convRule: rule22
}, {
  start: 42639,
  length: 1,
  convRule: rule23
}, {
  start: 42640,
  length: 1,
  convRule: rule22
}, {
  start: 42641,
  length: 1,
  convRule: rule23
}, {
  start: 42642,
  length: 1,
  convRule: rule22
}, {
  start: 42643,
  length: 1,
  convRule: rule23
}, {
  start: 42644,
  length: 1,
  convRule: rule22
}, {
  start: 42645,
  length: 1,
  convRule: rule23
}, {
  start: 42646,
  length: 1,
  convRule: rule22
}, {
  start: 42647,
  length: 1,
  convRule: rule23
}, {
  start: 42648,
  length: 1,
  convRule: rule22
}, {
  start: 42649,
  length: 1,
  convRule: rule23
}, {
  start: 42650,
  length: 1,
  convRule: rule22
}, {
  start: 42651,
  length: 1,
  convRule: rule23
}, {
  start: 42652,
  length: 2,
  convRule: rule91
}, {
  start: 42654,
  length: 2,
  convRule: rule92
}, {
  start: 42656,
  length: 70,
  convRule: rule14
}, {
  start: 42726,
  length: 10,
  convRule: rule128
}, {
  start: 42736,
  length: 2,
  convRule: rule92
}, {
  start: 42738,
  length: 6,
  convRule: rule2
}, {
  start: 42752,
  length: 23,
  convRule: rule10
}, {
  start: 42775,
  length: 9,
  convRule: rule91
}, {
  start: 42784,
  length: 2,
  convRule: rule10
}, {
  start: 42786,
  length: 1,
  convRule: rule22
}, {
  start: 42787,
  length: 1,
  convRule: rule23
}, {
  start: 42788,
  length: 1,
  convRule: rule22
}, {
  start: 42789,
  length: 1,
  convRule: rule23
}, {
  start: 42790,
  length: 1,
  convRule: rule22
}, {
  start: 42791,
  length: 1,
  convRule: rule23
}, {
  start: 42792,
  length: 1,
  convRule: rule22
}, {
  start: 42793,
  length: 1,
  convRule: rule23
}, {
  start: 42794,
  length: 1,
  convRule: rule22
}, {
  start: 42795,
  length: 1,
  convRule: rule23
}, {
  start: 42796,
  length: 1,
  convRule: rule22
}, {
  start: 42797,
  length: 1,
  convRule: rule23
}, {
  start: 42798,
  length: 1,
  convRule: rule22
}, {
  start: 42799,
  length: 1,
  convRule: rule23
}, {
  start: 42800,
  length: 2,
  convRule: rule20
}, {
  start: 42802,
  length: 1,
  convRule: rule22
}, {
  start: 42803,
  length: 1,
  convRule: rule23
}, {
  start: 42804,
  length: 1,
  convRule: rule22
}, {
  start: 42805,
  length: 1,
  convRule: rule23
}, {
  start: 42806,
  length: 1,
  convRule: rule22
}, {
  start: 42807,
  length: 1,
  convRule: rule23
}, {
  start: 42808,
  length: 1,
  convRule: rule22
}, {
  start: 42809,
  length: 1,
  convRule: rule23
}, {
  start: 42810,
  length: 1,
  convRule: rule22
}, {
  start: 42811,
  length: 1,
  convRule: rule23
}, {
  start: 42812,
  length: 1,
  convRule: rule22
}, {
  start: 42813,
  length: 1,
  convRule: rule23
}, {
  start: 42814,
  length: 1,
  convRule: rule22
}, {
  start: 42815,
  length: 1,
  convRule: rule23
}, {
  start: 42816,
  length: 1,
  convRule: rule22
}, {
  start: 42817,
  length: 1,
  convRule: rule23
}, {
  start: 42818,
  length: 1,
  convRule: rule22
}, {
  start: 42819,
  length: 1,
  convRule: rule23
}, {
  start: 42820,
  length: 1,
  convRule: rule22
}, {
  start: 42821,
  length: 1,
  convRule: rule23
}, {
  start: 42822,
  length: 1,
  convRule: rule22
}, {
  start: 42823,
  length: 1,
  convRule: rule23
}, {
  start: 42824,
  length: 1,
  convRule: rule22
}, {
  start: 42825,
  length: 1,
  convRule: rule23
}, {
  start: 42826,
  length: 1,
  convRule: rule22
}, {
  start: 42827,
  length: 1,
  convRule: rule23
}, {
  start: 42828,
  length: 1,
  convRule: rule22
}, {
  start: 42829,
  length: 1,
  convRule: rule23
}, {
  start: 42830,
  length: 1,
  convRule: rule22
}, {
  start: 42831,
  length: 1,
  convRule: rule23
}, {
  start: 42832,
  length: 1,
  convRule: rule22
}, {
  start: 42833,
  length: 1,
  convRule: rule23
}, {
  start: 42834,
  length: 1,
  convRule: rule22
}, {
  start: 42835,
  length: 1,
  convRule: rule23
}, {
  start: 42836,
  length: 1,
  convRule: rule22
}, {
  start: 42837,
  length: 1,
  convRule: rule23
}, {
  start: 42838,
  length: 1,
  convRule: rule22
}, {
  start: 42839,
  length: 1,
  convRule: rule23
}, {
  start: 42840,
  length: 1,
  convRule: rule22
}, {
  start: 42841,
  length: 1,
  convRule: rule23
}, {
  start: 42842,
  length: 1,
  convRule: rule22
}, {
  start: 42843,
  length: 1,
  convRule: rule23
}, {
  start: 42844,
  length: 1,
  convRule: rule22
}, {
  start: 42845,
  length: 1,
  convRule: rule23
}, {
  start: 42846,
  length: 1,
  convRule: rule22
}, {
  start: 42847,
  length: 1,
  convRule: rule23
}, {
  start: 42848,
  length: 1,
  convRule: rule22
}, {
  start: 42849,
  length: 1,
  convRule: rule23
}, {
  start: 42850,
  length: 1,
  convRule: rule22
}, {
  start: 42851,
  length: 1,
  convRule: rule23
}, {
  start: 42852,
  length: 1,
  convRule: rule22
}, {
  start: 42853,
  length: 1,
  convRule: rule23
}, {
  start: 42854,
  length: 1,
  convRule: rule22
}, {
  start: 42855,
  length: 1,
  convRule: rule23
}, {
  start: 42856,
  length: 1,
  convRule: rule22
}, {
  start: 42857,
  length: 1,
  convRule: rule23
}, {
  start: 42858,
  length: 1,
  convRule: rule22
}, {
  start: 42859,
  length: 1,
  convRule: rule23
}, {
  start: 42860,
  length: 1,
  convRule: rule22
}, {
  start: 42861,
  length: 1,
  convRule: rule23
}, {
  start: 42862,
  length: 1,
  convRule: rule22
}, {
  start: 42863,
  length: 1,
  convRule: rule23
}, {
  start: 42864,
  length: 1,
  convRule: rule91
}, {
  start: 42865,
  length: 8,
  convRule: rule20
}, {
  start: 42873,
  length: 1,
  convRule: rule22
}, {
  start: 42874,
  length: 1,
  convRule: rule23
}, {
  start: 42875,
  length: 1,
  convRule: rule22
}, {
  start: 42876,
  length: 1,
  convRule: rule23
}, {
  start: 42877,
  length: 1,
  convRule: rule183
}, {
  start: 42878,
  length: 1,
  convRule: rule22
}, {
  start: 42879,
  length: 1,
  convRule: rule23
}, {
  start: 42880,
  length: 1,
  convRule: rule22
}, {
  start: 42881,
  length: 1,
  convRule: rule23
}, {
  start: 42882,
  length: 1,
  convRule: rule22
}, {
  start: 42883,
  length: 1,
  convRule: rule23
}, {
  start: 42884,
  length: 1,
  convRule: rule22
}, {
  start: 42885,
  length: 1,
  convRule: rule23
}, {
  start: 42886,
  length: 1,
  convRule: rule22
}, {
  start: 42887,
  length: 1,
  convRule: rule23
}, {
  start: 42888,
  length: 1,
  convRule: rule91
}, {
  start: 42889,
  length: 2,
  convRule: rule10
}, {
  start: 42891,
  length: 1,
  convRule: rule22
}, {
  start: 42892,
  length: 1,
  convRule: rule23
}, {
  start: 42893,
  length: 1,
  convRule: rule184
}, {
  start: 42894,
  length: 1,
  convRule: rule20
}, {
  start: 42895,
  length: 1,
  convRule: rule14
}, {
  start: 42896,
  length: 1,
  convRule: rule22
}, {
  start: 42897,
  length: 1,
  convRule: rule23
}, {
  start: 42898,
  length: 1,
  convRule: rule22
}, {
  start: 42899,
  length: 1,
  convRule: rule23
}, {
  start: 42900,
  length: 1,
  convRule: rule185
}, {
  start: 42901,
  length: 1,
  convRule: rule20
}, {
  start: 42902,
  length: 1,
  convRule: rule22
}, {
  start: 42903,
  length: 1,
  convRule: rule23
}, {
  start: 42904,
  length: 1,
  convRule: rule22
}, {
  start: 42905,
  length: 1,
  convRule: rule23
}, {
  start: 42906,
  length: 1,
  convRule: rule22
}, {
  start: 42907,
  length: 1,
  convRule: rule23
}, {
  start: 42908,
  length: 1,
  convRule: rule22
}, {
  start: 42909,
  length: 1,
  convRule: rule23
}, {
  start: 42910,
  length: 1,
  convRule: rule22
}, {
  start: 42911,
  length: 1,
  convRule: rule23
}, {
  start: 42912,
  length: 1,
  convRule: rule22
}, {
  start: 42913,
  length: 1,
  convRule: rule23
}, {
  start: 42914,
  length: 1,
  convRule: rule22
}, {
  start: 42915,
  length: 1,
  convRule: rule23
}, {
  start: 42916,
  length: 1,
  convRule: rule22
}, {
  start: 42917,
  length: 1,
  convRule: rule23
}, {
  start: 42918,
  length: 1,
  convRule: rule22
}, {
  start: 42919,
  length: 1,
  convRule: rule23
}, {
  start: 42920,
  length: 1,
  convRule: rule22
}, {
  start: 42921,
  length: 1,
  convRule: rule23
}, {
  start: 42922,
  length: 1,
  convRule: rule186
}, {
  start: 42923,
  length: 1,
  convRule: rule187
}, {
  start: 42924,
  length: 1,
  convRule: rule188
}, {
  start: 42925,
  length: 1,
  convRule: rule189
}, {
  start: 42926,
  length: 1,
  convRule: rule186
}, {
  start: 42927,
  length: 1,
  convRule: rule20
}, {
  start: 42928,
  length: 1,
  convRule: rule190
}, {
  start: 42929,
  length: 1,
  convRule: rule191
}, {
  start: 42930,
  length: 1,
  convRule: rule192
}, {
  start: 42931,
  length: 1,
  convRule: rule193
}, {
  start: 42932,
  length: 1,
  convRule: rule22
}, {
  start: 42933,
  length: 1,
  convRule: rule23
}, {
  start: 42934,
  length: 1,
  convRule: rule22
}, {
  start: 42935,
  length: 1,
  convRule: rule23
}, {
  start: 42936,
  length: 1,
  convRule: rule22
}, {
  start: 42937,
  length: 1,
  convRule: rule23
}, {
  start: 42938,
  length: 1,
  convRule: rule22
}, {
  start: 42939,
  length: 1,
  convRule: rule23
}, {
  start: 42940,
  length: 1,
  convRule: rule22
}, {
  start: 42941,
  length: 1,
  convRule: rule23
}, {
  start: 42942,
  length: 1,
  convRule: rule22
}, {
  start: 42943,
  length: 1,
  convRule: rule23
}, {
  start: 42946,
  length: 1,
  convRule: rule22
}, {
  start: 42947,
  length: 1,
  convRule: rule23
}, {
  start: 42948,
  length: 1,
  convRule: rule194
}, {
  start: 42949,
  length: 1,
  convRule: rule195
}, {
  start: 42950,
  length: 1,
  convRule: rule196
}, {
  start: 42951,
  length: 1,
  convRule: rule22
}, {
  start: 42952,
  length: 1,
  convRule: rule23
}, {
  start: 42953,
  length: 1,
  convRule: rule22
}, {
  start: 42954,
  length: 1,
  convRule: rule23
}, {
  start: 42997,
  length: 1,
  convRule: rule22
}, {
  start: 42998,
  length: 1,
  convRule: rule23
}, {
  start: 42999,
  length: 1,
  convRule: rule14
}, {
  start: 43e3,
  length: 2,
  convRule: rule91
}, {
  start: 43002,
  length: 1,
  convRule: rule20
}, {
  start: 43003,
  length: 7,
  convRule: rule14
}, {
  start: 43010,
  length: 1,
  convRule: rule92
}, {
  start: 43011,
  length: 3,
  convRule: rule14
}, {
  start: 43014,
  length: 1,
  convRule: rule92
}, {
  start: 43015,
  length: 4,
  convRule: rule14
}, {
  start: 43019,
  length: 1,
  convRule: rule92
}, {
  start: 43020,
  length: 23,
  convRule: rule14
}, {
  start: 43043,
  length: 2,
  convRule: rule124
}, {
  start: 43045,
  length: 2,
  convRule: rule92
}, {
  start: 43047,
  length: 1,
  convRule: rule124
}, {
  start: 43048,
  length: 4,
  convRule: rule13
}, {
  start: 43052,
  length: 1,
  convRule: rule92
}, {
  start: 43056,
  length: 6,
  convRule: rule17
}, {
  start: 43062,
  length: 2,
  convRule: rule13
}, {
  start: 43064,
  length: 1,
  convRule: rule3
}, {
  start: 43065,
  length: 1,
  convRule: rule13
}, {
  start: 43072,
  length: 52,
  convRule: rule14
}, {
  start: 43124,
  length: 4,
  convRule: rule2
}, {
  start: 43136,
  length: 2,
  convRule: rule124
}, {
  start: 43138,
  length: 50,
  convRule: rule14
}, {
  start: 43188,
  length: 16,
  convRule: rule124
}, {
  start: 43204,
  length: 2,
  convRule: rule92
}, {
  start: 43214,
  length: 2,
  convRule: rule2
}, {
  start: 43216,
  length: 10,
  convRule: rule8
}, {
  start: 43232,
  length: 18,
  convRule: rule92
}, {
  start: 43250,
  length: 6,
  convRule: rule14
}, {
  start: 43256,
  length: 3,
  convRule: rule2
}, {
  start: 43259,
  length: 1,
  convRule: rule14
}, {
  start: 43260,
  length: 1,
  convRule: rule2
}, {
  start: 43261,
  length: 2,
  convRule: rule14
}, {
  start: 43263,
  length: 1,
  convRule: rule92
}, {
  start: 43264,
  length: 10,
  convRule: rule8
}, {
  start: 43274,
  length: 28,
  convRule: rule14
}, {
  start: 43302,
  length: 8,
  convRule: rule92
}, {
  start: 43310,
  length: 2,
  convRule: rule2
}, {
  start: 43312,
  length: 23,
  convRule: rule14
}, {
  start: 43335,
  length: 11,
  convRule: rule92
}, {
  start: 43346,
  length: 2,
  convRule: rule124
}, {
  start: 43359,
  length: 1,
  convRule: rule2
}, {
  start: 43360,
  length: 29,
  convRule: rule14
}, {
  start: 43392,
  length: 3,
  convRule: rule92
}, {
  start: 43395,
  length: 1,
  convRule: rule124
}, {
  start: 43396,
  length: 47,
  convRule: rule14
}, {
  start: 43443,
  length: 1,
  convRule: rule92
}, {
  start: 43444,
  length: 2,
  convRule: rule124
}, {
  start: 43446,
  length: 4,
  convRule: rule92
}, {
  start: 43450,
  length: 2,
  convRule: rule124
}, {
  start: 43452,
  length: 2,
  convRule: rule92
}, {
  start: 43454,
  length: 3,
  convRule: rule124
}, {
  start: 43457,
  length: 13,
  convRule: rule2
}, {
  start: 43471,
  length: 1,
  convRule: rule91
}, {
  start: 43472,
  length: 10,
  convRule: rule8
}, {
  start: 43486,
  length: 2,
  convRule: rule2
}, {
  start: 43488,
  length: 5,
  convRule: rule14
}, {
  start: 43493,
  length: 1,
  convRule: rule92
}, {
  start: 43494,
  length: 1,
  convRule: rule91
}, {
  start: 43495,
  length: 9,
  convRule: rule14
}, {
  start: 43504,
  length: 10,
  convRule: rule8
}, {
  start: 43514,
  length: 5,
  convRule: rule14
}, {
  start: 43520,
  length: 41,
  convRule: rule14
}, {
  start: 43561,
  length: 6,
  convRule: rule92
}, {
  start: 43567,
  length: 2,
  convRule: rule124
}, {
  start: 43569,
  length: 2,
  convRule: rule92
}, {
  start: 43571,
  length: 2,
  convRule: rule124
}, {
  start: 43573,
  length: 2,
  convRule: rule92
}, {
  start: 43584,
  length: 3,
  convRule: rule14
}, {
  start: 43587,
  length: 1,
  convRule: rule92
}, {
  start: 43588,
  length: 8,
  convRule: rule14
}, {
  start: 43596,
  length: 1,
  convRule: rule92
}, {
  start: 43597,
  length: 1,
  convRule: rule124
}, {
  start: 43600,
  length: 10,
  convRule: rule8
}, {
  start: 43612,
  length: 4,
  convRule: rule2
}, {
  start: 43616,
  length: 16,
  convRule: rule14
}, {
  start: 43632,
  length: 1,
  convRule: rule91
}, {
  start: 43633,
  length: 6,
  convRule: rule14
}, {
  start: 43639,
  length: 3,
  convRule: rule13
}, {
  start: 43642,
  length: 1,
  convRule: rule14
}, {
  start: 43643,
  length: 1,
  convRule: rule124
}, {
  start: 43644,
  length: 1,
  convRule: rule92
}, {
  start: 43645,
  length: 1,
  convRule: rule124
}, {
  start: 43646,
  length: 50,
  convRule: rule14
}, {
  start: 43696,
  length: 1,
  convRule: rule92
}, {
  start: 43697,
  length: 1,
  convRule: rule14
}, {
  start: 43698,
  length: 3,
  convRule: rule92
}, {
  start: 43701,
  length: 2,
  convRule: rule14
}, {
  start: 43703,
  length: 2,
  convRule: rule92
}, {
  start: 43705,
  length: 5,
  convRule: rule14
}, {
  start: 43710,
  length: 2,
  convRule: rule92
}, {
  start: 43712,
  length: 1,
  convRule: rule14
}, {
  start: 43713,
  length: 1,
  convRule: rule92
}, {
  start: 43714,
  length: 1,
  convRule: rule14
}, {
  start: 43739,
  length: 2,
  convRule: rule14
}, {
  start: 43741,
  length: 1,
  convRule: rule91
}, {
  start: 43742,
  length: 2,
  convRule: rule2
}, {
  start: 43744,
  length: 11,
  convRule: rule14
}, {
  start: 43755,
  length: 1,
  convRule: rule124
}, {
  start: 43756,
  length: 2,
  convRule: rule92
}, {
  start: 43758,
  length: 2,
  convRule: rule124
}, {
  start: 43760,
  length: 2,
  convRule: rule2
}, {
  start: 43762,
  length: 1,
  convRule: rule14
}, {
  start: 43763,
  length: 2,
  convRule: rule91
}, {
  start: 43765,
  length: 1,
  convRule: rule124
}, {
  start: 43766,
  length: 1,
  convRule: rule92
}, {
  start: 43777,
  length: 6,
  convRule: rule14
}, {
  start: 43785,
  length: 6,
  convRule: rule14
}, {
  start: 43793,
  length: 6,
  convRule: rule14
}, {
  start: 43808,
  length: 7,
  convRule: rule14
}, {
  start: 43816,
  length: 7,
  convRule: rule14
}, {
  start: 43824,
  length: 35,
  convRule: rule20
}, {
  start: 43859,
  length: 1,
  convRule: rule197
}, {
  start: 43860,
  length: 7,
  convRule: rule20
}, {
  start: 43867,
  length: 1,
  convRule: rule10
}, {
  start: 43868,
  length: 4,
  convRule: rule91
}, {
  start: 43872,
  length: 9,
  convRule: rule20
}, {
  start: 43881,
  length: 1,
  convRule: rule91
}, {
  start: 43882,
  length: 2,
  convRule: rule10
}, {
  start: 43888,
  length: 80,
  convRule: rule198
}, {
  start: 43968,
  length: 35,
  convRule: rule14
}, {
  start: 44003,
  length: 2,
  convRule: rule124
}, {
  start: 44005,
  length: 1,
  convRule: rule92
}, {
  start: 44006,
  length: 2,
  convRule: rule124
}, {
  start: 44008,
  length: 1,
  convRule: rule92
}, {
  start: 44009,
  length: 2,
  convRule: rule124
}, {
  start: 44011,
  length: 1,
  convRule: rule2
}, {
  start: 44012,
  length: 1,
  convRule: rule124
}, {
  start: 44013,
  length: 1,
  convRule: rule92
}, {
  start: 44016,
  length: 10,
  convRule: rule8
}, {
  start: 44032,
  length: 11172,
  convRule: rule14
}, {
  start: 55216,
  length: 23,
  convRule: rule14
}, {
  start: 55243,
  length: 49,
  convRule: rule14
}, {
  start: 55296,
  length: 896,
  convRule: rule199
}, {
  start: 56192,
  length: 128,
  convRule: rule199
}, {
  start: 56320,
  length: 1024,
  convRule: rule199
}, {
  start: 57344,
  length: 6400,
  convRule: rule200
}, {
  start: 63744,
  length: 366,
  convRule: rule14
}, {
  start: 64112,
  length: 106,
  convRule: rule14
}, {
  start: 64256,
  length: 7,
  convRule: rule20
}, {
  start: 64275,
  length: 5,
  convRule: rule20
}, {
  start: 64285,
  length: 1,
  convRule: rule14
}, {
  start: 64286,
  length: 1,
  convRule: rule92
}, {
  start: 64287,
  length: 10,
  convRule: rule14
}, {
  start: 64297,
  length: 1,
  convRule: rule6
}, {
  start: 64298,
  length: 13,
  convRule: rule14
}, {
  start: 64312,
  length: 5,
  convRule: rule14
}, {
  start: 64318,
  length: 1,
  convRule: rule14
}, {
  start: 64320,
  length: 2,
  convRule: rule14
}, {
  start: 64323,
  length: 2,
  convRule: rule14
}, {
  start: 64326,
  length: 108,
  convRule: rule14
}, {
  start: 64434,
  length: 16,
  convRule: rule10
}, {
  start: 64467,
  length: 363,
  convRule: rule14
}, {
  start: 64830,
  length: 1,
  convRule: rule5
}, {
  start: 64831,
  length: 1,
  convRule: rule4
}, {
  start: 64848,
  length: 64,
  convRule: rule14
}, {
  start: 64914,
  length: 54,
  convRule: rule14
}, {
  start: 65008,
  length: 12,
  convRule: rule14
}, {
  start: 65020,
  length: 1,
  convRule: rule3
}, {
  start: 65021,
  length: 1,
  convRule: rule13
}, {
  start: 65024,
  length: 16,
  convRule: rule92
}, {
  start: 65040,
  length: 7,
  convRule: rule2
}, {
  start: 65047,
  length: 1,
  convRule: rule4
}, {
  start: 65048,
  length: 1,
  convRule: rule5
}, {
  start: 65049,
  length: 1,
  convRule: rule2
}, {
  start: 65056,
  length: 16,
  convRule: rule92
}, {
  start: 65072,
  length: 1,
  convRule: rule2
}, {
  start: 65073,
  length: 2,
  convRule: rule7
}, {
  start: 65075,
  length: 2,
  convRule: rule11
}, {
  start: 65077,
  length: 1,
  convRule: rule4
}, {
  start: 65078,
  length: 1,
  convRule: rule5
}, {
  start: 65079,
  length: 1,
  convRule: rule4
}, {
  start: 65080,
  length: 1,
  convRule: rule5
}, {
  start: 65081,
  length: 1,
  convRule: rule4
}, {
  start: 65082,
  length: 1,
  convRule: rule5
}, {
  start: 65083,
  length: 1,
  convRule: rule4
}, {
  start: 65084,
  length: 1,
  convRule: rule5
}, {
  start: 65085,
  length: 1,
  convRule: rule4
}, {
  start: 65086,
  length: 1,
  convRule: rule5
}, {
  start: 65087,
  length: 1,
  convRule: rule4
}, {
  start: 65088,
  length: 1,
  convRule: rule5
}, {
  start: 65089,
  length: 1,
  convRule: rule4
}, {
  start: 65090,
  length: 1,
  convRule: rule5
}, {
  start: 65091,
  length: 1,
  convRule: rule4
}, {
  start: 65092,
  length: 1,
  convRule: rule5
}, {
  start: 65093,
  length: 2,
  convRule: rule2
}, {
  start: 65095,
  length: 1,
  convRule: rule4
}, {
  start: 65096,
  length: 1,
  convRule: rule5
}, {
  start: 65097,
  length: 4,
  convRule: rule2
}, {
  start: 65101,
  length: 3,
  convRule: rule11
}, {
  start: 65104,
  length: 3,
  convRule: rule2
}, {
  start: 65108,
  length: 4,
  convRule: rule2
}, {
  start: 65112,
  length: 1,
  convRule: rule7
}, {
  start: 65113,
  length: 1,
  convRule: rule4
}, {
  start: 65114,
  length: 1,
  convRule: rule5
}, {
  start: 65115,
  length: 1,
  convRule: rule4
}, {
  start: 65116,
  length: 1,
  convRule: rule5
}, {
  start: 65117,
  length: 1,
  convRule: rule4
}, {
  start: 65118,
  length: 1,
  convRule: rule5
}, {
  start: 65119,
  length: 3,
  convRule: rule2
}, {
  start: 65122,
  length: 1,
  convRule: rule6
}, {
  start: 65123,
  length: 1,
  convRule: rule7
}, {
  start: 65124,
  length: 3,
  convRule: rule6
}, {
  start: 65128,
  length: 1,
  convRule: rule2
}, {
  start: 65129,
  length: 1,
  convRule: rule3
}, {
  start: 65130,
  length: 2,
  convRule: rule2
}, {
  start: 65136,
  length: 5,
  convRule: rule14
}, {
  start: 65142,
  length: 135,
  convRule: rule14
}, {
  start: 65279,
  length: 1,
  convRule: rule16
}, {
  start: 65281,
  length: 3,
  convRule: rule2
}, {
  start: 65284,
  length: 1,
  convRule: rule3
}, {
  start: 65285,
  length: 3,
  convRule: rule2
}, {
  start: 65288,
  length: 1,
  convRule: rule4
}, {
  start: 65289,
  length: 1,
  convRule: rule5
}, {
  start: 65290,
  length: 1,
  convRule: rule2
}, {
  start: 65291,
  length: 1,
  convRule: rule6
}, {
  start: 65292,
  length: 1,
  convRule: rule2
}, {
  start: 65293,
  length: 1,
  convRule: rule7
}, {
  start: 65294,
  length: 2,
  convRule: rule2
}, {
  start: 65296,
  length: 10,
  convRule: rule8
}, {
  start: 65306,
  length: 2,
  convRule: rule2
}, {
  start: 65308,
  length: 3,
  convRule: rule6
}, {
  start: 65311,
  length: 2,
  convRule: rule2
}, {
  start: 65313,
  length: 26,
  convRule: rule9
}, {
  start: 65339,
  length: 1,
  convRule: rule4
}, {
  start: 65340,
  length: 1,
  convRule: rule2
}, {
  start: 65341,
  length: 1,
  convRule: rule5
}, {
  start: 65342,
  length: 1,
  convRule: rule10
}, {
  start: 65343,
  length: 1,
  convRule: rule11
}, {
  start: 65344,
  length: 1,
  convRule: rule10
}, {
  start: 65345,
  length: 26,
  convRule: rule12
}, {
  start: 65371,
  length: 1,
  convRule: rule4
}, {
  start: 65372,
  length: 1,
  convRule: rule6
}, {
  start: 65373,
  length: 1,
  convRule: rule5
}, {
  start: 65374,
  length: 1,
  convRule: rule6
}, {
  start: 65375,
  length: 1,
  convRule: rule4
}, {
  start: 65376,
  length: 1,
  convRule: rule5
}, {
  start: 65377,
  length: 1,
  convRule: rule2
}, {
  start: 65378,
  length: 1,
  convRule: rule4
}, {
  start: 65379,
  length: 1,
  convRule: rule5
}, {
  start: 65380,
  length: 2,
  convRule: rule2
}, {
  start: 65382,
  length: 10,
  convRule: rule14
}, {
  start: 65392,
  length: 1,
  convRule: rule91
}, {
  start: 65393,
  length: 45,
  convRule: rule14
}, {
  start: 65438,
  length: 2,
  convRule: rule91
}, {
  start: 65440,
  length: 31,
  convRule: rule14
}, {
  start: 65474,
  length: 6,
  convRule: rule14
}, {
  start: 65482,
  length: 6,
  convRule: rule14
}, {
  start: 65490,
  length: 6,
  convRule: rule14
}, {
  start: 65498,
  length: 3,
  convRule: rule14
}, {
  start: 65504,
  length: 2,
  convRule: rule3
}, {
  start: 65506,
  length: 1,
  convRule: rule6
}, {
  start: 65507,
  length: 1,
  convRule: rule10
}, {
  start: 65508,
  length: 1,
  convRule: rule13
}, {
  start: 65509,
  length: 2,
  convRule: rule3
}, {
  start: 65512,
  length: 1,
  convRule: rule13
}, {
  start: 65513,
  length: 4,
  convRule: rule6
}, {
  start: 65517,
  length: 2,
  convRule: rule13
}, {
  start: 65529,
  length: 3,
  convRule: rule16
}, {
  start: 65532,
  length: 2,
  convRule: rule13
}, {
  start: 65536,
  length: 12,
  convRule: rule14
}, {
  start: 65549,
  length: 26,
  convRule: rule14
}, {
  start: 65576,
  length: 19,
  convRule: rule14
}, {
  start: 65596,
  length: 2,
  convRule: rule14
}, {
  start: 65599,
  length: 15,
  convRule: rule14
}, {
  start: 65616,
  length: 14,
  convRule: rule14
}, {
  start: 65664,
  length: 123,
  convRule: rule14
}, {
  start: 65792,
  length: 3,
  convRule: rule2
}, {
  start: 65799,
  length: 45,
  convRule: rule17
}, {
  start: 65847,
  length: 9,
  convRule: rule13
}, {
  start: 65856,
  length: 53,
  convRule: rule128
}, {
  start: 65909,
  length: 4,
  convRule: rule17
}, {
  start: 65913,
  length: 17,
  convRule: rule13
}, {
  start: 65930,
  length: 2,
  convRule: rule17
}, {
  start: 65932,
  length: 3,
  convRule: rule13
}, {
  start: 65936,
  length: 13,
  convRule: rule13
}, {
  start: 65952,
  length: 1,
  convRule: rule13
}, {
  start: 66e3,
  length: 45,
  convRule: rule13
}, {
  start: 66045,
  length: 1,
  convRule: rule92
}, {
  start: 66176,
  length: 29,
  convRule: rule14
}, {
  start: 66208,
  length: 49,
  convRule: rule14
}, {
  start: 66272,
  length: 1,
  convRule: rule92
}, {
  start: 66273,
  length: 27,
  convRule: rule17
}, {
  start: 66304,
  length: 32,
  convRule: rule14
}, {
  start: 66336,
  length: 4,
  convRule: rule17
}, {
  start: 66349,
  length: 20,
  convRule: rule14
}, {
  start: 66369,
  length: 1,
  convRule: rule128
}, {
  start: 66370,
  length: 8,
  convRule: rule14
}, {
  start: 66378,
  length: 1,
  convRule: rule128
}, {
  start: 66384,
  length: 38,
  convRule: rule14
}, {
  start: 66422,
  length: 5,
  convRule: rule92
}, {
  start: 66432,
  length: 30,
  convRule: rule14
}, {
  start: 66463,
  length: 1,
  convRule: rule2
}, {
  start: 66464,
  length: 36,
  convRule: rule14
}, {
  start: 66504,
  length: 8,
  convRule: rule14
}, {
  start: 66512,
  length: 1,
  convRule: rule2
}, {
  start: 66513,
  length: 5,
  convRule: rule128
}, {
  start: 66560,
  length: 40,
  convRule: rule201
}, {
  start: 66600,
  length: 40,
  convRule: rule202
}, {
  start: 66640,
  length: 78,
  convRule: rule14
}, {
  start: 66720,
  length: 10,
  convRule: rule8
}, {
  start: 66736,
  length: 36,
  convRule: rule201
}, {
  start: 66776,
  length: 36,
  convRule: rule202
}, {
  start: 66816,
  length: 40,
  convRule: rule14
}, {
  start: 66864,
  length: 52,
  convRule: rule14
}, {
  start: 66927,
  length: 1,
  convRule: rule2
}, {
  start: 67072,
  length: 311,
  convRule: rule14
}, {
  start: 67392,
  length: 22,
  convRule: rule14
}, {
  start: 67424,
  length: 8,
  convRule: rule14
}, {
  start: 67584,
  length: 6,
  convRule: rule14
}, {
  start: 67592,
  length: 1,
  convRule: rule14
}, {
  start: 67594,
  length: 44,
  convRule: rule14
}, {
  start: 67639,
  length: 2,
  convRule: rule14
}, {
  start: 67644,
  length: 1,
  convRule: rule14
}, {
  start: 67647,
  length: 23,
  convRule: rule14
}, {
  start: 67671,
  length: 1,
  convRule: rule2
}, {
  start: 67672,
  length: 8,
  convRule: rule17
}, {
  start: 67680,
  length: 23,
  convRule: rule14
}, {
  start: 67703,
  length: 2,
  convRule: rule13
}, {
  start: 67705,
  length: 7,
  convRule: rule17
}, {
  start: 67712,
  length: 31,
  convRule: rule14
}, {
  start: 67751,
  length: 9,
  convRule: rule17
}, {
  start: 67808,
  length: 19,
  convRule: rule14
}, {
  start: 67828,
  length: 2,
  convRule: rule14
}, {
  start: 67835,
  length: 5,
  convRule: rule17
}, {
  start: 67840,
  length: 22,
  convRule: rule14
}, {
  start: 67862,
  length: 6,
  convRule: rule17
}, {
  start: 67871,
  length: 1,
  convRule: rule2
}, {
  start: 67872,
  length: 26,
  convRule: rule14
}, {
  start: 67903,
  length: 1,
  convRule: rule2
}, {
  start: 67968,
  length: 56,
  convRule: rule14
}, {
  start: 68028,
  length: 2,
  convRule: rule17
}, {
  start: 68030,
  length: 2,
  convRule: rule14
}, {
  start: 68032,
  length: 16,
  convRule: rule17
}, {
  start: 68050,
  length: 46,
  convRule: rule17
}, {
  start: 68096,
  length: 1,
  convRule: rule14
}, {
  start: 68097,
  length: 3,
  convRule: rule92
}, {
  start: 68101,
  length: 2,
  convRule: rule92
}, {
  start: 68108,
  length: 4,
  convRule: rule92
}, {
  start: 68112,
  length: 4,
  convRule: rule14
}, {
  start: 68117,
  length: 3,
  convRule: rule14
}, {
  start: 68121,
  length: 29,
  convRule: rule14
}, {
  start: 68152,
  length: 3,
  convRule: rule92
}, {
  start: 68159,
  length: 1,
  convRule: rule92
}, {
  start: 68160,
  length: 9,
  convRule: rule17
}, {
  start: 68176,
  length: 9,
  convRule: rule2
}, {
  start: 68192,
  length: 29,
  convRule: rule14
}, {
  start: 68221,
  length: 2,
  convRule: rule17
}, {
  start: 68223,
  length: 1,
  convRule: rule2
}, {
  start: 68224,
  length: 29,
  convRule: rule14
}, {
  start: 68253,
  length: 3,
  convRule: rule17
}, {
  start: 68288,
  length: 8,
  convRule: rule14
}, {
  start: 68296,
  length: 1,
  convRule: rule13
}, {
  start: 68297,
  length: 28,
  convRule: rule14
}, {
  start: 68325,
  length: 2,
  convRule: rule92
}, {
  start: 68331,
  length: 5,
  convRule: rule17
}, {
  start: 68336,
  length: 7,
  convRule: rule2
}, {
  start: 68352,
  length: 54,
  convRule: rule14
}, {
  start: 68409,
  length: 7,
  convRule: rule2
}, {
  start: 68416,
  length: 22,
  convRule: rule14
}, {
  start: 68440,
  length: 8,
  convRule: rule17
}, {
  start: 68448,
  length: 19,
  convRule: rule14
}, {
  start: 68472,
  length: 8,
  convRule: rule17
}, {
  start: 68480,
  length: 18,
  convRule: rule14
}, {
  start: 68505,
  length: 4,
  convRule: rule2
}, {
  start: 68521,
  length: 7,
  convRule: rule17
}, {
  start: 68608,
  length: 73,
  convRule: rule14
}, {
  start: 68736,
  length: 51,
  convRule: rule97
}, {
  start: 68800,
  length: 51,
  convRule: rule102
}, {
  start: 68858,
  length: 6,
  convRule: rule17
}, {
  start: 68864,
  length: 36,
  convRule: rule14
}, {
  start: 68900,
  length: 4,
  convRule: rule92
}, {
  start: 68912,
  length: 10,
  convRule: rule8
}, {
  start: 69216,
  length: 31,
  convRule: rule17
}, {
  start: 69248,
  length: 42,
  convRule: rule14
}, {
  start: 69291,
  length: 2,
  convRule: rule92
}, {
  start: 69293,
  length: 1,
  convRule: rule7
}, {
  start: 69296,
  length: 2,
  convRule: rule14
}, {
  start: 69376,
  length: 29,
  convRule: rule14
}, {
  start: 69405,
  length: 10,
  convRule: rule17
}, {
  start: 69415,
  length: 1,
  convRule: rule14
}, {
  start: 69424,
  length: 22,
  convRule: rule14
}, {
  start: 69446,
  length: 11,
  convRule: rule92
}, {
  start: 69457,
  length: 4,
  convRule: rule17
}, {
  start: 69461,
  length: 5,
  convRule: rule2
}, {
  start: 69552,
  length: 21,
  convRule: rule14
}, {
  start: 69573,
  length: 7,
  convRule: rule17
}, {
  start: 69600,
  length: 23,
  convRule: rule14
}, {
  start: 69632,
  length: 1,
  convRule: rule124
}, {
  start: 69633,
  length: 1,
  convRule: rule92
}, {
  start: 69634,
  length: 1,
  convRule: rule124
}, {
  start: 69635,
  length: 53,
  convRule: rule14
}, {
  start: 69688,
  length: 15,
  convRule: rule92
}, {
  start: 69703,
  length: 7,
  convRule: rule2
}, {
  start: 69714,
  length: 20,
  convRule: rule17
}, {
  start: 69734,
  length: 10,
  convRule: rule8
}, {
  start: 69759,
  length: 3,
  convRule: rule92
}, {
  start: 69762,
  length: 1,
  convRule: rule124
}, {
  start: 69763,
  length: 45,
  convRule: rule14
}, {
  start: 69808,
  length: 3,
  convRule: rule124
}, {
  start: 69811,
  length: 4,
  convRule: rule92
}, {
  start: 69815,
  length: 2,
  convRule: rule124
}, {
  start: 69817,
  length: 2,
  convRule: rule92
}, {
  start: 69819,
  length: 2,
  convRule: rule2
}, {
  start: 69821,
  length: 1,
  convRule: rule16
}, {
  start: 69822,
  length: 4,
  convRule: rule2
}, {
  start: 69837,
  length: 1,
  convRule: rule16
}, {
  start: 69840,
  length: 25,
  convRule: rule14
}, {
  start: 69872,
  length: 10,
  convRule: rule8
}, {
  start: 69888,
  length: 3,
  convRule: rule92
}, {
  start: 69891,
  length: 36,
  convRule: rule14
}, {
  start: 69927,
  length: 5,
  convRule: rule92
}, {
  start: 69932,
  length: 1,
  convRule: rule124
}, {
  start: 69933,
  length: 8,
  convRule: rule92
}, {
  start: 69942,
  length: 10,
  convRule: rule8
}, {
  start: 69952,
  length: 4,
  convRule: rule2
}, {
  start: 69956,
  length: 1,
  convRule: rule14
}, {
  start: 69957,
  length: 2,
  convRule: rule124
}, {
  start: 69959,
  length: 1,
  convRule: rule14
}, {
  start: 69968,
  length: 35,
  convRule: rule14
}, {
  start: 70003,
  length: 1,
  convRule: rule92
}, {
  start: 70004,
  length: 2,
  convRule: rule2
}, {
  start: 70006,
  length: 1,
  convRule: rule14
}, {
  start: 70016,
  length: 2,
  convRule: rule92
}, {
  start: 70018,
  length: 1,
  convRule: rule124
}, {
  start: 70019,
  length: 48,
  convRule: rule14
}, {
  start: 70067,
  length: 3,
  convRule: rule124
}, {
  start: 70070,
  length: 9,
  convRule: rule92
}, {
  start: 70079,
  length: 2,
  convRule: rule124
}, {
  start: 70081,
  length: 4,
  convRule: rule14
}, {
  start: 70085,
  length: 4,
  convRule: rule2
}, {
  start: 70089,
  length: 4,
  convRule: rule92
}, {
  start: 70093,
  length: 1,
  convRule: rule2
}, {
  start: 70094,
  length: 1,
  convRule: rule124
}, {
  start: 70095,
  length: 1,
  convRule: rule92
}, {
  start: 70096,
  length: 10,
  convRule: rule8
}, {
  start: 70106,
  length: 1,
  convRule: rule14
}, {
  start: 70107,
  length: 1,
  convRule: rule2
}, {
  start: 70108,
  length: 1,
  convRule: rule14
}, {
  start: 70109,
  length: 3,
  convRule: rule2
}, {
  start: 70113,
  length: 20,
  convRule: rule17
}, {
  start: 70144,
  length: 18,
  convRule: rule14
}, {
  start: 70163,
  length: 25,
  convRule: rule14
}, {
  start: 70188,
  length: 3,
  convRule: rule124
}, {
  start: 70191,
  length: 3,
  convRule: rule92
}, {
  start: 70194,
  length: 2,
  convRule: rule124
}, {
  start: 70196,
  length: 1,
  convRule: rule92
}, {
  start: 70197,
  length: 1,
  convRule: rule124
}, {
  start: 70198,
  length: 2,
  convRule: rule92
}, {
  start: 70200,
  length: 6,
  convRule: rule2
}, {
  start: 70206,
  length: 1,
  convRule: rule92
}, {
  start: 70272,
  length: 7,
  convRule: rule14
}, {
  start: 70280,
  length: 1,
  convRule: rule14
}, {
  start: 70282,
  length: 4,
  convRule: rule14
}, {
  start: 70287,
  length: 15,
  convRule: rule14
}, {
  start: 70303,
  length: 10,
  convRule: rule14
}, {
  start: 70313,
  length: 1,
  convRule: rule2
}, {
  start: 70320,
  length: 47,
  convRule: rule14
}, {
  start: 70367,
  length: 1,
  convRule: rule92
}, {
  start: 70368,
  length: 3,
  convRule: rule124
}, {
  start: 70371,
  length: 8,
  convRule: rule92
}, {
  start: 70384,
  length: 10,
  convRule: rule8
}, {
  start: 70400,
  length: 2,
  convRule: rule92
}, {
  start: 70402,
  length: 2,
  convRule: rule124
}, {
  start: 70405,
  length: 8,
  convRule: rule14
}, {
  start: 70415,
  length: 2,
  convRule: rule14
}, {
  start: 70419,
  length: 22,
  convRule: rule14
}, {
  start: 70442,
  length: 7,
  convRule: rule14
}, {
  start: 70450,
  length: 2,
  convRule: rule14
}, {
  start: 70453,
  length: 5,
  convRule: rule14
}, {
  start: 70459,
  length: 2,
  convRule: rule92
}, {
  start: 70461,
  length: 1,
  convRule: rule14
}, {
  start: 70462,
  length: 2,
  convRule: rule124
}, {
  start: 70464,
  length: 1,
  convRule: rule92
}, {
  start: 70465,
  length: 4,
  convRule: rule124
}, {
  start: 70471,
  length: 2,
  convRule: rule124
}, {
  start: 70475,
  length: 3,
  convRule: rule124
}, {
  start: 70480,
  length: 1,
  convRule: rule14
}, {
  start: 70487,
  length: 1,
  convRule: rule124
}, {
  start: 70493,
  length: 5,
  convRule: rule14
}, {
  start: 70498,
  length: 2,
  convRule: rule124
}, {
  start: 70502,
  length: 7,
  convRule: rule92
}, {
  start: 70512,
  length: 5,
  convRule: rule92
}, {
  start: 70656,
  length: 53,
  convRule: rule14
}, {
  start: 70709,
  length: 3,
  convRule: rule124
}, {
  start: 70712,
  length: 8,
  convRule: rule92
}, {
  start: 70720,
  length: 2,
  convRule: rule124
}, {
  start: 70722,
  length: 3,
  convRule: rule92
}, {
  start: 70725,
  length: 1,
  convRule: rule124
}, {
  start: 70726,
  length: 1,
  convRule: rule92
}, {
  start: 70727,
  length: 4,
  convRule: rule14
}, {
  start: 70731,
  length: 5,
  convRule: rule2
}, {
  start: 70736,
  length: 10,
  convRule: rule8
}, {
  start: 70746,
  length: 2,
  convRule: rule2
}, {
  start: 70749,
  length: 1,
  convRule: rule2
}, {
  start: 70750,
  length: 1,
  convRule: rule92
}, {
  start: 70751,
  length: 3,
  convRule: rule14
}, {
  start: 70784,
  length: 48,
  convRule: rule14
}, {
  start: 70832,
  length: 3,
  convRule: rule124
}, {
  start: 70835,
  length: 6,
  convRule: rule92
}, {
  start: 70841,
  length: 1,
  convRule: rule124
}, {
  start: 70842,
  length: 1,
  convRule: rule92
}, {
  start: 70843,
  length: 4,
  convRule: rule124
}, {
  start: 70847,
  length: 2,
  convRule: rule92
}, {
  start: 70849,
  length: 1,
  convRule: rule124
}, {
  start: 70850,
  length: 2,
  convRule: rule92
}, {
  start: 70852,
  length: 2,
  convRule: rule14
}, {
  start: 70854,
  length: 1,
  convRule: rule2
}, {
  start: 70855,
  length: 1,
  convRule: rule14
}, {
  start: 70864,
  length: 10,
  convRule: rule8
}, {
  start: 71040,
  length: 47,
  convRule: rule14
}, {
  start: 71087,
  length: 3,
  convRule: rule124
}, {
  start: 71090,
  length: 4,
  convRule: rule92
}, {
  start: 71096,
  length: 4,
  convRule: rule124
}, {
  start: 71100,
  length: 2,
  convRule: rule92
}, {
  start: 71102,
  length: 1,
  convRule: rule124
}, {
  start: 71103,
  length: 2,
  convRule: rule92
}, {
  start: 71105,
  length: 23,
  convRule: rule2
}, {
  start: 71128,
  length: 4,
  convRule: rule14
}, {
  start: 71132,
  length: 2,
  convRule: rule92
}, {
  start: 71168,
  length: 48,
  convRule: rule14
}, {
  start: 71216,
  length: 3,
  convRule: rule124
}, {
  start: 71219,
  length: 8,
  convRule: rule92
}, {
  start: 71227,
  length: 2,
  convRule: rule124
}, {
  start: 71229,
  length: 1,
  convRule: rule92
}, {
  start: 71230,
  length: 1,
  convRule: rule124
}, {
  start: 71231,
  length: 2,
  convRule: rule92
}, {
  start: 71233,
  length: 3,
  convRule: rule2
}, {
  start: 71236,
  length: 1,
  convRule: rule14
}, {
  start: 71248,
  length: 10,
  convRule: rule8
}, {
  start: 71264,
  length: 13,
  convRule: rule2
}, {
  start: 71296,
  length: 43,
  convRule: rule14
}, {
  start: 71339,
  length: 1,
  convRule: rule92
}, {
  start: 71340,
  length: 1,
  convRule: rule124
}, {
  start: 71341,
  length: 1,
  convRule: rule92
}, {
  start: 71342,
  length: 2,
  convRule: rule124
}, {
  start: 71344,
  length: 6,
  convRule: rule92
}, {
  start: 71350,
  length: 1,
  convRule: rule124
}, {
  start: 71351,
  length: 1,
  convRule: rule92
}, {
  start: 71352,
  length: 1,
  convRule: rule14
}, {
  start: 71360,
  length: 10,
  convRule: rule8
}, {
  start: 71424,
  length: 27,
  convRule: rule14
}, {
  start: 71453,
  length: 3,
  convRule: rule92
}, {
  start: 71456,
  length: 2,
  convRule: rule124
}, {
  start: 71458,
  length: 4,
  convRule: rule92
}, {
  start: 71462,
  length: 1,
  convRule: rule124
}, {
  start: 71463,
  length: 5,
  convRule: rule92
}, {
  start: 71472,
  length: 10,
  convRule: rule8
}, {
  start: 71482,
  length: 2,
  convRule: rule17
}, {
  start: 71484,
  length: 3,
  convRule: rule2
}, {
  start: 71487,
  length: 1,
  convRule: rule13
}, {
  start: 71680,
  length: 44,
  convRule: rule14
}, {
  start: 71724,
  length: 3,
  convRule: rule124
}, {
  start: 71727,
  length: 9,
  convRule: rule92
}, {
  start: 71736,
  length: 1,
  convRule: rule124
}, {
  start: 71737,
  length: 2,
  convRule: rule92
}, {
  start: 71739,
  length: 1,
  convRule: rule2
}, {
  start: 71840,
  length: 32,
  convRule: rule9
}, {
  start: 71872,
  length: 32,
  convRule: rule12
}, {
  start: 71904,
  length: 10,
  convRule: rule8
}, {
  start: 71914,
  length: 9,
  convRule: rule17
}, {
  start: 71935,
  length: 8,
  convRule: rule14
}, {
  start: 71945,
  length: 1,
  convRule: rule14
}, {
  start: 71948,
  length: 8,
  convRule: rule14
}, {
  start: 71957,
  length: 2,
  convRule: rule14
}, {
  start: 71960,
  length: 24,
  convRule: rule14
}, {
  start: 71984,
  length: 6,
  convRule: rule124
}, {
  start: 71991,
  length: 2,
  convRule: rule124
}, {
  start: 71995,
  length: 2,
  convRule: rule92
}, {
  start: 71997,
  length: 1,
  convRule: rule124
}, {
  start: 71998,
  length: 1,
  convRule: rule92
}, {
  start: 71999,
  length: 1,
  convRule: rule14
}, {
  start: 72e3,
  length: 1,
  convRule: rule124
}, {
  start: 72001,
  length: 1,
  convRule: rule14
}, {
  start: 72002,
  length: 1,
  convRule: rule124
}, {
  start: 72003,
  length: 1,
  convRule: rule92
}, {
  start: 72004,
  length: 3,
  convRule: rule2
}, {
  start: 72016,
  length: 10,
  convRule: rule8
}, {
  start: 72096,
  length: 8,
  convRule: rule14
}, {
  start: 72106,
  length: 39,
  convRule: rule14
}, {
  start: 72145,
  length: 3,
  convRule: rule124
}, {
  start: 72148,
  length: 4,
  convRule: rule92
}, {
  start: 72154,
  length: 2,
  convRule: rule92
}, {
  start: 72156,
  length: 4,
  convRule: rule124
}, {
  start: 72160,
  length: 1,
  convRule: rule92
}, {
  start: 72161,
  length: 1,
  convRule: rule14
}, {
  start: 72162,
  length: 1,
  convRule: rule2
}, {
  start: 72163,
  length: 1,
  convRule: rule14
}, {
  start: 72164,
  length: 1,
  convRule: rule124
}, {
  start: 72192,
  length: 1,
  convRule: rule14
}, {
  start: 72193,
  length: 10,
  convRule: rule92
}, {
  start: 72203,
  length: 40,
  convRule: rule14
}, {
  start: 72243,
  length: 6,
  convRule: rule92
}, {
  start: 72249,
  length: 1,
  convRule: rule124
}, {
  start: 72250,
  length: 1,
  convRule: rule14
}, {
  start: 72251,
  length: 4,
  convRule: rule92
}, {
  start: 72255,
  length: 8,
  convRule: rule2
}, {
  start: 72263,
  length: 1,
  convRule: rule92
}, {
  start: 72272,
  length: 1,
  convRule: rule14
}, {
  start: 72273,
  length: 6,
  convRule: rule92
}, {
  start: 72279,
  length: 2,
  convRule: rule124
}, {
  start: 72281,
  length: 3,
  convRule: rule92
}, {
  start: 72284,
  length: 46,
  convRule: rule14
}, {
  start: 72330,
  length: 13,
  convRule: rule92
}, {
  start: 72343,
  length: 1,
  convRule: rule124
}, {
  start: 72344,
  length: 2,
  convRule: rule92
}, {
  start: 72346,
  length: 3,
  convRule: rule2
}, {
  start: 72349,
  length: 1,
  convRule: rule14
}, {
  start: 72350,
  length: 5,
  convRule: rule2
}, {
  start: 72384,
  length: 57,
  convRule: rule14
}, {
  start: 72704,
  length: 9,
  convRule: rule14
}, {
  start: 72714,
  length: 37,
  convRule: rule14
}, {
  start: 72751,
  length: 1,
  convRule: rule124
}, {
  start: 72752,
  length: 7,
  convRule: rule92
}, {
  start: 72760,
  length: 6,
  convRule: rule92
}, {
  start: 72766,
  length: 1,
  convRule: rule124
}, {
  start: 72767,
  length: 1,
  convRule: rule92
}, {
  start: 72768,
  length: 1,
  convRule: rule14
}, {
  start: 72769,
  length: 5,
  convRule: rule2
}, {
  start: 72784,
  length: 10,
  convRule: rule8
}, {
  start: 72794,
  length: 19,
  convRule: rule17
}, {
  start: 72816,
  length: 2,
  convRule: rule2
}, {
  start: 72818,
  length: 30,
  convRule: rule14
}, {
  start: 72850,
  length: 22,
  convRule: rule92
}, {
  start: 72873,
  length: 1,
  convRule: rule124
}, {
  start: 72874,
  length: 7,
  convRule: rule92
}, {
  start: 72881,
  length: 1,
  convRule: rule124
}, {
  start: 72882,
  length: 2,
  convRule: rule92
}, {
  start: 72884,
  length: 1,
  convRule: rule124
}, {
  start: 72885,
  length: 2,
  convRule: rule92
}, {
  start: 72960,
  length: 7,
  convRule: rule14
}, {
  start: 72968,
  length: 2,
  convRule: rule14
}, {
  start: 72971,
  length: 38,
  convRule: rule14
}, {
  start: 73009,
  length: 6,
  convRule: rule92
}, {
  start: 73018,
  length: 1,
  convRule: rule92
}, {
  start: 73020,
  length: 2,
  convRule: rule92
}, {
  start: 73023,
  length: 7,
  convRule: rule92
}, {
  start: 73030,
  length: 1,
  convRule: rule14
}, {
  start: 73031,
  length: 1,
  convRule: rule92
}, {
  start: 73040,
  length: 10,
  convRule: rule8
}, {
  start: 73056,
  length: 6,
  convRule: rule14
}, {
  start: 73063,
  length: 2,
  convRule: rule14
}, {
  start: 73066,
  length: 32,
  convRule: rule14
}, {
  start: 73098,
  length: 5,
  convRule: rule124
}, {
  start: 73104,
  length: 2,
  convRule: rule92
}, {
  start: 73107,
  length: 2,
  convRule: rule124
}, {
  start: 73109,
  length: 1,
  convRule: rule92
}, {
  start: 73110,
  length: 1,
  convRule: rule124
}, {
  start: 73111,
  length: 1,
  convRule: rule92
}, {
  start: 73112,
  length: 1,
  convRule: rule14
}, {
  start: 73120,
  length: 10,
  convRule: rule8
}, {
  start: 73440,
  length: 19,
  convRule: rule14
}, {
  start: 73459,
  length: 2,
  convRule: rule92
}, {
  start: 73461,
  length: 2,
  convRule: rule124
}, {
  start: 73463,
  length: 2,
  convRule: rule2
}, {
  start: 73648,
  length: 1,
  convRule: rule14
}, {
  start: 73664,
  length: 21,
  convRule: rule17
}, {
  start: 73685,
  length: 8,
  convRule: rule13
}, {
  start: 73693,
  length: 4,
  convRule: rule3
}, {
  start: 73697,
  length: 17,
  convRule: rule13
}, {
  start: 73727,
  length: 1,
  convRule: rule2
}, {
  start: 73728,
  length: 922,
  convRule: rule14
}, {
  start: 74752,
  length: 111,
  convRule: rule128
}, {
  start: 74864,
  length: 5,
  convRule: rule2
}, {
  start: 74880,
  length: 196,
  convRule: rule14
}, {
  start: 77824,
  length: 1071,
  convRule: rule14
}, {
  start: 78896,
  length: 9,
  convRule: rule16
}, {
  start: 82944,
  length: 583,
  convRule: rule14
}, {
  start: 92160,
  length: 569,
  convRule: rule14
}, {
  start: 92736,
  length: 31,
  convRule: rule14
}, {
  start: 92768,
  length: 10,
  convRule: rule8
}, {
  start: 92782,
  length: 2,
  convRule: rule2
}, {
  start: 92880,
  length: 30,
  convRule: rule14
}, {
  start: 92912,
  length: 5,
  convRule: rule92
}, {
  start: 92917,
  length: 1,
  convRule: rule2
}, {
  start: 92928,
  length: 48,
  convRule: rule14
}, {
  start: 92976,
  length: 7,
  convRule: rule92
}, {
  start: 92983,
  length: 5,
  convRule: rule2
}, {
  start: 92988,
  length: 4,
  convRule: rule13
}, {
  start: 92992,
  length: 4,
  convRule: rule91
}, {
  start: 92996,
  length: 1,
  convRule: rule2
}, {
  start: 92997,
  length: 1,
  convRule: rule13
}, {
  start: 93008,
  length: 10,
  convRule: rule8
}, {
  start: 93019,
  length: 7,
  convRule: rule17
}, {
  start: 93027,
  length: 21,
  convRule: rule14
}, {
  start: 93053,
  length: 19,
  convRule: rule14
}, {
  start: 93760,
  length: 32,
  convRule: rule9
}, {
  start: 93792,
  length: 32,
  convRule: rule12
}, {
  start: 93824,
  length: 23,
  convRule: rule17
}, {
  start: 93847,
  length: 4,
  convRule: rule2
}, {
  start: 93952,
  length: 75,
  convRule: rule14
}, {
  start: 94031,
  length: 1,
  convRule: rule92
}, {
  start: 94032,
  length: 1,
  convRule: rule14
}, {
  start: 94033,
  length: 55,
  convRule: rule124
}, {
  start: 94095,
  length: 4,
  convRule: rule92
}, {
  start: 94099,
  length: 13,
  convRule: rule91
}, {
  start: 94176,
  length: 2,
  convRule: rule91
}, {
  start: 94178,
  length: 1,
  convRule: rule2
}, {
  start: 94179,
  length: 1,
  convRule: rule91
}, {
  start: 94180,
  length: 1,
  convRule: rule92
}, {
  start: 94192,
  length: 2,
  convRule: rule124
}, {
  start: 94208,
  length: 6136,
  convRule: rule14
}, {
  start: 100352,
  length: 1238,
  convRule: rule14
}, {
  start: 101632,
  length: 9,
  convRule: rule14
}, {
  start: 110592,
  length: 287,
  convRule: rule14
}, {
  start: 110928,
  length: 3,
  convRule: rule14
}, {
  start: 110948,
  length: 4,
  convRule: rule14
}, {
  start: 110960,
  length: 396,
  convRule: rule14
}, {
  start: 113664,
  length: 107,
  convRule: rule14
}, {
  start: 113776,
  length: 13,
  convRule: rule14
}, {
  start: 113792,
  length: 9,
  convRule: rule14
}, {
  start: 113808,
  length: 10,
  convRule: rule14
}, {
  start: 113820,
  length: 1,
  convRule: rule13
}, {
  start: 113821,
  length: 2,
  convRule: rule92
}, {
  start: 113823,
  length: 1,
  convRule: rule2
}, {
  start: 113824,
  length: 4,
  convRule: rule16
}, {
  start: 118784,
  length: 246,
  convRule: rule13
}, {
  start: 119040,
  length: 39,
  convRule: rule13
}, {
  start: 119081,
  length: 60,
  convRule: rule13
}, {
  start: 119141,
  length: 2,
  convRule: rule124
}, {
  start: 119143,
  length: 3,
  convRule: rule92
}, {
  start: 119146,
  length: 3,
  convRule: rule13
}, {
  start: 119149,
  length: 6,
  convRule: rule124
}, {
  start: 119155,
  length: 8,
  convRule: rule16
}, {
  start: 119163,
  length: 8,
  convRule: rule92
}, {
  start: 119171,
  length: 2,
  convRule: rule13
}, {
  start: 119173,
  length: 7,
  convRule: rule92
}, {
  start: 119180,
  length: 30,
  convRule: rule13
}, {
  start: 119210,
  length: 4,
  convRule: rule92
}, {
  start: 119214,
  length: 59,
  convRule: rule13
}, {
  start: 119296,
  length: 66,
  convRule: rule13
}, {
  start: 119362,
  length: 3,
  convRule: rule92
}, {
  start: 119365,
  length: 1,
  convRule: rule13
}, {
  start: 119520,
  length: 20,
  convRule: rule17
}, {
  start: 119552,
  length: 87,
  convRule: rule13
}, {
  start: 119648,
  length: 25,
  convRule: rule17
}, {
  start: 119808,
  length: 26,
  convRule: rule107
}, {
  start: 119834,
  length: 26,
  convRule: rule20
}, {
  start: 119860,
  length: 26,
  convRule: rule107
}, {
  start: 119886,
  length: 7,
  convRule: rule20
}, {
  start: 119894,
  length: 18,
  convRule: rule20
}, {
  start: 119912,
  length: 26,
  convRule: rule107
}, {
  start: 119938,
  length: 26,
  convRule: rule20
}, {
  start: 119964,
  length: 1,
  convRule: rule107
}, {
  start: 119966,
  length: 2,
  convRule: rule107
}, {
  start: 119970,
  length: 1,
  convRule: rule107
}, {
  start: 119973,
  length: 2,
  convRule: rule107
}, {
  start: 119977,
  length: 4,
  convRule: rule107
}, {
  start: 119982,
  length: 8,
  convRule: rule107
}, {
  start: 119990,
  length: 4,
  convRule: rule20
}, {
  start: 119995,
  length: 1,
  convRule: rule20
}, {
  start: 119997,
  length: 7,
  convRule: rule20
}, {
  start: 120005,
  length: 11,
  convRule: rule20
}, {
  start: 120016,
  length: 26,
  convRule: rule107
}, {
  start: 120042,
  length: 26,
  convRule: rule20
}, {
  start: 120068,
  length: 2,
  convRule: rule107
}, {
  start: 120071,
  length: 4,
  convRule: rule107
}, {
  start: 120077,
  length: 8,
  convRule: rule107
}, {
  start: 120086,
  length: 7,
  convRule: rule107
}, {
  start: 120094,
  length: 26,
  convRule: rule20
}, {
  start: 120120,
  length: 2,
  convRule: rule107
}, {
  start: 120123,
  length: 4,
  convRule: rule107
}, {
  start: 120128,
  length: 5,
  convRule: rule107
}, {
  start: 120134,
  length: 1,
  convRule: rule107
}, {
  start: 120138,
  length: 7,
  convRule: rule107
}, {
  start: 120146,
  length: 26,
  convRule: rule20
}, {
  start: 120172,
  length: 26,
  convRule: rule107
}, {
  start: 120198,
  length: 26,
  convRule: rule20
}, {
  start: 120224,
  length: 26,
  convRule: rule107
}, {
  start: 120250,
  length: 26,
  convRule: rule20
}, {
  start: 120276,
  length: 26,
  convRule: rule107
}, {
  start: 120302,
  length: 26,
  convRule: rule20
}, {
  start: 120328,
  length: 26,
  convRule: rule107
}, {
  start: 120354,
  length: 26,
  convRule: rule20
}, {
  start: 120380,
  length: 26,
  convRule: rule107
}, {
  start: 120406,
  length: 26,
  convRule: rule20
}, {
  start: 120432,
  length: 26,
  convRule: rule107
}, {
  start: 120458,
  length: 28,
  convRule: rule20
}, {
  start: 120488,
  length: 25,
  convRule: rule107
}, {
  start: 120513,
  length: 1,
  convRule: rule6
}, {
  start: 120514,
  length: 25,
  convRule: rule20
}, {
  start: 120539,
  length: 1,
  convRule: rule6
}, {
  start: 120540,
  length: 6,
  convRule: rule20
}, {
  start: 120546,
  length: 25,
  convRule: rule107
}, {
  start: 120571,
  length: 1,
  convRule: rule6
}, {
  start: 120572,
  length: 25,
  convRule: rule20
}, {
  start: 120597,
  length: 1,
  convRule: rule6
}, {
  start: 120598,
  length: 6,
  convRule: rule20
}, {
  start: 120604,
  length: 25,
  convRule: rule107
}, {
  start: 120629,
  length: 1,
  convRule: rule6
}, {
  start: 120630,
  length: 25,
  convRule: rule20
}, {
  start: 120655,
  length: 1,
  convRule: rule6
}, {
  start: 120656,
  length: 6,
  convRule: rule20
}, {
  start: 120662,
  length: 25,
  convRule: rule107
}, {
  start: 120687,
  length: 1,
  convRule: rule6
}, {
  start: 120688,
  length: 25,
  convRule: rule20
}, {
  start: 120713,
  length: 1,
  convRule: rule6
}, {
  start: 120714,
  length: 6,
  convRule: rule20
}, {
  start: 120720,
  length: 25,
  convRule: rule107
}, {
  start: 120745,
  length: 1,
  convRule: rule6
}, {
  start: 120746,
  length: 25,
  convRule: rule20
}, {
  start: 120771,
  length: 1,
  convRule: rule6
}, {
  start: 120772,
  length: 6,
  convRule: rule20
}, {
  start: 120778,
  length: 1,
  convRule: rule107
}, {
  start: 120779,
  length: 1,
  convRule: rule20
}, {
  start: 120782,
  length: 50,
  convRule: rule8
}, {
  start: 120832,
  length: 512,
  convRule: rule13
}, {
  start: 121344,
  length: 55,
  convRule: rule92
}, {
  start: 121399,
  length: 4,
  convRule: rule13
}, {
  start: 121403,
  length: 50,
  convRule: rule92
}, {
  start: 121453,
  length: 8,
  convRule: rule13
}, {
  start: 121461,
  length: 1,
  convRule: rule92
}, {
  start: 121462,
  length: 14,
  convRule: rule13
}, {
  start: 121476,
  length: 1,
  convRule: rule92
}, {
  start: 121477,
  length: 2,
  convRule: rule13
}, {
  start: 121479,
  length: 5,
  convRule: rule2
}, {
  start: 121499,
  length: 5,
  convRule: rule92
}, {
  start: 121505,
  length: 15,
  convRule: rule92
}, {
  start: 122880,
  length: 7,
  convRule: rule92
}, {
  start: 122888,
  length: 17,
  convRule: rule92
}, {
  start: 122907,
  length: 7,
  convRule: rule92
}, {
  start: 122915,
  length: 2,
  convRule: rule92
}, {
  start: 122918,
  length: 5,
  convRule: rule92
}, {
  start: 123136,
  length: 45,
  convRule: rule14
}, {
  start: 123184,
  length: 7,
  convRule: rule92
}, {
  start: 123191,
  length: 7,
  convRule: rule91
}, {
  start: 123200,
  length: 10,
  convRule: rule8
}, {
  start: 123214,
  length: 1,
  convRule: rule14
}, {
  start: 123215,
  length: 1,
  convRule: rule13
}, {
  start: 123584,
  length: 44,
  convRule: rule14
}, {
  start: 123628,
  length: 4,
  convRule: rule92
}, {
  start: 123632,
  length: 10,
  convRule: rule8
}, {
  start: 123647,
  length: 1,
  convRule: rule3
}, {
  start: 124928,
  length: 197,
  convRule: rule14
}, {
  start: 125127,
  length: 9,
  convRule: rule17
}, {
  start: 125136,
  length: 7,
  convRule: rule92
}, {
  start: 125184,
  length: 34,
  convRule: rule203
}, {
  start: 125218,
  length: 34,
  convRule: rule204
}, {
  start: 125252,
  length: 7,
  convRule: rule92
}, {
  start: 125259,
  length: 1,
  convRule: rule91
}, {
  start: 125264,
  length: 10,
  convRule: rule8
}, {
  start: 125278,
  length: 2,
  convRule: rule2
}, {
  start: 126065,
  length: 59,
  convRule: rule17
}, {
  start: 126124,
  length: 1,
  convRule: rule13
}, {
  start: 126125,
  length: 3,
  convRule: rule17
}, {
  start: 126128,
  length: 1,
  convRule: rule3
}, {
  start: 126129,
  length: 4,
  convRule: rule17
}, {
  start: 126209,
  length: 45,
  convRule: rule17
}, {
  start: 126254,
  length: 1,
  convRule: rule13
}, {
  start: 126255,
  length: 15,
  convRule: rule17
}, {
  start: 126464,
  length: 4,
  convRule: rule14
}, {
  start: 126469,
  length: 27,
  convRule: rule14
}, {
  start: 126497,
  length: 2,
  convRule: rule14
}, {
  start: 126500,
  length: 1,
  convRule: rule14
}, {
  start: 126503,
  length: 1,
  convRule: rule14
}, {
  start: 126505,
  length: 10,
  convRule: rule14
}, {
  start: 126516,
  length: 4,
  convRule: rule14
}, {
  start: 126521,
  length: 1,
  convRule: rule14
}, {
  start: 126523,
  length: 1,
  convRule: rule14
}, {
  start: 126530,
  length: 1,
  convRule: rule14
}, {
  start: 126535,
  length: 1,
  convRule: rule14
}, {
  start: 126537,
  length: 1,
  convRule: rule14
}, {
  start: 126539,
  length: 1,
  convRule: rule14
}, {
  start: 126541,
  length: 3,
  convRule: rule14
}, {
  start: 126545,
  length: 2,
  convRule: rule14
}, {
  start: 126548,
  length: 1,
  convRule: rule14
}, {
  start: 126551,
  length: 1,
  convRule: rule14
}, {
  start: 126553,
  length: 1,
  convRule: rule14
}, {
  start: 126555,
  length: 1,
  convRule: rule14
}, {
  start: 126557,
  length: 1,
  convRule: rule14
}, {
  start: 126559,
  length: 1,
  convRule: rule14
}, {
  start: 126561,
  length: 2,
  convRule: rule14
}, {
  start: 126564,
  length: 1,
  convRule: rule14
}, {
  start: 126567,
  length: 4,
  convRule: rule14
}, {
  start: 126572,
  length: 7,
  convRule: rule14
}, {
  start: 126580,
  length: 4,
  convRule: rule14
}, {
  start: 126585,
  length: 4,
  convRule: rule14
}, {
  start: 126590,
  length: 1,
  convRule: rule14
}, {
  start: 126592,
  length: 10,
  convRule: rule14
}, {
  start: 126603,
  length: 17,
  convRule: rule14
}, {
  start: 126625,
  length: 3,
  convRule: rule14
}, {
  start: 126629,
  length: 5,
  convRule: rule14
}, {
  start: 126635,
  length: 17,
  convRule: rule14
}, {
  start: 126704,
  length: 2,
  convRule: rule6
}, {
  start: 126976,
  length: 44,
  convRule: rule13
}, {
  start: 127024,
  length: 100,
  convRule: rule13
}, {
  start: 127136,
  length: 15,
  convRule: rule13
}, {
  start: 127153,
  length: 15,
  convRule: rule13
}, {
  start: 127169,
  length: 15,
  convRule: rule13
}, {
  start: 127185,
  length: 37,
  convRule: rule13
}, {
  start: 127232,
  length: 13,
  convRule: rule17
}, {
  start: 127245,
  length: 161,
  convRule: rule13
}, {
  start: 127462,
  length: 29,
  convRule: rule13
}, {
  start: 127504,
  length: 44,
  convRule: rule13
}, {
  start: 127552,
  length: 9,
  convRule: rule13
}, {
  start: 127568,
  length: 2,
  convRule: rule13
}, {
  start: 127584,
  length: 6,
  convRule: rule13
}, {
  start: 127744,
  length: 251,
  convRule: rule13
}, {
  start: 127995,
  length: 5,
  convRule: rule10
}, {
  start: 128e3,
  length: 728,
  convRule: rule13
}, {
  start: 128736,
  length: 13,
  convRule: rule13
}, {
  start: 128752,
  length: 13,
  convRule: rule13
}, {
  start: 128768,
  length: 116,
  convRule: rule13
}, {
  start: 128896,
  length: 89,
  convRule: rule13
}, {
  start: 128992,
  length: 12,
  convRule: rule13
}, {
  start: 129024,
  length: 12,
  convRule: rule13
}, {
  start: 129040,
  length: 56,
  convRule: rule13
}, {
  start: 129104,
  length: 10,
  convRule: rule13
}, {
  start: 129120,
  length: 40,
  convRule: rule13
}, {
  start: 129168,
  length: 30,
  convRule: rule13
}, {
  start: 129200,
  length: 2,
  convRule: rule13
}, {
  start: 129280,
  length: 121,
  convRule: rule13
}, {
  start: 129402,
  length: 82,
  convRule: rule13
}, {
  start: 129485,
  length: 135,
  convRule: rule13
}, {
  start: 129632,
  length: 14,
  convRule: rule13
}, {
  start: 129648,
  length: 5,
  convRule: rule13
}, {
  start: 129656,
  length: 3,
  convRule: rule13
}, {
  start: 129664,
  length: 7,
  convRule: rule13
}, {
  start: 129680,
  length: 25,
  convRule: rule13
}, {
  start: 129712,
  length: 7,
  convRule: rule13
}, {
  start: 129728,
  length: 3,
  convRule: rule13
}, {
  start: 129744,
  length: 7,
  convRule: rule13
}, {
  start: 129792,
  length: 147,
  convRule: rule13
}, {
  start: 129940,
  length: 55,
  convRule: rule13
}, {
  start: 130032,
  length: 10,
  convRule: rule8
}, {
  start: 131072,
  length: 42718,
  convRule: rule14
}, {
  start: 173824,
  length: 4149,
  convRule: rule14
}, {
  start: 177984,
  length: 222,
  convRule: rule14
}, {
  start: 178208,
  length: 5762,
  convRule: rule14
}, {
  start: 183984,
  length: 7473,
  convRule: rule14
}, {
  start: 194560,
  length: 542,
  convRule: rule14
}, {
  start: 196608,
  length: 4939,
  convRule: rule14
}, {
  start: 917505,
  length: 1,
  convRule: rule16
}, {
  start: 917536,
  length: 96,
  convRule: rule16
}, {
  start: 917760,
  length: 240,
  convRule: rule92
}, {
  start: 983040,
  length: 65534,
  convRule: rule200
}, {
  start: 1048576,
  length: 65534,
  convRule: rule200
}];
var checkAttr = function(categories) {
  return function($$char5) {
    var numOfBlocks = function() {
      var $43 = $$char5 < 256;
      if ($43) {
        return numLat1Blocks;
      }
      ;
      return numBlocks;
    }();
    var maybeConversionRule = getRule(allchars)($$char5)(numOfBlocks);
    if (maybeConversionRule instanceof Nothing) {
      return false;
    }
    ;
    if (maybeConversionRule instanceof Just) {
      return isJust(elemIndex2(maybeConversionRule.value0.category)(categories));
    }
    ;
    throw new Error("Failed pattern match at Data.CodePoint.Unicode.Internal (line 5645, column 5 - line 5647, column 86): " + [maybeConversionRule.constructor.name]);
  };
};
var uIswalnum = /* @__PURE__ */ checkAttr([gencatLT, gencatLU, gencatLL, gencatLM, gencatLO, gencatMC, gencatME, gencatMN, gencatNO, gencatND, gencatNL]);
var uIswlower = /* @__PURE__ */ checkAttr([gencatLL]);

// output/Data.CodePoint.Unicode/index.js
var fromEnum7 = /* @__PURE__ */ fromEnum(boundedEnumCodePoint);
var isLower = function($68) {
  return uIswlower(fromEnum7($68));
};
var isDecDigit = function(c) {
  var diff2 = fromEnum7(c) - toCharCode2("0") | 0;
  return diff2 <= 9 && diff2 >= 0;
};
var isAlphaNum = function($70) {
  return uIswalnum(fromEnum7($70));
};

// output/Parsing.String.Basic/index.js
var elem1 = /* @__PURE__ */ elem2(eqChar);
var show14 = /* @__PURE__ */ show(/* @__PURE__ */ showArray(showChar));
var satisfyCP = function(p) {
  return satisfy(function($32) {
    return p(codePointFromChar($32));
  });
};
var oneOf3 = function(ss) {
  return withLazyErrorMessage(satisfy(flip(elem1)(ss)))(function(v) {
    return "one of " + show14(ss);
  });
};
var lower2 = /* @__PURE__ */ withErrorMessage(/* @__PURE__ */ satisfyCP(isLower))("lowercase letter");
var digit = /* @__PURE__ */ withErrorMessage(/* @__PURE__ */ satisfyCP(isDecDigit))("digit");
var alphaNum = /* @__PURE__ */ withErrorMessage(/* @__PURE__ */ satisfyCP(isAlphaNum))("letter or digit");

// output/Data.Formatter.Parser.Number/index.js
var oneOfAs2 = /* @__PURE__ */ oneOfAs(functorArray)(foldableArray);
var parseDigit = function(dictMonad) {
  return $$try4(oneOfAs2(dictMonad)($$char3)([new Tuple("0", 0), new Tuple("1", 1), new Tuple("2", 2), new Tuple("3", 3), new Tuple("4", 4), new Tuple("5", 5), new Tuple("6", 6), new Tuple("7", 7), new Tuple("8", 8), new Tuple("9", 9)]));
};

// output/Data.Formatter.DateTime/index.js
var bind16 = /* @__PURE__ */ bind(/* @__PURE__ */ bindReaderT(bindEither));
var ask2 = /* @__PURE__ */ ask(/* @__PURE__ */ monadAskReaderT(monadEither));
var lift7 = /* @__PURE__ */ lift(monadTransReaderT)(monadEither);
var show15 = /* @__PURE__ */ show(showInt);
var for_2 = /* @__PURE__ */ for_(applicativeEither)(foldableArray);
var when2 = /* @__PURE__ */ when(applicativeEither);
var pure27 = /* @__PURE__ */ pure(applicativeEither);
var foldMap4 = /* @__PURE__ */ foldMap(foldableList);
var foldMap15 = /* @__PURE__ */ foldMap4(monoidString);
var mapFlipped4 = /* @__PURE__ */ mapFlipped(functorParserT);
var oneOfAs3 = /* @__PURE__ */ oneOfAs(functorArray)(foldableArray);
var bind17 = /* @__PURE__ */ bind(bindParserT);
var foldDigits2 = /* @__PURE__ */ foldDigits(foldableList);
var pure113 = /* @__PURE__ */ pure(applicativeParserT);
var map38 = /* @__PURE__ */ map(functorParserT);
var negate2 = /* @__PURE__ */ negate(ringInt);
var identity19 = /* @__PURE__ */ identity(categoryFn);
var abs3 = /* @__PURE__ */ abs(ordInt)(ringInt);
var some3 = /* @__PURE__ */ some2(alternativeParserT)(lazyParserT);
var fromEnum8 = /* @__PURE__ */ fromEnum(boundedEnumYear);
var show16 = /* @__PURE__ */ show(showMonth);
var fromEnum1 = /* @__PURE__ */ fromEnum(boundedEnumMonth);
var fromEnum22 = /* @__PURE__ */ fromEnum(boundedEnumDay);
var unwrap11 = /* @__PURE__ */ unwrap();
var fromEnum32 = /* @__PURE__ */ fromEnum(boundedEnumWeekday);
var show23 = /* @__PURE__ */ show(showWeekday);
var fromEnum42 = /* @__PURE__ */ fromEnum(boundedEnumHour);
var mod5 = /* @__PURE__ */ mod(euclideanRingInt);
var fromEnum52 = /* @__PURE__ */ fromEnum(boundedEnumMinute);
var fromEnum62 = /* @__PURE__ */ fromEnum(boundedEnumSecond);
var fromEnum72 = /* @__PURE__ */ fromEnum(boundedEnumMillisecond);
var div1 = /* @__PURE__ */ div(euclideanRingInt);
var monadStateT3 = /* @__PURE__ */ monadStateT(monadIdentity);
var lift13 = /* @__PURE__ */ lift(monadTransParserT)(monadStateT3);
var monadStateStateT2 = /* @__PURE__ */ monadStateStateT(monadIdentity);
var modify_4 = /* @__PURE__ */ modify_2(monadStateStateT2);
var lift25 = /* @__PURE__ */ lift2(applyParserT);
var mul2 = /* @__PURE__ */ mul(semiringInt);
var parseDigit2 = /* @__PURE__ */ parseDigit(monadStateT3);
var append18 = /* @__PURE__ */ append(/* @__PURE__ */ semigroupReaderT(applyEither)(semigroupUnit));
var map116 = /* @__PURE__ */ map(functorMaybe);
var put2 = /* @__PURE__ */ put(monadStateStateT2);
var $$void11 = /* @__PURE__ */ $$void(functorParserT);
var applySecond2 = /* @__PURE__ */ applySecond(applyEither);
var apply15 = /* @__PURE__ */ apply2(applyEither);
var map212 = /* @__PURE__ */ map(functorEither);
var toEnum5 = /* @__PURE__ */ toEnum(boundedEnumYear);
var toEnum1 = /* @__PURE__ */ toEnum(boundedEnumMonth);
var toEnum23 = /* @__PURE__ */ toEnum(boundedEnumDay);
var toEnum32 = /* @__PURE__ */ toEnum(boundedEnumHour);
var toEnum42 = /* @__PURE__ */ toEnum(boundedEnumMinute);
var toEnum52 = /* @__PURE__ */ toEnum(boundedEnumSecond);
var toEnum6 = /* @__PURE__ */ toEnum(boundedEnumMillisecond);
var voidLeft4 = /* @__PURE__ */ voidLeft(functorEither);
var mapParserT2 = /* @__PURE__ */ mapParserT(/* @__PURE__ */ monadRecStateT(monadRecIdentity));
var foldMap22 = /* @__PURE__ */ foldMap4(/* @__PURE__ */ monoidParserT(monoidUnit));
var AM = /* @__PURE__ */ function() {
  function AM2() {
  }
  ;
  AM2.value = new AM2();
  return AM2;
}();
var PM = /* @__PURE__ */ function() {
  function PM2() {
  }
  ;
  PM2.value = new PM2();
  return PM2;
}();
var YearFull = /* @__PURE__ */ function() {
  function YearFull2() {
  }
  ;
  YearFull2.value = new YearFull2();
  return YearFull2;
}();
var YearTwoDigits = /* @__PURE__ */ function() {
  function YearTwoDigits2() {
  }
  ;
  YearTwoDigits2.value = new YearTwoDigits2();
  return YearTwoDigits2;
}();
var YearAbsolute = /* @__PURE__ */ function() {
  function YearAbsolute2() {
  }
  ;
  YearAbsolute2.value = new YearAbsolute2();
  return YearAbsolute2;
}();
var MonthFull = /* @__PURE__ */ function() {
  function MonthFull2() {
  }
  ;
  MonthFull2.value = new MonthFull2();
  return MonthFull2;
}();
var MonthShort = /* @__PURE__ */ function() {
  function MonthShort2() {
  }
  ;
  MonthShort2.value = new MonthShort2();
  return MonthShort2;
}();
var MonthTwoDigits = /* @__PURE__ */ function() {
  function MonthTwoDigits2() {
  }
  ;
  MonthTwoDigits2.value = new MonthTwoDigits2();
  return MonthTwoDigits2;
}();
var DayOfMonthTwoDigits = /* @__PURE__ */ function() {
  function DayOfMonthTwoDigits2() {
  }
  ;
  DayOfMonthTwoDigits2.value = new DayOfMonthTwoDigits2();
  return DayOfMonthTwoDigits2;
}();
var DayOfMonth = /* @__PURE__ */ function() {
  function DayOfMonth2() {
  }
  ;
  DayOfMonth2.value = new DayOfMonth2();
  return DayOfMonth2;
}();
var UnixTimestamp = /* @__PURE__ */ function() {
  function UnixTimestamp2() {
  }
  ;
  UnixTimestamp2.value = new UnixTimestamp2();
  return UnixTimestamp2;
}();
var DayOfWeek = /* @__PURE__ */ function() {
  function DayOfWeek2() {
  }
  ;
  DayOfWeek2.value = new DayOfWeek2();
  return DayOfWeek2;
}();
var DayOfWeekName = /* @__PURE__ */ function() {
  function DayOfWeekName2() {
  }
  ;
  DayOfWeekName2.value = new DayOfWeekName2();
  return DayOfWeekName2;
}();
var DayOfWeekNameShort = /* @__PURE__ */ function() {
  function DayOfWeekNameShort2() {
  }
  ;
  DayOfWeekNameShort2.value = new DayOfWeekNameShort2();
  return DayOfWeekNameShort2;
}();
var Hours24 = /* @__PURE__ */ function() {
  function Hours242() {
  }
  ;
  Hours242.value = new Hours242();
  return Hours242;
}();
var Hours12 = /* @__PURE__ */ function() {
  function Hours122() {
  }
  ;
  Hours122.value = new Hours122();
  return Hours122;
}();
var Meridiem = /* @__PURE__ */ function() {
  function Meridiem2() {
  }
  ;
  Meridiem2.value = new Meridiem2();
  return Meridiem2;
}();
var Minutes = /* @__PURE__ */ function() {
  function Minutes2() {
  }
  ;
  Minutes2.value = new Minutes2();
  return Minutes2;
}();
var MinutesTwoDigits = /* @__PURE__ */ function() {
  function MinutesTwoDigits2() {
  }
  ;
  MinutesTwoDigits2.value = new MinutesTwoDigits2();
  return MinutesTwoDigits2;
}();
var Seconds = /* @__PURE__ */ function() {
  function Seconds2() {
  }
  ;
  Seconds2.value = new Seconds2();
  return Seconds2;
}();
var SecondsTwoDigits = /* @__PURE__ */ function() {
  function SecondsTwoDigits2() {
  }
  ;
  SecondsTwoDigits2.value = new SecondsTwoDigits2();
  return SecondsTwoDigits2;
}();
var Milliseconds2 = /* @__PURE__ */ function() {
  function Milliseconds3() {
  }
  ;
  Milliseconds3.value = new Milliseconds3();
  return Milliseconds3;
}();
var MillisecondsShort = /* @__PURE__ */ function() {
  function MillisecondsShort2() {
  }
  ;
  MillisecondsShort2.value = new MillisecondsShort2();
  return MillisecondsShort2;
}();
var MillisecondsTwoDigits = /* @__PURE__ */ function() {
  function MillisecondsTwoDigits2() {
  }
  ;
  MillisecondsTwoDigits2.value = new MillisecondsTwoDigits2();
  return MillisecondsTwoDigits2;
}();
var Placeholder = /* @__PURE__ */ function() {
  function Placeholder2(value0) {
    this.value0 = value0;
  }
  ;
  Placeholder2.create = function(value0) {
    return new Placeholder2(value0);
  };
  return Placeholder2;
}();
var validateRange = function(min8) {
  return function(max8) {
    return bind16(ask2)(function(v) {
      return lift7(function() {
        var $316 = v.num < min8 || v.num > max8;
        if ($316) {
          return new Left("Number is out of range [ " + (show15(min8) + (", " + (show15(max8) + " ]"))));
        }
        ;
        return new Right(unit);
      }());
    });
  };
};
var validAccum = function(v) {
  if (v.hour instanceof Just && v.hour.value0 === 24) {
    return for_2([v.minute, v.second, v.millisecond])(function(val) {
      return when2(fromMaybe(0)(val) > 0)(new Left("When hour is 24, other time components must be 0"));
    });
  }
  ;
  return pure27(unit);
};
var takeSome = function(dictAlternative) {
  var Applicative0 = dictAlternative.Applicative0();
  var pure211 = pure(Applicative0);
  var apply111 = apply2(Applicative0.Apply0());
  var map315 = map(dictAlternative.Plus1().Alt0().Functor0());
  return function(dictLazy) {
    var defer6 = defer(dictLazy);
    return function(v) {
      return function(v1) {
        if (v === 0) {
          return pure211(Nil.value);
        }
        ;
        return apply111(map315(Cons.create)(v1))(defer6(function(v3) {
          return takeMany(dictAlternative)(dictLazy)(v - 1 | 0)(v1);
        }));
      };
    };
  };
};
var takeMany = function(dictAlternative) {
  var pure211 = pure(dictAlternative.Applicative0());
  var alt32 = alt(dictAlternative.Plus1().Alt0());
  return function(dictLazy) {
    return function(v) {
      return function(v1) {
        if (v === 0) {
          return pure211(Nil.value);
        }
        ;
        return alt32(takeSome(dictAlternative)(dictLazy)(v)(v1))(pure211(Nil.value));
      };
    };
  };
};
var takeSome1 = /* @__PURE__ */ takeSome(alternativeParserT)(lazyParserT);
var printShortMonth = function(v) {
  if (v instanceof January) {
    return "Jan";
  }
  ;
  if (v instanceof February) {
    return "Feb";
  }
  ;
  if (v instanceof March) {
    return "Mar";
  }
  ;
  if (v instanceof April) {
    return "Apr";
  }
  ;
  if (v instanceof May) {
    return "May";
  }
  ;
  if (v instanceof June) {
    return "Jun";
  }
  ;
  if (v instanceof July) {
    return "Jul";
  }
  ;
  if (v instanceof August) {
    return "Aug";
  }
  ;
  if (v instanceof September) {
    return "Sep";
  }
  ;
  if (v instanceof October) {
    return "Oct";
  }
  ;
  if (v instanceof November) {
    return "Nov";
  }
  ;
  if (v instanceof December) {
    return "Dec";
  }
  ;
  throw new Error("Failed pattern match at Data.Formatter.DateTime (line 489, column 19 - line 501, column 22): " + [v.constructor.name]);
};
var parseShortMonth = function(dictMonad) {
  return oneOfAs3(dictMonad)(function($659) {
    return $$try4(string3($659));
  })([new Tuple("Jan", January.value), new Tuple("Feb", February.value), new Tuple("Mar", March.value), new Tuple("Apr", April.value), new Tuple("May", May.value), new Tuple("Jun", June.value), new Tuple("Jul", July.value), new Tuple("Aug", August.value), new Tuple("Sep", September.value), new Tuple("Oct", October.value), new Tuple("Nov", November.value), new Tuple("Dec", December.value)]);
};
var parseShortMonth1 = /* @__PURE__ */ parseShortMonth(monadStateT3);
var parseMonth = function(dictMonad) {
  return oneOfAs3(dictMonad)(function($660) {
    return $$try4(string3($660));
  })([new Tuple("January", January.value), new Tuple("February", February.value), new Tuple("March", March.value), new Tuple("April", April.value), new Tuple("May", May.value), new Tuple("June", June.value), new Tuple("July", July.value), new Tuple("August", August.value), new Tuple("September", September.value), new Tuple("October", October.value), new Tuple("November", November.value), new Tuple("December", December.value)]);
};
var parseMonth1 = /* @__PURE__ */ parseMonth(monadStateT3);
var parseMeridiem = function(dictMonad) {
  return oneOfAs3(dictMonad)(function($661) {
    return $$try4(string3($661));
  })([new Tuple("am", AM.value), new Tuple("AM", AM.value), new Tuple("pm", PM.value), new Tuple("PM", PM.value)]);
};
var parseMeridiem1 = /* @__PURE__ */ parseMeridiem(monadStateT3);
var $$parseInt = function(dictMonad) {
  var parseDigit1 = parseDigit(dictMonad);
  return function(maxLength) {
    return function(validators) {
      return function(errMsg) {
        return bind17(takeSome1(maxLength)(parseDigit1))(function(ds) {
          var num = foldDigits2(ds);
          var length7 = length5(ds);
          var v = runReaderT(validators)({
            length: length7,
            num,
            maxLength
          });
          if (v instanceof Left) {
            return fail2(errMsg + ("(" + (v.value0 + ")")));
          }
          ;
          if (v instanceof Right) {
            return pure113(num);
          }
          ;
          throw new Error("Failed pattern match at Data.Formatter.DateTime (line 342, column 3 - line 344, column 24): " + [v.constructor.name]);
        });
      };
    };
  };
};
var parseInt1 = /* @__PURE__ */ $$parseInt(monadStateT3);
var parseSignedInt = function(dictMonad) {
  var parseInt2 = $$parseInt(dictMonad);
  return function(maxLength) {
    return function(validators) {
      return function(errMsg) {
        return bind17(map38(isJust)(optionMaybe($$char3("-"))))(function(isNegative) {
          return map38(function() {
            if (isNegative) {
              return negate2;
            }
            ;
            return identity19;
          }())(parseInt2(maxLength)(validators)(errMsg));
        });
      };
    };
  };
};
var parseSignedInt1 = /* @__PURE__ */ parseSignedInt(monadStateT3);
var parseDayOfWeekNameShort = function(dictMonad) {
  return oneOfAs3(dictMonad)(function($662) {
    return $$try4(string3($662));
  })([new Tuple("Mon", Monday.value), new Tuple("Tue", Tuesday.value), new Tuple("Wed", Wednesday.value), new Tuple("Thu", Thursday.value), new Tuple("Fri", Friday.value), new Tuple("Sat", Saturday.value), new Tuple("Sun", Sunday.value)]);
};
var parseDayOfWeekNameShort1 = /* @__PURE__ */ parseDayOfWeekNameShort(monadStateT3);
var parseDayOfWeekName = function(dictMonad) {
  return oneOfAs3(dictMonad)(function($663) {
    return $$try4(string3($663));
  })([new Tuple("Monday", Monday.value), new Tuple("Tuesday", Tuesday.value), new Tuple("Wednesday", Wednesday.value), new Tuple("Thursday", Thursday.value), new Tuple("Friday", Friday.value), new Tuple("Saturday", Saturday.value), new Tuple("Sunday", Sunday.value)]);
};
var parseDayOfWeekName1 = /* @__PURE__ */ parseDayOfWeekName(monadStateT3);
var padSingleDigit = function(i) {
  if (i < 0) {
    return "-" + padSingleDigit(-i | 0);
  }
  ;
  if (i < 10) {
    return "0" + show15(i);
  }
  ;
  if (otherwise) {
    return show15(i);
  }
  ;
  throw new Error("Failed pattern match at Data.Formatter.DateTime (line 194, column 1 - line 194, column 32): " + [i.constructor.name]);
};
var padQuadrupleDigit = function(i) {
  if (i < 0) {
    return "-" + padQuadrupleDigit(-i | 0);
  }
  ;
  if (i < 10) {
    return "000" + show15(i);
  }
  ;
  if (i < 100) {
    return "00" + show15(i);
  }
  ;
  if (i < 1e3) {
    return "0" + show15(i);
  }
  ;
  if (otherwise) {
    return show15(i);
  }
  ;
  throw new Error("Failed pattern match at Data.Formatter.DateTime (line 207, column 1 - line 207, column 35): " + [i.constructor.name]);
};
var padDoubleDigit = function(i) {
  if (i < 0) {
    return "-" + padDoubleDigit(-i | 0);
  }
  ;
  if (i < 10) {
    return "00" + show15(i);
  }
  ;
  if (i < 100) {
    return "0" + show15(i);
  }
  ;
  if (otherwise) {
    return show15(i);
  }
  ;
  throw new Error("Failed pattern match at Data.Formatter.DateTime (line 200, column 1 - line 200, column 32): " + [i.constructor.name]);
};
var initialAccum = /* @__PURE__ */ function() {
  return {
    year: Nothing.value,
    month: Nothing.value,
    day: Nothing.value,
    hour: Nothing.value,
    minute: Nothing.value,
    second: Nothing.value,
    millisecond: Nothing.value,
    meridiem: Nothing.value
  };
}();
var formatYearTwoDigits = function(i) {
  var dateString = show15(abs3(i));
  var dateLength = length4(dateString);
  if (dateLength === 1) {
    return "0" + dateString;
  }
  ;
  if (dateLength === 2) {
    return dateString;
  }
  ;
  return drop3(dateLength - 2 | 0)(dateString);
};
var fix12 = function(h) {
  var $618 = h === 0;
  if ($618) {
    return 12;
  }
  ;
  return h;
};
var formatCommand = function(v) {
  return function(v1) {
    if (v1 instanceof YearFull) {
      return padQuadrupleDigit(fromEnum8(year(v.value0)));
    }
    ;
    if (v1 instanceof YearTwoDigits) {
      return formatYearTwoDigits(fromEnum8(year(v.value0)));
    }
    ;
    if (v1 instanceof YearAbsolute) {
      return show15(fromEnum8(year(v.value0)));
    }
    ;
    if (v1 instanceof MonthFull) {
      return show16(month(v.value0));
    }
    ;
    if (v1 instanceof MonthShort) {
      return printShortMonth(month(v.value0));
    }
    ;
    if (v1 instanceof MonthTwoDigits) {
      return padSingleDigit(fromEnum1(month(v.value0)));
    }
    ;
    if (v1 instanceof DayOfMonthTwoDigits) {
      return padSingleDigit(fromEnum22(day(v.value0)));
    }
    ;
    if (v1 instanceof DayOfMonth) {
      return show15(fromEnum22(day(v.value0)));
    }
    ;
    if (v1 instanceof UnixTimestamp) {
      return show15(floor2(function(v2) {
        return v2 / 1e3;
      }(unwrap11(unInstant(fromDateTime(v))))));
    }
    ;
    if (v1 instanceof DayOfWeek) {
      return show15(fromEnum32(weekday(v.value0)));
    }
    ;
    if (v1 instanceof DayOfWeekName) {
      return show23(weekday(v.value0));
    }
    ;
    if (v1 instanceof DayOfWeekNameShort) {
      return take3(3)(show23(weekday(v.value0)));
    }
    ;
    if (v1 instanceof Hours24) {
      return padSingleDigit(fromEnum42(hour(v.value1)));
    }
    ;
    if (v1 instanceof Hours12) {
      return padSingleDigit(fix12(mod5(fromEnum42(hour(v.value1)))(12)));
    }
    ;
    if (v1 instanceof Meridiem) {
      var $621 = fromEnum42(hour(v.value1)) >= 12;
      if ($621) {
        return "PM";
      }
      ;
      return "AM";
    }
    ;
    if (v1 instanceof Minutes) {
      return show15(fromEnum52(minute(v.value1)));
    }
    ;
    if (v1 instanceof MinutesTwoDigits) {
      return padSingleDigit(fromEnum52(minute(v.value1)));
    }
    ;
    if (v1 instanceof Seconds) {
      return show15(fromEnum62(second(v.value1)));
    }
    ;
    if (v1 instanceof SecondsTwoDigits) {
      return padSingleDigit(fromEnum62(second(v.value1)));
    }
    ;
    if (v1 instanceof Milliseconds2) {
      return padDoubleDigit(fromEnum72(millisecond(v.value1)));
    }
    ;
    if (v1 instanceof MillisecondsShort) {
      return show15(function(v2) {
        return div1(v2)(100);
      }(fromEnum72(millisecond(v.value1))));
    }
    ;
    if (v1 instanceof MillisecondsTwoDigits) {
      return padSingleDigit(function(v2) {
        return div1(v2)(10);
      }(fromEnum72(millisecond(v.value1))));
    }
    ;
    if (v1 instanceof Placeholder) {
      return v1.value0;
    }
    ;
    throw new Error("Failed pattern match at Data.Formatter.DateTime (line 169, column 38 - line 192, column 21): " + [v1.constructor.name]);
  };
};
var format = function(f) {
  return function(d) {
    return foldMap15(formatCommand(d))(f);
  };
};
var exactLength = /* @__PURE__ */ bind16(ask2)(function(v) {
  return lift7(function() {
    var $626 = v.maxLength !== v.length;
    if ($626) {
      return new Left("Expected " + (show15(v.maxLength) + (" digits but got " + show15(v.length))));
    }
    ;
    return new Right(unit);
  }());
});
var unformatCommandParser = /* @__PURE__ */ function() {
  var modifyWithParser = function(f) {
    return function(p) {
      return bind17(p)(function(v) {
        return lift13(modify_4(flip(f)(new Just(v))));
      });
    };
  };
  return function(v) {
    if (v instanceof YearFull) {
      return modifyWithParser(function(v1) {
        return function(v2) {
          return {
            year: v2,
            day: v1.day,
            hour: v1.hour,
            meridiem: v1.meridiem,
            millisecond: v1.millisecond,
            minute: v1.minute,
            month: v1.month,
            second: v1.second
          };
        };
      })(parseSignedInt1(4)(exactLength)("Incorrect full year"));
    }
    ;
    if (v instanceof YearTwoDigits) {
      return modifyWithParser(function(v1) {
        return function(v2) {
          return {
            year: v2,
            day: v1.day,
            hour: v1.hour,
            meridiem: v1.meridiem,
            millisecond: v1.millisecond,
            minute: v1.minute,
            month: v1.month,
            second: v1.second
          };
        };
      })(parseSignedInt1(2)(exactLength)("Incorrect 2-digit year"));
    }
    ;
    if (v instanceof YearAbsolute) {
      return modifyWithParser(function(v1) {
        return function(v2) {
          return {
            year: v2,
            day: v1.day,
            hour: v1.hour,
            meridiem: v1.meridiem,
            millisecond: v1.millisecond,
            minute: v1.minute,
            month: v1.month,
            second: v1.second
          };
        };
      })(lift25(mul2)(option2(1)($$try4(mapFlipped4(string3("-"))($$const(-1 | 0)))))(mapFlipped4(some3(parseDigit2))(foldDigits2)));
    }
    ;
    if (v instanceof MonthFull) {
      return modifyWithParser(function(v1) {
        return function(v2) {
          return {
            month: v2,
            day: v1.day,
            hour: v1.hour,
            meridiem: v1.meridiem,
            millisecond: v1.millisecond,
            minute: v1.minute,
            second: v1.second,
            year: v1.year
          };
        };
      })(map38(fromEnum1)(parseMonth1));
    }
    ;
    if (v instanceof MonthShort) {
      return modifyWithParser(function(v1) {
        return function(v2) {
          return {
            month: v2,
            day: v1.day,
            hour: v1.hour,
            meridiem: v1.meridiem,
            millisecond: v1.millisecond,
            minute: v1.minute,
            second: v1.second,
            year: v1.year
          };
        };
      })(map38(fromEnum1)(parseShortMonth1));
    }
    ;
    if (v instanceof MonthTwoDigits) {
      return modifyWithParser(function(v1) {
        return function(v2) {
          return {
            month: v2,
            day: v1.day,
            hour: v1.hour,
            meridiem: v1.meridiem,
            millisecond: v1.millisecond,
            minute: v1.minute,
            second: v1.second,
            year: v1.year
          };
        };
      })(parseInt1(2)(append18(validateRange(1)(12))(exactLength))("Incorrect 2-digit month"));
    }
    ;
    if (v instanceof DayOfMonthTwoDigits) {
      return modifyWithParser(function(v1) {
        return function(v2) {
          return {
            day: v2,
            hour: v1.hour,
            meridiem: v1.meridiem,
            millisecond: v1.millisecond,
            minute: v1.minute,
            month: v1.month,
            second: v1.second,
            year: v1.year
          };
        };
      })(parseInt1(2)(append18(validateRange(1)(31))(exactLength))("Incorrect day of month"));
    }
    ;
    if (v instanceof DayOfMonth) {
      return modifyWithParser(function(v1) {
        return function(v2) {
          return {
            day: v2,
            hour: v1.hour,
            meridiem: v1.meridiem,
            millisecond: v1.millisecond,
            minute: v1.minute,
            month: v1.month,
            second: v1.second,
            year: v1.year
          };
        };
      })(parseInt1(2)(validateRange(1)(31))("Incorrect day of month"));
    }
    ;
    if (v instanceof UnixTimestamp) {
      return bind17(map38(foldDigits2)(some3(parseDigit2)))(function(s) {
        var v1 = map116(toDateTime)(instant(1e3 * toNumber2(s)));
        if (v1 instanceof Nothing) {
          return fail2("Incorrect timestamp");
        }
        ;
        if (v1 instanceof Just) {
          return lift13(put2({
            year: new Just(fromEnum8(year(v1.value0.value0))),
            month: new Just(fromEnum1(month(v1.value0.value0))),
            day: new Just(fromEnum22(day(v1.value0.value0))),
            hour: new Just(fromEnum42(hour(v1.value0.value1))),
            minute: new Just(fromEnum52(minute(v1.value0.value1))),
            second: new Just(fromEnum62(second(v1.value0.value1))),
            millisecond: new Just(fromEnum72(millisecond(v1.value0.value1))),
            meridiem: Nothing.value
          }));
        }
        ;
        throw new Error("Failed pattern match at Data.Formatter.DateTime (line 369, column 5 - line 380, column 10): " + [v1.constructor.name]);
      });
    }
    ;
    if (v instanceof DayOfWeek) {
      return $$void11(parseInt1(1)(validateRange(1)(7))("Incorrect day of week"));
    }
    ;
    if (v instanceof DayOfWeekName) {
      return modifyWithParser(function(v1) {
        return function(v2) {
          return {
            day: v2,
            hour: v1.hour,
            meridiem: v1.meridiem,
            millisecond: v1.millisecond,
            minute: v1.minute,
            month: v1.month,
            second: v1.second,
            year: v1.year
          };
        };
      })(map38(fromEnum32)(parseDayOfWeekName1));
    }
    ;
    if (v instanceof DayOfWeekNameShort) {
      return modifyWithParser(function(v1) {
        return function(v2) {
          return {
            day: v2,
            hour: v1.hour,
            meridiem: v1.meridiem,
            millisecond: v1.millisecond,
            minute: v1.minute,
            month: v1.month,
            second: v1.second,
            year: v1.year
          };
        };
      })(map38(fromEnum32)(parseDayOfWeekNameShort1));
    }
    ;
    if (v instanceof Hours24) {
      return modifyWithParser(function(v1) {
        return function(v2) {
          return {
            hour: v2,
            day: v1.day,
            meridiem: v1.meridiem,
            millisecond: v1.millisecond,
            minute: v1.minute,
            month: v1.month,
            second: v1.second,
            year: v1.year
          };
        };
      })(parseInt1(2)(append18(validateRange(0)(24))(exactLength))("Incorrect 24 hour"));
    }
    ;
    if (v instanceof Hours12) {
      return modifyWithParser(function(v1) {
        return function(v2) {
          return {
            hour: v2,
            day: v1.day,
            meridiem: v1.meridiem,
            millisecond: v1.millisecond,
            minute: v1.minute,
            month: v1.month,
            second: v1.second,
            year: v1.year
          };
        };
      })(parseInt1(2)(append18(validateRange(0)(12))(exactLength))("Incorrect 12 hour"));
    }
    ;
    if (v instanceof Meridiem) {
      return modifyWithParser(function(v1) {
        return function(v2) {
          return {
            meridiem: v2,
            day: v1.day,
            hour: v1.hour,
            millisecond: v1.millisecond,
            minute: v1.minute,
            month: v1.month,
            second: v1.second,
            year: v1.year
          };
        };
      })(parseMeridiem1);
    }
    ;
    if (v instanceof MinutesTwoDigits) {
      return modifyWithParser(function(v1) {
        return function(v2) {
          return {
            minute: v2,
            day: v1.day,
            hour: v1.hour,
            meridiem: v1.meridiem,
            millisecond: v1.millisecond,
            month: v1.month,
            second: v1.second,
            year: v1.year
          };
        };
      })(parseInt1(2)(append18(validateRange(0)(59))(exactLength))("Incorrect 2-digit minute"));
    }
    ;
    if (v instanceof Minutes) {
      return modifyWithParser(function(v1) {
        return function(v2) {
          return {
            minute: v2,
            day: v1.day,
            hour: v1.hour,
            meridiem: v1.meridiem,
            millisecond: v1.millisecond,
            month: v1.month,
            second: v1.second,
            year: v1.year
          };
        };
      })(parseInt1(2)(validateRange(0)(59))("Incorrect minute"));
    }
    ;
    if (v instanceof SecondsTwoDigits) {
      return modifyWithParser(function(v1) {
        return function(v2) {
          return {
            second: v2,
            day: v1.day,
            hour: v1.hour,
            meridiem: v1.meridiem,
            millisecond: v1.millisecond,
            minute: v1.minute,
            month: v1.month,
            year: v1.year
          };
        };
      })(parseInt1(2)(append18(validateRange(0)(59))(exactLength))("Incorrect 2-digit second"));
    }
    ;
    if (v instanceof Seconds) {
      return modifyWithParser(function(v1) {
        return function(v2) {
          return {
            second: v2,
            day: v1.day,
            hour: v1.hour,
            meridiem: v1.meridiem,
            millisecond: v1.millisecond,
            minute: v1.minute,
            month: v1.month,
            year: v1.year
          };
        };
      })(parseInt1(2)(validateRange(0)(59))("Incorrect second"));
    }
    ;
    if (v instanceof Milliseconds2) {
      return modifyWithParser(function(v1) {
        return function(v2) {
          return {
            millisecond: v2,
            day: v1.day,
            hour: v1.hour,
            meridiem: v1.meridiem,
            minute: v1.minute,
            month: v1.month,
            second: v1.second,
            year: v1.year
          };
        };
      })(parseInt1(3)(exactLength)("Incorrect millisecond"));
    }
    ;
    if (v instanceof Placeholder) {
      return $$void11(string3(v.value0));
    }
    ;
    if (v instanceof MillisecondsShort) {
      return modifyWithParser(function(v1) {
        return function(v2) {
          return {
            millisecond: v2,
            day: v1.day,
            hour: v1.hour,
            meridiem: v1.meridiem,
            minute: v1.minute,
            month: v1.month,
            second: v1.second,
            year: v1.year
          };
        };
      })(mapFlipped4(parseInt1(1)(exactLength)("Incorrect 1-digit millisecond"))(function(v1) {
        return v1 * 100 | 0;
      }));
    }
    ;
    if (v instanceof MillisecondsTwoDigits) {
      return modifyWithParser(function(v1) {
        return function(v2) {
          return {
            millisecond: v2,
            day: v1.day,
            hour: v1.hour,
            meridiem: v1.meridiem,
            minute: v1.minute,
            month: v1.month,
            second: v1.second,
            year: v1.year
          };
        };
      })(mapFlipped4(parseInt1(2)(exactLength)("Incorrect 2-digit millisecond"))(function(v1) {
        return v1 * 10 | 0;
      }));
    }
    ;
    throw new Error("Failed pattern match at Data.Formatter.DateTime (line 347, column 25 - line 406, column 74): " + [v.constructor.name]);
  };
}();
var adjustMeridiem = function(v) {
  return function(v1) {
    if (v instanceof Just && (v.value0 instanceof AM && v1 === 12)) {
      return 0;
    }
    ;
    if (v instanceof Just && (v.value0 instanceof PM && v1 === 12)) {
      return 12;
    }
    ;
    if (v instanceof Just && v.value0 instanceof PM) {
      return v1 + 12 | 0;
    }
    ;
    if (v instanceof Just && v.value0 instanceof AM) {
      return v1;
    }
    ;
    if (v instanceof Nothing && v1 === 24) {
      return 0;
    }
    ;
    if (v instanceof Nothing) {
      return v1;
    }
    ;
    throw new Error("Failed pattern match at Data.Formatter.DateTime (line 279, column 1 - line 279, column 47): " + [v.constructor.name, v1.constructor.name]);
  };
};
var adjustDay = function(v) {
  return function(v1) {
    if (v instanceof Just && v.value0 === 24) {
      return v1 + 1 | 0;
    }
    ;
    return v1;
  };
};
var unformatAccumToDateTime = function(a) {
  return applySecond2(validAccum(a))(apply15(map212(DateTime.create)(apply15(apply15(map212(canonicalDate)(maybe(new Left("Incorrect year"))(pure27)(toEnum5(fromMaybe(0)(a.year)))))(maybe(new Left("Incorrect month"))(pure27)(toEnum1(fromMaybe(1)(a.month)))))(maybe(new Left("Incorrect day"))(pure27)(toEnum23(adjustDay(a.hour)(fromMaybe(1)(a.day)))))))(apply15(apply15(apply15(map212(Time.create)(maybe(new Left("Incorrect hour"))(pure27)(toEnum32(fromMaybe(0)(map116(adjustMeridiem(a.meridiem))(a.hour))))))(maybe(new Left("Incorrect minute"))(pure27)(toEnum42(fromMaybe(0)(a.minute)))))(maybe(new Left("Incorrect second"))(pure27)(toEnum52(fromMaybe(0)(a.second)))))(maybe(new Left("Incorrect millisecond"))(pure27)(toEnum6(fromMaybe(0)(a.millisecond))))));
};
var unformatParser = function(dictMonad) {
  var mapParserT1 = mapParserT2(dictMonad.Bind1().Apply0().Functor0());
  return function(f) {
    var unState = function(dictMonad1) {
      var pure211 = pure(dictMonad1.Applicative0());
      return function(s) {
        var v = runState(s)(initialAccum);
        return pure211(new Tuple(voidLeft4(v.value0.value0)(v.value1), v.value0.value1));
      };
    };
    return bind17(mapParserT1(unState(dictMonad))(foldMap22(unformatCommandParser)(f)))(function(acc) {
      return either(fail2)(pure113)(unformatAccumToDateTime(acc));
    });
  };
};
var unformat = /* @__PURE__ */ function() {
  var $665 = unformatParser(monadIdentity);
  return function($666) {
    return runP2($665($666));
  };
}();

// output/Parsing.Combinators.Array/index.js
var bind18 = /* @__PURE__ */ bind(bindParserT);
var tailRecM4 = /* @__PURE__ */ tailRecM(monadRecParserT);
var alt9 = /* @__PURE__ */ alt(altParserT);
var pure28 = /* @__PURE__ */ pure(applicativeParserT);
var fromFoldable15 = /* @__PURE__ */ fromFoldable(foldableList);
var manyTill_ = function(p) {
  return function(end4) {
    return bind18(flip(tailRecM4)(Nil.value)(function(xs) {
      return alt9(bind18(end4)(function(t) {
        return pure28(new Done(new Tuple(xs, t)));
      }))(bind18(p)(function(x) {
        return pure28(new Loop(new Cons(x, xs)));
      }));
    }))(function(v) {
      return pure28(new Tuple(reverse(fromFoldable15(v.value0)), v.value1));
    });
  };
};
var many4 = function(p) {
  return bind18(flip(tailRecM4)(Nil.value)(function(xs) {
    return alt9(bind18($$try4(p))(function(x) {
      return pure28(new Loop(new Cons(x, xs)));
    }))(pure28(new Done(xs)));
  }))(function(rlist) {
    return pure28(reverse(fromFoldable15(rlist)));
  });
};
var many1 = function(p) {
  return bind18(many4(p))(function(xs) {
    var v = fromArray(xs);
    if (v instanceof Nothing) {
      return fail2("Expected at least 1");
    }
    ;
    if (v instanceof Just) {
      return pure28(v.value0);
    }
    ;
    throw new Error("Failed pattern match at Parsing.Combinators.Array (line 52, column 3 - line 54, column 25): " + [v.constructor.name]);
  });
};

// output/Registry.Internal.Parsing/index.js
var bind19 = /* @__PURE__ */ bind(bindParserT);
var alt10 = /* @__PURE__ */ alt(altParserT);
var voidLeft5 = /* @__PURE__ */ voidLeft(functorParserT);
var pure29 = /* @__PURE__ */ pure(applicativeParserT);
var applySecond3 = /* @__PURE__ */ applySecond(applyParserT);
var mapFlipped5 = /* @__PURE__ */ mapFlipped(functorParserT);
var show17 = /* @__PURE__ */ show(showInt);
var fold10 = /* @__PURE__ */ fold2(monoidString);
var gitUrl = /* @__PURE__ */ bind19(getParserT)(function(v) {
  return bind19(alt10(string3("git"))(alt10(string3("https"))(string3("http"))))(function() {
    return bind19(string3("://"))(function() {
      return bind19(function() {
        var terminator = alt10(voidLeft5(string3(".git"))(false))(voidLeft5(eof)(true));
        var matcher = alt10(alphaNum)(oneOf3([".", "/", "@", "_", "-", "~"]));
        return manyTill_(matcher)(terminator);
      }())(function(v1) {
        if (v1.value1) {
          return pure29(v.value0);
        }
        ;
        return bind19(optional2($$try4($$char3("/"))))(function() {
          return bind19(eof)(function() {
            return pure29(v.value0);
          });
        });
      });
    });
  });
});
var charsUntil = /* @__PURE__ */ function() {
  var $28 = map(functorParserT)(fst);
  var $29 = manyTill_(anyChar);
  return function($30) {
    return $28($29($30));
  };
}();
var charsUntilSpace = /* @__PURE__ */ charsUntil(/* @__PURE__ */ $$char3(" "));
var rfc3339 = /* @__PURE__ */ bind19(/* @__PURE__ */ takeN(4))(function(year2) {
  return bind19($$char3("-"))(function() {
    return bind19(takeN(2))(function(month2) {
      return bind19($$char3("-"))(function() {
        return bind19(takeN(2))(function(day2) {
          return bind19($$char3("T"))(function() {
            return bind19(takeN(2))(function(hour2) {
              return bind19($$char3(":"))(function() {
                return bind19(takeN(2))(function(minute2) {
                  return bind19($$char3(":"))(function() {
                    return bind19(takeN(2))(function(second3) {
                      return bind19(bind19(optionMaybe($$char3(".")))(function(v) {
                        if (v instanceof Nothing) {
                          return applySecond3($$char3("Z"))(pure29("000"));
                        }
                        ;
                        if (v instanceof Just) {
                          return mapFlipped5(charsUntil($$char3("Z")))(fromCharArray);
                        }
                        ;
                        throw new Error("Failed pattern match at Registry.Internal.Parsing (line 60, column 82 - line 62, column 79): " + [v.constructor.name]);
                      }))(function(milliseconds$prime) {
                        return bind19(function() {
                          var v = length4(milliseconds$prime);
                          if (v === 0) {
                            return pure29("000");
                          }
                          ;
                          if (v === 1) {
                            return pure29(milliseconds$prime + "00");
                          }
                          ;
                          if (v === 2) {
                            return pure29(milliseconds$prime + "0");
                          }
                          ;
                          if (v === 3) {
                            return pure29(milliseconds$prime);
                          }
                          ;
                          return fail2("Expected milliseconds with length 0-3, but received milliseconds with length: " + show17(v));
                        }())(function(milliseconds) {
                          return pure29({
                            date: fold10([year2, "-", month2, "-", day2]),
                            time: fold10([hour2, ":", minute2, ":", second3]),
                            milliseconds
                          });
                        });
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
  });
});
var chars = /* @__PURE__ */ many(alternativeParserT)(lazyParserT)(anyChar);

// output/Registry.Internal.Format/index.js
var bind20 = /* @__PURE__ */ bind(bindEither);
var lmap4 = /* @__PURE__ */ lmap(bifunctorEither);
var pure30 = /* @__PURE__ */ pure(applicativeEither);
var fold11 = /* @__PURE__ */ fold2(monoidString);
var fromFoldable16 = /* @__PURE__ */ fromFoldable5(foldableArray);
var rfc3339ToISO8601 = function(input) {
  return bind20(lmap4(parseErrorMessage)(runParser2(input)(rfc3339)))(function(v) {
    return pure30(fold11([v.date, "T", v.time, ".", v.milliseconds, "Z"]));
  });
};
var iso8601Date = /* @__PURE__ */ function() {
  return fromFoldable16([YearFull.value, new Placeholder("-"), MonthTwoDigits.value, new Placeholder("-"), DayOfMonthTwoDigits.value]);
}();
var iso8601DateTime = /* @__PURE__ */ function() {
  var utcFormat = fromFoldable16([Milliseconds2.value, new Placeholder("Z")]);
  var timeFormat = fromFoldable16([Hours24.value, new Placeholder(":"), MinutesTwoDigits.value, new Placeholder(":"), SecondsTwoDigits.value]);
  return fold(foldableArray)(monoidList)([iso8601Date, singleton8(new Placeholder("T")), timeFormat, singleton8(new Placeholder(".")), utcFormat]);
}();

// output/Registry.PackageName/index.js
var bind21 = /* @__PURE__ */ bind(bindParserT);
var elem4 = /* @__PURE__ */ elem2(eqString);
var discard5 = /* @__PURE__ */ discard(discardUnit)(bindParserT);
var when3 = /* @__PURE__ */ when(applicativeParserT);
var alt11 = /* @__PURE__ */ alt(altParserT);
var choice2 = /* @__PURE__ */ choice(foldableArray);
var pure31 = /* @__PURE__ */ pure(applicativeParserT);
var applySecond4 = /* @__PURE__ */ applySecond(applyParserT);
var map39 = /* @__PURE__ */ map(functorParserT);
var ordPackageName = ordString;
var eqPackageName = eqString;
var stripPureScriptPrefix = function(pkg) {
  return fromMaybe(pkg)(stripPrefix("purescript-")(pkg));
};
var print2 = function(v) {
  return v;
};
var parser = /* @__PURE__ */ bind21(getParserT)(function(v) {
  var hasPureScriptPrefix = isJust(stripPrefix("purescript-")(v.value0));
  var allowedPrefixNames = ["purescript-compiler-backend-utilities"];
  var isBlessedPackage = elem4(v.value0)(allowedPrefixNames);
  return discard5(when3(hasPureScriptPrefix && !isBlessedPackage)(fail2("Package names should not begin with 'purescript-'")))(function() {
    var acceptedChars = alt11(choice2([lower2, digit]))(fail2("Package name can contain lower case chars, digits and non-consecutive dashes"));
    var chunk1 = many1(acceptedChars);
    return bind21(alt11(chunk1)(fail2("Package name should start with a lower case char or a digit")))(function(firstChunk) {
      return bind21(bind21(flip(manyTill_)(eof)(bind21(alt11($$char3("-"))(fail2("Package name can contain lower case chars, digits and non-consecutive dashes")))(function() {
        return bind21(bind21(optionMaybe(lookAhead(anyChar)))(function(v1) {
          if (v1 instanceof Just) {
            if (v1.value0 === "-") {
              return fail2("Package names cannot contain consecutive dashes");
            }
            ;
            if (otherwise) {
              return pure31(unit);
            }
            ;
          }
          ;
          if (v1 instanceof Nothing) {
            return applySecond4(lookAhead(eof))(fail2("Package name should end with a lower case char or digit"));
          }
          ;
          throw new Error("Failed pattern match at Registry.PackageName (line 102, column 103 - line 106, column 91): " + [v1.constructor.name]);
        }))(function() {
          return alt11(map39(cons2("-"))(chunk1))(fail2("Package name should end with a lower case char or digit"));
        });
      })))(function(chunks) {
        return pure31(fst(chunks));
      }))(function(nextChunks) {
        return discard5(alt11(eof)(fail2("Package name can contain lower case chars, digits and non-consecutive dashes")))(function() {
          var allChunks = concatMap(toArray)(cons(firstChunk)(nextChunks));
          var name4 = fromCharArray(allChunks);
          var $25 = $$null2(name4);
          if ($25) {
            return fail2("Package name cannot be empty");
          }
          ;
          var $26 = length4(name4) > 50;
          if ($26) {
            return fail2("Package name cannot be longer than 50 characters");
          }
          ;
          return pure31(name4);
        });
      });
    });
  });
});
var parse3 = /* @__PURE__ */ function() {
  var $30 = lmap(bifunctorEither)(parseErrorMessage);
  var $31 = flip(runParser2)(parser);
  return function($32) {
    return $30($31($32));
  };
}();
var codec2 = /* @__PURE__ */ prismaticCodec("PackageName")(function($33) {
  return hush(parse3($33));
})(print2)(string);

// output/Registry.Version/index.js
var compare7 = /* @__PURE__ */ compare(ordInt);
var map40 = /* @__PURE__ */ map(functorArray);
var bind23 = /* @__PURE__ */ bind(bindParserT);
var pure33 = /* @__PURE__ */ pure(applicativeParserT);
var discard6 = /* @__PURE__ */ discard(discardUnit)(bindParserT);
var when4 = /* @__PURE__ */ when(applicativeParserT);
var show18 = /* @__PURE__ */ show(showInt);
var eqVersion = {
  eq: function(v) {
    return function(v1) {
      var v2 = v.major === v1.major;
      if (v2) {
        var v3 = v.minor === v1.minor;
        if (v3) {
          return v.patch === v1.patch;
        }
        ;
        return v3;
      }
      ;
      return v2;
    };
  }
};
var ordVersion = {
  compare: function(v) {
    return function(v1) {
      var v2 = compare7(v.major)(v1.major);
      if (v2 instanceof EQ) {
        var v3 = compare7(v.minor)(v1.minor);
        if (v3 instanceof EQ) {
          return compare7(v.patch)(v1.patch);
        }
        ;
        return v3;
      }
      ;
      return v2;
    };
  },
  Eq0: function() {
    return eqVersion;
  }
};
var print3 = function(v) {
  var places = map40(toStringAs(decimal))([v.major, v.minor, v.patch]);
  return joinWith(".")(places);
};
var patch = function(v) {
  return v.patch;
};
var parser2 = /* @__PURE__ */ function() {
  var nonNegativeInt = bind23(many1(digit))(function(digitChars) {
    var zeroCount = length(takeWhile2(function(v) {
      return v === "0";
    })(digitChars));
    var digitString = fromCharArray(toArray(digitChars));
    var failInteger = fail2("Invalid 32-bit integer: " + digitString);
    return bind23(maybe(failInteger)(pure33)(fromString2(digitString)))(function(integer) {
      return discard6(when4(zeroCount > 1 || zeroCount === 1 && integer !== 0)(fail2("Leading zeros are not allowed: " + digitString)))(function() {
        return discard6(when4(integer < 0)(fail2("Invalid non-negative integer: " + show18(integer))))(function() {
          return pure33(integer);
        });
      });
    });
  });
  return bind23(nonNegativeInt)(function(major$prime) {
    return bind23($$char3("."))(function() {
      return bind23(nonNegativeInt)(function(minor$prime) {
        return bind23($$char3("."))(function() {
          return bind23(nonNegativeInt)(function(patch$prime) {
            return discard6(eof)(function() {
              return pure33({
                major: major$prime,
                minor: minor$prime,
                patch: patch$prime
              });
            });
          });
        });
      });
    });
  });
}();
var parse4 = /* @__PURE__ */ function() {
  var $64 = lmap(bifunctorEither)(parseErrorMessage);
  var $65 = flip(runParser2)(parser2);
  return function($66) {
    return $64($65($66));
  };
}();
var minor = function(v) {
  return v.minor;
};
var major = function(v) {
  return v.major;
};
var codec3 = /* @__PURE__ */ prismaticCodec("Version")(function($67) {
  return hush(parse4($67));
})(print3)(string);
var bumpPatch = function(v) {
  return {
    major: v.major,
    minor: v.minor,
    patch: v.patch + 1 | 0
  };
};
var bumpMinor = function(v) {
  return {
    major: v.major,
    minor: v.minor + 1 | 0,
    patch: 0
  };
};
var bumpMajor = function(v) {
  return {
    major: v.major + 1 | 0,
    minor: 0,
    patch: 0
  };
};
var bumpHighest = function(v) {
  var $62 = v.major >= 1;
  if ($62) {
    return bumpMajor(v);
  }
  ;
  var $63 = v.minor >= 1;
  if ($63) {
    return bumpMinor(v);
  }
  ;
  return bumpPatch(v);
};

// output/Registry.Internal.Codec/index.js
var forWithIndex_2 = /* @__PURE__ */ forWithIndex_(applicativeST)(foldableWithIndexMap);
var bind110 = /* @__PURE__ */ bind(bindEither);
var map41 = /* @__PURE__ */ map(functorEither);
var toUnfoldable10 = /* @__PURE__ */ toUnfoldable3(unfoldableArray);
var $$for2 = /* @__PURE__ */ $$for(applicativeEither)(traversableArray);
var lmap5 = /* @__PURE__ */ lmap(bifunctorEither);
var pure114 = /* @__PURE__ */ pure(applicativeEither);
var append10 = /* @__PURE__ */ append(semigroupString);
var strMap = function(dictOrd) {
  var fromFoldable36 = fromFoldable6(dictOrd)(foldableArray);
  return function(type_) {
    return function(parse10) {
      return function(print9) {
        return function(valueCodec) {
          var encode3 = function(m) {
            return encode(jobject)(runST(function __do3() {
              var obj = newImpl();
              forWithIndex_2(m)(function(k) {
                return function(v) {
                  return poke2(print9(k))(encode(valueCodec)(v))(obj);
                };
              })();
              return obj;
            }));
          };
          var decode2 = function(json4) {
            return bind110(map41(toUnfoldable10)(decode(jobject)(json4)))(function(v) {
              return bind110($$for2(v)(function(v1) {
                return bind110(note(new AtKey(v1.value0, new TypeMismatch(type_)))(parse10(v1.value0)))(function(key) {
                  return bind110(lmap5(AtKey.create(v1.value0))(decode(valueCodec)(v1.value1)))(function(val) {
                    return pure114(new Tuple(key, val));
                  });
                });
              }))(function(parsed) {
                return pure114(fromFoldable36(parsed));
              });
            });
          };
          return codec$prime(decode2)(encode3);
        };
      };
    };
  };
};
var versionMap = /* @__PURE__ */ strMap(ordVersion)("Version")(function($38) {
  return hush(parse4($38));
})(print3);
var parsedString = function(label) {
  return function(parser5) {
    var encode3 = encode(string);
    var decode2 = function(json4) {
      return bind110(decode(string)(json4))(function(string7) {
        var v = runParser2(string7)(parser5);
        if (v instanceof Left) {
          return new Left(new TypeMismatch(label + (": " + parseErrorMessage(v.value0))));
        }
        ;
        if (v instanceof Right) {
          return pure114(v.value0);
        }
        ;
        throw new Error("Failed pattern match at Registry.Internal.Codec (line 116, column 5 - line 118, column 32): " + [v.constructor.name]);
      });
    };
    return codec$prime(decode2)(encode3);
  };
};
var packageMap = /* @__PURE__ */ strMap(ordPackageName)("PackageName")(function($39) {
  return hush(parse3($39));
})(print2);
var limitedString = function(limit) {
  var encode3 = encode(string);
  var decode2 = function(json4) {
    return bind110(decode(string)(json4))(function(string7) {
      var $34 = length4(string7) > limit;
      if ($34) {
        return new Left(new TypeMismatch("LimitedString: Exceeds limit of " + (toStringAs(decimal)(limit) + " characters.")));
      }
      ;
      return new Right(string7);
    });
  };
  return codec$prime(decode2)(encode3);
};
var iso8601DateTime2 = /* @__PURE__ */ function() {
  var encode3 = function() {
    var $40 = encode(string);
    var $41 = format(iso8601DateTime);
    return function($42) {
      return $40($41($42));
    };
  }();
  var decode2 = function(json4) {
    return bind110(decode(string)(json4))(function(string7) {
      var v = rfc3339ToISO8601(string7);
      if (v instanceof Left) {
        return new Left(new TypeMismatch("Unable to parse input as ISO8601: " + v.value0));
      }
      ;
      if (v instanceof Right) {
        return lmap5(function() {
          var $43 = append10("ISO8601: ");
          return function($44) {
            return TypeMismatch.create($43($44));
          };
        }())(unformat(iso8601DateTime)(v.value0));
      }
      ;
      throw new Error("Failed pattern match at Registry.Internal.Codec (line 62, column 5 - line 65, column 122): " + [v.constructor.name]);
    });
  };
  return codec$prime(decode2)(encode3);
}();

// output/Registry.License/foreign.js
var import_spdx_expression_parse = __toESM(require_spdx_expression_parse(), 1);
var parseSPDXLicenseIdImpl = (onError3, onSuccess, identifier) => {
  try {
    (0, import_spdx_expression_parse.default)(identifier);
    return onSuccess(identifier);
  } catch (_) {
    return onError3(`Invalid SPDX identifier ${identifier}`);
  }
};

// output/Registry.License/index.js
var License = function(x) {
  return x;
};
var print4 = function(v) {
  return v;
};
var parse6 = /* @__PURE__ */ function() {
  return runFn3(parseSPDXLicenseIdImpl)(Left.create)(function($12) {
    return Right.create(License($12));
  });
}();
var codec4 = /* @__PURE__ */ prismaticCodec("License")(function($17) {
  return hush(parse6($17));
})(print4)(string);

// output/Data.Codec.Argonaut.Record/index.js
var coerce3 = /* @__PURE__ */ coerce();
var Optional = function(x) {
  return x;
};
var rowListCodecNil = {
  rowListCodec: function(v) {
    return function(v1) {
      return record;
    };
  }
};
var rowListCodec = function(dict) {
  return dict.rowListCodec;
};
var rowListCodecCons = function(dictRowListCodec) {
  var rowListCodec1 = rowListCodec(dictRowListCodec);
  return function() {
    return function() {
      return function(dictIsSymbol) {
        var get7 = get3(dictIsSymbol)();
        var recordProp4 = recordProp(dictIsSymbol)();
        return {
          rowListCodec: function(v) {
            return function(codecs) {
              var tail3 = rowListCodec1($$Proxy.value)(codecs);
              var codec11 = get7($$Proxy.value)(codecs);
              return recordProp4($$Proxy.value)(codec11)(tail3);
            };
          }
        };
      };
    };
  };
};
var rowListCodecConsOptional = function(dictRowListCodec) {
  var rowListCodec1 = rowListCodec(dictRowListCodec);
  return function() {
    return function() {
      return function(dictIsSymbol) {
        var get7 = get3(dictIsSymbol)();
        var recordPropOptional2 = recordPropOptional(dictIsSymbol)();
        return {
          rowListCodec: function(v) {
            return function(codecs) {
              var tail3 = rowListCodec1($$Proxy.value)(codecs);
              var codec11 = coerce3(get7($$Proxy.value)(codecs));
              return recordPropOptional2($$Proxy.value)(codec11)(tail3);
            };
          }
        };
      };
    };
  };
};
var record2 = function() {
  return function(dictRowListCodec) {
    return rowListCodec(dictRowListCodec)($$Proxy.value);
  };
};
var record1 = /* @__PURE__ */ record2();
var optional3 = Optional;
var object2 = function() {
  return function(dictRowListCodec) {
    var record22 = record1(dictRowListCodec);
    return function(name4) {
      return function(rec) {
        return object(name4)(record22(rec));
      };
    };
  };
};

// output/Registry.Location/index.js
var eq7 = /* @__PURE__ */ eq(/* @__PURE__ */ eqMaybe(eqString));
var dimap2 = /* @__PURE__ */ dimap(/* @__PURE__ */ profunctorCodec(functorEither));
var object3 = /* @__PURE__ */ object2();
var rowListCodecCons2 = /* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecConsOptional(rowListCodecNil)()()({
  reflectSymbol: function() {
    return "subdir";
  }
}))()();
var alt14 = /* @__PURE__ */ alt(altEither);
var lmap6 = /* @__PURE__ */ lmap(bifunctorEither);
var map44 = /* @__PURE__ */ map(functorEither);
var Git = /* @__PURE__ */ function() {
  function Git2(value0) {
    this.value0 = value0;
  }
  ;
  Git2.create = function(value0) {
    return new Git2(value0);
  };
  return Git2;
}();
var GitHub = /* @__PURE__ */ function() {
  function GitHub2(value0) {
    this.value0 = value0;
  }
  ;
  GitHub2.create = function(value0) {
    return new GitHub2(value0);
  };
  return GitHub2;
}();
var eqLocation = {
  eq: function(x) {
    return function(y) {
      if (x instanceof Git && y instanceof Git) {
        return eq7(x.value0.subdir)(y.value0.subdir) && x.value0.url === y.value0.url;
      }
      ;
      if (x instanceof GitHub && y instanceof GitHub) {
        return x.value0.owner === y.value0.owner && x.value0.repo === y.value0.repo && eq7(x.value0.subdir)(y.value0.subdir);
      }
      ;
      return false;
    };
  }
};
var githubCodec = /* @__PURE__ */ function() {
  var toJsonRep = function(v) {
    return {
      githubOwner: v.owner,
      githubRepo: v.repo,
      subdir: v.subdir
    };
  };
  var fromJsonRep = function(v) {
    return {
      owner: v.githubOwner,
      repo: v.githubRepo,
      subdir: v.subdir
    };
  };
  return dimap2(toJsonRep)(fromJsonRep)(object3(rowListCodecCons(rowListCodecCons2({
    reflectSymbol: function() {
      return "githubRepo";
    }
  }))()()({
    reflectSymbol: function() {
      return "githubOwner";
    }
  }))("GitHub")({
    githubOwner: string,
    githubRepo: string,
    subdir: optional3(string)
  }));
}();
var gitCodec = /* @__PURE__ */ function() {
  var toJsonRep = function(v) {
    return {
      gitUrl: v.url,
      subdir: v.subdir
    };
  };
  var fromJsonRep = function(v) {
    return {
      url: v.gitUrl,
      subdir: v.subdir
    };
  };
  return dimap2(toJsonRep)(fromJsonRep)(object3(rowListCodecCons2({
    reflectSymbol: function() {
      return "gitUrl";
    }
  }))("Git")({
    gitUrl: parsedString("GitUrl")(gitUrl),
    subdir: optional3(string)
  }));
}();
var codec5 = /* @__PURE__ */ function() {
  var encode3 = function(v) {
    if (v instanceof Git) {
      return encode(gitCodec)(v.value0);
    }
    ;
    if (v instanceof GitHub) {
      return encode(githubCodec)(v.value0);
    }
    ;
    throw new Error("Failed pattern match at Registry.Location (line 45, column 12 - line 47, column 50): " + [v.constructor.name]);
  };
  var decode2 = function(json4) {
    return alt14(lmap6($$const(new TypeMismatch("Location")))(map44(Git.create)(decode(gitCodec)(json4))))(map44(GitHub.create)(decode(githubCodec)(json4)));
  };
  return codec$prime(decode2)(encode3);
}();

// output/Registry.Owner/index.js
var publicIsSymbol = {
  reflectSymbol: function() {
    return "public";
  }
};
var keytypeIsSymbol = {
  reflectSymbol: function() {
    return "keytype";
  }
};
var idIsSymbol = {
  reflectSymbol: function() {
    return "id";
  }
};
var Owner = function(x) {
  return x;
};
var codec6 = /* @__PURE__ */ wrapIso(/* @__PURE__ */ profunctorCodec(functorEither))()(Owner)(/* @__PURE__ */ object2()(/* @__PURE__ */ rowListCodecConsOptional(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(rowListCodecNil)()()(publicIsSymbol))()()(keytypeIsSymbol))()()(idIsSymbol))("Owner")({
  id: /* @__PURE__ */ optional3(string),
  keytype: string,
  "public": string
}));

// output/Registry.Range/index.js
var min6 = /* @__PURE__ */ min(ordVersion);
var max5 = /* @__PURE__ */ max(ordVersion);
var fold14 = /* @__PURE__ */ fold2(monoidString);
var liftEither2 = /* @__PURE__ */ liftEither(monadThrowParseErrorParse);
var bind24 = /* @__PURE__ */ bind(bindParserT);
var alt15 = /* @__PURE__ */ alt(altParserT);
var bindFlipped6 = /* @__PURE__ */ bindFlipped(bindParserT);
var map45 = /* @__PURE__ */ map(functorParserT);
var discard7 = /* @__PURE__ */ discard(discardUnit)(bindParserT);
var greaterThanOrEq1 = /* @__PURE__ */ greaterThanOrEq(ordVersion);
var pure34 = /* @__PURE__ */ pure(applicativeParserT);
var lessThan1 = /* @__PURE__ */ lessThan(ordVersion);
var eqRange = {
  eq: /* @__PURE__ */ on(/* @__PURE__ */ eq(/* @__PURE__ */ eqArray(eqVersion)))(function(v) {
    return [v.lhs, v.rhs];
  })
};
var print5 = function(v) {
  return fold14([">=", print3(v.lhs), " <", print3(v.rhs)]);
};
var parser3 = /* @__PURE__ */ function() {
  var parseVersion = function(input) {
    return liftEither2(runParser2(input)(parser2));
  };
  return bind24(alt15(string3(">="))(fail2("Ranges must begin with >=")))(function() {
    return bind24(bindFlipped6(parseVersion)(map45(fromCharArray)(charsUntilSpace)))(function(lhs) {
      return bind24(alt15($$char3("<"))(fail2("Ranges must end with <")))(function() {
        return bind24(bindFlipped6(parseVersion)(map45(fromCharArray)(chars)))(function(rhs) {
          return discard7(eof)(function() {
            var $39 = greaterThanOrEq1(lhs)(rhs);
            if ($39) {
              return fail2(fold14(["Left-hand version (", print3(lhs), ") must be less than right-hand version (", print3(rhs), ")"]));
            }
            ;
            return pure34({
              lhs,
              rhs
            });
          });
        });
      });
    });
  });
}();
var parse7 = /* @__PURE__ */ function() {
  var $50 = lmap(bifunctorEither)(parseErrorMessage);
  var $51 = flip(runParser2)(parser3);
  return function($52) {
    return $50($51($52));
  };
}();
var lessThan2 = function(v) {
  return v.rhs;
};
var intersect2 = function(v) {
  return function(v1) {
    if (greaterThanOrEq1(v.lhs)(v1.rhs) || greaterThanOrEq1(v1.lhs)(v.rhs)) {
      return Nothing.value;
    }
    ;
    if (otherwise) {
      return new Just({
        lhs: max5(v.lhs)(v1.lhs),
        rhs: min6(v.rhs)(v1.rhs)
      });
    }
    ;
    throw new Error("Failed pattern match at Registry.Range (line 126, column 1 - line 126, column 43): " + [v.constructor.name, v1.constructor.name]);
  };
};
var includes = function(v) {
  return function(version) {
    return greaterThanOrEq1(version)(v.lhs) && lessThan1(version)(v.rhs);
  };
};
var greaterThanOrEq2 = function(v) {
  return v.lhs;
};
var codec7 = /* @__PURE__ */ prismaticCodec("Range")(function($53) {
  return hush(parse7($53));
})(print5)(string);
var caret = function(v) {
  return {
    lhs: v,
    rhs: bumpHighest(v)
  };
};

// output/Registry.Manifest/index.js
var Manifest = function(x) {
  return x;
};
var codec8 = /* @__PURE__ */ function() {
  return wrapIso(profunctorCodec(functorEither))()(Manifest)(object("Manifest")(recordProp({
    reflectSymbol: function() {
      return "name";
    }
  })()($$Proxy.value)(codec2)(recordProp({
    reflectSymbol: function() {
      return "version";
    }
  })()($$Proxy.value)(codec3)(recordProp({
    reflectSymbol: function() {
      return "license";
    }
  })()($$Proxy.value)(codec4)(recordPropOptional({
    reflectSymbol: function() {
      return "description";
    }
  })()($$Proxy.value)(limitedString(300))(recordProp({
    reflectSymbol: function() {
      return "location";
    }
  })()($$Proxy.value)(codec5)(recordPropOptional({
    reflectSymbol: function() {
      return "owners";
    }
  })()($$Proxy.value)(nonEmptyArray(codec6))(recordPropOptional({
    reflectSymbol: function() {
      return "files";
    }
  })()($$Proxy.value)(nonEmptyArray(nonEmptyString))(recordProp({
    reflectSymbol: function() {
      return "dependencies";
    }
  })()($$Proxy.value)(packageMap(codec7))(record))))))))));
}();

// output/Registry.ManifestIndex/index.js
var bind111 = /* @__PURE__ */ bind(bindEither);
var traverse3 = /* @__PURE__ */ traverse(traversableArray)(applicativeEither);
var lmap7 = /* @__PURE__ */ lmap(bifunctorEither);
var pure35 = /* @__PURE__ */ pure(applicativeEither);
var parseEntry = function(entry) {
  var split3 = function() {
    var $234 = split("\n");
    return function($235) {
      return $234(trim($235));
    };
  }();
  return bind111(traverse3(jsonParser)(split3(entry)))(function(jsonArray) {
    return bind111(traverse3(function() {
      var $236 = lmap7(printJsonDecodeError);
      var $237 = decode(codec8);
      return function($238) {
        return $236($237($238));
      };
    }())(jsonArray))(function(entries) {
      var v = fromArray(entries);
      if (v instanceof Nothing) {
        return new Left("No entries exist.");
      }
      ;
      if (v instanceof Just) {
        return pure35(v.value0);
      }
      ;
      throw new Error("Failed pattern match at Registry.ManifestIndex (line 246, column 3 - line 248, column 35): " + [v.constructor.name]);
    });
  });
};
var packageEntryDirectory = function($239) {
  return function(name4) {
    var v = length4(name4);
    if (v === 0) {
      return unsafeCrashWith("Unexpected empty PackageName");
    }
    ;
    if (v === 1) {
      return "1";
    }
    ;
    if (v === 2) {
      return "2";
    }
    ;
    if (v === 3) {
      return concat2(["3", take3(1)(name4)]);
    }
    ;
    return concat2([take3(2)(name4), take3(2)(drop3(2)(name4))]);
  }(print2($239));
};
var packageEntryFilePath = function(name4) {
  return concat2([packageEntryDirectory(name4), print2(name4)]);
};
var readEntryFile = function(dictMonadAff) {
  var Monad0 = dictMonadAff.MonadEffect0().Monad0();
  var bind310 = bind(Monad0.Bind1());
  var liftAff10 = liftAff(dictMonadAff);
  var pure122 = pure(Monad0.Applicative0());
  return function(indexPath) {
    return function($$package2) {
      var entryPath = concat2([indexPath, packageEntryFilePath($$package2)]);
      return bind310(liftAff10(attempt(readTextFile2(UTF8.value)(entryPath))))(function(v) {
        if (v instanceof Left) {
          return pure122(new Left("Failed to read entry: " + message(v.value0)));
        }
        ;
        if (v instanceof Right) {
          return pure122(parseEntry(v.value0));
        }
        ;
        throw new Error("Failed pattern match at Registry.ManifestIndex (line 264, column 66 - line 266, column 49): " + [v.constructor.name]);
      });
    };
  };
};

// output/Registry.Sha256/foreign.js
import crypto from "crypto";
var createHash = (algorithm) => () => crypto.createHash(algorithm);
var updateHash = (buffer) => (hash3) => () => hash3.update(buffer);
var digestHash = (hash3) => () => hash3.digest();

// output/Registry.Sha256/index.js
var bind25 = /* @__PURE__ */ bind(bindParserT);
var replicateM2 = /* @__PURE__ */ replicateM(monadParserT);
var discard8 = /* @__PURE__ */ discard(discardUnit)(bindParserT);
var fromFoldable18 = /* @__PURE__ */ fromFoldable(foldableList2);
var pure36 = /* @__PURE__ */ pure(applicativeParserT);
var toString7 = /* @__PURE__ */ toString4(mutableBufferEffect);
var fromString8 = /* @__PURE__ */ fromString5(mutableBufferEffect);
var eqSha256 = {
  eq: function(x) {
    return function(y) {
      return x.hash === y.hash && x.sri === y.sri;
    };
  }
};
var print6 = function(v) {
  return v.sri + ("-" + v.hash);
};
var parser4 = /* @__PURE__ */ bind25(/* @__PURE__ */ string3("sha256"))(function(prefix4) {
  return bind25($$char3("-"))(function() {
    return bind25(replicateM2(43)(anyChar))(function(hash3) {
      return bind25($$char3("="))(function(suffix2) {
        return discard8(eof)(function() {
          var fromCharList = function($35) {
            return fromCharArray(fromFoldable18($35));
          };
          return pure36({
            sri: prefix4,
            hash: fromCharList(hash3) + singleton6(suffix2)
          });
        });
      });
    });
  });
});
var parse8 = /* @__PURE__ */ function() {
  var $36 = lmap(bifunctorEither)(parseErrorMessage);
  var $37 = flip(runParser2)(parser4);
  return function($38) {
    return $36($37($38));
  };
}();
var hashBuffer = function(dictMonadEffect) {
  var liftEffect13 = liftEffect(dictMonadEffect);
  return function(buffer) {
    return liftEffect13(function __do3() {
      var newHash = createHash("sha256")();
      var hash3 = updateHash(buffer)(newHash)();
      var digest = digestHash(hash3)();
      var string7 = toString7(Base64.value)(digest)();
      return {
        sri: "sha256",
        hash: string7
      };
    });
  };
};
var hashBuffer1 = /* @__PURE__ */ hashBuffer(monadEffectEffect);
var hashString = function(dictMonadEffect) {
  var liftEffect13 = liftEffect(dictMonadEffect);
  return function(string7) {
    return liftEffect13(function __do3() {
      var buffer = fromString8(string7)(UTF8.value)();
      return hashBuffer1(buffer)();
    });
  };
};
var codec9 = /* @__PURE__ */ prismaticCodec("Sha256")(function($39) {
  return hush(parse8($39));
})(print6)(string);

// output/Registry.Metadata/index.js
var refIsSymbol = {
  reflectSymbol: function() {
    return "ref";
  }
};
var publishedTimeIsSymbol = {
  reflectSymbol: function() {
    return "publishedTime";
  }
};
var hashIsSymbol = {
  reflectSymbol: function() {
    return "hash";
  }
};
var bytesIsSymbol = {
  reflectSymbol: function() {
    return "bytes";
  }
};
var unpublishedTimeIsSymbol = {
  reflectSymbol: function() {
    return "unpublishedTime";
  }
};
var reasonIsSymbol = {
  reflectSymbol: function() {
    return "reason";
  }
};
var object4 = /* @__PURE__ */ object2();
var rowListCodecCons3 = /* @__PURE__ */ rowListCodecCons(rowListCodecNil)()();
var Metadata = function(x) {
  return x;
};
var unpublishedMetadataCodec = /* @__PURE__ */ object4(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons3(unpublishedTimeIsSymbol))()()(reasonIsSymbol))()()(publishedTimeIsSymbol))("UnpublishedMetadata")({
  publishedTime: iso8601DateTime2,
  reason: /* @__PURE__ */ limitedString(300),
  unpublishedTime: iso8601DateTime2
});
var publishedMetadataCodec = /* @__PURE__ */ object4(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons3(refIsSymbol))()()(publishedTimeIsSymbol))()()(hashIsSymbol))()()(bytesIsSymbol))("PublishedMetadata")({
  bytes: number,
  hash: codec9,
  publishedTime: iso8601DateTime2,
  ref: string
});
var codec10 = /* @__PURE__ */ function() {
  return wrapIso(profunctorCodec(functorEither))()(Metadata)(object("Metadata")(recordProp({
    reflectSymbol: function() {
      return "location";
    }
  })()($$Proxy.value)(codec5)(recordPropOptional({
    reflectSymbol: function() {
      return "owners";
    }
  })()($$Proxy.value)(nonEmptyArray(codec6))(recordProp({
    reflectSymbol: function() {
      return "published";
    }
  })()($$Proxy.value)(versionMap(publishedMetadataCodec))(recordProp({
    reflectSymbol: function() {
      return "unpublished";
    }
  })()($$Proxy.value)(versionMap(unpublishedMetadataCodec))(record))))));
}();

// output/Data.Map/index.js
var SemigroupMap = function(x) {
  return x;
};
var traversableWithIndexSemigroupMap = traversableWithIndexMap;
var traversableSemigroupMap = traversableMap;
var semigroupSemigroupMap = function(dictOrd) {
  var unionWith3 = unionWith(dictOrd);
  return function(dictSemigroup) {
    var append40 = append(dictSemigroup);
    return {
      append: function(v) {
        return function(v1) {
          return unionWith3(append40)(v)(v1);
        };
      }
    };
  };
};
var monoidSemigroupMap = function(dictOrd) {
  var semigroupSemigroupMap12 = semigroupSemigroupMap(dictOrd);
  return function(dictSemigroup) {
    var semigroupSemigroupMap23 = semigroupSemigroupMap12(dictSemigroup);
    return {
      mempty: empty3,
      Semigroup0: function() {
        return semigroupSemigroupMap23;
      }
    };
  };
};
var keys3 = /* @__PURE__ */ function() {
  var $38 = $$void(functorMap);
  return function($39) {
    return fromMap($38($39));
  };
}();
var functorWithIndexSemigroupMap = functorWithIndexMap;
var functorSemigroupMap = functorMap;
var foldableWithIndexSemigroupMap = foldableWithIndexMap;
var foldableSemigroupMap = foldableMap;
var eqSemigroupMap = function(dictEq) {
  var eqMap2 = eqMap(dictEq);
  return function(dictEq1) {
    return eqMap2(dictEq1);
  };
};

// output/Spago.Json/index.js
var composeKleisliFlipped4 = /* @__PURE__ */ composeKleisliFlipped(bindEither);
var lmap8 = /* @__PURE__ */ lmap(bifunctorEither);
var stringifyJson = function(codec11) {
  var $4 = encode(codec11);
  return function($5) {
    return stringify($4($5));
  };
};
var printJson = function(codec11) {
  var $6 = stringifyWithIndent(2);
  var $7 = encode(codec11);
  return function($8) {
    return $6($7($8));
  };
};
var parseJson = function(codec11) {
  return composeKleisliFlipped4(decode(codec11))(function() {
    var $9 = lmap8(function(err) {
      return new TypeMismatch("JSON: " + err);
    });
    return function($10) {
      return $9(jsonParser($10));
    };
  }());
};

// output/Ansi.Codes/index.js
var show19 = /* @__PURE__ */ show(showInt);
var intercalate6 = /* @__PURE__ */ intercalate(foldableNonEmptyList)(monoidString);
var map47 = /* @__PURE__ */ map(functorNonEmptyList);
var Bold = /* @__PURE__ */ function() {
  function Bold2() {
  }
  ;
  Bold2.value = new Bold2();
  return Bold2;
}();
var Dim = /* @__PURE__ */ function() {
  function Dim2() {
  }
  ;
  Dim2.value = new Dim2();
  return Dim2;
}();
var Italic = /* @__PURE__ */ function() {
  function Italic2() {
  }
  ;
  Italic2.value = new Italic2();
  return Italic2;
}();
var Underline = /* @__PURE__ */ function() {
  function Underline2() {
  }
  ;
  Underline2.value = new Underline2();
  return Underline2;
}();
var Inverse = /* @__PURE__ */ function() {
  function Inverse2() {
  }
  ;
  Inverse2.value = new Inverse2();
  return Inverse2;
}();
var Strikethrough = /* @__PURE__ */ function() {
  function Strikethrough2() {
  }
  ;
  Strikethrough2.value = new Strikethrough2();
  return Strikethrough2;
}();
var ToEnd = /* @__PURE__ */ function() {
  function ToEnd2() {
  }
  ;
  ToEnd2.value = new ToEnd2();
  return ToEnd2;
}();
var FromBeginning = /* @__PURE__ */ function() {
  function FromBeginning2() {
  }
  ;
  FromBeginning2.value = new FromBeginning2();
  return FromBeginning2;
}();
var Entire = /* @__PURE__ */ function() {
  function Entire2() {
  }
  ;
  Entire2.value = new Entire2();
  return Entire2;
}();
var Black = /* @__PURE__ */ function() {
  function Black2() {
  }
  ;
  Black2.value = new Black2();
  return Black2;
}();
var Red = /* @__PURE__ */ function() {
  function Red2() {
  }
  ;
  Red2.value = new Red2();
  return Red2;
}();
var Green = /* @__PURE__ */ function() {
  function Green2() {
  }
  ;
  Green2.value = new Green2();
  return Green2;
}();
var Yellow = /* @__PURE__ */ function() {
  function Yellow2() {
  }
  ;
  Yellow2.value = new Yellow2();
  return Yellow2;
}();
var Blue = /* @__PURE__ */ function() {
  function Blue2() {
  }
  ;
  Blue2.value = new Blue2();
  return Blue2;
}();
var Magenta = /* @__PURE__ */ function() {
  function Magenta2() {
  }
  ;
  Magenta2.value = new Magenta2();
  return Magenta2;
}();
var Cyan = /* @__PURE__ */ function() {
  function Cyan2() {
  }
  ;
  Cyan2.value = new Cyan2();
  return Cyan2;
}();
var White = /* @__PURE__ */ function() {
  function White2() {
  }
  ;
  White2.value = new White2();
  return White2;
}();
var BrightBlack = /* @__PURE__ */ function() {
  function BrightBlack2() {
  }
  ;
  BrightBlack2.value = new BrightBlack2();
  return BrightBlack2;
}();
var BrightRed = /* @__PURE__ */ function() {
  function BrightRed2() {
  }
  ;
  BrightRed2.value = new BrightRed2();
  return BrightRed2;
}();
var BrightGreen = /* @__PURE__ */ function() {
  function BrightGreen2() {
  }
  ;
  BrightGreen2.value = new BrightGreen2();
  return BrightGreen2;
}();
var BrightYellow = /* @__PURE__ */ function() {
  function BrightYellow2() {
  }
  ;
  BrightYellow2.value = new BrightYellow2();
  return BrightYellow2;
}();
var BrightBlue = /* @__PURE__ */ function() {
  function BrightBlue2() {
  }
  ;
  BrightBlue2.value = new BrightBlue2();
  return BrightBlue2;
}();
var BrightMagenta = /* @__PURE__ */ function() {
  function BrightMagenta2() {
  }
  ;
  BrightMagenta2.value = new BrightMagenta2();
  return BrightMagenta2;
}();
var BrightCyan = /* @__PURE__ */ function() {
  function BrightCyan2() {
  }
  ;
  BrightCyan2.value = new BrightCyan2();
  return BrightCyan2;
}();
var BrightWhite = /* @__PURE__ */ function() {
  function BrightWhite2() {
  }
  ;
  BrightWhite2.value = new BrightWhite2();
  return BrightWhite2;
}();
var Reset = /* @__PURE__ */ function() {
  function Reset2() {
  }
  ;
  Reset2.value = new Reset2();
  return Reset2;
}();
var PMode = /* @__PURE__ */ function() {
  function PMode2(value0) {
    this.value0 = value0;
  }
  ;
  PMode2.create = function(value0) {
    return new PMode2(value0);
  };
  return PMode2;
}();
var PForeground = /* @__PURE__ */ function() {
  function PForeground2(value0) {
    this.value0 = value0;
  }
  ;
  PForeground2.create = function(value0) {
    return new PForeground2(value0);
  };
  return PForeground2;
}();
var PBackground = /* @__PURE__ */ function() {
  function PBackground2(value0) {
    this.value0 = value0;
  }
  ;
  PBackground2.create = function(value0) {
    return new PBackground2(value0);
  };
  return PBackground2;
}();
var Up = /* @__PURE__ */ function() {
  function Up2(value0) {
    this.value0 = value0;
  }
  ;
  Up2.create = function(value0) {
    return new Up2(value0);
  };
  return Up2;
}();
var Down = /* @__PURE__ */ function() {
  function Down2(value0) {
    this.value0 = value0;
  }
  ;
  Down2.create = function(value0) {
    return new Down2(value0);
  };
  return Down2;
}();
var Forward = /* @__PURE__ */ function() {
  function Forward2(value0) {
    this.value0 = value0;
  }
  ;
  Forward2.create = function(value0) {
    return new Forward2(value0);
  };
  return Forward2;
}();
var Back = /* @__PURE__ */ function() {
  function Back2(value0) {
    this.value0 = value0;
  }
  ;
  Back2.create = function(value0) {
    return new Back2(value0);
  };
  return Back2;
}();
var NextLine = /* @__PURE__ */ function() {
  function NextLine2(value0) {
    this.value0 = value0;
  }
  ;
  NextLine2.create = function(value0) {
    return new NextLine2(value0);
  };
  return NextLine2;
}();
var PreviousLine = /* @__PURE__ */ function() {
  function PreviousLine2(value0) {
    this.value0 = value0;
  }
  ;
  PreviousLine2.create = function(value0) {
    return new PreviousLine2(value0);
  };
  return PreviousLine2;
}();
var HorizontalAbsolute = /* @__PURE__ */ function() {
  function HorizontalAbsolute2(value0) {
    this.value0 = value0;
  }
  ;
  HorizontalAbsolute2.create = function(value0) {
    return new HorizontalAbsolute2(value0);
  };
  return HorizontalAbsolute2;
}();
var Position = /* @__PURE__ */ function() {
  function Position2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Position2.create = function(value0) {
    return function(value12) {
      return new Position2(value0, value12);
    };
  };
  return Position2;
}();
var EraseData = /* @__PURE__ */ function() {
  function EraseData2(value0) {
    this.value0 = value0;
  }
  ;
  EraseData2.create = function(value0) {
    return new EraseData2(value0);
  };
  return EraseData2;
}();
var EraseLine = /* @__PURE__ */ function() {
  function EraseLine2(value0) {
    this.value0 = value0;
  }
  ;
  EraseLine2.create = function(value0) {
    return new EraseLine2(value0);
  };
  return EraseLine2;
}();
var ScrollUp = /* @__PURE__ */ function() {
  function ScrollUp2(value0) {
    this.value0 = value0;
  }
  ;
  ScrollUp2.create = function(value0) {
    return new ScrollUp2(value0);
  };
  return ScrollUp2;
}();
var ScrollDown = /* @__PURE__ */ function() {
  function ScrollDown2(value0) {
    this.value0 = value0;
  }
  ;
  ScrollDown2.create = function(value0) {
    return new ScrollDown2(value0);
  };
  return ScrollDown2;
}();
var Graphics = /* @__PURE__ */ function() {
  function Graphics2(value0) {
    this.value0 = value0;
  }
  ;
  Graphics2.create = function(value0) {
    return new Graphics2(value0);
  };
  return Graphics2;
}();
var SavePosition = /* @__PURE__ */ function() {
  function SavePosition2() {
  }
  ;
  SavePosition2.value = new SavePosition2();
  return SavePosition2;
}();
var RestorePosition = /* @__PURE__ */ function() {
  function RestorePosition2() {
  }
  ;
  RestorePosition2.value = new RestorePosition2();
  return RestorePosition2;
}();
var QueryPosition = /* @__PURE__ */ function() {
  function QueryPosition2() {
  }
  ;
  QueryPosition2.value = new QueryPosition2();
  return QueryPosition2;
}();
var HideCursor = /* @__PURE__ */ function() {
  function HideCursor2() {
  }
  ;
  HideCursor2.value = new HideCursor2();
  return HideCursor2;
}();
var ShowCursor = /* @__PURE__ */ function() {
  function ShowCursor2() {
  }
  ;
  ShowCursor2.value = new ShowCursor2();
  return ShowCursor2;
}();
var prefix = "\x1B[";
var eraseParamToString = function(ep) {
  if (ep instanceof ToEnd) {
    return "0";
  }
  ;
  if (ep instanceof FromBeginning) {
    return "1";
  }
  ;
  if (ep instanceof Entire) {
    return "2";
  }
  ;
  throw new Error("Failed pattern match at Ansi.Codes (line 95, column 3 - line 98, column 25): " + [ep.constructor.name]);
};
var eqRenderingMode = {
  eq: function(x) {
    return function(y) {
      if (x instanceof Bold && y instanceof Bold) {
        return true;
      }
      ;
      if (x instanceof Dim && y instanceof Dim) {
        return true;
      }
      ;
      if (x instanceof Italic && y instanceof Italic) {
        return true;
      }
      ;
      if (x instanceof Underline && y instanceof Underline) {
        return true;
      }
      ;
      if (x instanceof Inverse && y instanceof Inverse) {
        return true;
      }
      ;
      if (x instanceof Strikethrough && y instanceof Strikethrough) {
        return true;
      }
      ;
      return false;
    };
  }
};
var eq17 = /* @__PURE__ */ eq(eqRenderingMode);
var eqColor = {
  eq: function(x) {
    return function(y) {
      if (x instanceof Black && y instanceof Black) {
        return true;
      }
      ;
      if (x instanceof Red && y instanceof Red) {
        return true;
      }
      ;
      if (x instanceof Green && y instanceof Green) {
        return true;
      }
      ;
      if (x instanceof Yellow && y instanceof Yellow) {
        return true;
      }
      ;
      if (x instanceof Blue && y instanceof Blue) {
        return true;
      }
      ;
      if (x instanceof Magenta && y instanceof Magenta) {
        return true;
      }
      ;
      if (x instanceof Cyan && y instanceof Cyan) {
        return true;
      }
      ;
      if (x instanceof White && y instanceof White) {
        return true;
      }
      ;
      if (x instanceof BrightBlack && y instanceof BrightBlack) {
        return true;
      }
      ;
      if (x instanceof BrightRed && y instanceof BrightRed) {
        return true;
      }
      ;
      if (x instanceof BrightGreen && y instanceof BrightGreen) {
        return true;
      }
      ;
      if (x instanceof BrightYellow && y instanceof BrightYellow) {
        return true;
      }
      ;
      if (x instanceof BrightBlue && y instanceof BrightBlue) {
        return true;
      }
      ;
      if (x instanceof BrightMagenta && y instanceof BrightMagenta) {
        return true;
      }
      ;
      if (x instanceof BrightCyan && y instanceof BrightCyan) {
        return true;
      }
      ;
      if (x instanceof BrightWhite && y instanceof BrightWhite) {
        return true;
      }
      ;
      return false;
    };
  }
};
var eq33 = /* @__PURE__ */ eq(eqColor);
var eqGraphicsParam = {
  eq: function(x) {
    return function(y) {
      if (x instanceof Reset && y instanceof Reset) {
        return true;
      }
      ;
      if (x instanceof PMode && y instanceof PMode) {
        return eq17(x.value0)(y.value0);
      }
      ;
      if (x instanceof PForeground && y instanceof PForeground) {
        return eq33(x.value0)(y.value0);
      }
      ;
      if (x instanceof PBackground && y instanceof PBackground) {
        return eq33(x.value0)(y.value0);
      }
      ;
      return false;
    };
  }
};
var colorSuffix = "m";
var colorCode = function(c) {
  if (c instanceof Black) {
    return 30;
  }
  ;
  if (c instanceof Red) {
    return 31;
  }
  ;
  if (c instanceof Green) {
    return 32;
  }
  ;
  if (c instanceof Yellow) {
    return 33;
  }
  ;
  if (c instanceof Blue) {
    return 34;
  }
  ;
  if (c instanceof Magenta) {
    return 35;
  }
  ;
  if (c instanceof Cyan) {
    return 36;
  }
  ;
  if (c instanceof White) {
    return 37;
  }
  ;
  if (c instanceof BrightBlack) {
    return 90;
  }
  ;
  if (c instanceof BrightRed) {
    return 91;
  }
  ;
  if (c instanceof BrightGreen) {
    return 92;
  }
  ;
  if (c instanceof BrightYellow) {
    return 93;
  }
  ;
  if (c instanceof BrightBlue) {
    return 94;
  }
  ;
  if (c instanceof BrightMagenta) {
    return 95;
  }
  ;
  if (c instanceof BrightCyan) {
    return 96;
  }
  ;
  if (c instanceof BrightWhite) {
    return 97;
  }
  ;
  throw new Error("Failed pattern match at Ansi.Codes (line 173, column 3 - line 189, column 22): " + [c.constructor.name]);
};
var codeForRenderingMode = function(m) {
  if (m instanceof Bold) {
    return 1;
  }
  ;
  if (m instanceof Dim) {
    return 2;
  }
  ;
  if (m instanceof Italic) {
    return 3;
  }
  ;
  if (m instanceof Underline) {
    return 4;
  }
  ;
  if (m instanceof Inverse) {
    return 7;
  }
  ;
  if (m instanceof Strikethrough) {
    return 9;
  }
  ;
  throw new Error("Failed pattern match at Ansi.Codes (line 138, column 3 - line 144, column 23): " + [m.constructor.name]);
};
var graphicsParamToString = function(gp) {
  if (gp instanceof Reset) {
    return "0";
  }
  ;
  if (gp instanceof PMode) {
    return show19(codeForRenderingMode(gp.value0));
  }
  ;
  if (gp instanceof PForeground) {
    return show19(colorCode(gp.value0));
  }
  ;
  if (gp instanceof PBackground) {
    return show19(colorCode(gp.value0) + 10 | 0);
  }
  ;
  throw new Error("Failed pattern match at Ansi.Codes (line 116, column 3 - line 120, column 45): " + [gp.constructor.name]);
};
var escapeCodeToString = /* @__PURE__ */ function() {
  var go = function(c) {
    if (c instanceof Up) {
      return show19(c.value0) + "A";
    }
    ;
    if (c instanceof Down) {
      return show19(c.value0) + "B";
    }
    ;
    if (c instanceof Forward) {
      return show19(c.value0) + "C";
    }
    ;
    if (c instanceof Back) {
      return show19(c.value0) + "D";
    }
    ;
    if (c instanceof NextLine) {
      return show19(c.value0) + "E";
    }
    ;
    if (c instanceof PreviousLine) {
      return show19(c.value0) + "F";
    }
    ;
    if (c instanceof HorizontalAbsolute) {
      return show19(c.value0) + "G";
    }
    ;
    if (c instanceof Position) {
      return show19(c.value0) + (";" + (show19(c.value1) + "H"));
    }
    ;
    if (c instanceof EraseData) {
      return eraseParamToString(c.value0) + "J";
    }
    ;
    if (c instanceof EraseLine) {
      return eraseParamToString(c.value0) + "K";
    }
    ;
    if (c instanceof ScrollUp) {
      return show19(c.value0) + "S";
    }
    ;
    if (c instanceof ScrollDown) {
      return show19(c.value0) + "T";
    }
    ;
    if (c instanceof Graphics) {
      return intercalate6(";")(map47(graphicsParamToString)(c.value0)) + colorSuffix;
    }
    ;
    if (c instanceof SavePosition) {
      return "s";
    }
    ;
    if (c instanceof RestorePosition) {
      return "u";
    }
    ;
    if (c instanceof QueryPosition) {
      return "6n";
    }
    ;
    if (c instanceof HideCursor) {
      return "?25l";
    }
    ;
    if (c instanceof ShowCursor) {
      return "?25h";
    }
    ;
    throw new Error("Failed pattern match at Ansi.Codes (line 53, column 5 - line 71, column 37): " + [c.constructor.name]);
  };
  return function($846) {
    return function(v) {
      return prefix + v;
    }(go($846));
  };
}();

// output/Dodo.Ansi/index.js
var pure37 = /* @__PURE__ */ pure(applicativeNonEmptyList);
var eq8 = /* @__PURE__ */ eq(eqRenderingMode);
var notEq4 = /* @__PURE__ */ notEq(eqGraphicsParam);
var foreground = function(color) {
  return annotate(new PForeground(color));
};
var dim = /* @__PURE__ */ function() {
  return annotate(new PMode(Dim.value));
}();
var bold = /* @__PURE__ */ function() {
  return annotate(new PMode(Bold.value));
}();
var ansiGraphics = /* @__PURE__ */ function() {
  var writePendingGraphics = function(v) {
    if (v.pending instanceof Nothing) {
      return v;
    }
    ;
    if (v.pending instanceof Just) {
      return {
        output: v.output + escapeCodeToString(new Graphics(v.pending.value0)),
        pending: Nothing.value,
        current: v.current,
        previous: v.previous
      };
    }
    ;
    throw new Error("Failed pattern match at Dodo.Ansi (line 136, column 5 - line 143, column 12): " + [v.pending.constructor.name]);
  };
  var writeText = function(v) {
    return function(text3) {
      return function(output5) {
        var v1 = writePendingGraphics(output5);
        return {
          output: v1.output + text3,
          pending: v1.pending,
          current: v1.current,
          previous: Nil.value
        };
      };
    };
  };
  var writeIndent = function(v) {
    return function(text3) {
      return function(v1) {
        return {
          output: v1.output + text3,
          pending: v1.pending,
          current: v1.current,
          previous: v1.previous
        };
      };
    };
  };
  var resetCode = escapeCodeToString(new Graphics(pure37(Reset.value)));
  var graphicsConflict = function(v) {
    return function(v1) {
      if (v instanceof Reset && v1 instanceof Reset) {
        return true;
      }
      ;
      if (v instanceof PForeground && v1 instanceof PForeground) {
        return true;
      }
      ;
      if (v instanceof PBackground && v1 instanceof PBackground) {
        return true;
      }
      ;
      if (v instanceof PMode && v1 instanceof PMode) {
        return eq8(v.value0)(v1.value0);
      }
      ;
      return false;
    };
  };
  var getPendingGraphics = function() {
    var $50 = map(functorMaybe)(cons3(Reset.value));
    return function($51) {
      return $50(fromList($51));
    };
  }();
  var writeBreak = function(v) {
    var pending = getPendingGraphics(v.current);
    var resetOrEmpty = function() {
      var $42 = isNothing(pending) && $$null3(v.previous);
      if ($42) {
        return "";
      }
      ;
      return resetCode;
    }();
    return {
      output: v.output + (resetOrEmpty + "\n"),
      pending,
      current: v.current,
      previous: v.previous
    };
  };
  var getCurrentGraphics = function() {
    var $52 = nubByEq2(graphicsConflict);
    var $53 = takeWhile4(function(v) {
      return notEq4(v)(Reset.value);
    });
    return function($54) {
      return reverse2($52($53($54)));
    };
  }();
  var leaveAnnotation = function(v) {
    return function(as3) {
      return function(v1) {
        var current = getCurrentGraphics(as3);
        return {
          output: v1.output,
          pending: new Just(fromMaybe(pure37(Reset.value))(getPendingGraphics(current))),
          current,
          previous: v1.current
        };
      };
    };
  };
  var flushBuffer = function(ansiBuffer) {
    var v = writePendingGraphics(ansiBuffer);
    return v.output;
  };
  var enterAnnotation = function(a) {
    return function(as3) {
      return function(v) {
        var current = getCurrentGraphics(new Cons(a, as3));
        return {
          output: v.output,
          pending: getPendingGraphics(current),
          current,
          previous: v.current
        };
      };
    };
  };
  var emptyBuffer = {
    output: "",
    pending: Nothing.value,
    current: Nil.value,
    previous: Nil.value
  };
  return {
    emptyBuffer,
    writeText,
    writeIndent,
    writeBreak,
    enterAnnotation,
    leaveAnnotation,
    flushBuffer
  };
}();

// output/Dodo.Box/index.js
var max6 = /* @__PURE__ */ max(ordInt);
var coerce4 = /* @__PURE__ */ coerce();
var append11 = /* @__PURE__ */ append(semigroupDoc);
var power3 = /* @__PURE__ */ power(monoidDoc);
var mempty9 = /* @__PURE__ */ mempty(monoidDoc);
var under2 = /* @__PURE__ */ under()();
var LinePad = /* @__PURE__ */ function() {
  function LinePad2(value0) {
    this.value0 = value0;
  }
  ;
  LinePad2.create = function(value0) {
    return new LinePad2(value0);
  };
  return LinePad2;
}();
var LineDoc = /* @__PURE__ */ function() {
  function LineDoc2(value0) {
    this.value0 = value0;
  }
  ;
  LineDoc2.create = function(value0) {
    return new LineDoc2(value0);
  };
  return LineDoc2;
}();
var LineAppend = /* @__PURE__ */ function() {
  function LineAppend2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  LineAppend2.create = function(value0) {
    return function(value12) {
      return new LineAppend2(value0, value12);
    };
  };
  return LineAppend2;
}();
var FullHeight = /* @__PURE__ */ function() {
  function FullHeight2(value0) {
    this.value0 = value0;
  }
  ;
  FullHeight2.create = function(value0) {
    return new FullHeight2(value0);
  };
  return FullHeight2;
}();
var FullWidth = /* @__PURE__ */ function() {
  function FullWidth2(value0) {
    this.value0 = value0;
  }
  ;
  FullWidth2.create = function(value0) {
    return new FullWidth2(value0);
  };
  return FullWidth2;
}();
var AsIs = /* @__PURE__ */ function() {
  function AsIs2() {
  }
  ;
  AsIs2.value = new AsIs2();
  return AsIs2;
}();
var StpDone = /* @__PURE__ */ function() {
  function StpDone2() {
  }
  ;
  StpDone2.value = new StpDone2();
  return StpDone2;
}();
var StpLine = /* @__PURE__ */ function() {
  function StpLine2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  StpLine2.create = function(value0) {
    return function(value12) {
      return new StpLine2(value0, value12);
    };
  };
  return StpLine2;
}();
var StpPad = /* @__PURE__ */ function() {
  function StpPad2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  StpPad2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new StpPad2(value0, value12, value22);
      };
    };
  };
  return StpPad2;
}();
var StpHorz = /* @__PURE__ */ function() {
  function StpHorz2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  StpHorz2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new StpHorz2(value0, value12, value22);
      };
    };
  };
  return StpHorz2;
}();
var ResumeEnter = /* @__PURE__ */ function() {
  function ResumeEnter2(value0) {
    this.value0 = value0;
  }
  ;
  ResumeEnter2.create = function(value0) {
    return new ResumeEnter2(value0);
  };
  return ResumeEnter2;
}();
var ResumeLeave = /* @__PURE__ */ function() {
  function ResumeLeave2(value0) {
    this.value0 = value0;
  }
  ;
  ResumeLeave2.create = function(value0) {
    return new ResumeLeave2(value0);
  };
  return ResumeLeave2;
}();
var ResumeHorzR = /* @__PURE__ */ function() {
  function ResumeHorzR2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  ResumeHorzR2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new ResumeHorzR2(value0, value12, value22);
      };
    };
  };
  return ResumeHorzR2;
}();
var ResumeHorzH = /* @__PURE__ */ function() {
  function ResumeHorzH2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  ResumeHorzH2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new ResumeHorzH2(value0, value12, value22);
      };
    };
  };
  return ResumeHorzH2;
}();
var ResumeNil = /* @__PURE__ */ function() {
  function ResumeNil2() {
  }
  ;
  ResumeNil2.value = new ResumeNil2();
  return ResumeNil2;
}();
var Start = /* @__PURE__ */ function() {
  function Start2() {
  }
  ;
  Start2.value = new Start2();
  return Start2;
}();
var Middle = /* @__PURE__ */ function() {
  function Middle2() {
  }
  ;
  Middle2.value = new Middle2();
  return Middle2;
}();
var End = /* @__PURE__ */ function() {
  function End2() {
  }
  ;
  End2.value = new End2();
  return End2;
}();
var DocLine = /* @__PURE__ */ function() {
  function DocLine2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  DocLine2.create = function(value0) {
    return function(value12) {
      return new DocLine2(value0, value12);
    };
  };
  return DocLine2;
}();
var DocVApp = /* @__PURE__ */ function() {
  function DocVApp2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  DocVApp2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new DocVApp2(value0, value12, value22);
      };
    };
  };
  return DocVApp2;
}();
var DocHApp = /* @__PURE__ */ function() {
  function DocHApp2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  DocHApp2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new DocHApp2(value0, value12, value22);
      };
    };
  };
  return DocHApp2;
}();
var DocAlign = /* @__PURE__ */ function() {
  function DocAlign2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  DocAlign2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new DocAlign2(value0, value12, value22);
      };
    };
  };
  return DocAlign2;
}();
var DocPad = /* @__PURE__ */ function() {
  function DocPad2(value0) {
    this.value0 = value0;
  }
  ;
  DocPad2.create = function(value0) {
    return new DocPad2(value0);
  };
  return DocPad2;
}();
var DocEmpty = /* @__PURE__ */ function() {
  function DocEmpty2() {
  }
  ;
  DocEmpty2.value = new DocEmpty2();
  return DocEmpty2;
}();
var BuildEnter = /* @__PURE__ */ function() {
  function BuildEnter2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  BuildEnter2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new BuildEnter2(value0, value12, value22);
      };
    };
  };
  return BuildEnter2;
}();
var BuildLeave = /* @__PURE__ */ function() {
  function BuildLeave2(value0) {
    this.value0 = value0;
  }
  ;
  BuildLeave2.create = function(value0) {
    return new BuildLeave2(value0);
  };
  return BuildLeave2;
}();
var BuildVAppR = /* @__PURE__ */ function() {
  function BuildVAppR2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  BuildVAppR2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new BuildVAppR2(value0, value12, value22);
      };
    };
  };
  return BuildVAppR2;
}();
var BuildHAppR = /* @__PURE__ */ function() {
  function BuildHAppR2(value0, value12, value22, value32) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
    this.value3 = value32;
  }
  ;
  BuildHAppR2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return function(value32) {
          return new BuildHAppR2(value0, value12, value22, value32);
        };
      };
    };
  };
  return BuildHAppR2;
}();
var BuildHAppH = /* @__PURE__ */ function() {
  function BuildHAppH2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  BuildHAppH2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new BuildHAppH2(value0, value12, value22);
      };
    };
  };
  return BuildHAppH2;
}();
var BuildNil = /* @__PURE__ */ function() {
  function BuildNil2() {
  }
  ;
  BuildNil2.value = new BuildNil2();
  return BuildNil2;
}();
var Vertical = function(x) {
  return x;
};
var vpadding = function(height) {
  if (height <= 0) {
    return DocEmpty.value;
  }
  ;
  if (otherwise) {
    return new DocPad({
      height,
      width: 0
    });
  }
  ;
  throw new Error("Failed pattern match at Dodo.Box (line 228, column 1 - line 228, column 38): " + [height.constructor.name]);
};
var valignOf = function(v) {
  if (v instanceof DocAlign) {
    return v.value0;
  }
  ;
  return Start.value;
};
var valign = function(a) {
  return function(v) {
    var v1 = function(v2) {
      if (v instanceof DocAlign && otherwise) {
        return new DocAlign(a, v.value1, v.value2);
      }
      ;
      return new DocAlign(a, Start.value, v);
    };
    if (v instanceof DocAlign) {
      if (a instanceof Start) {
        if (v.value1 instanceof Start) {
          return v.value2;
        }
        ;
        return v1(true);
      }
      ;
      return v1(true);
    }
    ;
    return v1(true);
  };
};
var sizeOf = function($copy_v) {
  var $tco_done = false;
  var $tco_result;
  function $tco_loop(v) {
    if (v instanceof DocLine) {
      $tco_done = true;
      return {
        width: v.value1,
        height: 1
      };
    }
    ;
    if (v instanceof DocVApp) {
      $tco_done = true;
      return v.value2;
    }
    ;
    if (v instanceof DocHApp) {
      $tco_done = true;
      return v.value2;
    }
    ;
    if (v instanceof DocAlign) {
      $copy_v = v.value2;
      return;
    }
    ;
    if (v instanceof DocPad) {
      $tco_done = true;
      return v.value0;
    }
    ;
    if (v instanceof DocEmpty) {
      $tco_done = true;
      return {
        width: 0,
        height: 0
      };
    }
    ;
    throw new Error("Failed pattern match at Dodo.Box (line 241, column 10 - line 247, column 38): " + [v.constructor.name]);
  }
  ;
  while (!$tco_done) {
    $tco_result = $tco_loop($copy_v);
  }
  ;
  return $tco_result;
};
var vappend = /* @__PURE__ */ function() {
  var scale = function(sizea) {
    return function(sizeb) {
      return {
        width: max6(sizea.width)(sizeb.width),
        height: sizea.height + sizeb.height | 0
      };
    };
  };
  return function(v) {
    return function(v1) {
      if (v instanceof DocEmpty) {
        return v1;
      }
      ;
      if (v1 instanceof DocEmpty) {
        return v;
      }
      ;
      if (v instanceof DocPad && v1 instanceof DocPad) {
        return new DocPad(scale(v.value0)(v1.value0));
      }
      ;
      return new DocVApp(v, v1, scale(sizeOf(v))(sizeOf(v1)));
    };
  };
}();
var vertical = function(dictFoldable) {
  return foldr(dictFoldable)(vappend)(DocEmpty.value);
};
var semigroupVertical = {
  append: /* @__PURE__ */ coerce4(vappend)
};
var monoidVertical = /* @__PURE__ */ function() {
  return {
    mempty: DocEmpty.value,
    Semigroup0: function() {
      return semigroupVertical;
    }
  };
}();
var power1 = /* @__PURE__ */ power(monoidVertical);
var resume2 = /* @__PURE__ */ function() {
  var go = function($copy_cmd) {
    return function($copy_stack) {
      var $tco_var_cmd = $copy_cmd;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(cmd, stack) {
        if (cmd instanceof ResumeEnter) {
          if (cmd.value0 instanceof StpDone) {
            $tco_var_cmd = new ResumeLeave(Nothing.value);
            $copy_stack = stack;
            return;
          }
          ;
          if (cmd.value0 instanceof StpLine) {
            $tco_var_cmd = new ResumeLeave(new Just({
              line: new LineDoc(cmd.value0.value0),
              next: cmd.value0.value1
            }));
            $copy_stack = stack;
            return;
          }
          ;
          if (cmd.value0 instanceof StpPad) {
            var $136 = cmd.value0.value1 === 0;
            if ($136) {
              $tco_var_cmd = new ResumeEnter(cmd.value0.value2);
              $copy_stack = stack;
              return;
            }
            ;
            $tco_var_cmd = new ResumeLeave(new Just({
              line: new LinePad(cmd.value0.value0),
              next: new StpPad(cmd.value0.value0, cmd.value0.value1 - 1 | 0, cmd.value0.value2)
            }));
            $copy_stack = stack;
            return;
          }
          ;
          if (cmd.value0 instanceof StpHorz) {
            $tco_var_cmd = new ResumeEnter(cmd.value0.value1);
            $copy_stack = new ResumeHorzR(cmd.value0.value0, cmd.value0.value2, stack);
            return;
          }
          ;
          throw new Error("Failed pattern match at Dodo.Box (line 389, column 7 - line 406, column 56): " + [cmd.value0.constructor.name]);
        }
        ;
        if (cmd instanceof ResumeLeave) {
          if (stack instanceof ResumeHorzR) {
            $tco_var_cmd = new ResumeEnter(stack.value0);
            $copy_stack = new ResumeHorzH(cmd.value0, stack.value1, stack.value2);
            return;
          }
          ;
          if (stack instanceof ResumeHorzH) {
            if (cmd.value0 instanceof Just && stack.value0 instanceof Just) {
              $tco_var_cmd = new ResumeLeave(new Just({
                line: new LineAppend(cmd.value0.value0.line, stack.value0.value0.line),
                next: new StpHorz(cmd.value0.value0.next, stack.value0.value0.next, stack.value1)
              }));
              $copy_stack = stack.value2;
              return;
            }
            ;
            $tco_var_cmd = new ResumeEnter(stack.value1);
            $copy_stack = stack.value2;
            return;
          }
          ;
          if (stack instanceof ResumeNil) {
            $tco_done = true;
            return cmd.value0;
          }
          ;
          throw new Error("Failed pattern match at Dodo.Box (line 408, column 7 - line 424, column 15): " + [stack.constructor.name]);
        }
        ;
        throw new Error("Failed pattern match at Dodo.Box (line 387, column 18 - line 424, column 15): " + [cmd.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_cmd, $copy_stack);
      }
      ;
      return $tco_result;
    };
  };
  var $277 = flip(go)(ResumeNil.value);
  return function($278) {
    return $277(ResumeEnter.create($278));
  };
}();
var padWithAlign = function(appendFn) {
  return function(paddingFn) {
    return function(padWidth) {
      return function(doc) {
        return function(v) {
          if (v instanceof Start) {
            return appendFn(doc)(paddingFn(padWidth));
          }
          ;
          if (v instanceof Middle) {
            var mid = toNumber2(padWidth) / 2;
            return appendFn(appendFn(paddingFn(floor2(mid)))(doc))(paddingFn(ceil2(mid)));
          }
          ;
          if (v instanceof End) {
            return appendFn(paddingFn(padWidth))(doc);
          }
          ;
          throw new Error("Failed pattern match at Dodo.Box (line 197, column 48 - line 206, column 38): " + [v.constructor.name]);
        };
      };
    };
  };
};
var isEmpty6 = function(v) {
  if (v instanceof DocEmpty) {
    return true;
  }
  ;
  return false;
};
var hpadding = function(width2) {
  if (width2 <= 0) {
    return DocEmpty.value;
  }
  ;
  if (otherwise) {
    return new DocPad({
      height: 1,
      width: width2
    });
  }
  ;
  throw new Error("Failed pattern match at Dodo.Box (line 234, column 1 - line 234, column 38): " + [width2.constructor.name]);
};
var happend = /* @__PURE__ */ function() {
  var scale = function(sizea) {
    return function(sizeb) {
      return {
        width: sizea.width + sizeb.width | 0,
        height: max6(sizea.height)(sizeb.height)
      };
    };
  };
  return function(v) {
    return function(v1) {
      if (v instanceof DocEmpty) {
        return v1;
      }
      ;
      if (v1 instanceof DocEmpty) {
        return v;
      }
      ;
      if (v instanceof DocPad && v1 instanceof DocPad) {
        return new DocPad(scale(v.value0)(v1.value0));
      }
      ;
      return new DocHApp(v, v1, scale(sizeOf(v))(sizeOf(v1)));
    };
  };
}();
var horizontal = function(dictFoldable) {
  return foldr(dictFoldable)(happend)(DocEmpty.value);
};
var halignOf = function(v) {
  if (v instanceof DocAlign) {
    return v.value1;
  }
  ;
  return Start.value;
};
var halign = function(b) {
  return function(v) {
    var v1 = function(v2) {
      if (v instanceof DocAlign && otherwise) {
        return new DocAlign(v.value0, b, v.value2);
      }
      ;
      return new DocAlign(Start.value, b, v);
    };
    if (v instanceof DocAlign) {
      if (v.value0 instanceof Start) {
        if (b instanceof Start) {
          return v.value2;
        }
        ;
        return v1(true);
      }
      ;
      return v1(true);
    }
    ;
    return v1(true);
  };
};
var resize = function(newSize) {
  return function(box) {
    var size10 = sizeOf(box);
    var vpad = newSize.height - size10.height | 0;
    var hpad = newSize.width - size10.width | 0;
    var box$prime = function() {
      if (box instanceof DocAlign) {
        return box.value2;
      }
      ;
      return box;
    }();
    var hdoc = function() {
      if (hpad <= 0) {
        return valign(Start.value)(box$prime);
      }
      ;
      if (otherwise) {
        return padWithAlign(happend)(hpadding)(hpad)(box)(halignOf(box));
      }
      ;
      throw new Error("Failed pattern match at Dodo.Box (line 189, column 3 - line 191, column 72): " + []);
    }();
    var vdoc = function() {
      if (vpad <= 0) {
        return halign(Start.value)(hdoc);
      }
      ;
      if (otherwise) {
        return padWithAlign(vappend)(vpadding)(vpad)(hdoc)(valignOf(box));
      }
      ;
      throw new Error("Failed pattern match at Dodo.Box (line 192, column 3 - line 194, column 73): " + []);
    }();
    return vdoc;
  };
};
var formatLine = /* @__PURE__ */ function() {
  var go = function($copy_acc) {
    return function($copy_v) {
      var $tco_var_acc = $copy_acc;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(acc, v) {
        if (v instanceof Nil) {
          $tco_done = true;
          return acc;
        }
        ;
        if (v instanceof Cons) {
          if (v.value0 instanceof LinePad) {
            if (isEmpty4(acc)) {
              $tco_var_acc = acc;
              $copy_v = v.value1;
              return;
            }
            ;
            if (otherwise) {
              $tco_var_acc = append11(power3(space)(v.value0.value0))(acc);
              $copy_v = v.value1;
              return;
            }
            ;
          }
          ;
          if (v.value0 instanceof LineDoc) {
            $tco_var_acc = append11(v.value0.value0)(acc);
            $copy_v = v.value1;
            return;
          }
          ;
          if (v.value0 instanceof LineAppend) {
            $tco_var_acc = acc;
            $copy_v = new Cons(v.value0.value1, new Cons(v.value0.value0, v.value1));
            return;
          }
          ;
          throw new Error("Failed pattern match at Dodo.Box (line 290, column 7 - line 299, column 33): " + [v.value0.constructor.name]);
        }
        ;
        throw new Error("Failed pattern match at Dodo.Box (line 286, column 12 - line 299, column 33): " + [v.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_acc, $copy_v);
      }
      ;
      return $tco_result;
    };
  };
  var $279 = go(mempty9);
  return function($280) {
    return $279(singleton8($280));
  };
}();
var fill3 = function(ch) {
  return function(v) {
    var line2 = function() {
      if (ch instanceof Annotate) {
        return new DocLine(annotate(ch.value0)(power3(ch.value1)(v.width)), v.width);
      }
      ;
      return new DocLine(power3(ch)(v.width), v.width);
    }();
    return under2(Vertical)(flip(power1)(v.height))(line2);
  };
};
var docBox = /* @__PURE__ */ function() {
  var writeText = function(width2) {
    return function(text3) {
      return function(v) {
        var doc$prime = new Text(width2, text3);
        var line2 = function() {
          if (v.currentLine instanceof Cons && v.currentLine.value0 instanceof Right) {
            return new Cons(new Right(append11(v.currentLine.value0.value0)(doc$prime)), v.currentLine.value1);
          }
          ;
          return new Cons(new Right(doc$prime), v.currentLine);
        }();
        return {
          currentIndent: v.currentIndent,
          currentLine: line2,
          currentWidth: v.currentWidth + width2 | 0,
          lines: v.lines
        };
      };
    };
  };
  var writeIndent = function(width2) {
    return function(text3) {
      return function(v) {
        var doc = new Text(width2, text3);
        return {
          currentIndent: append11(v.currentIndent)(doc),
          currentLine: v.currentLine,
          currentWidth: v.currentWidth + width2 | 0,
          lines: v.lines
        };
      };
    };
  };
  var stkToDoc = foldl(foldableList)(function(doc) {
    return function(v) {
      if (v instanceof Left) {
        return annotate(v.value0)(doc);
      }
      ;
      if (v instanceof Right) {
        return append11(v.value0)(doc);
      }
      ;
      throw new Error("Failed pattern match at Dodo.Box (line 521, column 15 - line 525, column 22): " + [v.constructor.name]);
    };
  })(mempty9);
  var writeBreak = function(v) {
    var line2 = stkToDoc(v.currentLine);
    return {
      currentIndent: mempty9,
      currentLine: filter2(isLeft)(v.currentLine),
      currentWidth: 0,
      lines: vappend(v.lines)(new DocLine(append11(v.currentIndent)(line2), v.currentWidth))
    };
  };
  var leaveAnnotation = function(v) {
    return function(v1) {
      return function(v2) {
        var line2 = function() {
          if (v2.currentLine instanceof Cons && (v2.currentLine.value0 instanceof Right && (v2.currentLine.value1 instanceof Cons && v2.currentLine.value1.value0 instanceof Left))) {
            return new Cons(new Right(annotate(v2.currentLine.value1.value0.value0)(v2.currentLine.value0.value0)), v2.currentLine.value1.value1);
          }
          ;
          if (v2.currentLine instanceof Cons && v2.currentLine.value0 instanceof Left) {
            return v2.currentLine.value1;
          }
          ;
          return unsafeCrashWith("leaveAnnotation: docs and annotations must be interleaved");
        }();
        return {
          currentIndent: v2.currentIndent,
          currentLine: line2,
          currentWidth: v2.currentWidth,
          lines: v2.lines
        };
      };
    };
  };
  var flushBuffer = function(v) {
    if (isEmpty6(v.lines) && $$null3(v.currentLine)) {
      return DocEmpty.value;
    }
    ;
    if (otherwise) {
      var line2 = stkToDoc(v.currentLine);
      return vappend(v.lines)(new DocLine(append11(v.currentIndent)(line2), v.currentWidth));
    }
    ;
    throw new Error("Failed pattern match at Dodo.Box (line 511, column 3 - line 511, column 44): " + [v.constructor.name]);
  };
  var enterAnnotation = function(ann) {
    return function(v) {
      return function(v1) {
        return {
          currentIndent: v1.currentIndent,
          currentLine: new Cons(new Left(ann), v1.currentLine),
          currentWidth: v1.currentWidth,
          lines: v1.lines
        };
      };
    };
  };
  var emptyBuffer = {
    currentIndent: mempty9,
    currentLine: Nil.value,
    currentWidth: 0,
    lines: DocEmpty.value
  };
  return {
    emptyBuffer,
    writeText,
    writeIndent,
    writeBreak,
    enterAnnotation,
    leaveAnnotation,
    flushBuffer
  };
}();
var build2 = /* @__PURE__ */ function() {
  var go = function($copy_cmd) {
    return function($copy_stack) {
      var $tco_var_cmd = $copy_cmd;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(cmd, stack) {
        if (cmd instanceof BuildEnter) {
          if (cmd.value0 instanceof FullHeight) {
            if (cmd.value2 instanceof DocHApp) {
              $tco_var_cmd = new BuildEnter(cmd.value0, StpDone.value, cmd.value2.value1);
              $copy_stack = new BuildHAppR(cmd.value0.value0, cmd.value2.value0, cmd.value1, stack);
              return;
            }
            ;
            $tco_var_cmd = new BuildEnter(AsIs.value, cmd.value1, resize({
              width: 0,
              height: cmd.value0.value0
            })(cmd.value2));
            $copy_stack = stack;
            return;
          }
          ;
          if (cmd.value0 instanceof FullWidth) {
            if (cmd.value2 instanceof DocVApp) {
              $tco_var_cmd = new BuildEnter(cmd.value0, cmd.value1, cmd.value2.value1);
              $copy_stack = new BuildVAppR(cmd.value0.value0, cmd.value2.value0, stack);
              return;
            }
            ;
            $tco_var_cmd = new BuildEnter(AsIs.value, cmd.value1, resize({
              width: cmd.value0.value0,
              height: 0
            })(cmd.value2));
            $copy_stack = stack;
            return;
          }
          ;
          if (cmd.value0 instanceof AsIs) {
            if (cmd.value2 instanceof DocVApp) {
              $tco_var_cmd = new BuildEnter(new FullWidth(cmd.value2.value2.width), cmd.value1, cmd.value2.value1);
              $copy_stack = new BuildVAppR(cmd.value2.value2.width, cmd.value2.value0, stack);
              return;
            }
            ;
            if (cmd.value2 instanceof DocHApp) {
              $tco_var_cmd = new BuildEnter(new FullHeight(cmd.value2.value2.height), StpDone.value, cmd.value2.value1);
              $copy_stack = new BuildHAppR(cmd.value2.value2.height, cmd.value2.value0, cmd.value1, stack);
              return;
            }
            ;
            if (cmd.value2 instanceof DocAlign) {
              $tco_var_cmd = new BuildEnter(cmd.value0, cmd.value1, cmd.value2.value2);
              $copy_stack = stack;
              return;
            }
            ;
            if (cmd.value2 instanceof DocLine) {
              $tco_var_cmd = new BuildLeave(new StpLine(cmd.value2.value0, cmd.value1));
              $copy_stack = stack;
              return;
            }
            ;
            if (cmd.value2 instanceof DocPad) {
              $tco_var_cmd = new BuildLeave(new StpPad(cmd.value2.value0.width, cmd.value2.value0.height, cmd.value1));
              $copy_stack = stack;
              return;
            }
            ;
            if (cmd.value2 instanceof DocEmpty) {
              $tco_var_cmd = new BuildLeave(StpDone.value);
              $copy_stack = stack;
              return;
            }
            ;
            throw new Error("Failed pattern match at Dodo.Box (line 341, column 11 - line 353, column 44): " + [cmd.value2.constructor.name]);
          }
          ;
          throw new Error("Failed pattern match at Dodo.Box (line 327, column 7 - line 353, column 44): " + [cmd.value0.constructor.name]);
        }
        ;
        if (cmd instanceof BuildLeave) {
          if (stack instanceof BuildVAppR) {
            $tco_var_cmd = new BuildEnter(new FullWidth(stack.value0), cmd.value0, stack.value1);
            $copy_stack = stack.value2;
            return;
          }
          ;
          if (stack instanceof BuildHAppR) {
            $tco_var_cmd = new BuildEnter(new FullHeight(stack.value0), StpDone.value, stack.value1);
            $copy_stack = new BuildHAppH(cmd.value0, stack.value2, stack.value3);
            return;
          }
          ;
          if (stack instanceof BuildHAppH) {
            $tco_var_cmd = new BuildLeave(new StpHorz(cmd.value0, stack.value0, stack.value1));
            $copy_stack = stack.value2;
            return;
          }
          ;
          if (stack instanceof BuildNil) {
            $tco_done = true;
            return cmd.value0;
          }
          ;
          throw new Error("Failed pattern match at Dodo.Box (line 355, column 7 - line 363, column 15): " + [stack.constructor.name]);
        }
        ;
        throw new Error("Failed pattern match at Dodo.Box (line 325, column 18 - line 363, column 15): " + [cmd.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_cmd, $copy_stack);
      }
      ;
      return $tco_result;
    };
  };
  return function(size10) {
    return function(next2) {
      return function(box) {
        return go(new BuildEnter(size10, next2, box))(BuildNil.value);
      };
    };
  };
}();
var toDoc = /* @__PURE__ */ function() {
  var go2 = function($copy_acc) {
    return function($copy_v) {
      var $tco_var_acc = $copy_acc;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(acc, v) {
        if (v instanceof Nothing) {
          $tco_done = true;
          return acc;
        }
        ;
        if (v instanceof Just) {
          $tco_var_acc = append11(acc)(append11($$break)(formatLine(v.value0.line)));
          $copy_v = resume2(v.value0.next);
          return;
        }
        ;
        throw new Error("Failed pattern match at Dodo.Box (line 278, column 13 - line 281, column 63): " + [v.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_acc, $copy_v);
      }
      ;
      return $tco_result;
    };
  };
  var go1 = function(v) {
    if (v instanceof Nothing) {
      return mempty9;
    }
    ;
    if (v instanceof Just) {
      return go2(formatLine(v.value0.line))(resume2(v.value0.next));
    }
    ;
    throw new Error("Failed pattern match at Dodo.Box (line 273, column 9 - line 276, column 42): " + [v.constructor.name]);
  };
  var $281 = build2(AsIs.value)(StpDone.value);
  return function($282) {
    return go1(resume2($281($282)));
  };
}();

// output/Effect.Console/foreign.js
var log2 = function(s) {
  return function() {
    console.log(s);
  };
};
var error2 = function(s) {
  return function() {
    console.error(s);
  };
};

// output/Effect.Class.Console/index.js
var log3 = function(dictMonadEffect) {
  var $51 = liftEffect(dictMonadEffect);
  return function($52) {
    return $51(log2($52));
  };
};
var error3 = function(dictMonadEffect) {
  var $59 = liftEffect(dictMonadEffect);
  return function($60) {
    return $59(error2($60));
  };
};

// output/Spago.Log/index.js
var lines3 = /* @__PURE__ */ lines(foldableArray);
var map48 = /* @__PURE__ */ map(functorArray);
var map117 = /* @__PURE__ */ map(functorMaybe);
var max7 = /* @__PURE__ */ max(ordInt);
var horizontal2 = /* @__PURE__ */ horizontal(foldableArray);
var vertical2 = /* @__PURE__ */ vertical(foldableArray);
var append19 = /* @__PURE__ */ append(semigroupDoc);
var traverse4 = /* @__PURE__ */ traverse(traversableArray);
var discard9 = /* @__PURE__ */ discard(discardUnit);
var OutputJson = /* @__PURE__ */ function() {
  function OutputJson2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  OutputJson2.create = function(value0) {
    return function(value12) {
      return new OutputJson2(value0, value12);
    };
  };
  return OutputJson2;
}();
var OutputTable = /* @__PURE__ */ function() {
  function OutputTable2(value0) {
    this.value0 = value0;
  }
  ;
  OutputTable2.create = function(value0) {
    return new OutputTable2(value0);
  };
  return OutputTable2;
}();
var OutputLines = /* @__PURE__ */ function() {
  function OutputLines2(value0) {
    this.value0 = value0;
  }
  ;
  OutputLines2.create = function(value0) {
    return new OutputLines2(value0);
  };
  return OutputLines2;
}();
var LogQuiet = /* @__PURE__ */ function() {
  function LogQuiet2() {
  }
  ;
  LogQuiet2.value = new LogQuiet2();
  return LogQuiet2;
}();
var LogNormal = /* @__PURE__ */ function() {
  function LogNormal2() {
  }
  ;
  LogNormal2.value = new LogNormal2();
  return LogNormal2;
}();
var LogVerbose = /* @__PURE__ */ function() {
  function LogVerbose2() {
  }
  ;
  LogVerbose2.value = new LogVerbose2();
  return LogVerbose2;
}();
var LogDebug = /* @__PURE__ */ function() {
  function LogDebug2() {
  }
  ;
  LogDebug2.value = new LogDebug2();
  return LogDebug2;
}();
var LogInfo = /* @__PURE__ */ function() {
  function LogInfo2() {
  }
  ;
  LogInfo2.value = new LogInfo2();
  return LogInfo2;
}();
var LogWarning = /* @__PURE__ */ function() {
  function LogWarning2() {
  }
  ;
  LogWarning2.value = new LogWarning2();
  return LogWarning2;
}();
var LogError = /* @__PURE__ */ function() {
  function LogError2() {
  }
  ;
  LogError2.value = new LogError2();
  return LogError2;
}();
var loggableString = {
  toDoc: text
};
var loggableDocc = {
  toDoc: /* @__PURE__ */ identity(categoryFn)
};
var toDoc2 = function(dict) {
  return dict.toDoc;
};
var toDoc1 = /* @__PURE__ */ toDoc2(loggableString);
var loggableArray = function(dictLoggable) {
  return {
    toDoc: function() {
      var $114 = map48(toDoc2(dictLoggable));
      return function($115) {
        return lines3($114($115));
      };
    }()
  };
};
var loggablePackageName = {
  toDoc: function($116) {
    return toDoc1(print2($116));
  }
};
var textBox = /* @__PURE__ */ function() {
  var $117 = print(docBox)(twoSpaces);
  return function($118) {
    return $117(text($118));
  };
}();
var logTable = function(v) {
  var widths = mapWithIndex2(function(ix) {
    return function(hd) {
      return foldr2(function() {
        var $119 = fromMaybe(0);
        var $120 = map117(function($123) {
          return function(v1) {
            return v1.width;
          }(sizeOf($123));
        });
        var $121 = flip(index)(ix);
        return function($122) {
          return max7($119($120($121($122))));
        };
      }())(sizeOf(hd).width)(v.rows);
    };
  })(v.headers);
  var joint = fill3(text("+"))({
    width: 1,
    height: 1
  });
  var rowSep = horizontal2([joint, horizontal2(intersperse(joint)(map48(function(width2) {
    return fill3(text("-"))({
      width: width2 + 2 | 0,
      height: 1
    });
  })(widths))), joint]);
  var columns = function(cols) {
    var height = foldr2(function($124) {
      return max7(function(v1) {
        return v1.height;
      }(sizeOf($124)));
    })(0)(cols);
    var sep2 = fill3(text("|"))({
      width: 1,
      height
    });
    var colBoxes = mapWithIndex2(function(ix) {
      return function(col) {
        return horizontal2([hpadding(1), resize({
          width: fromMaybe(0)(index(widths)(ix)),
          height
        })(col), hpadding(1)]);
      };
    })(cols);
    return horizontal2([sep2, horizontal2(intersperse(sep2)(colBoxes)), sep2]);
  };
  return vertical2([rowSep, vertical2(cons(columns(v.headers))(cons(rowSep)(map48(columns)(v.rows)))), rowSep]);
};
var output = function(dictMonadEffect) {
  var log1 = log3(dictMonadEffect);
  return function(format2) {
    return log1(function() {
      if (format2 instanceof OutputJson) {
        return printJson(format2.value0)(format2.value1);
      }
      ;
      if (format2 instanceof OutputLines) {
        return joinWith("\n")(format2.value0);
      }
      ;
      if (format2 instanceof OutputTable) {
        return print(plainText)(twoSpaces)(toDoc(logTable({
          headers: map48(textBox)(format2.value0.titles),
          rows: map48(map48(textBox))(format2.value0.rows)
        })));
      }
      ;
      throw new Error("Failed pattern match at Spago.Log (line 140, column 29 - line 147, column 79): " + [format2.constructor.name]);
    }());
  };
};
var log4 = function(dictMonadEffect) {
  var error4 = error3(dictMonadEffect);
  return function(dictMonadAsk) {
    var Monad0 = dictMonadAsk.Monad0();
    var bind59 = bind(Monad0.Bind1());
    var ask17 = ask(dictMonadAsk);
    var pure75 = pure(Monad0.Applicative0());
    return function(v) {
      return bind59(ask17)(function(v1) {
        var printFn = function() {
          if (v1.logOptions.color) {
            return print(ansiGraphics);
          }
          ;
          return print(plainText);
        }();
        if (v1.logOptions.verbosity instanceof LogQuiet) {
          return pure75(unit);
        }
        ;
        if (v1.logOptions.verbosity instanceof LogNormal && v.level instanceof LogDebug) {
          return pure75(unit);
        }
        ;
        return error4(printFn({
          pageWidth: 200,
          ribbonRatio: twoSpaces.ribbonRatio,
          indentUnit: twoSpaces.indentUnit,
          indentWidth: twoSpaces.indentWidth
        })(v.content));
      });
    };
  };
};
var logDebug = function(dictMonadEffect) {
  var log1 = log4(dictMonadEffect);
  return function(dictMonadAsk) {
    var log22 = log1(dictMonadAsk);
    return function(dictLoggable) {
      var toDoc25 = toDoc2(dictLoggable);
      return function(l) {
        return log22({
          level: LogDebug.value,
          content: foreground(Blue.value)(toDoc25(l))
        });
      };
    };
  };
};
var logError = function(dictMonadEffect) {
  var log1 = log4(dictMonadEffect);
  return function(dictMonadAsk) {
    var log22 = log1(dictMonadAsk);
    return function(dictLoggable) {
      var toDoc25 = toDoc2(dictLoggable);
      return function(l) {
        return log22({
          level: LogError.value,
          content: foreground(Red.value)(toDoc25(l))
        });
      };
    };
  };
};
var logFailure = function(dictMonadEffect) {
  var log1 = log4(dictMonadEffect);
  return function(dictMonadAsk) {
    var log22 = log1(dictMonadAsk);
    return function(dictLoggable) {
      var toDoc25 = toDoc2(dictLoggable);
      return function(l) {
        return log22({
          level: LogInfo.value,
          content: foreground(Red.value)(append19($$break)(append19(bold(append19(toDoc1("\u274C"))(append19(space)(toDoc25(l)))))($$break)))
        });
      };
    };
  };
};
var logInfo = function(dictMonadEffect) {
  var log1 = log4(dictMonadEffect);
  return function(dictMonadAsk) {
    var log22 = log1(dictMonadAsk);
    return function(dictLoggable) {
      var toDoc25 = toDoc2(dictLoggable);
      return function(l) {
        return log22({
          level: LogInfo.value,
          content: toDoc25(l)
        });
      };
    };
  };
};
var logSuccess = function(dictMonadEffect) {
  var log1 = log4(dictMonadEffect);
  return function(dictMonadAsk) {
    var log22 = log1(dictMonadAsk);
    return function(dictLoggable) {
      var toDoc25 = toDoc2(dictLoggable);
      return function(l) {
        return log22({
          level: LogInfo.value,
          content: foreground(Green.value)(append19($$break)(append19(bold(append19(toDoc1("\u2705"))(append19(space)(toDoc25(l)))))($$break)))
        });
      };
    };
  };
};
var logWarn = function(dictMonadEffect) {
  var log1 = log4(dictMonadEffect);
  return function(dictMonadAsk) {
    var log22 = log1(dictMonadAsk);
    return function(dictLoggable) {
      var toDoc25 = toDoc2(dictLoggable);
      return function(l) {
        return log22({
          level: LogWarning.value,
          content: foreground(Yellow.value)(bold(append19(toDoc1("\u26A0\uFE0F"))(append19(space)(toDoc25(l)))))
        });
      };
    };
  };
};
var indent22 = function($125) {
  return indent(indent($125));
};
var die$prime = function(dictMonadEffect) {
  var logFailure1 = logFailure(dictMonadEffect);
  var liftEffect13 = liftEffect(dictMonadEffect);
  return function(dictMonadAsk) {
    var Monad0 = dictMonadAsk.Monad0();
    var bind59 = bind(Monad0.Bind1());
    var traverse12 = traverse4(Monad0.Applicative0());
    var logFailure2 = logFailure1(dictMonadAsk);
    return function(dictLoggable) {
      var logFailure3 = logFailure2(dictLoggable);
      return function(msgs) {
        return bind59(traverse12(logFailure3)(msgs))(function() {
          return liftEffect13(exit(1));
        });
      };
    };
  };
};
var die = function(dictMonadEffect) {
  var logFailure1 = logFailure(dictMonadEffect);
  var liftEffect13 = liftEffect(dictMonadEffect);
  return function(dictMonadAsk) {
    var discard113 = discard9(dictMonadAsk.Monad0().Bind1());
    var logFailure2 = logFailure1(dictMonadAsk);
    return function(dictLoggable) {
      var logFailure3 = logFailure2(dictLoggable);
      return function(msg) {
        return discard113(logFailure3(msg))(function() {
          return liftEffect13(exit(1));
        });
      };
    };
  };
};

// output/Spago.Yaml/foreign.js
var import_yaml = __toESM(require_dist(), 1);
function yamlDocParserImpl(fail5, succ2, s) {
  const doc = import_yaml.default.parseDocument(s);
  if (doc.errors.length === 0) {
    return succ2(doc);
  } else {
    return fail5(JSON.stringify(doc.errors));
  }
}
function toJsonImpl(doc) {
  return doc.toJSON();
}
function toStringImpl2(doc) {
  return doc.toString();
}
function stringifyWithIndent2(i) {
  return function(j) {
    return import_yaml.default.stringify(j, null, i);
  };
}

// output/Spago.Yaml/index.js
var bind26 = /* @__PURE__ */ bind(bindEither);
var lmap9 = /* @__PURE__ */ lmap(bifunctorEither);
var pure38 = /* @__PURE__ */ pure(applicativeEither);
var map49 = /* @__PURE__ */ map(functorEither);
var yamlParser = function(j) {
  return yamlDocParserImpl(Left.create, Right.create, j);
};
var toString8 = /* @__PURE__ */ runFn1(toStringImpl2);
var toJson = /* @__PURE__ */ runFn1(toJsonImpl);
var printYaml = function(codec11) {
  var $10 = stringifyWithIndent2(2);
  var $11 = encode(codec11);
  return function($12) {
    return $10($11($12));
  };
};
var parseYamlDoc = function(codec11) {
  return function(yamlStr) {
    return bind26(lmap9(function(err) {
      return new TypeMismatch("YAML: " + err);
    })(yamlParser(yamlStr)))(function(doc) {
      return bind26(decode(codec11)(toJson(doc)))(function(yaml) {
        return pure38({
          doc,
          yaml
        });
      });
    });
  };
};
var parseYaml = function(codec11) {
  var $13 = map49(function(v) {
    return v.yaml;
  });
  var $14 = parseYamlDoc(codec11);
  return function($15) {
    return $13($14($15));
  };
};

// output/Spago.Core.Prelude/index.js
var monadSpago = /* @__PURE__ */ monadReaderT(monadAff);
var monadErrorErrorSpago = /* @__PURE__ */ monadErrorReaderT(monadErrorAff);
var monadEffectSpago = /* @__PURE__ */ monadEffectReader(monadEffectAff);
var monadAskSpago = /* @__PURE__ */ monadAskReaderT(monadAff);
var monadAffSpago = /* @__PURE__ */ monadAffReader(monadAffAff);
var functorSpago = /* @__PURE__ */ functorReaderT(functorAff);
var bindSpago = /* @__PURE__ */ bindReaderT(bindAff);
var applySpago = /* @__PURE__ */ applyReaderT(applyAff);
var applicativeSpago = /* @__PURE__ */ applicativeReaderT(applicativeAff);
var unsafeFromJust = /* @__PURE__ */ fromMaybe$prime(function(v) {
  return unsafeCrashWith("Unexpected Nothing");
});
var runSpago$prime = function(env3) {
  return function(v) {
    return runReaderT(v)(env3);
  };
};
var runSpago = function(dictMonadAff) {
  var liftAff10 = liftAff(dictMonadAff);
  return function(env3) {
    return function(a) {
      return liftAff10(runSpago$prime(env3)(a));
    };
  };
};

// output/Spago.FS/foreign.js
var import_fs_extra = __toESM(require_lib(), 1);
import path2 from "path";
var { moveSync, ensureFileSync } = import_fs_extra.default;
var moveSyncImpl = (source2) => (destination) => () => moveSync(source2, destination);
var ensureFileSyncImpl = (file) => () => ensureFileSync(file);
function getPathDifference(basepath, pathToCompare) {
  const normalizedBase = path2.normalize(basepath).split(path2.sep);
  const normalizedPath = path2.normalize(pathToCompare).split(path2.sep);
  return normalizedPath.slice(normalizedBase.length);
}
function getInBetweenPathsImpl(basepath, pathToCompare) {
  const difference6 = getPathDifference(basepath, pathToCompare);
  let currentPath = path2.normalize(basepath);
  const allPaths = [];
  for (let segment2 of difference6) {
    currentPath = path2.join(currentPath, segment2);
    allPaths.push(currentPath);
  }
  return allPaths;
}

// output/Spago.FS/index.js
var $$try5 = /* @__PURE__ */ $$try2(monadErrorAff);
var bind27 = /* @__PURE__ */ bind(bindAff);
var pure39 = /* @__PURE__ */ pure(applicativeAff);
var bind112 = /* @__PURE__ */ bind(bindEither);
var lmap10 = /* @__PURE__ */ lmap(bifunctorEither);
var try1 = /* @__PURE__ */ $$try2(monadErrorEffect);
var writeYamlFile = function(codec11) {
  return function(path5) {
    var $46 = writeTextFile2(UTF8.value)(path5);
    var $47 = printYaml(codec11);
    return function($48) {
      return $46(function(v) {
        return v + "\n";
      }(trim($47($48))));
    };
  };
};
var writeYamlDocFile = function(path5) {
  var $49 = writeTextFile2(UTF8.value)(path5);
  return function($50) {
    return $49(function(v) {
      return v + "\n";
    }(trim(toString8($50))));
  };
};
var writeTextFile3 = function(dictMonadAff) {
  var liftAff10 = liftAff(dictMonadAff);
  return function(path5) {
    return function(text3) {
      return liftAff10(writeTextFile2(UTF8.value)(path5)(text3));
    };
  };
};
var writeFile4 = function(dictMonadAff) {
  var liftAff10 = liftAff(dictMonadAff);
  return function(path5) {
    return function(buf) {
      return liftAff10(writeFile3(path5)(buf));
    };
  };
};
var stat5 = function(dictMonadAff) {
  var liftAff10 = liftAff(dictMonadAff);
  return function(path5) {
    return liftAff10($$try5(stat3(path5)));
  };
};
var readYamlFile = function(codec11) {
  return function(path5) {
    return bind27(attempt(readTextFile2(UTF8.value)(path5)))(function(result) {
      return pure39(bind112(lmap10(message)(result))(function() {
        var $54 = lmap10(printJsonDecodeError);
        var $55 = parseYaml(codec11);
        return function($56) {
          return $54($55($56));
        };
      }()));
    });
  };
};
var readYamlDocFile = function(codec11) {
  return function(path5) {
    return bind27(attempt(readTextFile2(UTF8.value)(path5)))(function(result) {
      return pure39(bind112(lmap10(message)(result))(function() {
        var $57 = lmap10(printJsonDecodeError);
        var $58 = parseYamlDoc(codec11);
        return function($59) {
          return $57($58($59));
        };
      }()));
    });
  };
};
var readTextFile3 = function(dictMonadAff) {
  var liftAff10 = liftAff(dictMonadAff);
  return function(path5) {
    return liftAff10(readTextFile2(UTF8.value)(path5));
  };
};
var readJsonFile = function(codec11) {
  return function(path5) {
    return bind27(attempt(readTextFile2(UTF8.value)(path5)))(function(result) {
      return pure39(bind112(lmap10(message)(result))(function() {
        var $60 = lmap10(printJsonDecodeError);
        var $61 = parseJson(codec11);
        return function($62) {
          return $60($61($62));
        };
      }()));
    });
  };
};
var moveSync2 = function(dictMonadEffect) {
  var liftEffect13 = liftEffect(dictMonadEffect);
  return function(v) {
    return liftEffect13(moveSyncImpl(v.src)(v.dst));
  };
};
var mkdirp = function(dictMonadAff) {
  var $63 = liftAff(dictMonadAff);
  var $64 = flip(mkdir$prime2)({
    recursive: true,
    mode: mkPerms(all4)(all4)(all4)
  });
  return function($65) {
    return $63($64($65));
  };
};
var ls = function(dictMonadAff) {
  var $66 = liftAff(dictMonadAff);
  return function($67) {
    return $66(readdir3($67));
  };
};
var isLink = function(dictMonadEffect) {
  var liftEffect13 = liftEffect(dictMonadEffect);
  return function(path5) {
    return liftEffect13(function __do3() {
      var v = try1(lstat2(path5))();
      if (v instanceof Left) {
        return true;
      }
      ;
      if (v instanceof Right) {
        return isSymbolicLink(v.value0);
      }
      ;
      throw new Error("Failed pattern match at Spago.FS (line 100, column 57 - line 102, column 51): " + [v.constructor.name]);
    });
  };
};
var getInBetweenPaths = function(dictMonadEffect) {
  var liftEffect13 = liftEffect(dictMonadEffect);
  return function(a) {
    return function(b) {
      return liftEffect13(function() {
        return getInBetweenPathsImpl(a, b);
      });
    };
  };
};
var exists2 = function(dictMonadEffect) {
  var $68 = liftEffect(dictMonadEffect);
  return function($69) {
    return $68(exists($69));
  };
};
var ensureFileSync2 = function(dictMonadEffect) {
  var liftEffect13 = liftEffect(dictMonadEffect);
  return function(file) {
    return liftEffect13(ensureFileSyncImpl(file));
  };
};
var chmod4 = function(dictMonadAff) {
  var liftAff10 = liftAff(dictMonadAff);
  return function(path5) {
    return function(perms) {
      return liftAff10(chmod3(path5)(perms));
    };
  };
};

// output/Spago.Core.Config/index.js
var unionWith2 = /* @__PURE__ */ unionWith(ordPackageName);
var dimap3 = /* @__PURE__ */ dimap(/* @__PURE__ */ profunctorCodec(functorEither));
var object5 = /* @__PURE__ */ object2();
var rowListCodecCons4 = /* @__PURE__ */ rowListCodecCons(rowListCodecNil)()();
var alt16 = /* @__PURE__ */ alt(altEither);
var map50 = /* @__PURE__ */ map(functorEither);
var rowListCodecConsOptional2 = /* @__PURE__ */ rowListCodecConsOptional(rowListCodecNil)()();
var mainIsSymbol = {
  reflectSymbol: function() {
    return "main";
  }
};
var execArgsIsSymbol = {
  reflectSymbol: function() {
    return "execArgs";
  }
};
var rowListCodecCons1 = /* @__PURE__ */ rowListCodecCons4({
  reflectSymbol: function() {
    return "version";
  }
});
var eq62 = /* @__PURE__ */ eq(eqRange);
var dependenciesIsSymbol = {
  reflectSymbol: function() {
    return "dependencies";
  }
};
var map118 = /* @__PURE__ */ map(functorArray);
var toUnfoldable13 = /* @__PURE__ */ toUnfoldable5(unfoldableArray);
var rmap3 = /* @__PURE__ */ rmap(bifunctorTuple);
var toUnfoldable14 = /* @__PURE__ */ toUnfoldable5(unfoldableList);
var nonEmptySet2 = /* @__PURE__ */ nonEmptySet(ordString);
var discard10 = /* @__PURE__ */ discard(discardUnit)(bindSpago);
var logDebug2 = /* @__PURE__ */ logDebug(monadEffectSpago)(monadAskSpago)(loggableString);
var bind28 = /* @__PURE__ */ bind(bindSpago);
var exists3 = /* @__PURE__ */ exists2(monadEffectSpago);
var pure40 = /* @__PURE__ */ pure(applicativeSpago);
var liftAff2 = /* @__PURE__ */ liftAff(monadAffSpago);
var NoStats = /* @__PURE__ */ function() {
  function NoStats2() {
  }
  ;
  NoStats2.value = new NoStats2();
  return NoStats2;
}();
var CompactStats = /* @__PURE__ */ function() {
  function CompactStats2() {
  }
  ;
  CompactStats2.value = new CompactStats2();
  return CompactStats2;
}();
var VerboseStats = /* @__PURE__ */ function() {
  function VerboseStats2() {
  }
  ;
  VerboseStats2.value = new VerboseStats2();
  return VerboseStats2;
}();
var ShowSourceCode = /* @__PURE__ */ function() {
  function ShowSourceCode2() {
  }
  ;
  ShowSourceCode2.value = new ShowSourceCode2();
  return ShowSourceCode2;
}();
var NoSourceCode = /* @__PURE__ */ function() {
  function NoSourceCode2() {
  }
  ;
  NoSourceCode2.value = new NoSourceCode2();
  return NoSourceCode2;
}();
var SetFromRegistry = /* @__PURE__ */ function() {
  function SetFromRegistry2(value0) {
    this.value0 = value0;
  }
  ;
  SetFromRegistry2.create = function(value0) {
    return new SetFromRegistry2(value0);
  };
  return SetFromRegistry2;
}();
var SetFromUrl = /* @__PURE__ */ function() {
  function SetFromUrl2(value0) {
    this.value0 = value0;
  }
  ;
  SetFromUrl2.create = function(value0) {
    return new SetFromUrl2(value0);
  };
  return SetFromUrl2;
}();
var Dependencies = function(x) {
  return x;
};
var RemoteGitPackage = /* @__PURE__ */ function() {
  function RemoteGitPackage2(value0) {
    this.value0 = value0;
  }
  ;
  RemoteGitPackage2.create = function(value0) {
    return new RemoteGitPackage2(value0);
  };
  return RemoteGitPackage2;
}();
var RemoteRegistryVersion = /* @__PURE__ */ function() {
  function RemoteRegistryVersion2(value0) {
    this.value0 = value0;
  }
  ;
  RemoteRegistryVersion2.create = function(value0) {
    return new RemoteRegistryVersion2(value0);
  };
  return RemoteRegistryVersion2;
}();
var RemoteLegacyPackage = /* @__PURE__ */ function() {
  function RemoteLegacyPackage2(value0) {
    this.value0 = value0;
  }
  ;
  RemoteLegacyPackage2.create = function(value0) {
    return new RemoteLegacyPackage2(value0);
  };
  return RemoteLegacyPackage2;
}();
var ExtraLocalPackage = /* @__PURE__ */ function() {
  function ExtraLocalPackage2(value0) {
    this.value0 = value0;
  }
  ;
  ExtraLocalPackage2.create = function(value0) {
    return new ExtraLocalPackage2(value0);
  };
  return ExtraLocalPackage2;
}();
var ExtraRemotePackage = /* @__PURE__ */ function() {
  function ExtraRemotePackage2(value0) {
    this.value0 = value0;
  }
  ;
  ExtraRemotePackage2.create = function(value0) {
    return new ExtraRemotePackage2(value0);
  };
  return ExtraRemotePackage2;
}();
var CensorNoWarnings = /* @__PURE__ */ function() {
  function CensorNoWarnings2() {
  }
  ;
  CensorNoWarnings2.value = new CensorNoWarnings2();
  return CensorNoWarnings2;
}();
var CensorDependencyWarnings = /* @__PURE__ */ function() {
  function CensorDependencyWarnings2() {
  }
  ;
  CensorDependencyWarnings2.value = new CensorDependencyWarnings2();
  return CensorDependencyWarnings2;
}();
var CensorProjectWarnings = /* @__PURE__ */ function() {
  function CensorProjectWarnings2() {
  }
  ;
  CensorProjectWarnings2.value = new CensorProjectWarnings2();
  return CensorProjectWarnings2;
}();
var CensorAllWarnings = /* @__PURE__ */ function() {
  function CensorAllWarnings2() {
  }
  ;
  CensorAllWarnings2.value = new CensorAllWarnings2();
  return CensorAllWarnings2;
}();
var BundleApp = /* @__PURE__ */ function() {
  function BundleApp2() {
  }
  ;
  BundleApp2.value = new BundleApp2();
  return BundleApp2;
}();
var BundleModule = /* @__PURE__ */ function() {
  function BundleModule2() {
  }
  ;
  BundleModule2.value = new BundleModule2();
  return BundleModule2;
}();
var BundleNode = /* @__PURE__ */ function() {
  function BundleNode2() {
  }
  ;
  BundleNode2.value = new BundleNode2();
  return BundleNode2;
}();
var BundleBrowser = /* @__PURE__ */ function() {
  function BundleBrowser2() {
  }
  ;
  BundleBrowser2.value = new BundleBrowser2();
  return BundleBrowser2;
}();
var showStatVerbosity = {
  show: function(v) {
    if (v instanceof NoStats) {
      return "NoStats";
    }
    ;
    if (v instanceof CompactStats) {
      return "CompactStats";
    }
    ;
    if (v instanceof VerboseStats) {
      return "VerboseStats";
    }
    ;
    throw new Error("Failed pattern match at Spago.Core.Config (line 363, column 10 - line 366, column 35): " + [v.constructor.name]);
  }
};
var showShowSourceCode = {
  show: function(v) {
    if (v instanceof ShowSourceCode) {
      return "ShowSourceCode";
    }
    ;
    if (v instanceof NoSourceCode) {
      return "NoSourceCode";
    }
    ;
    throw new Error("Failed pattern match at Spago.Core.Config (line 353, column 10 - line 355, column 35): " + [v.constructor.name]);
  }
};
var showCensorBuildWarnings = {
  show: function(v) {
    if (v instanceof CensorNoWarnings) {
      return "CensorNoWarnings";
    }
    ;
    if (v instanceof CensorDependencyWarnings) {
      return "CensorDependencyWarnings";
    }
    ;
    if (v instanceof CensorProjectWarnings) {
      return "CensorProjectWarnings";
    }
    ;
    if (v instanceof CensorAllWarnings) {
      return "CensorAllWarnings";
    }
    ;
    throw new Error("Failed pattern match at Spago.Core.Config (line 314, column 10 - line 318, column 45): " + [v.constructor.name]);
  }
};
var showBundleType = {
  show: function(v) {
    if (v instanceof BundleApp) {
      return "app";
    }
    ;
    if (v instanceof BundleModule) {
      return "module";
    }
    ;
    throw new Error("Failed pattern match at Spago.Core.Config (line 183, column 10 - line 185, column 29): " + [v.constructor.name]);
  }
};
var showBundlePlatform = {
  show: function(v) {
    if (v instanceof BundleNode) {
      return "node";
    }
    ;
    if (v instanceof BundleBrowser) {
      return "browser";
    }
    ;
    throw new Error("Failed pattern match at Spago.Core.Config (line 165, column 10 - line 167, column 31): " + [v.constructor.name]);
  }
};
var semigroupDependencies = {
  append: function(v) {
    return function(v1) {
      return unionWith2(function(v2) {
        return function(v3) {
          if (v2 instanceof Nothing && v3 instanceof Nothing) {
            return Nothing.value;
          }
          ;
          if (v2 instanceof Just && v3 instanceof Nothing) {
            return new Just(v2.value0);
          }
          ;
          if (v2 instanceof Nothing && v3 instanceof Just) {
            return new Just(v3.value0);
          }
          ;
          if (v2 instanceof Just && v3 instanceof Just) {
            return intersect2(v2.value0)(v3.value0);
          }
          ;
          throw new Error("Failed pattern match at Spago.Core.Config (line 203, column 7 - line 207, column 50): " + [v2.constructor.name, v3.constructor.name]);
        };
      })(v)(v1);
    };
  }
};
var monoidDependencies = {
  mempty: empty3,
  Semigroup0: function() {
    return semigroupDependencies;
  }
};
var eqShowSourceCode = {
  eq: function(x) {
    return function(y) {
      if (x instanceof ShowSourceCode && y instanceof ShowSourceCode) {
        return true;
      }
      ;
      if (x instanceof NoSourceCode && y instanceof NoSourceCode) {
        return true;
      }
      ;
      return false;
    };
  }
};
var widestRange = /* @__PURE__ */ fromRight$prime(function(v) {
  return unsafeCrashWith("Fake range failed");
})(/* @__PURE__ */ parse7(">=0.0.0 <2147483647.0.0"));
var statVerbosityCodec = /* @__PURE__ */ function() {
  var print9 = function(v) {
    if (v instanceof NoStats) {
      return "no-stats";
    }
    ;
    if (v instanceof CompactStats) {
      return "compact-stats";
    }
    ;
    if (v instanceof VerboseStats) {
      return "verbose-stats";
    }
    ;
    throw new Error("Failed pattern match at Spago.Core.Config (line 371, column 11 - line 374, column 36): " + [v.constructor.name]);
  };
  var parse10 = function(v) {
    if (v === "no-stats") {
      return new Just(NoStats.value);
    }
    ;
    if (v === "compact-stats") {
      return new Just(CompactStats.value);
    }
    ;
    if (v === "verbose-stats") {
      return new Just(VerboseStats.value);
    }
    ;
    return Nothing.value;
  };
  return enumSum(print9)(parse10);
}();
var showSourceCodec = /* @__PURE__ */ function() {
  var to2 = function(v) {
    if (v instanceof ShowSourceCode) {
      return true;
    }
    ;
    if (v instanceof NoSourceCode) {
      return false;
    }
    ;
    throw new Error("Failed pattern match at Spago.Core.Config (line 345, column 8 - line 347, column 26): " + [v.constructor.name]);
  };
  var from3 = function(v) {
    if (!v) {
      return NoSourceCode.value;
    }
    ;
    if (v) {
      return ShowSourceCode.value;
    }
    ;
    throw new Error("Failed pattern match at Spago.Core.Config (line 348, column 10 - line 350, column 27): " + [v.constructor.name]);
  };
  return dimap3(to2)(from3)($$boolean);
}();
var setAddressCodec = /* @__PURE__ */ function() {
  var setFromUrlCodec = object5(rowListCodecConsOptional(rowListCodecCons4({
    reflectSymbol: function() {
      return "url";
    }
  }))()()({
    reflectSymbol: function() {
      return "hash";
    }
  }))("SetFromUrl")({
    url: string,
    hash: optional3(codec9)
  });
  var setFromRegistryCodec = object5(rowListCodecCons4({
    reflectSymbol: function() {
      return "registry";
    }
  }))("SetFromRegistry")({
    registry: codec3
  });
  var encode3 = function(v) {
    if (v instanceof SetFromRegistry) {
      return encode(setFromRegistryCodec)(v.value0);
    }
    ;
    if (v instanceof SetFromUrl) {
      return encode(setFromUrlCodec)(v.value0);
    }
    ;
    throw new Error("Failed pattern match at Spago.Core.Config (line 393, column 3 - line 393, column 64): " + [v.constructor.name]);
  };
  var decode2 = function(json4) {
    return alt16(map50(SetFromRegistry.create)(decode(setFromRegistryCodec)(json4)))(map50(SetFromUrl.create)(decode(setFromUrlCodec)(json4)));
  };
  return codec$prime(decode2)(encode3);
}();
var runConfigCodec = /* @__PURE__ */ object5(/* @__PURE__ */ rowListCodecConsOptional(/* @__PURE__ */ rowListCodecConsOptional2(mainIsSymbol))()()(execArgsIsSymbol))("RunConfig")({
  main: /* @__PURE__ */ optional3(string),
  execArgs: /* @__PURE__ */ optional3(/* @__PURE__ */ array(string))
});
var publishConfigCodec = /* @__PURE__ */ object5(/* @__PURE__ */ rowListCodecConsOptional(/* @__PURE__ */ rowListCodecConsOptional(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecConsOptional(rowListCodecCons1)()()({
  reflectSymbol: function() {
    return "location";
  }
}))()()({
  reflectSymbol: function() {
    return "license";
  }
}))()()({
  reflectSymbol: function() {
    return "include";
  }
}))()()({
  reflectSymbol: function() {
    return "exclude";
  }
}))("PublishConfig")({
  version: codec3,
  license: codec4,
  location: /* @__PURE__ */ optional3(codec5),
  include: /* @__PURE__ */ optional3(/* @__PURE__ */ array(string)),
  exclude: /* @__PURE__ */ optional3(/* @__PURE__ */ array(string))
});
var printSpagoRange = function(range3) {
  var $383 = eq62(range3)(widestRange);
  if ($383) {
    return "*";
  }
  ;
  return print5(range3);
};
var spagoRangeCodec = /* @__PURE__ */ function() {
  var rangeParse = function(str2) {
    var $384 = str2 === "*";
    if ($384) {
      return new Just(widestRange);
    }
    ;
    return hush(parse7(str2));
  };
  return prismaticCodec("SpagoRange")(rangeParse)(printSpagoRange)(string);
}();
var parsePlatform = function(v) {
  if (v === "node") {
    return new Just(BundleNode.value);
  }
  ;
  if (v === "browser") {
    return new Just(BundleBrowser.value);
  }
  ;
  return Nothing.value;
};
var parseBundleType = function(v) {
  if (v === "app") {
    return new Just(BundleApp.value);
  }
  ;
  if (v === "module") {
    return new Just(BundleModule.value);
  }
  ;
  return Nothing.value;
};
var localPackageCodec = /* @__PURE__ */ object5(/* @__PURE__ */ rowListCodecCons4({
  reflectSymbol: function() {
    return "path";
  }
}))("LocalPackage")({
  path: string
});
var legacyPackageSetEntryCodec = /* @__PURE__ */ object5(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(rowListCodecCons1)()()({
  reflectSymbol: function() {
    return "repo";
  }
}))()()(dependenciesIsSymbol))("LegacyPackageSetEntry")({
  dependencies: /* @__PURE__ */ array(codec2),
  repo: string,
  version: string
});
var dependenciesCodec = /* @__PURE__ */ function() {
  var to2 = function(v) {
    return map118(function(v1) {
      if (v1.value1 instanceof Nothing) {
        return new Left(v1.value0);
      }
      ;
      if (v1.value1 instanceof Just) {
        return new Right(singleton10(v1.value0)(v1.value1.value0));
      }
      ;
      throw new Error("Failed pattern match at Spago.Core.Config (line 223, column 37 - line 225, column 49): " + [v1.value1.constructor.name]);
    })(toUnfoldable13(v));
  };
  var packageSingletonCodec = packageMap(spagoRangeCodec);
  var from3 = function() {
    var $409 = fromFoldable6(ordPackageName)(foldableArray);
    var $410 = map118(function(v) {
      if (v instanceof Left) {
        return new Tuple(v.value0, Nothing.value);
      }
      ;
      if (v instanceof Right) {
        return rmap3(Just.create)(unsafeFromJust(head3(toUnfoldable14(v.value0))));
      }
      ;
      throw new Error("Failed pattern match at Spago.Core.Config (line 231, column 7 - line 233, column 79): " + [v.constructor.name]);
    });
    return function($411) {
      return Dependencies($409($410($411)));
    };
  }();
  var dependencyCodec = function() {
    var encode3 = function(v) {
      if (v instanceof Left) {
        return encode(codec2)(v.value0);
      }
      ;
      if (v instanceof Right) {
        return encode(packageSingletonCodec)(v.value0);
      }
      ;
      throw new Error("Failed pattern match at Spago.Core.Config (line 239, column 14 - line 241, column 73): " + [v.constructor.name]);
    };
    var decode2 = function(json4) {
      return alt16(map50(Left.create)(decode(codec2)(json4)))(map50(Right.create)(decode(packageSingletonCodec)(json4)));
    };
    return codec$prime(decode2)(encode3);
  }();
  return dimap3(to2)(from3)(array(dependencyCodec));
}();
var gitPackageCodec = /* @__PURE__ */ object5(/* @__PURE__ */ rowListCodecConsOptional(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecConsOptional2({
  reflectSymbol: function() {
    return "subdir";
  }
}))()()({
  reflectSymbol: function() {
    return "ref";
  }
}))()()({
  reflectSymbol: function() {
    return "git";
  }
}))()()(dependenciesIsSymbol))("GitPackage")({
  git: string,
  ref: string,
  subdir: /* @__PURE__ */ optional3(string),
  dependencies: /* @__PURE__ */ optional3(dependenciesCodec)
});
var remotePackageCodec = /* @__PURE__ */ function() {
  var encode3 = function(v) {
    if (v instanceof RemoteRegistryVersion) {
      return encode(codec3)(v.value0);
    }
    ;
    if (v instanceof RemoteGitPackage) {
      return encode(gitPackageCodec)(v.value0);
    }
    ;
    if (v instanceof RemoteLegacyPackage) {
      return encode(legacyPackageSetEntryCodec)(v.value0);
    }
    ;
    throw new Error("Failed pattern match at Spago.Core.Config (line 429, column 3 - line 429, column 63): " + [v.constructor.name]);
  };
  var decode2 = function(json4) {
    return alt16(map50(RemoteRegistryVersion.create)(decode(codec3)(json4)))(alt16(map50(RemoteGitPackage.create)(decode(gitPackageCodec)(json4)))(map50(RemoteLegacyPackage.create)(decode(legacyPackageSetEntryCodec)(json4))));
  };
  return codec$prime(decode2)(encode3);
}();
var extraPackageCodec = /* @__PURE__ */ function() {
  var encode3 = function(v) {
    if (v instanceof ExtraLocalPackage) {
      return encode(localPackageCodec)(v.value0);
    }
    ;
    if (v instanceof ExtraRemotePackage) {
      return encode(remotePackageCodec)(v.value0);
    }
    ;
    throw new Error("Failed pattern match at Spago.Core.Config (line 408, column 3 - line 408, column 65): " + [v.constructor.name]);
  };
  var decode2 = function(json4) {
    return alt16(map50(ExtraLocalPackage.create)(decode(localPackageCodec)(json4)))(map50(ExtraRemotePackage.create)(decode(remotePackageCodec)(json4)));
  };
  return codec$prime(decode2)(encode3);
}();
var testConfigCodec = /* @__PURE__ */ object5(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecConsOptional(/* @__PURE__ */ rowListCodecCons4(mainIsSymbol))()()(execArgsIsSymbol))()()(dependenciesIsSymbol))("TestConfig")({
  main: string,
  execArgs: /* @__PURE__ */ optional3(/* @__PURE__ */ array(string)),
  dependencies: dependenciesCodec
});
var censorBuildWarningsCodec = /* @__PURE__ */ function() {
  var print9 = function(v) {
    if (v instanceof CensorNoWarnings) {
      return "none";
    }
    ;
    if (v instanceof CensorDependencyWarnings) {
      return "dependency";
    }
    ;
    if (v instanceof CensorProjectWarnings) {
      return "project";
    }
    ;
    if (v instanceof CensorAllWarnings) {
      return "all";
    }
    ;
    throw new Error("Failed pattern match at Spago.Core.Config (line 323, column 11 - line 327, column 31): " + [v.constructor.name]);
  };
  var parse10 = function(v) {
    if (v === "none") {
      return new Just(CensorNoWarnings.value);
    }
    ;
    if (v === "dependency") {
      return new Just(CensorDependencyWarnings.value);
    }
    ;
    if (v === "project") {
      return new Just(CensorProjectWarnings.value);
    }
    ;
    if (v === "all") {
      return new Just(CensorAllWarnings.value);
    }
    ;
    return Nothing.value;
  };
  return enumSum(print9)(parse10);
}();
var bundleTypeCodec = /* @__PURE__ */ enumSum(/* @__PURE__ */ show(showBundleType))(parseBundleType);
var bundlePlatformCodec = /* @__PURE__ */ enumSum(/* @__PURE__ */ show(showBundlePlatform))(parsePlatform);
var bundleConfigCodec = /* @__PURE__ */ object5(/* @__PURE__ */ rowListCodecConsOptional(/* @__PURE__ */ rowListCodecConsOptional(/* @__PURE__ */ rowListCodecConsOptional(/* @__PURE__ */ rowListCodecConsOptional(/* @__PURE__ */ rowListCodecConsOptional2({
  reflectSymbol: function() {
    return "type";
  }
}))()()({
  reflectSymbol: function() {
    return "platform";
  }
}))()()({
  reflectSymbol: function() {
    return "outfile";
  }
}))()()({
  reflectSymbol: function() {
    return "module";
  }
}))()()({
  reflectSymbol: function() {
    return "minify";
  }
}))("BundleConfig")({
  minify: /* @__PURE__ */ optional3($$boolean),
  module: /* @__PURE__ */ optional3(string),
  outfile: /* @__PURE__ */ optional3(string),
  platform: /* @__PURE__ */ optional3(bundlePlatformCodec),
  type: /* @__PURE__ */ optional3(bundleTypeCodec)
});
var packageConfigCodec = /* @__PURE__ */ object5(/* @__PURE__ */ rowListCodecConsOptional(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecConsOptional(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecConsOptional(/* @__PURE__ */ rowListCodecConsOptional(/* @__PURE__ */ rowListCodecConsOptional2({
  reflectSymbol: function() {
    return "test";
  }
}))()()({
  reflectSymbol: function() {
    return "run";
  }
}))()()({
  reflectSymbol: function() {
    return "publish";
  }
}))()()({
  reflectSymbol: function() {
    return "name";
  }
}))()()({
  reflectSymbol: function() {
    return "description";
  }
}))()()(dependenciesIsSymbol))()()({
  reflectSymbol: function() {
    return "bundle";
  }
}))("PackageConfig")({
  name: codec2,
  description: /* @__PURE__ */ optional3(string),
  dependencies: dependenciesCodec,
  bundle: /* @__PURE__ */ optional3(bundleConfigCodec),
  run: /* @__PURE__ */ optional3(runConfigCodec),
  test: /* @__PURE__ */ optional3(testConfigCodec),
  publish: /* @__PURE__ */ optional3(publishConfigCodec)
});
var buildOptionsCodec = /* @__PURE__ */ object5(/* @__PURE__ */ rowListCodecConsOptional(/* @__PURE__ */ rowListCodecConsOptional(/* @__PURE__ */ rowListCodecConsOptional(/* @__PURE__ */ rowListCodecConsOptional(/* @__PURE__ */ rowListCodecConsOptional(/* @__PURE__ */ rowListCodecConsOptional(/* @__PURE__ */ rowListCodecConsOptional(/* @__PURE__ */ rowListCodecConsOptional(/* @__PURE__ */ rowListCodecConsOptional2({
  reflectSymbol: function() {
    return "strict";
  }
}))()()({
  reflectSymbol: function() {
    return "stat_verbosity";
  }
}))()()({
  reflectSymbol: function() {
    return "show_source";
  }
}))()()({
  reflectSymbol: function() {
    return "persist_warnings";
  }
}))()()({
  reflectSymbol: function() {
    return "pedantic_packages";
  }
}))()()({
  reflectSymbol: function() {
    return "output";
  }
}))()()({
  reflectSymbol: function() {
    return "filter_codes";
  }
}))()()({
  reflectSymbol: function() {
    return "censor_warnings";
  }
}))()()({
  reflectSymbol: function() {
    return "censor_codes";
  }
}))("CompileOptionsInput")({
  output: /* @__PURE__ */ optional3(string),
  pedantic_packages: /* @__PURE__ */ optional3($$boolean),
  censor_warnings: /* @__PURE__ */ optional3(censorBuildWarningsCodec),
  censor_codes: /* @__PURE__ */ optional3(/* @__PURE__ */ nonEmptySet2(string)),
  filter_codes: /* @__PURE__ */ optional3(/* @__PURE__ */ nonEmptySet2(string)),
  stat_verbosity: /* @__PURE__ */ optional3(statVerbosityCodec),
  show_source: /* @__PURE__ */ optional3(showSourceCodec),
  strict: /* @__PURE__ */ optional3($$boolean),
  persist_warnings: /* @__PURE__ */ optional3($$boolean)
});
var backendConfigCodec = /* @__PURE__ */ object5(/* @__PURE__ */ rowListCodecConsOptional(/* @__PURE__ */ rowListCodecCons4({
  reflectSymbol: function() {
    return "cmd";
  }
}))()()({
  reflectSymbol: function() {
    return "args";
  }
}))("BackendConfig")({
  cmd: string,
  args: /* @__PURE__ */ optional3(/* @__PURE__ */ array(string))
});
var workspaceConfigCodec = /* @__PURE__ */ object5(/* @__PURE__ */ rowListCodecConsOptional(/* @__PURE__ */ rowListCodecConsOptional(/* @__PURE__ */ rowListCodecConsOptional(/* @__PURE__ */ rowListCodecConsOptional(/* @__PURE__ */ rowListCodecConsOptional2({
  reflectSymbol: function() {
    return "package_set";
  }
}))()()({
  reflectSymbol: function() {
    return "lock";
  }
}))()()({
  reflectSymbol: function() {
    return "extra_packages";
  }
}))()()({
  reflectSymbol: function() {
    return "build_opts";
  }
}))()()({
  reflectSymbol: function() {
    return "backend";
  }
}))("WorkspaceConfig")({
  package_set: /* @__PURE__ */ optional3(setAddressCodec),
  extra_packages: /* @__PURE__ */ optional3(/* @__PURE__ */ packageMap(extraPackageCodec)),
  backend: /* @__PURE__ */ optional3(backendConfigCodec),
  build_opts: /* @__PURE__ */ optional3(buildOptionsCodec),
  lock: /* @__PURE__ */ optional3($$boolean)
});
var configCodec = /* @__PURE__ */ object5(/* @__PURE__ */ rowListCodecConsOptional(/* @__PURE__ */ rowListCodecConsOptional2({
  reflectSymbol: function() {
    return "workspace";
  }
}))()()({
  reflectSymbol: function() {
    return "package";
  }
}))("Config")({
  "package": /* @__PURE__ */ optional3(packageConfigCodec),
  workspace: /* @__PURE__ */ optional3(workspaceConfigCodec)
});
var readConfig = function(path5) {
  return discard10(logDebug2("Reading config from " + path5))(function() {
    return bind28(exists3(path5))(function(v) {
      if (!v) {
        return pure40(new Left("Did not find " + (path5 + " file. Run `spago init` to initialise a new project.")));
      }
      ;
      if (v) {
        return liftAff2(readYamlDocFile(configCodec)(path5));
      }
      ;
      throw new Error("Failed pattern match at Spago.Core.Config (line 470, column 22 - line 472, column 58): " + [v.constructor.name]);
    });
  });
};

// output/Spago.Bin.Flags/index.js
var append20 = /* @__PURE__ */ append(modSemigroup);
var $$long3 = /* @__PURE__ */ $$long(flagFieldsHasName);
var $$short2 = /* @__PURE__ */ $$short(flagFieldsHasName);
var optional4 = /* @__PURE__ */ optional(parserAlt)(parserApplicative);
var voidRight3 = /* @__PURE__ */ voidRight(parserFunctor);
var long12 = /* @__PURE__ */ $$long(optionFieldsHasName);
var short1 = /* @__PURE__ */ $$short(optionFieldsHasName);
var map51 = /* @__PURE__ */ map(parserFunctor);
var metavar3 = /* @__PURE__ */ metavar(optionFieldsHasMetavar);
var fromFoldable19 = /* @__PURE__ */ fromFoldable8(foldableList)(ordString);
var verbose = /* @__PURE__ */ $$switch(/* @__PURE__ */ append20(/* @__PURE__ */ $$long3("verbose"))(/* @__PURE__ */ append20(/* @__PURE__ */ $$short2("v"))(/* @__PURE__ */ help("Enable additional debug logging, e.g. printing `purs` commands"))));
var transitive = /* @__PURE__ */ $$switch(/* @__PURE__ */ append20(/* @__PURE__ */ $$long3("transitive"))(/* @__PURE__ */ help("Include transitive dependencies")));
var strict = /* @__PURE__ */ optional4(/* @__PURE__ */ $$switch(/* @__PURE__ */ append20(/* @__PURE__ */ $$long3("strict"))(/* @__PURE__ */ help("Promotes project sources' warnings to errors"))));
var statVerbosity = /* @__PURE__ */ function() {
  return optional4(alt(parserAlt)(voidRight3(VerboseStats.value)($$switch(append20($$long3("verbose-stats"))(help("Show counts for each warning type")))))(voidRight3(NoStats.value)($$switch(append20($$long3("censor-stats"))(help("Censor warning/error summary"))))));
}();
var showSource = /* @__PURE__ */ function() {
  return optional4(voidLeft(parserFunctor)($$switch(append20($$long3("no-source"))(help("Disable original source code printing"))))(NoSourceCode.value));
}();
var selectedPackage = /* @__PURE__ */ optional4(/* @__PURE__ */ strOption(/* @__PURE__ */ append20(/* @__PURE__ */ long12("package"))(/* @__PURE__ */ append20(/* @__PURE__ */ short1("p"))(/* @__PURE__ */ help("Select the local project to build")))));
var quiet = /* @__PURE__ */ $$switch(/* @__PURE__ */ append20(/* @__PURE__ */ $$long3("quiet"))(/* @__PURE__ */ append20(/* @__PURE__ */ $$short2("q"))(/* @__PURE__ */ help("Suppress all spago logging"))));
var pursArgs = /* @__PURE__ */ map51(/* @__PURE__ */ fromFoldable5(foldableList))(/* @__PURE__ */ many3(/* @__PURE__ */ strOption(/* @__PURE__ */ append20(/* @__PURE__ */ long12("purs-args"))(/* @__PURE__ */ append20(/* @__PURE__ */ metavar3("ARGS"))(/* @__PURE__ */ help("Arguments to pass to purs compile. Wrap in quotes. `--output` and `--json-errors` must be passed to Spago directly."))))));
var platform2 = /* @__PURE__ */ optional4(/* @__PURE__ */ option(/* @__PURE__ */ eitherReader(function(v) {
  if (v === "node") {
    return new Right("node");
  }
  ;
  if (v === "browser") {
    return new Right("browser");
  }
  ;
  return new Left('Expected "node" or "browser"');
}))(/* @__PURE__ */ append20(/* @__PURE__ */ long12("platform"))(/* @__PURE__ */ help("The bundle platform. 'node' or 'browser'"))));
var persistWarnings = /* @__PURE__ */ optional4(/* @__PURE__ */ $$switch(/* @__PURE__ */ append20(/* @__PURE__ */ $$long3("persist-warnings"))(/* @__PURE__ */ help("Persist the compiler warnings between multiple underlying `purs compile` calls"))));
var pedanticPackages = /* @__PURE__ */ $$switch(/* @__PURE__ */ append20(/* @__PURE__ */ $$long3("pedantic-packages"))(/* @__PURE__ */ help("Check for redundant or missing packages in the config and fail the build if any")));
var packages = /* @__PURE__ */ many3(/* @__PURE__ */ strOption(/* @__PURE__ */ append20(/* @__PURE__ */ metavar3("PACKAGE"))(/* @__PURE__ */ help("Package name to add as dependency"))));
var $$package = /* @__PURE__ */ strOption(/* @__PURE__ */ append20(/* @__PURE__ */ metavar3("PACKAGE"))(/* @__PURE__ */ help("Package name")));
var output2 = /* @__PURE__ */ optional4(/* @__PURE__ */ strOption(/* @__PURE__ */ append20(/* @__PURE__ */ long12("output"))(/* @__PURE__ */ append20(/* @__PURE__ */ help("The output directory for compiled files"))(/* @__PURE__ */ append20(/* @__PURE__ */ metavar3("DIR"))(/* @__PURE__ */ value(optionFieldsHasValue)("output"))))));
var outfile = /* @__PURE__ */ optional4(/* @__PURE__ */ strOption(/* @__PURE__ */ append20(/* @__PURE__ */ long12("outfile"))(/* @__PURE__ */ help("Destination path for the bundle"))));
var noColor = /* @__PURE__ */ $$switch(/* @__PURE__ */ append20(/* @__PURE__ */ $$long3("no-color"))(/* @__PURE__ */ append20(/* @__PURE__ */ $$long3("monochrome"))(/* @__PURE__ */ help("Force logging without ANSI color escape sequences"))));
var moduleName = /* @__PURE__ */ optional4(/* @__PURE__ */ strOption(/* @__PURE__ */ append20(/* @__PURE__ */ long12("main"))(/* @__PURE__ */ append20(/* @__PURE__ */ short1("m"))(/* @__PURE__ */ help("Module to be used as the application's entry point")))));
var minify = /* @__PURE__ */ $$switch(/* @__PURE__ */ append20(/* @__PURE__ */ $$long3("minify"))(/* @__PURE__ */ help("Minify the bundle")));
var maybeVersion = /* @__PURE__ */ optional4(/* @__PURE__ */ strOption(/* @__PURE__ */ append20(/* @__PURE__ */ metavar3("VERSION"))(/* @__PURE__ */ help("Package version"))));
var maybeSetVersion = /* @__PURE__ */ optional4(/* @__PURE__ */ strOption(/* @__PURE__ */ append20(/* @__PURE__ */ long12("package-set"))(/* @__PURE__ */ help("Optional package set version to be used instead of the latest one"))));
var maybePackageName = /* @__PURE__ */ optional4(/* @__PURE__ */ strOption(/* @__PURE__ */ append20(/* @__PURE__ */ long12("name"))(/* @__PURE__ */ help("Optional package name to be used for the new project"))));
var jsonErrors = /* @__PURE__ */ $$switch(/* @__PURE__ */ append20(/* @__PURE__ */ $$long3("json-errors"))(/* @__PURE__ */ help("Output compiler warnings/errors as JSON")));
var json2 = /* @__PURE__ */ $$switch(/* @__PURE__ */ append20(/* @__PURE__ */ $$long3("json"))(/* @__PURE__ */ help("Format the output as JSON")));
var filterCodes = /* @__PURE__ */ map51(fromFoldable19)(/* @__PURE__ */ many3(/* @__PURE__ */ strOption(/* @__PURE__ */ append20(/* @__PURE__ */ long12("filter-code"))(/* @__PURE__ */ append20(/* @__PURE__ */ metavar3("CODE"))(/* @__PURE__ */ help("Only show a specific error code (e.g. `TypesDoNotUnify`)"))))));
var execArgs = /* @__PURE__ */ optional4(/* @__PURE__ */ map51(/* @__PURE__ */ fromFoldable(foldableList))(/* @__PURE__ */ many3(/* @__PURE__ */ strArgument(/* @__PURE__ */ append20(/* @__PURE__ */ help("Arguments to pass to the running script"))(/* @__PURE__ */ metavar(argumentFieldsHasMetavar)("ARGS"))))));
var entrypoint = /* @__PURE__ */ optional4(/* @__PURE__ */ strOption(/* @__PURE__ */ append20(/* @__PURE__ */ long12("module"))(/* @__PURE__ */ help("The module to bundle as the entrypoint"))));
var ensureRanges = /* @__PURE__ */ $$switch(/* @__PURE__ */ append20(/* @__PURE__ */ $$long3("ensure-ranges"))(/* @__PURE__ */ help("Add version bounds for all the dependencies of the selected project")));
var censorCodes = /* @__PURE__ */ map51(fromFoldable19)(/* @__PURE__ */ many3(/* @__PURE__ */ strOption(/* @__PURE__ */ append20(/* @__PURE__ */ long12("censor-code"))(/* @__PURE__ */ append20(/* @__PURE__ */ metavar3("CODE"))(/* @__PURE__ */ help("Censor a specific error code (e.g. `ShadowedName`)"))))));
var censorBuildWarnings = /* @__PURE__ */ optional4(/* @__PURE__ */ flip(option)(/* @__PURE__ */ append20(/* @__PURE__ */ long12("censor-build-warnings"))(/* @__PURE__ */ append20(/* @__PURE__ */ help("Censor compiler warnings based on file's location: 'dependency', 'project', or 'all'"))(/* @__PURE__ */ metavar3("ARG"))))(/* @__PURE__ */ eitherReader(function(v) {
  if (v === "all") {
    return new Right(CensorAllWarnings.value);
  }
  ;
  if (v === "project") {
    return new Right(CensorProjectWarnings.value);
  }
  ;
  if (v === "dependency") {
    return new Right(CensorDependencyWarnings.value);
  }
  ;
  return new Left("Expected 'all', 'project', or 'dependency'");
})));
var bundleType = /* @__PURE__ */ optional4(/* @__PURE__ */ strOption(/* @__PURE__ */ append20(/* @__PURE__ */ long12("type"))(/* @__PURE__ */ help("The type of the module produced. 'app' will call main, 'module' will just export the contents."))));
var backendArgs = /* @__PURE__ */ many3(/* @__PURE__ */ strOption(/* @__PURE__ */ append20(/* @__PURE__ */ long12("backend-args"))(/* @__PURE__ */ append20(/* @__PURE__ */ help("Arguments to pass to the running script"))(/* @__PURE__ */ metavar3("ARGS")))));

// output/Spago.Config/foreign.js
var import_yaml2 = __toESM(require_dist(), 1);
function updatePackageSetHashInConfigImpl(doc, sha) {
  doc.get("workspace").get("package_set").set("hash", sha);
}
function addPackagesToConfigImpl(doc, newPkgs) {
  const deps = doc.get("package").get("dependencies");
  let depsSet = new Set(deps.toJSON());
  for (const pkg of newPkgs) {
    depsSet.add(pkg);
  }
  let newItems = [];
  for (const el of deps.items) {
    if (import_yaml2.default.isScalar(el) && depsSet.has(el.value)) {
      depsSet.delete(el.value);
      newItems.push(el);
    }
    if (import_yaml2.default.isMap(el) && depsSet.has(el.items[0].key)) {
      depsSet.delete(el.value);
      newItems.push(el);
    }
  }
  for (const newPkg of depsSet) {
    newItems.push(doc.createNode(newPkg));
  }
  newItems.sort();
  deps.items = newItems;
}
function addRangesToConfigImpl(doc, rangesMap) {
  const deps = doc.get("package").get("dependencies");
  let newItems = [];
  for (const el of deps.items) {
    if (import_yaml2.default.isMap(el)) {
      newItems.push(el);
    }
    if (import_yaml2.default.isScalar(el)) {
      let newEl = /* @__PURE__ */ new Map();
      newEl.set(el.value, rangesMap[el.value]);
      newItems.push(doc.createNode(newEl));
    }
  }
  newItems.sort();
  deps.items = newItems;
}

// output/Affjax/foreign.js
function _ajax(platformSpecificDriver, timeoutErrorMessageIdent, requestFailedMessageIdent, mkHeader, options) {
  return function(errback, callback) {
    var xhr = platformSpecificDriver.newXHR();
    var fixedUrl = platformSpecificDriver.fixupUrl(options.url, xhr);
    xhr.open(options.method || "GET", fixedUrl, true, options.username, options.password);
    if (options.headers) {
      try {
        for (var i = 0, header; (header = options.headers[i]) != null; i++) {
          xhr.setRequestHeader(header.field, header.value);
        }
      } catch (e) {
        errback(e);
      }
    }
    var onerror = function(msgIdent) {
      return function() {
        errback(new Error(msgIdent));
      };
    };
    xhr.onerror = onerror(requestFailedMessageIdent);
    xhr.ontimeout = onerror(timeoutErrorMessageIdent);
    xhr.onload = function() {
      callback({
        status: xhr.status,
        statusText: xhr.statusText,
        headers: xhr.getAllResponseHeaders().split("\r\n").filter(function(header2) {
          return header2.length > 0;
        }).map(function(header2) {
          var i2 = header2.indexOf(":");
          return mkHeader(header2.substring(0, i2))(header2.substring(i2 + 2));
        }),
        body: xhr.response
      });
    };
    xhr.responseType = options.responseType;
    xhr.withCredentials = options.withCredentials;
    xhr.timeout = options.timeout;
    xhr.send(options.content);
    return function(error4, cancelErrback, cancelCallback) {
      try {
        xhr.abort();
      } catch (e) {
        return cancelErrback(e);
      }
      return cancelCallback();
    };
  };
}

// output/Data.MediaType.Common/index.js
var applicationJSON = "application/json";
var applicationFormURLEncoded = "application/x-www-form-urlencoded";

// output/Affjax.RequestBody/index.js
var ArrayView = /* @__PURE__ */ function() {
  function ArrayView2(value0) {
    this.value0 = value0;
  }
  ;
  ArrayView2.create = function(value0) {
    return new ArrayView2(value0);
  };
  return ArrayView2;
}();
var Blob = /* @__PURE__ */ function() {
  function Blob3(value0) {
    this.value0 = value0;
  }
  ;
  Blob3.create = function(value0) {
    return new Blob3(value0);
  };
  return Blob3;
}();
var Document = /* @__PURE__ */ function() {
  function Document3(value0) {
    this.value0 = value0;
  }
  ;
  Document3.create = function(value0) {
    return new Document3(value0);
  };
  return Document3;
}();
var $$String = /* @__PURE__ */ function() {
  function $$String3(value0) {
    this.value0 = value0;
  }
  ;
  $$String3.create = function(value0) {
    return new $$String3(value0);
  };
  return $$String3;
}();
var FormData = /* @__PURE__ */ function() {
  function FormData2(value0) {
    this.value0 = value0;
  }
  ;
  FormData2.create = function(value0) {
    return new FormData2(value0);
  };
  return FormData2;
}();
var FormURLEncoded = /* @__PURE__ */ function() {
  function FormURLEncoded2(value0) {
    this.value0 = value0;
  }
  ;
  FormURLEncoded2.create = function(value0) {
    return new FormURLEncoded2(value0);
  };
  return FormURLEncoded2;
}();
var Json = /* @__PURE__ */ function() {
  function Json3(value0) {
    this.value0 = value0;
  }
  ;
  Json3.create = function(value0) {
    return new Json3(value0);
  };
  return Json3;
}();
var toMediaType = function(v) {
  if (v instanceof FormURLEncoded) {
    return new Just(applicationFormURLEncoded);
  }
  ;
  if (v instanceof Json) {
    return new Just(applicationJSON);
  }
  ;
  return Nothing.value;
};
var json3 = /* @__PURE__ */ function() {
  return Json.create;
}();

// output/Affjax.RequestHeader/index.js
var unwrap12 = /* @__PURE__ */ unwrap();
var Accept = /* @__PURE__ */ function() {
  function Accept2(value0) {
    this.value0 = value0;
  }
  ;
  Accept2.create = function(value0) {
    return new Accept2(value0);
  };
  return Accept2;
}();
var ContentType = /* @__PURE__ */ function() {
  function ContentType2(value0) {
    this.value0 = value0;
  }
  ;
  ContentType2.create = function(value0) {
    return new ContentType2(value0);
  };
  return ContentType2;
}();
var RequestHeader = /* @__PURE__ */ function() {
  function RequestHeader2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  RequestHeader2.create = function(value0) {
    return function(value12) {
      return new RequestHeader2(value0, value12);
    };
  };
  return RequestHeader2;
}();
var value3 = function(v) {
  if (v instanceof Accept) {
    return unwrap12(v.value0);
  }
  ;
  if (v instanceof ContentType) {
    return unwrap12(v.value0);
  }
  ;
  if (v instanceof RequestHeader) {
    return v.value1;
  }
  ;
  throw new Error("Failed pattern match at Affjax.RequestHeader (line 26, column 1 - line 26, column 33): " + [v.constructor.name]);
};
var name3 = function(v) {
  if (v instanceof Accept) {
    return "Accept";
  }
  ;
  if (v instanceof ContentType) {
    return "Content-Type";
  }
  ;
  if (v instanceof RequestHeader) {
    return v.value0;
  }
  ;
  throw new Error("Failed pattern match at Affjax.RequestHeader (line 21, column 1 - line 21, column 32): " + [v.constructor.name]);
};

// output/Affjax.ResponseFormat/index.js
var identity20 = /* @__PURE__ */ identity(categoryFn);
var $$ArrayBuffer = /* @__PURE__ */ function() {
  function $$ArrayBuffer2(value0) {
    this.value0 = value0;
  }
  ;
  $$ArrayBuffer2.create = function(value0) {
    return new $$ArrayBuffer2(value0);
  };
  return $$ArrayBuffer2;
}();
var Blob2 = /* @__PURE__ */ function() {
  function Blob3(value0) {
    this.value0 = value0;
  }
  ;
  Blob3.create = function(value0) {
    return new Blob3(value0);
  };
  return Blob3;
}();
var Document2 = /* @__PURE__ */ function() {
  function Document3(value0) {
    this.value0 = value0;
  }
  ;
  Document3.create = function(value0) {
    return new Document3(value0);
  };
  return Document3;
}();
var Json2 = /* @__PURE__ */ function() {
  function Json3(value0) {
    this.value0 = value0;
  }
  ;
  Json3.create = function(value0) {
    return new Json3(value0);
  };
  return Json3;
}();
var $$String2 = /* @__PURE__ */ function() {
  function $$String3(value0) {
    this.value0 = value0;
  }
  ;
  $$String3.create = function(value0) {
    return new $$String3(value0);
  };
  return $$String3;
}();
var Ignore = /* @__PURE__ */ function() {
  function Ignore3(value0) {
    this.value0 = value0;
  }
  ;
  Ignore3.create = function(value0) {
    return new Ignore3(value0);
  };
  return Ignore3;
}();
var toResponseType = function(v) {
  if (v instanceof $$ArrayBuffer) {
    return "arraybuffer";
  }
  ;
  if (v instanceof Blob2) {
    return "blob";
  }
  ;
  if (v instanceof Document2) {
    return "document";
  }
  ;
  if (v instanceof Json2) {
    return "text";
  }
  ;
  if (v instanceof $$String2) {
    return "text";
  }
  ;
  if (v instanceof Ignore) {
    return "";
  }
  ;
  throw new Error("Failed pattern match at Affjax.ResponseFormat (line 44, column 3 - line 50, column 19): " + [v.constructor.name]);
};
var toMediaType2 = function(v) {
  if (v instanceof Json2) {
    return new Just(applicationJSON);
  }
  ;
  return Nothing.value;
};
var string4 = /* @__PURE__ */ function() {
  return new $$String2(identity20);
}();
var ignore = /* @__PURE__ */ function() {
  return new Ignore(identity20);
}();
var arrayBuffer = /* @__PURE__ */ function() {
  return new $$ArrayBuffer(identity20);
}();

// output/Affjax.ResponseHeader/index.js
var ResponseHeader = /* @__PURE__ */ function() {
  function ResponseHeader2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ResponseHeader2.create = function(value0) {
    return function(value12) {
      return new ResponseHeader2(value0, value12);
    };
  };
  return ResponseHeader2;
}();

// output/JSURI/foreign.js
function encodeURIComponent_to_RFC3986(input) {
  return input.replace(/[!'()*]/g, function(c) {
    return "%" + c.charCodeAt(0).toString(16);
  });
}
function _encodeURIComponent(fail5, succeed, input) {
  try {
    return succeed(encodeURIComponent_to_RFC3986(encodeURIComponent(input)));
  } catch (err) {
    return fail5(err);
  }
}
function _encodeFormURLComponent(fail5, succeed, input) {
  try {
    return succeed(encodeURIComponent_to_RFC3986(encodeURIComponent(input)).replace(/%20/g, "+"));
  } catch (err) {
    return fail5(err);
  }
}

// output/JSURI/index.js
var $$encodeURIComponent = /* @__PURE__ */ function() {
  return runFn3(_encodeURIComponent)($$const(Nothing.value))(Just.create);
}();
var encodeFormURLComponent = /* @__PURE__ */ function() {
  return runFn3(_encodeFormURLComponent)($$const(Nothing.value))(Just.create);
}();

// output/Data.FormURLEncoded/index.js
var apply16 = /* @__PURE__ */ apply2(applyMaybe);
var map52 = /* @__PURE__ */ map(functorMaybe);
var traverse5 = /* @__PURE__ */ traverse(traversableArray)(applicativeMaybe);
var toArray6 = function(v) {
  return v;
};
var encode2 = /* @__PURE__ */ function() {
  var encodePart = function(v) {
    if (v.value1 instanceof Nothing) {
      return encodeFormURLComponent(v.value0);
    }
    ;
    if (v.value1 instanceof Just) {
      return apply16(map52(function(key) {
        return function(val) {
          return key + ("=" + val);
        };
      })(encodeFormURLComponent(v.value0)))(encodeFormURLComponent(v.value1.value0));
    }
    ;
    throw new Error("Failed pattern match at Data.FormURLEncoded (line 37, column 16 - line 39, column 114): " + [v.constructor.name]);
  };
  var $37 = map52(joinWith("&"));
  var $38 = traverse5(encodePart);
  return function($39) {
    return $37($38(toArray6($39)));
  };
}();

// output/Data.HTTP.Method/index.js
var OPTIONS = /* @__PURE__ */ function() {
  function OPTIONS2() {
  }
  ;
  OPTIONS2.value = new OPTIONS2();
  return OPTIONS2;
}();
var GET = /* @__PURE__ */ function() {
  function GET2() {
  }
  ;
  GET2.value = new GET2();
  return GET2;
}();
var HEAD = /* @__PURE__ */ function() {
  function HEAD2() {
  }
  ;
  HEAD2.value = new HEAD2();
  return HEAD2;
}();
var POST = /* @__PURE__ */ function() {
  function POST2() {
  }
  ;
  POST2.value = new POST2();
  return POST2;
}();
var PUT = /* @__PURE__ */ function() {
  function PUT2() {
  }
  ;
  PUT2.value = new PUT2();
  return PUT2;
}();
var DELETE = /* @__PURE__ */ function() {
  function DELETE2() {
  }
  ;
  DELETE2.value = new DELETE2();
  return DELETE2;
}();
var TRACE = /* @__PURE__ */ function() {
  function TRACE2() {
  }
  ;
  TRACE2.value = new TRACE2();
  return TRACE2;
}();
var CONNECT = /* @__PURE__ */ function() {
  function CONNECT2() {
  }
  ;
  CONNECT2.value = new CONNECT2();
  return CONNECT2;
}();
var PROPFIND = /* @__PURE__ */ function() {
  function PROPFIND2() {
  }
  ;
  PROPFIND2.value = new PROPFIND2();
  return PROPFIND2;
}();
var PROPPATCH = /* @__PURE__ */ function() {
  function PROPPATCH2() {
  }
  ;
  PROPPATCH2.value = new PROPPATCH2();
  return PROPPATCH2;
}();
var MKCOL = /* @__PURE__ */ function() {
  function MKCOL2() {
  }
  ;
  MKCOL2.value = new MKCOL2();
  return MKCOL2;
}();
var COPY = /* @__PURE__ */ function() {
  function COPY2() {
  }
  ;
  COPY2.value = new COPY2();
  return COPY2;
}();
var MOVE = /* @__PURE__ */ function() {
  function MOVE2() {
  }
  ;
  MOVE2.value = new MOVE2();
  return MOVE2;
}();
var LOCK = /* @__PURE__ */ function() {
  function LOCK2() {
  }
  ;
  LOCK2.value = new LOCK2();
  return LOCK2;
}();
var UNLOCK = /* @__PURE__ */ function() {
  function UNLOCK2() {
  }
  ;
  UNLOCK2.value = new UNLOCK2();
  return UNLOCK2;
}();
var PATCH = /* @__PURE__ */ function() {
  function PATCH2() {
  }
  ;
  PATCH2.value = new PATCH2();
  return PATCH2;
}();
var unCustomMethod = function(v) {
  return v;
};
var showMethod = {
  show: function(v) {
    if (v instanceof OPTIONS) {
      return "OPTIONS";
    }
    ;
    if (v instanceof GET) {
      return "GET";
    }
    ;
    if (v instanceof HEAD) {
      return "HEAD";
    }
    ;
    if (v instanceof POST) {
      return "POST";
    }
    ;
    if (v instanceof PUT) {
      return "PUT";
    }
    ;
    if (v instanceof DELETE) {
      return "DELETE";
    }
    ;
    if (v instanceof TRACE) {
      return "TRACE";
    }
    ;
    if (v instanceof CONNECT) {
      return "CONNECT";
    }
    ;
    if (v instanceof PROPFIND) {
      return "PROPFIND";
    }
    ;
    if (v instanceof PROPPATCH) {
      return "PROPPATCH";
    }
    ;
    if (v instanceof MKCOL) {
      return "MKCOL";
    }
    ;
    if (v instanceof COPY) {
      return "COPY";
    }
    ;
    if (v instanceof MOVE) {
      return "MOVE";
    }
    ;
    if (v instanceof LOCK) {
      return "LOCK";
    }
    ;
    if (v instanceof UNLOCK) {
      return "UNLOCK";
    }
    ;
    if (v instanceof PATCH) {
      return "PATCH";
    }
    ;
    throw new Error("Failed pattern match at Data.HTTP.Method (line 43, column 1 - line 59, column 23): " + [v.constructor.name]);
  }
};
var print7 = /* @__PURE__ */ either(/* @__PURE__ */ show(showMethod))(unCustomMethod);

// output/Effect.Uncurried/foreign.js
var mkEffectFn1 = function mkEffectFn12(fn) {
  return function(x) {
    return fn(x)();
  };
};
var mkEffectFn2 = function mkEffectFn22(fn) {
  return function(a, b) {
    return fn(a)(b)();
  };
};
var runEffectFn2 = function runEffectFn22(fn) {
  return function(a) {
    return function(b) {
      return function() {
        return fn(a, b);
      };
    };
  };
};

// output/Effect.Aff.Compat/index.js
var fromEffectFnAff = function(v) {
  return makeAff(function(k) {
    return function __do3() {
      var v1 = v(function($9) {
        return k(Left.create($9))();
      }, function($10) {
        return k(Right.create($10))();
      });
      return function(e) {
        return makeAff(function(k2) {
          return function __do4() {
            v1(e, function($11) {
              return k2(Left.create($11))();
            }, function($12) {
              return k2(Right.create($12))();
            });
            return nonCanceler;
          };
        });
      };
    };
  });
};

// output/Affjax/index.js
var pure41 = /* @__PURE__ */ pure(/* @__PURE__ */ applicativeExceptT(monadIdentity));
var fail3 = /* @__PURE__ */ fail(monadIdentity);
var unsafeReadTagged2 = /* @__PURE__ */ unsafeReadTagged(monadIdentity);
var alt17 = /* @__PURE__ */ alt(/* @__PURE__ */ altExceptT(semigroupNonEmptyList)(monadIdentity));
var composeKleisliFlipped5 = /* @__PURE__ */ composeKleisliFlipped(/* @__PURE__ */ bindExceptT(monadIdentity));
var map53 = /* @__PURE__ */ map(functorMaybe);
var any4 = /* @__PURE__ */ any2(foldableArray)(heytingAlgebraBoolean);
var eq9 = /* @__PURE__ */ eq(eqString);
var bindFlipped7 = /* @__PURE__ */ bindFlipped(bindMaybe);
var map119 = /* @__PURE__ */ map(functorArray);
var mapFlipped6 = /* @__PURE__ */ mapFlipped(functorAff);
var $$try6 = /* @__PURE__ */ $$try2(monadErrorAff);
var pure115 = /* @__PURE__ */ pure(applicativeAff);
var RequestContentError = /* @__PURE__ */ function() {
  function RequestContentError2(value0) {
    this.value0 = value0;
  }
  ;
  RequestContentError2.create = function(value0) {
    return new RequestContentError2(value0);
  };
  return RequestContentError2;
}();
var ResponseBodyError = /* @__PURE__ */ function() {
  function ResponseBodyError2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ResponseBodyError2.create = function(value0) {
    return function(value12) {
      return new ResponseBodyError2(value0, value12);
    };
  };
  return ResponseBodyError2;
}();
var TimeoutError = /* @__PURE__ */ function() {
  function TimeoutError2() {
  }
  ;
  TimeoutError2.value = new TimeoutError2();
  return TimeoutError2;
}();
var RequestFailedError = /* @__PURE__ */ function() {
  function RequestFailedError2() {
  }
  ;
  RequestFailedError2.value = new RequestFailedError2();
  return RequestFailedError2;
}();
var XHROtherError = /* @__PURE__ */ function() {
  function XHROtherError2(value0) {
    this.value0 = value0;
  }
  ;
  XHROtherError2.create = function(value0) {
    return new XHROtherError2(value0);
  };
  return XHROtherError2;
}();
var request = function(driver2) {
  return function(req) {
    var parseJSON = function(v2) {
      if (v2 === "") {
        return pure41(jsonEmptyObject);
      }
      ;
      return either(function($74) {
        return fail3(ForeignError.create($74));
      })(pure41)(jsonParser(v2));
    };
    var fromResponse = function() {
      if (req.responseFormat instanceof $$ArrayBuffer) {
        return unsafeReadTagged2("ArrayBuffer");
      }
      ;
      if (req.responseFormat instanceof Blob2) {
        return unsafeReadTagged2("Blob");
      }
      ;
      if (req.responseFormat instanceof Document2) {
        return function(x) {
          return alt17(unsafeReadTagged2("Document")(x))(alt17(unsafeReadTagged2("XMLDocument")(x))(unsafeReadTagged2("HTMLDocument")(x)));
        };
      }
      ;
      if (req.responseFormat instanceof Json2) {
        return composeKleisliFlipped5(function($75) {
          return req.responseFormat.value0(parseJSON($75));
        })(unsafeReadTagged2("String"));
      }
      ;
      if (req.responseFormat instanceof $$String2) {
        return unsafeReadTagged2("String");
      }
      ;
      if (req.responseFormat instanceof Ignore) {
        return $$const(req.responseFormat.value0(pure41(unit)));
      }
      ;
      throw new Error("Failed pattern match at Affjax (line 274, column 18 - line 283, column 57): " + [req.responseFormat.constructor.name]);
    }();
    var extractContent = function(v2) {
      if (v2 instanceof ArrayView) {
        return new Right(v2.value0(unsafeToForeign));
      }
      ;
      if (v2 instanceof Blob) {
        return new Right(unsafeToForeign(v2.value0));
      }
      ;
      if (v2 instanceof Document) {
        return new Right(unsafeToForeign(v2.value0));
      }
      ;
      if (v2 instanceof $$String) {
        return new Right(unsafeToForeign(v2.value0));
      }
      ;
      if (v2 instanceof FormData) {
        return new Right(unsafeToForeign(v2.value0));
      }
      ;
      if (v2 instanceof FormURLEncoded) {
        return note("Body contains values that cannot be encoded as application/x-www-form-urlencoded")(map53(unsafeToForeign)(encode2(v2.value0)));
      }
      ;
      if (v2 instanceof Json) {
        return new Right(unsafeToForeign(stringify(v2.value0)));
      }
      ;
      throw new Error("Failed pattern match at Affjax (line 235, column 20 - line 250, column 69): " + [v2.constructor.name]);
    };
    var addHeader = function(mh) {
      return function(hs) {
        if (mh instanceof Just && !any4(on(eq9)(name3)(mh.value0))(hs)) {
          return snoc(hs)(mh.value0);
        }
        ;
        return hs;
      };
    };
    var headers = function(reqContent) {
      return addHeader(map53(ContentType.create)(bindFlipped7(toMediaType)(reqContent)))(addHeader(map53(Accept.create)(toMediaType2(req.responseFormat)))(req.headers));
    };
    var ajaxRequest = function(v2) {
      return {
        method: print7(req.method),
        url: req.url,
        headers: map119(function(h) {
          return {
            field: name3(h),
            value: value3(h)
          };
        })(headers(req.content)),
        content: v2,
        responseType: toResponseType(req.responseFormat),
        username: toNullable(req.username),
        password: toNullable(req.password),
        withCredentials: req.withCredentials,
        timeout: fromMaybe(0)(map53(function(v1) {
          return v1;
        })(req.timeout))
      };
    };
    var send2 = function(content) {
      return mapFlipped6($$try6(fromEffectFnAff(_ajax(driver2, "AffjaxTimeoutErrorMessageIdent", "AffjaxRequestFailedMessageIdent", ResponseHeader.create, ajaxRequest(content)))))(function(v2) {
        if (v2 instanceof Right) {
          var v1 = runExcept(fromResponse(v2.value0.body));
          if (v1 instanceof Left) {
            return new Left(new ResponseBodyError(head4(v1.value0), v2.value0));
          }
          ;
          if (v1 instanceof Right) {
            return new Right({
              body: v1.value0,
              headers: v2.value0.headers,
              status: v2.value0.status,
              statusText: v2.value0.statusText
            });
          }
          ;
          throw new Error("Failed pattern match at Affjax (line 209, column 9 - line 211, column 52): " + [v1.constructor.name]);
        }
        ;
        if (v2 instanceof Left) {
          return new Left(function() {
            var message2 = message(v2.value0);
            var $61 = message2 === "AffjaxTimeoutErrorMessageIdent";
            if ($61) {
              return TimeoutError.value;
            }
            ;
            var $62 = message2 === "AffjaxRequestFailedMessageIdent";
            if ($62) {
              return RequestFailedError.value;
            }
            ;
            return new XHROtherError(v2.value0);
          }());
        }
        ;
        throw new Error("Failed pattern match at Affjax (line 207, column 144 - line 219, column 28): " + [v2.constructor.name]);
      });
    };
    if (req.content instanceof Nothing) {
      return send2(toNullable(Nothing.value));
    }
    ;
    if (req.content instanceof Just) {
      var v = extractContent(req.content.value0);
      if (v instanceof Right) {
        return send2(toNullable(new Just(v.value0)));
      }
      ;
      if (v instanceof Left) {
        return pure115(new Left(new RequestContentError(v.value0)));
      }
      ;
      throw new Error("Failed pattern match at Affjax (line 199, column 7 - line 203, column 48): " + [v.constructor.name]);
    }
    ;
    throw new Error("Failed pattern match at Affjax (line 195, column 3 - line 203, column 48): " + [req.content.constructor.name]);
  };
};
var printError2 = function(v) {
  if (v instanceof RequestContentError) {
    return "There was a problem with the request content: " + v.value0;
  }
  ;
  if (v instanceof ResponseBodyError) {
    return "There was a problem with the response body: " + renderForeignError(v.value0);
  }
  ;
  if (v instanceof TimeoutError) {
    return "There was a problem making the request: timeout";
  }
  ;
  if (v instanceof RequestFailedError) {
    return "There was a problem making the request: request failed";
  }
  ;
  if (v instanceof XHROtherError) {
    return "There was a problem making the request: " + message(v.value0);
  }
  ;
  throw new Error("Failed pattern match at Affjax (line 113, column 14 - line 123, column 66): " + [v.constructor.name]);
};
var defaultRequest = /* @__PURE__ */ function() {
  return {
    method: new Left(GET.value),
    url: "/",
    headers: [],
    content: Nothing.value,
    username: Nothing.value,
    password: Nothing.value,
    withCredentials: false,
    responseFormat: ignore,
    timeout: Nothing.value
  };
}();
var get4 = function(driver2) {
  return function(rf) {
    return function(u) {
      return request(driver2)({
        method: defaultRequest.method,
        url: u,
        headers: defaultRequest.headers,
        content: defaultRequest.content,
        username: defaultRequest.username,
        password: defaultRequest.password,
        withCredentials: defaultRequest.withCredentials,
        responseFormat: rf,
        timeout: defaultRequest.timeout
      });
    };
  };
};
var post = function(driver2) {
  return function(rf) {
    return function(u) {
      return function(c) {
        return request(driver2)({
          method: new Left(POST.value),
          url: u,
          headers: defaultRequest.headers,
          content: c,
          username: defaultRequest.username,
          password: defaultRequest.password,
          withCredentials: defaultRequest.withCredentials,
          responseFormat: rf,
          timeout: defaultRequest.timeout
        });
      };
    };
  };
};

// output/Affjax.Node/foreign.js
var import_xhr2 = __toESM(require_xhr2(), 1);
import urllib from "url";
var driver = {
  newXHR: function() {
    return new import_xhr2.default();
  },
  fixupUrl: function(url2, xhr) {
    if (xhr.nodejsBaseUrl === null) {
      var u = urllib.parse(url2);
      u.protocol = u.protocol || "http:";
      u.hostname = u.hostname || "localhost";
      return urllib.format(u);
    } else {
      return url2 || "/";
    }
  }
};

// output/Affjax.Node/index.js
var request2 = /* @__PURE__ */ request(driver);
var post2 = /* @__PURE__ */ post(driver);
var get5 = /* @__PURE__ */ get4(driver);

// output/Affjax.StatusCode/index.js
var show20 = /* @__PURE__ */ show(showInt);
var showStatusCode = {
  show: function(v) {
    return "(StatusCode " + (show20(v) + ")");
  }
};
var eqStatusCode = {
  eq: function(x) {
    return function(y) {
      return x === y;
    };
  }
};

// output/ConvertableOptions/index.js
var merge2 = /* @__PURE__ */ merge()();
var defaultsRecord = function() {
  return function() {
    return {
      defaults: flip(merge2)
    };
  };
};
var defaults = function(dict) {
  return dict.defaults;
};

// output/Registry.Foreign.FastGlob/foreign.js
var import_fast_glob = __toESM(require_out4(), 1);
var matchImpl = (entries) => (options) => () => (0, import_fast_glob.default)(entries, options);

// output/Control.Promise/foreign.js
function thenImpl(promise2) {
  return function(errCB) {
    return function(succCB) {
      return function() {
        promise2.then(succCB, errCB);
      };
    };
  };
}

// output/Control.Promise/index.js
var voidRight4 = /* @__PURE__ */ voidRight(functorEffect);
var mempty10 = /* @__PURE__ */ mempty(monoidCanceler);
var identity21 = /* @__PURE__ */ identity(categoryFn);
var alt18 = /* @__PURE__ */ alt(/* @__PURE__ */ altExceptT(semigroupNonEmptyList)(monadIdentity));
var unsafeReadTagged3 = /* @__PURE__ */ unsafeReadTagged(monadIdentity);
var map54 = /* @__PURE__ */ map(/* @__PURE__ */ functorExceptT(functorIdentity));
var readString5 = /* @__PURE__ */ readString(monadIdentity);
var bind29 = /* @__PURE__ */ bind(bindAff);
var liftEffect3 = /* @__PURE__ */ liftEffect(monadEffectAff);
var toAff$prime = function(customCoerce) {
  return function(p) {
    return makeAff(function(cb) {
      return voidRight4(mempty10)(thenImpl(p)(function($14) {
        return cb(Left.create(customCoerce($14)))();
      })(function($15) {
        return cb(Right.create($15))();
      }));
    });
  };
};
var coerce5 = function(fn) {
  return either(function(v) {
    return error("Promise failed, couldn't extract JS Error or String");
  })(identity21)(runExcept(alt18(unsafeReadTagged3("Error")(fn))(map54(error)(readString5(fn)))));
};
var toAff4 = /* @__PURE__ */ toAff$prime(coerce5);
var toAffE = function(f) {
  return bind29(liftEffect3(f))(toAff4);
};

// output/Registry.Internal.Path/index.js
var bind30 = /* @__PURE__ */ bind(/* @__PURE__ */ bindExceptT(monadAff));
var map55 = /* @__PURE__ */ map(functorAff);
var lmap11 = /* @__PURE__ */ lmap(bifunctorEither);
var pure42 = /* @__PURE__ */ pure(applicativeAff);
var bind113 = /* @__PURE__ */ bind(bindAff);
var foldMap5 = /* @__PURE__ */ foldMap2(/* @__PURE__ */ monoidAff(monoidArray));
var sanitizePath = function(dictMonadAff) {
  var liftAff10 = liftAff(dictMonadAff);
  return function(baseDirectory) {
    return function(path5) {
      return liftAff10(runExceptT(bind30(map55(lmap11(function(v) {
        return "sanitizePath provided with a base directory that does not exist: " + baseDirectory;
      }))(attempt(realpath3(baseDirectory))))(function(absoluteRoot) {
        return bind30(map55(lmap11(function(v) {
          return "sanitizePath provided with a path that does not exist: " + path5;
        }))(attempt(realpath3(concat2([absoluteRoot, path5])))))(function(absolutePath) {
          return pure42(function() {
            var v = indexOf2(absoluteRoot)(absolutePath);
            if (v instanceof Just && v.value0 === 0) {
              return new Right(path5);
            }
            ;
            return new Left(path5);
          }());
        });
      })));
    };
  };
};
var pursFileExtensionRegex = /* @__PURE__ */ unsafeRegex("\\.purs$")(noFlags);
var readPursFiles = function(dictMonadAff) {
  var liftAff10 = liftAff(dictMonadAff);
  return function(init4) {
    var go = function(depth) {
      return function(root2) {
        return bind113(readdir3(root2))(foldMap5(function(file) {
          var path5 = concat2([root2, sep, file]);
          return bind113(stat3(path5))(function(stats) {
            var $19 = isDirectory(stats);
            if ($19) {
              return go(depth + 1 | 0)(path5);
            }
            ;
            var $20 = test(pursFileExtensionRegex)(path5);
            if ($20) {
              return pure42([path5]);
            }
            ;
            return pure42([]);
          });
        }));
      };
    };
    return liftAff10(bind113(attempt(go(0)(init4)))(function(result) {
      if (result instanceof Left) {
        return pure42(Nothing.value);
      }
      ;
      if (result instanceof Right) {
        return pure42(fromArray(result.value0));
      }
      ;
      throw new Error("Failed pattern match at Registry.Internal.Path (line 43, column 3 - line 45, column 46): " + [result.constructor.name]);
    }));
  };
};

// output/Registry.Foreign.FastGlob/index.js
var traverse6 = /* @__PURE__ */ traverse(traversableArray);
var partitionMap2 = /* @__PURE__ */ partitionMap(filterableArray);
var identity22 = /* @__PURE__ */ identity(categoryFn);
var defaultsRecord2 = /* @__PURE__ */ defaultsRecord()();
var FilesAndDirectories = /* @__PURE__ */ function() {
  function FilesAndDirectories2() {
  }
  ;
  FilesAndDirectories2.value = new FilesAndDirectories2();
  return FilesAndDirectories2;
}();
var FilesOnly = /* @__PURE__ */ function() {
  function FilesOnly2() {
  }
  ;
  FilesOnly2.value = new FilesOnly2();
  return FilesOnly2;
}();
var DirectoriesOnly = /* @__PURE__ */ function() {
  function DirectoriesOnly2() {
  }
  ;
  DirectoriesOnly2.value = new DirectoriesOnly2();
  return DirectoriesOnly2;
}();
var eqInclude = {
  eq: function(x) {
    return function(y) {
      if (x instanceof FilesAndDirectories && y instanceof FilesAndDirectories) {
        return true;
      }
      ;
      if (x instanceof FilesOnly && y instanceof FilesOnly) {
        return true;
      }
      ;
      if (x instanceof DirectoriesOnly && y instanceof DirectoriesOnly) {
        return true;
      }
      ;
      return false;
    };
  }
};
var eq10 = /* @__PURE__ */ eq(eqInclude);
var globOptionsToJSGlobOptions = function(cwd3) {
  return function(options) {
    return {
      cwd: cwd3,
      ignore: options.ignore,
      onlyDirectories: eq10(options.include)(DirectoriesOnly.value),
      onlyFiles: eq10(options.include)(FilesOnly.value),
      caseSensitive: options.caseSensitive,
      dotfiles: options.dotfiles,
      unique: options.unique
    };
  };
};
var defaultGlobOptions = /* @__PURE__ */ function() {
  return {
    ignore: [],
    include: FilesAndDirectories.value,
    caseSensitive: true,
    dotfiles: true,
    unique: true
  };
}();
var match$prime = function(dictMonadAff) {
  var Monad0 = dictMonadAff.MonadEffect0().Monad0();
  var bind59 = bind(Monad0.Bind1());
  var liftAff10 = liftAff(dictMonadAff);
  var Applicative0 = Monad0.Applicative0();
  var traverse12 = traverse6(Applicative0);
  var sanitizePath2 = sanitizePath(dictMonadAff);
  var pure75 = pure(Applicative0);
  return function(dictDefaults) {
    var defaults2 = defaults(dictDefaults);
    return function(baseDirectory) {
      return function(entries) {
        return function(opts) {
          var options = defaults2(defaultGlobOptions)(opts);
          var jsOptions = globOptionsToJSGlobOptions(baseDirectory)(options);
          return bind59(liftAff10(toAffE(matchImpl(entries)(jsOptions))))(function(matches) {
            return bind59(traverse12(sanitizePath2(baseDirectory))(matches))(function(results) {
              var v = partitionMap2(identity22)(results);
              return pure75({
                failed: v.left,
                succeeded: v.right
              });
            });
          });
        };
      };
    };
  };
};
var match2 = function(dictMonadAff) {
  var match$prime1 = match$prime(dictMonadAff)(defaultsRecord2);
  return function(baseDir) {
    return function(entries) {
      return match$prime1(baseDir)(entries)({});
    };
  };
};

// output/Node.Library.Execa/foreign.js
import {
  spawn,
  spawnSync
} from "node:child_process";
function monkeyPatchKill(cp, killFn) {
  cp.kill = killFn.bind(null, cp.kill.bind(cp));
}
function setTimeoutImpl(timeout, cb) {
  const t = setTimeout(cb, timeout);
  return t.unref ? t : { unref: () => {
  } };
}
function channelImpl(cp) {
  return cp.channel;
}
function connectedImpl(cp) {
  return cp.connected;
}
function disconnectImpl(cp) {
  return cp.disconnect();
}
function exitCodeImpl(cp) {
  return cp.exitCode;
}
function killImpl(cp, signal, options) {
  return cp.kill(signal, options);
}
function pidExistsImpl(cp) {
  return cp.kill(0);
}
function killedImpl(cp) {
  return cp.killed;
}
function pidImpl(cp) {
  return cp.pid;
}
function refImpl(cp) {
  return cp.ref();
}
function unrefImpl(cp) {
  return cp.unref();
}
function sendImpl(cp, msg, handle, options, cb) {
  return cp.send(msg, handle, options, cb);
}
function signalCodeImpl(cp) {
  return cp.signalCode;
}
function spawnArgs(cp) {
  return cp.spawnArgs;
}
function spawnFile(cp) {
  return cp.spawnFile;
}
function stderr2(cp) {
  return cp.stderr;
}
function stdin2(cp) {
  return cp.stdin;
}
function stdioImpl(cp) {
  return cp.stdio;
}
function stdout2(cp) {
  return cp.stdout;
}
function onCloseImpl(cp, cb) {
  return cp.on("close", cb);
}
function onDisconnectImpl(cp, cb) {
  return cp.on("disconnect", cb);
}
function onErrorImpl(cp, cb) {
  return cp.on("error", cb);
}
function onExitImpl(cp, cb) {
  return cp.on("exit", cb);
}
function onMessageImpl(cp, cb) {
  return cp.on("message", cb);
}
function onSpawnImpl(cp, cb) {
  return cp.on("spawn", cb);
}
var _undefined2 = void 0;

// output/Data.Lens.Internal.Forget/index.js
var Forget = function(x) {
  return x;
};
var profunctorForget = {
  dimap: function(f) {
    return function(v) {
      return function(v1) {
        return function($36) {
          return v1(f($36));
        };
      };
    };
  }
};
var choiceForget = function(dictMonoid) {
  var mempty27 = mempty(monoidFn(dictMonoid));
  return {
    left: function(v) {
      return either(v)(mempty27);
    },
    right: function(v) {
      return either(mempty27)(v);
    },
    Profunctor0: function() {
      return profunctorForget;
    }
  };
};

// output/Data.Profunctor.Choice/index.js
var right = function(dict) {
  return dict.right;
};

// output/Data.Lens.Internal.Market/index.js
var lmap12 = /* @__PURE__ */ lmap(bifunctorEither);
var Market = /* @__PURE__ */ function() {
  function Market2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Market2.create = function(value0) {
    return function(value12) {
      return new Market2(value0, value12);
    };
  };
  return Market2;
}();
var profunctorMarket = {
  dimap: function(f) {
    return function(g) {
      return function(v) {
        return new Market(function($21) {
          return g(v.value0($21));
        }, function() {
          var $22 = lmap12(g);
          return function($23) {
            return $22(v.value1(f($23)));
          };
        }());
      };
    };
  }
};
var choiceMarket = {
  left: function(v) {
    return new Market(function($27) {
      return Left.create(v.value0($27));
    }, either(function() {
      var $28 = lmap12(Left.create);
      return function($29) {
        return $28(v.value1($29));
      };
    }())(function($30) {
      return Left.create(Right.create($30));
    }));
  },
  right: function(v) {
    return new Market(function($31) {
      return Right.create(v.value0($31));
    }, either(function($32) {
      return Left.create(Left.create($32));
    })(function() {
      var $33 = lmap12(Right.create);
      return function($34) {
        return $33(v.value1($34));
      };
    }()));
  },
  Profunctor0: function() {
    return profunctorMarket;
  }
};

// output/Data.Lens.Fold/index.js
var unwrap13 = /* @__PURE__ */ unwrap();
var foldMapOf = /* @__PURE__ */ under()()(Forget);
var preview = function(p) {
  var $135 = foldMapOf(p)(function($137) {
    return First(Just.create($137));
  });
  return function($136) {
    return unwrap13($135($136));
  };
};

// output/Data.Lens.Prism/index.js
var identity23 = /* @__PURE__ */ identity(categoryFn);
var withPrism = function(l) {
  return function(f) {
    var v = l(new Market(identity23, Right.create));
    return f(v.value0)(v.value1);
  };
};
var prism = function(to2) {
  return function(fro) {
    return function(dictChoice) {
      var Profunctor0 = dictChoice.Profunctor0();
      var dimap6 = dimap(Profunctor0);
      var right2 = right(dictChoice);
      var rmap4 = rmap2(Profunctor0);
      return function(pab) {
        return dimap6(fro)(either(identity23)(identity23))(right2(rmap4(to2)(pab)));
      };
    };
  };
};
var matching = function(l) {
  return withPrism(l)(function(v) {
    return function(f) {
      return f;
    };
  });
};
var is = function(dictHeytingAlgebra) {
  var ff2 = ff(dictHeytingAlgebra);
  var tt2 = tt(dictHeytingAlgebra);
  return function(l) {
    var $39 = either($$const(ff2))($$const(tt2));
    var $40 = matching(l);
    return function($41) {
      return $39($40($41));
    };
  };
};

// output/Effect.Timer/foreign.js
function setTimeoutImpl2(ms) {
  return function(fn) {
    return function() {
      return setTimeout(fn, ms);
    };
  };
}
function clearTimeoutImpl(id2) {
  return function() {
    clearTimeout(id2);
  };
}

// output/Effect.Timer/index.js
var setTimeout2 = setTimeoutImpl2;
var clearTimeout2 = clearTimeoutImpl;

// output/Node.Library.Execa.CrossSpawn/foreign.js
import process4 from "process";
var processHasChdir = () => process4.chdir !== void 0;

// output/Node.Library.Execa.ShebangCommand/index.js
var bind31 = /* @__PURE__ */ bind(bindMaybe);
var voidRight5 = /* @__PURE__ */ voidRight(functorMaybe);
var guard5 = /* @__PURE__ */ guard2(alternativeMaybe);
var pure43 = /* @__PURE__ */ pure(applicativeMaybe);
var shebangCommand = function(firstLineOfFile) {
  var shebangRegex = unsafeRegex("^#! ?(.*)")(noFlags);
  return bind31(match(shebangRegex)(firstLineOfFile))(function(parts) {
    var extractBinary = function() {
      var $14 = split("/");
      return function($15) {
        return last($14($15));
      };
    }();
    return bind31(head2(parts))(function(everythingAfterShebang) {
      var v = split(" ")(everythingAfterShebang);
      if (v.length === 1) {
        return bind31(extractBinary(v[0]))(function(binary) {
          return voidRight5(binary)(guard5(binary !== "env"));
        });
      }
      ;
      if (v.length === 2) {
        return bind31(extractBinary(v[0]))(function(binary) {
          return pure43(function() {
            var $11 = binary === "env";
            if ($11) {
              return v[1];
            }
            ;
            return binary + (" " + v[1]);
          }());
        });
      }
      ;
      return Nothing.value;
    });
  });
};

// output/Node.Library.Execa.Utils/foreign.js
import stream from "node:stream";
var buildCustomErrorImpl = (msg, obj) => Object.assign(new Error(msg), obj);
function newPassThroughStream() {
  return new stream.PassThrough({ objectMode: false });
}

// output/Node.Library.Execa.Utils/index.js
var voidRight6 = /* @__PURE__ */ voidRight(functorEffect);
var buildCustomError = function() {
  return function() {
    return function(msg) {
      return function(info4) {
        return buildCustomErrorImpl(msg, info4);
      };
    };
  };
};
var bracketEffect = function(open2) {
  return function(close2) {
    return function(use) {
      return function __do3() {
        var resource = open2();
        var b = use(resource)();
        return voidRight6(b)(close2(resource))();
      };
    };
  };
};

// output/Node.Library.Execa.IsExe/foreign.js
import process5 from "process";
var getUidImpl = (nothing, just) => {
  if (process5.getuid) {
    return just(process5.getuid());
  } else {
    return nothing;
  }
};
var getGidImpl = (nothing, just) => {
  if (process5.getgid) {
    return just(process5.getgid());
  } else {
    return nothing;
  }
};

// output/Node.Library.Execa.IsExe/index.js
var alt19 = /* @__PURE__ */ alt(altMaybe);
var pure44 = /* @__PURE__ */ pure(applicativeEffect);
var eq11 = /* @__PURE__ */ eq(eqString);
var identity24 = /* @__PURE__ */ identity(categoryFn);
var eq18 = /* @__PURE__ */ eq(eqInt);
var getUid = function() {
  return getUidImpl(Nothing.value, Just.create);
};
var getGid = function() {
  return getGidImpl(Nothing.value, Just.create);
};
var getErrorCode = function(e) {
  return e.code;
};
var defaultIsExeOptions = /* @__PURE__ */ function() {
  return {
    pathExt: Nothing.value,
    uid: Nothing.value,
    gid: Nothing.value,
    ignoreErrors: false
  };
}();
var coreWindows = /* @__PURE__ */ function() {
  var checkPathExt = function(path5) {
    return function(options) {
      return function __do3() {
        var mbPathExt = lookupEnv("PATHEXT")();
        var v = alt19(options.pathExt)(mbPathExt);
        if (v instanceof Nothing) {
          return true;
        }
        ;
        if (v instanceof Just) {
          var pathLen = length4(path5);
          var pathExt = split(";")(v.value0);
          var pathEndsInExt = isJust(find2(function(p1) {
            var p2 = drop3(pathLen - length4(p1) | 0)(path5);
            return toLower(p1) === toLower(p2);
          })(pathExt));
          var allElemsNonEmpty = isNothing(find2(eq11(""))(pathExt));
          return allElemsNonEmpty || pathEndsInExt;
        }
        ;
        throw new Error("Failed pattern match at Node.Library.Execa.IsExe (line 102, column 5 - line 116, column 49): " + [v.constructor.name]);
      };
    };
  };
  var checkStat = function(stat6) {
    return function(path5) {
      return function(options) {
        var v = function(v1) {
          if (otherwise) {
            return checkPathExt(path5)(options);
          }
          ;
          throw new Error("Failed pattern match at Node.Library.Execa.IsExe (line 89, column 1 - line 89, column 25): " + [stat6.constructor.name, path5.constructor.name, options.constructor.name]);
        };
        var $34 = !isSymbolicLink(stat6);
        if ($34) {
          var $35 = !isFile(stat6);
          if ($35) {
            return pure44(false);
          }
          ;
          return v(true);
        }
        ;
        return v(true);
      };
    };
  };
  var winIsExe = function(path5) {
    return function(options) {
      return makeAff(function(cb) {
        return function __do3() {
          stat2(path5)(function(v) {
            if (v instanceof Left) {
              return cb(new Right(new Tuple(new Just(v.value0), false)));
            }
            ;
            if (v instanceof Right) {
              return function __do4() {
                var result = checkStat(v.value0)(path5)(options)();
                return cb(new Right(new Tuple(Nothing.value, result)))();
              };
            }
            ;
            throw new Error("Failed pattern match at Node.Library.Execa.IsExe (line 120, column 23 - line 124, column 42): " + [v.constructor.name]);
          })();
          return nonCanceler;
        };
      });
    };
  };
  var winIsExeSync = function(path5) {
    return function(options) {
      return function __do3() {
        var statsObj = stat4(path5)();
        return checkStat(statsObj)(path5)(options)();
      };
    };
  };
  return {
    isExe: winIsExe,
    isExeSync: winIsExeSync
  };
}();
var coreNonWindows = /* @__PURE__ */ function() {
  var checkMode = function(v) {
    return function(options) {
      var uid = floor2(v.value0.uid);
      var mode = floor2(v.value0.mode);
      var gid = floor2(v.value0.gid);
      return function __do3() {
        var processMbUid = getUid();
        var processMbGid = getGid();
        var truthy = function(x) {
          return x !== 0;
        };
        var myUid = alt19(options.uid)(processMbUid);
        var myGid = alt19(options.gid)(processMbGid);
        var ug = 64 | 8;
        return any(identity24)([truthy(mode & 1), truthy(mode & 8) && maybe(false)(eq18(gid))(myGid), truthy(mode & 64) && maybe(false)(eq18(uid))(myUid), truthy(mode & ug) && maybe(false)(eq18(0))(myUid)]);
      };
    };
  };
  var checkStat = function(stat6) {
    return function(options) {
      return function __do3() {
        var b = checkMode(stat6)(options)();
        return isFile(stat6) && b;
      };
    };
  };
  var nonWinIsExe = function(path5) {
    return function(options) {
      return makeAff(function(cb) {
        return function __do3() {
          stat2(path5)(function(v) {
            if (v instanceof Left) {
              return cb(new Right(new Tuple(new Just(v.value0), false)));
            }
            ;
            if (v instanceof Right) {
              return function __do4() {
                var b = checkStat(v.value0)(options)();
                return cb(new Right(new Tuple(Nothing.value, b)))();
              };
            }
            ;
            throw new Error("Failed pattern match at Node.Library.Execa.IsExe (line 138, column 23 - line 142, column 37): " + [v.constructor.name]);
          })();
          return nonCanceler;
        };
      });
    };
  };
  var nonWinIsExeSync = function(path5) {
    return function(options) {
      return function __do3() {
        var stats = stat4(path5)();
        return checkStat(stats)(options)();
      };
    };
  };
  return {
    isExe: nonWinIsExe,
    isExeSync: nonWinIsExeSync
  };
}();
var isExeSync = function(path5) {
  return function(options) {
    var core = function() {
      if (platform instanceof Just && platform.value0 instanceof Win32) {
        return coreWindows;
      }
      ;
      return coreNonWindows;
    }();
    return function __do3() {
      var mbEither = $$try(core.isExeSync(path5)(options))();
      var v = function(v1) {
        if (mbEither instanceof Left && otherwise) {
          return pure44(new Left(mbEither.value0));
        }
        ;
        if (mbEither instanceof Right) {
          return pure44(new Right(mbEither.value0));
        }
        ;
        throw new Error("Failed pattern match at Node.Library.Execa.IsExe (line 67, column 1 - line 67, column 69): " + [mbEither.constructor.name]);
      };
      if (mbEither instanceof Left) {
        if (options.ignoreErrors) {
          var $58 = getErrorCode(mbEither.value0);
          if ($58 === "EACCESS") {
            return new Right(false);
          }
          ;
          return v(true)();
        }
        ;
        return v(true)();
      }
      ;
      return v(true)();
    };
  };
};

// output/Node.Library.Execa.Which/index.js
var eq19 = /* @__PURE__ */ eq(/* @__PURE__ */ eqMaybe(eqString));
var pure45 = /* @__PURE__ */ pure(applicativeEffect);
var eq110 = /* @__PURE__ */ eq(/* @__PURE__ */ eqMaybe(eqPlatform));
var alt20 = /* @__PURE__ */ alt(altMaybe);
var buildCustomError2 = /* @__PURE__ */ buildCustomError()();
var tailRecM5 = /* @__PURE__ */ tailRecM(monadRecEffect);
var quotedRegex = /* @__PURE__ */ function() {
  return unsafeRegex('^".*"$')(noFlags);
}();
var isWindows = function __do() {
  var env3 = getEnv();
  var osTypeIs = function(x) {
    return eq19(new Just(x))(lookup2("OSTYPE")(env3));
  };
  return eq110(platform)(new Just(Win32.value)) || (osTypeIs("cygwin") || osTypeIs("msys"));
};
var jsColon = function __do2() {
  var w = isWindows();
  if (w) {
    return ";";
  }
  ;
  return ":";
};
var getPathInfo = function(cmd) {
  return function(options) {
    var hasWindowsSlashRegex = unsafeRegex("\\\\")(noFlags);
    var hasPosixSlashRegex = unsafeRegex("\\/")(noFlags);
    return function __do3() {
      var cwd3 = cwd();
      var mbPath = lookupEnv("PATH")();
      var mbPathExt = lookupEnv("PATHEXT")();
      var isWin2 = isWindows();
      var colon = function() {
        if (options.colon instanceof Nothing) {
          return jsColon();
        }
        ;
        if (options.colon instanceof Just) {
          return options.colon.value0;
        }
        ;
        throw new Error("Failed pattern match at Node.Library.Execa.Which (line 79, column 12 - line 81, column 21): " + [options.colon.constructor.name]);
      }();
      var pathExtExe = function() {
        if (isWin2) {
          return fromMaybe(".EXE;.CMD;.BAT;.exe;.cmd;.bat")(alt20(options.pathExt)(mbPathExt));
        }
        ;
        if (otherwise) {
          return "";
        }
        ;
        throw new Error("Failed pattern match at Node.Library.Execa.Which (line 94, column 5 - line 98, column 23): " + []);
      }();
      var pathExt = function() {
        if (isWin2) {
          return split(colon)(pathExtExe);
        }
        ;
        if (otherwise) {
          return [""];
        }
        ;
        throw new Error("Failed pattern match at Node.Library.Execa.Which (line 100, column 5 - line 102, column 27): " + []);
      }();
      var pathEnv = function() {
        if (test(hasPosixSlashRegex)(cmd) || isWin2 && test(hasWindowsSlashRegex)(cmd)) {
          return [""];
        }
        ;
        if (otherwise) {
          var paths2 = split(colon)(fromMaybe("")(alt20(options.path)(mbPath)));
          if (isWin2) {
            return cons(cwd3)(paths2);
          }
          ;
          return paths2;
        }
        ;
        throw new Error("Failed pattern match at Node.Library.Execa.Which (line 86, column 5 - line 92, column 56): " + []);
      }();
      return {
        pathEnv,
        pathExt,
        pathExtExe
      };
    };
  };
};
var getNotFoundError = function(cmd) {
  return buildCustomError2("not found: " + cmd)({
    code: "ENOENT"
  });
};
var dotSlashRegex = /* @__PURE__ */ unsafeRegex("^\\.[\\/]")(noFlags);
var whichSync = function(cmd) {
  return function(options) {
    var go = function(pathEnv) {
      return function(pathExt) {
        return function(pathExtExe) {
          var loop = function(v) {
            if (v.innerLoop instanceof Nothing) {
              var v1 = index(pathEnv)(v.outerLoopIdx);
              if (v1 instanceof Nothing) {
                return pure45(new Done(new Left(getNotFoundError(cmd))));
              }
              ;
              if (v1 instanceof Just) {
                var pathPart = function() {
                  if (test(quotedRegex)(v1.value0)) {
                    return slice2(1)(-1 | 0)(v1.value0);
                  }
                  ;
                  if (otherwise) {
                    return v1.value0;
                  }
                  ;
                  throw new Error("Failed pattern match at Node.Library.Execa.Which (line 165, column 15 - line 167, column 36): " + []);
                }();
                var pCmd = concat2([pathPart, cmd]);
                var p = function() {
                  var v2 = function(v3) {
                    if (otherwise) {
                      return pCmd;
                    }
                    ;
                    throw new Error("Failed pattern match at Node.Library.Execa.Which (line 150, column 1 - line 150, column 109): " + []);
                  };
                  var $61 = !$$null2(pathPart);
                  if ($61) {
                    var $62 = test(dotSlashRegex)(cmd);
                    if ($62) {
                      return slice2(0)(2)(cmd) + pCmd;
                    }
                    ;
                    return v2(true);
                  }
                  ;
                  return v2(true);
                }();
                return pure45(new Loop({
                  innerLoop: new Just({
                    p,
                    j: 0
                  }),
                  found: v.found,
                  outerLoopIdx: v.outerLoopIdx
                }));
              }
              ;
              throw new Error("Failed pattern match at Node.Library.Execa.Which (line 160, column 20 - line 173, column 63): " + [v1.constructor.name]);
            }
            ;
            if (v.innerLoop instanceof Just) {
              var v1 = index(pathExt)(v.innerLoop.value0.j);
              if (v1 instanceof Nothing) {
                return pure45(new Loop({
                  outerLoopIdx: v.outerLoopIdx + 1 | 0,
                  innerLoop: Nothing.value,
                  found: v.found
                }));
              }
              ;
              if (v1 instanceof Just) {
                var cur = v.innerLoop.value0.p + v1.value0;
                return function __do3() {
                  var eOrB = isExeSync(cur)({
                    pathExt: new Just(pathExtExe),
                    uid: defaultIsExeOptions.uid,
                    gid: defaultIsExeOptions.gid,
                    ignoreErrors: defaultIsExeOptions.ignoreErrors
                  })();
                  if (eOrB instanceof Right) {
                    if (eOrB.value0 && !options.all) {
                      return new Done(new Right(singleton4(cur)));
                    }
                    ;
                    if (eOrB.value0) {
                      return new Loop({
                        found: snoc(v.found)(cur),
                        innerLoop: new Just({
                          p: v.innerLoop.value0.p,
                          j: v.innerLoop.value0.j + 1 | 0
                        }),
                        outerLoopIdx: v.outerLoopIdx
                      });
                    }
                    ;
                  }
                  ;
                  return new Loop({
                    innerLoop: new Just({
                      p: v.innerLoop.value0.p,
                      j: v.innerLoop.value0.j + 1 | 0
                    }),
                    found: v.found,
                    outerLoopIdx: v.outerLoopIdx
                  });
                };
              }
              ;
              throw new Error("Failed pattern match at Node.Library.Execa.Which (line 176, column 26 - line 189, column 71): " + [v1.constructor.name]);
            }
            ;
            throw new Error("Failed pattern match at Node.Library.Execa.Which (line 158, column 7 - line 189, column 71): " + [v.innerLoop.constructor.name]);
          };
          return tailRecM5(loop)({
            found: [],
            outerLoopIdx: 0,
            innerLoop: Nothing.value
          });
        };
      };
    };
    return function __do3() {
      var v = getPathInfo(cmd)(options)();
      return go(v.pathEnv)(v.pathExt)(v.pathExtExe)();
    };
  };
};
var defaultWhichOptions = /* @__PURE__ */ function() {
  return {
    path: Nothing.value,
    pathExt: Nothing.value,
    colon: Nothing.value,
    all: false
  };
}();

// output/Node.Library.Execa.CrossSpawn/index.js
var for_3 = /* @__PURE__ */ for_(applicativeEffect)(foldableMaybe);
var applySecond5 = /* @__PURE__ */ applySecond(applyMaybe);
var guard6 = /* @__PURE__ */ guard2(alternativeMaybe);
var pure46 = /* @__PURE__ */ pure(applicativeEffect);
var map56 = /* @__PURE__ */ map(functorEffect);
var join2 = /* @__PURE__ */ join(bindMaybe);
var $$for3 = /* @__PURE__ */ $$for(applicativeEffect)(traversableMaybe);
var create4 = /* @__PURE__ */ create(mutableBufferEffect);
var $$void12 = /* @__PURE__ */ $$void(functorEffect);
var toString9 = /* @__PURE__ */ toString4(mutableBufferEffect);
var append110 = /* @__PURE__ */ append(semigroupArray);
var voidLeft6 = /* @__PURE__ */ voidLeft(functorArray);
var guard1 = /* @__PURE__ */ guard2(alternativeArray);
var intercalate7 = /* @__PURE__ */ intercalate2(monoidString);
var mapFlipped7 = /* @__PURE__ */ mapFlipped(functorArray);
var isWindows2 = /* @__PURE__ */ function() {
  return eq(eqMaybe(eqPlatform))(platform)(new Just(Win32.value));
}();
var parse9 = function(command2) {
  return function(args) {
    return function(options) {
      var wrapInDoubleQuotes = function(s) {
        return '"' + (s + '"');
      };
      var resolveCommand = function(parseRec) {
        var withOptionsCwdIfNeeded = function(optionsCwd) {
          var open2 = function __do3() {
            var cwd3 = cwd();
            var hasChdir = processHasChdir();
            for_3(applySecond5(guard6(hasChdir))(optionsCwd))(function(optionCwd) {
              return chdir(optionCwd);
            })();
            return {
              cwd: cwd3,
              hasChdir
            };
          };
          var close2 = function(v) {
            return for_3(applySecond5(guard6(v.hasChdir))(optionsCwd))(function(v1) {
              return chdir(v.cwd);
            });
          };
          return bracketEffect(open2)(close2);
        };
        return function __do3() {
          var env3 = function() {
            if (parseRec.options.env instanceof Nothing) {
              return getEnv();
            }
            ;
            if (parseRec.options.env instanceof Just) {
              return parseRec.options.env.value0;
            }
            ;
            throw new Error("Failed pattern match at Node.Library.Execa.CrossSpawn (line 155, column 12 - line 157, column 23): " + [parseRec.options.env.constructor.name]);
          }();
          var resolved = withOptionsCwdIfNeeded(parseRec.options.cwd)(function(v) {
            return map56(join2)($$for3(lookup2("PATH")(env3))(function(envPath) {
              var getFirst = either($$const(Nothing.value))(function($61) {
                return Just.create(head2($61));
              });
              return function __do4() {
                var attempt1 = map56(getFirst)(whichSync(command2)({
                  path: new Just(envPath),
                  pathExt: new Just(delimiter),
                  colon: defaultWhichOptions.colon,
                  all: defaultWhichOptions.all
                }))();
                var $44 = isJust(attempt1);
                if ($44) {
                  return attempt1;
                }
                ;
                return map56(getFirst)(whichSync(command2)({
                  path: new Just(envPath),
                  pathExt: defaultWhichOptions.pathExt,
                  colon: defaultWhichOptions.colon,
                  all: defaultWhichOptions.all
                }))();
              };
            }));
          })();
          if (parseRec.options.cwd instanceof Just && resolved instanceof Just) {
            return map56(Just.create)(resolve([parseRec.options.cwd.value0])(resolved.value0))();
          }
          ;
          if (parseRec.options.cwd instanceof Nothing && resolved instanceof Just) {
            return map56(Just.create)(resolve([""])(resolved.value0))();
          }
          ;
          return Nothing.value;
        };
      };
      var readShebang = function(cmd) {
        return function __do3() {
          var buf = create4(150)();
          $$void12($$try(bracketEffect(fdOpen2(cmd)(R.value)(Nothing.value))(fdClose2)(function(fd) {
            return fdRead2(fd)(buf)(0)(150)(new Just(0));
          })))();
          var firstLine = toString9(UTF8.value)(buf)();
          return shebangCommand(firstLine);
        };
      };
      var metaCharsRegex = unsafeRegex('([()\\][%!^"`<>&|;, *?])')(global2);
      var isExecutableRegex = unsafeRegex("\\.(?:com|exe)$")(ignoreCase);
      var isCommandShimRegex = unsafeRegex("node_modules[\\\\/].bin[\\\\/][^\\\\/]+\\.cmd$")(ignoreCase);
      var initParseRec = {
        command: command2,
        args,
        options,
        file: Nothing.value,
        original: {
          command: command2,
          args
        }
      };
      var escapeCommand = replace2(metaCharsRegex)("^$1");
      var escapeArgument = function(doubleEscapeMetaChars) {
        var escapeCount = function() {
          if (doubleEscapeMetaChars) {
            return 2;
          }
          ;
          return 1;
        }();
        var endOfStringRegex = unsafeRegex("(\\\\*)$")(noFlags);
        var backSlashSequenceThenDoubleQuoteRegex = unsafeRegex('(\\\\*)"')(global2);
        var $62 = applyN(replace2(metaCharsRegex)("^$1"))(escapeCount);
        var $63 = replace2(endOfStringRegex)("$1$1");
        var $64 = replace2(backSlashSequenceThenDoubleQuoteRegex)('$1$1\\"');
        return function($65) {
          return $62(wrapInDoubleQuotes($63($64($65))));
        };
      };
      var detectShebang = function(parseRec) {
        return function __do3() {
          var mbFile = resolveCommand(parseRec)();
          if (mbFile instanceof Nothing) {
            return new Tuple({
              file: mbFile,
              args: parseRec.args,
              command: parseRec.command,
              options: parseRec.options,
              original: parseRec.original
            }, mbFile);
          }
          ;
          if (mbFile instanceof Just) {
            var mbShebang = readShebang(mbFile.value0)();
            if (mbShebang instanceof Nothing) {
              return new Tuple({
                file: mbFile,
                args: parseRec.args,
                command: parseRec.command,
                options: parseRec.options,
                original: parseRec.original
              }, mbFile);
            }
            ;
            if (mbShebang instanceof Just) {
              var rec1 = {
                file: mbFile,
                args: cons(mbFile.value0)(parseRec.args),
                command: mbShebang.value0,
                options: parseRec.options,
                original: parseRec.original
              };
              var newCommand = resolveCommand(rec1)();
              return new Tuple(rec1, newCommand);
            }
            ;
            throw new Error("Failed pattern match at Node.Library.Execa.CrossSpawn (line 141, column 9 - line 151, column 41): " + [mbShebang.constructor.name]);
          }
          ;
          throw new Error("Failed pattern match at Node.Library.Execa.CrossSpawn (line 137, column 5 - line 151, column 41): " + [mbFile.constructor.name]);
        };
      };
      var parseNonShell = function(parseRec) {
        return function __do3() {
          var v = detectShebang(parseRec)();
          var needsShell = function() {
            var $66 = test(isExecutableRegex);
            return function($67) {
              return !$66($67);
            };
          }();
          if (v.value1 instanceof Just && needsShell(v.value1.value0)) {
            var needsDoubleEscapeChars = test(isCommandShimRegex)(v.value1.value0);
            var comSpec = map56(fromMaybe("cmd.exe"))(lookupEnv("comspec"))();
            return {
              args: append110(voidLeft6(guard1(toLower(comSpec) === "cmd.exe" && !parseRec.options.windowsEnableCmdEcho))("/q"))(["/d", "/s", "/c", wrapInDoubleQuotes(intercalate7(" ")(cons(escapeCommand(normalize(v.value0.command)))(mapFlipped7(v.value0.args)(escapeArgument(needsDoubleEscapeChars)))))]),
              command: comSpec,
              options: {
                windowsVerbatimArguments: new Just(true),
                cwd: v.value0.options.cwd,
                env: v.value0.options.env,
                shell: v.value0.options.shell,
                windowsEnableCmdEcho: v.value0.options.windowsEnableCmdEcho
              },
              file: v.value0.file,
              original: v.value0.original
            };
          }
          ;
          return v.value0;
        };
      };
      var parseWindows = function() {
        if (isJust(options.shell)) {
          return pure46(initParseRec);
        }
        ;
        if (otherwise) {
          return parseNonShell(initParseRec);
        }
        ;
        throw new Error("Failed pattern match at Node.Library.Execa.CrossSpawn (line 89, column 3 - line 91, column 45): " + []);
      }();
      var $60 = !isWindows2;
      if ($60) {
        return pure46(initParseRec);
      }
      ;
      return parseWindows;
    };
  };
};

// output/Node.Library.Execa.GetStream/foreign.js
import stream2 from "node:stream";
import { constants as constants2 } from "node:buffer";
var maxBufferLength = constants2.MAX_LENGTH;
function pipeline(source2, destination, cb) {
  return stream2.pipeline([source2, destination], cb);
}

// output/Node.Library.Execa.GetStream/index.js
var size8 = /* @__PURE__ */ size4(mutableBufferEffect);
var concat$prime4 = /* @__PURE__ */ concat$prime(mutableBufferEffect);
var bind114 = /* @__PURE__ */ bind(bindAff);
var liftEffect4 = /* @__PURE__ */ liftEffect(monadEffectAff);
var unsafeFreeze4 = /* @__PURE__ */ unsafeFreeze2(mutableBufferEffect);
var when5 = /* @__PURE__ */ when(applicativeEffect);
var show21 = /* @__PURE__ */ show(showNumber);
var getStreamBuffer = function(inputStream) {
  return function(initialOptions) {
    var bufferStream = function __do3() {
      var chunksRef = $$new([])();
      var lengthRef = $$new(0)();
      var stream3 = newPassThroughStream();
      onData(stream3)(function(buf) {
        return function __do4() {
          modify_(function(chunks) {
            return snoc(chunks)(buf);
          })(chunksRef)();
          var bufLen = size8(buf)();
          return modify_(function(v) {
            return v + toNumber2(bufLen);
          })(lengthRef)();
        };
      })();
      return {
        getBufferedValue: function __do4() {
          var chunks = read(chunksRef)();
          var len = read(lengthRef)();
          return concat$prime4(chunks)(len)();
        },
        getBufferedLength: read(lengthRef),
        stream: stream3
      };
    };
    var options = {
      maxBuffer: fromMaybe(infinity)(initialOptions.maxBuffer)
    };
    return bind114(liftEffect4(bufferStream))(function($$interface) {
      return makeAff(function(cb) {
        return function __do3() {
          pipeline(inputStream, $$interface.stream, function(err) {
            var bufferedData = $$interface.getBufferedValue();
            var buff = unsafeFreeze4(bufferedData)();
            return cb(new Right({
              buffer: buff,
              inputError: toMaybe(err)
            }))();
          });
          onData($$interface.stream)(function(v) {
            return function __do4() {
              var bufferedLen = $$interface.getBufferedLength();
              return when5(bufferedLen > options.maxBuffer)(function __do5() {
                var bufferedData = $$interface.getBufferedValue();
                var buff = unsafeFreeze4(bufferedData)();
                return cb(new Right({
                  buffer: buff,
                  inputError: new Just(error(maybe("Max buffer exceeded")(function(size1) {
                    return "Max buffer size exceeded. Buffer size was: " + show21(size1);
                  })(initialOptions.maxBuffer)))
                }))();
              })();
            };
          })();
          return nonCanceler;
        };
      });
    });
  };
};

// output/Node.Library.Execa.NpmRunPath/index.js
var intercalate8 = /* @__PURE__ */ intercalate2(monoidString);
var append21 = /* @__PURE__ */ append(semigroupArray);
var foldMap6 = /* @__PURE__ */ foldMap(foldableMaybe)(monoidArray);
var alt21 = /* @__PURE__ */ alt(altMaybe);
var map57 = /* @__PURE__ */ map(functorEffect);
var monoidMaybe2 = /* @__PURE__ */ monoidMaybe(semigroupString);
var npmRunPath = function(initialOptions) {
  var go = function(options) {
    return function(result) {
      return function(previous) {
        return function(cwdPath) {
          if (previous instanceof Just && previous.value0 === cwdPath) {
            return function __do3() {
              var nodeBinaryPath = resolve([cwdPath, options.execPath])("..")();
              return intercalate8(delimiter)(append21(result)(append21([nodeBinaryPath])(foldMap6(singleton2)(options.path))));
            };
          }
          ;
          var nextResult = concat2([cwdPath, "node_modules/.bin"]);
          var nextPrevious = new Just(cwdPath);
          return function __do3() {
            var nextCwdPath = resolve([cwdPath])("..")();
            return go(options)(snoc(result)(nextResult))(nextPrevious)(nextCwdPath)();
          };
        };
      };
    };
  };
  return function __do3() {
    var processCwd = cwd();
    var processPath = lookupEnv("PATH")();
    var processExecPath = execPath();
    var options = {
      cwd: fromMaybe(processCwd)(initialOptions.cwd),
      path: alt21(initialOptions.path)(processPath),
      execPath: fromMaybe(processExecPath)(initialOptions.execPath)
    };
    var cwdPath = resolve([])(options.cwd)();
    return go(options)([])(Nothing.value)(cwdPath)();
  };
};
var npmRunPathEnv = function(env3) {
  return function(options) {
    return map57(function(p) {
      return insert2("PATH")(p)(env3);
    })(npmRunPath(options));
  };
};
var defaultNpmRunPathOptions = /* @__PURE__ */ mempty(/* @__PURE__ */ monoidRecord()(/* @__PURE__ */ monoidRecordCons({
  reflectSymbol: function() {
    return "cwd";
  }
})(monoidMaybe2)()(/* @__PURE__ */ monoidRecordCons({
  reflectSymbol: function() {
    return "execPath";
  }
})(monoidMaybe2)()(/* @__PURE__ */ monoidRecordCons({
  reflectSymbol: function() {
    return "path";
  }
})(monoidMaybe2)()(monoidRecordNil)))));

// output/Node.Library.Execa.SignalExit/foreign.js
function unsafeProcessHasProp(prop3) {
  return global.process[prop3] !== null && global.process[prop3] !== void 0;
}
function unsafeReadProcessProp(prop3) {
  return global.process[prop3];
}
function unsafeWriteProcessProp(prop3, value4) {
  global.process[prop3] = value4;
}
function processCallFn(originalProcessReallyExit, exitCode2) {
  return originalProcessReallyExit.call(global.process, exitCode2);
}
function processKill(pid3, sig) {
  global.process.kill(pid3, sig);
}
function processListenersLength(sig) {
  return global.process.listeners(sig).length;
}
function processOn(sig, listener) {
  return global.process.on(sig, listener);
}
function processOff(sig, listener) {
  return global.process.off(sig, listener);
}
function customProcessEmit(cb) {
  return function(ev, arg) {
    const thisArg = this;
    const argumentsArg = arguments;
    return cb((originalProcessEmit) => originalProcessEmit.apply(thisArg, argumentsArg), ev, arg);
  };
}
function processExitCode() {
  return global.process.exitCode;
}

// output/Node.EventEmitter/foreign.js
import events from "node:events";
var newImpl2 = function() {
  return new events.EventEmitter();
};
function listenersLengthImpl(emitter, event) {
  return emitter.listeners(event).length;
}
function setMaxListenersImpl(emitter, max8) {
  emitter.setMaxListeners(max8);
}
function onImpl(emitter, eventName, cb) {
  emitter.on(eventName, cb);
  return cb;
}
function offImpl(emitter, eventName, cb) {
  emitter.off(eventName, cb);
}
function emitImpl(emitter, eventName) {
  return function(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
    emitter.emit(eventName, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
  };
}
var undefined_ = void 0;

// output/Node.EventEmitter/index.js
var unsafeOnEventEffectFn2Uni = {
  unsafeOn: function(eventName) {
    return function(fn) {
      return function(emitter) {
        return function() {
          return onImpl(emitter, eventName, fn);
        };
      };
    };
  }
};
var unsafeOffEventEffectFn2Un = {
  unsafeOff: function(eventName) {
    return function(fn) {
      return function(emitter) {
        return function() {
          return offImpl(emitter, eventName, fn);
        };
      };
    };
  }
};
var unsafeEmitFunctionFunctio = {
  unsafeEmit: function(emitter) {
    return function(eventName) {
      return function(a1) {
        return function(a2) {
          return function() {
            return emitImpl(emitter, eventName)(a1, a2, undefined_, undefined_, undefined_, undefined_, undefined_, undefined_, undefined_, undefined_);
          };
        };
      };
    };
  }
};
var unsafeOn = function(dict) {
  return dict.unsafeOn;
};
var unsafeOn10 = /* @__PURE__ */ unsafeOn(unsafeOnEventEffectFn2Uni);
var unsafeOnEventFunctionFunc8 = {
  unsafeOn: function(eventName) {
    return function(fn) {
      return function(emitter) {
        return unsafeOn10(eventName)(mkEffectFn2(fn))(emitter);
      };
    };
  }
};
var unsafeOff = function(dict) {
  return dict.unsafeOff;
};
var unsafeSubscribe = function(dictUnsafeOnEvent) {
  var unsafeOn11 = unsafeOn(dictUnsafeOnEvent);
  return function(dictUnsafeOffEvent) {
    var unsafeOff1 = unsafeOff(dictUnsafeOffEvent);
    return function(event) {
      return function(cb) {
        return function(emitter) {
          return function __do3() {
            var cb$prime = unsafeOn11(event)(cb)(emitter)();
            return unsafeOff1(event)(cb$prime)(emitter);
          };
        };
      };
    };
  };
};
var unsafeEmit = function(dict) {
  return dict.unsafeEmit;
};
var setMaxListeners = function(max8) {
  return function(emitter) {
    return function() {
      return setMaxListenersImpl(emitter, max8);
    };
  };
};
var setUnlimitedListeners = /* @__PURE__ */ setMaxListeners(0);
var listenersLength = function(eventName) {
  return function(emitter) {
    return function() {
      return listenersLengthImpl(emitter, eventName);
    };
  };
};

// output/Node.EventEmitter.TypedEmitter/index.js
var coerce6 = /* @__PURE__ */ coerce();
var withEmit = /* @__PURE__ */ identity(categoryFn);
var subscribe = function() {
  return function(dictUnsafeOnEvent) {
    var unsafeSubscribe2 = unsafeSubscribe(dictUnsafeOnEvent);
    return function(dictUnsafeOffEvent) {
      var unsafeSubscribe1 = unsafeSubscribe2(dictUnsafeOffEvent);
      return function(dictIsSymbol) {
        var reflectSymbol3 = reflectSymbol(dictIsSymbol);
        return function(_sym) {
          return function(fn) {
            return function(v) {
              return unsafeSubscribe1(reflectSymbol3(_sym))(fn)(v);
            };
          };
        };
      };
    };
  };
};
var setUnlimitedListeners2 = function(v) {
  return setUnlimitedListeners(v);
};
var $$new3 = function(v) {
  return coerce6(newImpl2);
};
var listenersLength2 = function() {
  return function(dictIsSymbol) {
    var reflectSymbol3 = reflectSymbol(dictIsSymbol);
    return function(_sym) {
      return function(v) {
        return listenersLength(reflectSymbol3(_sym))(v);
      };
    };
  };
};
var emit = function() {
  return function() {
    return function(dictUnsafeEmit) {
      var unsafeEmit3 = unsafeEmit(dictUnsafeEmit);
      return function(dictIsSymbol) {
        var reflectSymbol3 = reflectSymbol(dictIsSymbol);
        return function(_sym) {
          return function(v) {
            return unsafeEmit3(v)(reflectSymbol3(_sym));
          };
        };
      };
    };
  };
};

// output/Node.Library.Execa.SignalExit/index.js
var eq20 = /* @__PURE__ */ eq(/* @__PURE__ */ eqMaybe(eqPlatform));
var guard7 = /* @__PURE__ */ guard(monoidArray);
var append23 = /* @__PURE__ */ append(semigroupArray);
var bind32 = /* @__PURE__ */ bind(bindEffect);
var pure47 = /* @__PURE__ */ pure(applicativeEffect);
var whenM2 = /* @__PURE__ */ whenM(monadEffect);
var traverse_2 = /* @__PURE__ */ traverse_(applicativeEffect)(foldableArray);
var $$void13 = /* @__PURE__ */ $$void(functorEffect);
var emit2 = /* @__PURE__ */ emit()()(unsafeEmitFunctionFunctio);
var exitIsSymbol = {
  reflectSymbol: function() {
    return "exit";
  }
};
var emit1 = /* @__PURE__ */ emit2(exitIsSymbol);
var afterexitIsSymbol = {
  reflectSymbol: function() {
    return "afterexit";
  }
};
var emit22 = /* @__PURE__ */ emit2(afterexitIsSymbol);
var unless2 = /* @__PURE__ */ unless(applicativeEffect);
var member3 = /* @__PURE__ */ member2(ordString);
var insert9 = /* @__PURE__ */ insert4(ordString);
var map58 = /* @__PURE__ */ map(functorEffect);
var unsafeEmit2 = /* @__PURE__ */ unsafeEmit(unsafeEmitFunctionFunctio);
var when6 = /* @__PURE__ */ when(applicativeEffect);
var reflectSymbol2 = /* @__PURE__ */ reflectSymbol(exitIsSymbol);
var reflectSymbol1 = /* @__PURE__ */ reflectSymbol(afterexitIsSymbol);
var unlessM2 = /* @__PURE__ */ unlessM(monadEffect);
var $$for4 = /* @__PURE__ */ $$for(applicativeEffect)(traversableArray);
var subscribe2 = /* @__PURE__ */ subscribe()(unsafeOnEventFunctionFunc8)(unsafeOffEventEffectFn2Un);
var subscribe1 = /* @__PURE__ */ subscribe2(afterexitIsSymbol);
var subscribe22 = /* @__PURE__ */ subscribe2(exitIsSymbol);
var listenersLength3 = /* @__PURE__ */ listenersLength2();
var listenersLength1 = /* @__PURE__ */ listenersLength3(exitIsSymbol);
var listenersLength22 = /* @__PURE__ */ listenersLength3(afterexitIsSymbol);
var signalExitProp = "__purescript_signal_exit__";
var isWin = /* @__PURE__ */ function() {
  return eq20(new Just(Win32.value))(platform);
}();
var signals = /* @__PURE__ */ function() {
  var windows2 = guard7(isWin)(["SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT", "SIGPROF"]);
  var normal = ["SIGABRT", "SIGALRM", "SIGHUP", "SIGINT", "SIGTERM"];
  var linux2 = guard7(eq20(platform)(new Just(Linux.value)))(["SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT", "SIGUNUSED"]);
  return append23(normal)(append23(windows2)(linux2));
}();
var getGlobalRecOnProcessObject = /* @__PURE__ */ function() {
  var attachRefsToProcessObject = function __do3() {
    var v = unsafeReadProcessProp("emit");
    var v1 = unsafeReadProcessProp("reallyExit");
    var restoreOriginalProcessFunctions = function __do4() {
      unsafeWriteProcessProp("emit", v);
      return unsafeWriteProcessProp("reallyExit", v1);
    };
    var emitter = $$new3($$Proxy.value)();
    setUnlimitedListeners2(emitter)();
    var countRef = $$new(0)();
    var emittedEventsRef = $$new(empty4)();
    var loadedRef = $$new(false)();
    var signalListenersRef = $$new([])();
    var obj = {
      originalProcessEmit: v,
      originalProcessReallyExit: v1,
      restoreOriginalProcessFunctions,
      emitter,
      countRef,
      emittedEventsRef,
      loadedRef,
      signalListenersRef
    };
    unsafeWriteProcessProp(signalExitProp, obj);
    return obj;
  };
  return ifM(bindEffect)(function() {
    return unsafeProcessHasProp(signalExitProp);
  })(function() {
    return unsafeReadProcessProp(signalExitProp);
  })(attachRefsToProcessObject);
}();
var _exit = /* @__PURE__ */ function() {
  return $$Proxy.value;
}();
var _afterexit = /* @__PURE__ */ function() {
  return $$Proxy.value;
}();
var onExit$prime = function(cb) {
  return function(options) {
    var unload = function __do3() {
      var v = getGlobalRecOnProcessObject();
      return whenM2(read(v.loadedRef))(function __do4() {
        write(false)(v.loadedRef)();
        bind32(read(v.signalListenersRef))(traverse_2(function(v1) {
          if (v1 instanceof Nothing) {
            return pure47(unit);
          }
          ;
          if (v1 instanceof Just) {
            return v1.value0;
          }
          ;
          throw new Error("Failed pattern match at Node.Library.Execa.SignalExit (line 99, column 49 - line 101, column 40): " + [v1.constructor.name]);
        }))();
        v.restoreOriginalProcessFunctions();
        return modify_(function(v1) {
          return v1 - 1 | 0;
        })(v.countRef)();
      })();
    };
    var processReallyExitFn = function(v) {
      var v1 = getGlobalRecOnProcessObject();
      var exitCode2 = fromMaybe(0)(toMaybe(v));
      unsafeWriteProcessProp("exit", exitCode2);
      $$void13(withEmit(emit1(_exit)(v1.emitter)(notNull(exitCode2))(nullImpl)))();
      $$void13(withEmit(emit22(_afterexit)(v1.emitter)(notNull(exitCode2))(nullImpl)))();
      return processCallFn(v1.originalProcessReallyExit, notNull(exitCode2));
    };
    var emitFn = function(event, code, signal) {
      var v = getGlobalRecOnProcessObject();
      var eventsAlreadyEmitted = read(v.emittedEventsRef)();
      return unless2(member3(event)(eventsAlreadyEmitted))(function __do3() {
        modify_(insert9(event))(v.emittedEventsRef)();
        return map58(function(v1) {
          return unit;
        })(unsafeEmit2(v.emitter)(event)(code)(signal))();
      })();
    };
    var mkListener = function(sig) {
      return function(countRef) {
        return function __do3() {
          var listenersLen = processListenersLength(sig);
          var count = read(countRef)();
          return when6(listenersLen === count)(function __do4() {
            unload();
            emitFn(reflectSymbol2(_exit), nullImpl, notNull(sig));
            emitFn(reflectSymbol1(_afterexit), nullImpl, notNull(sig));
            var sig$prime = function() {
              var $74 = isWin && sig === "SIGHUP";
              if ($74) {
                return "SIGINT";
              }
              ;
              return sig;
            }();
            return processKill(pid, sig$prime);
          })();
        };
      };
    };
    var processEmitFn = customProcessEmit(function(runOriginalProcessEmit, ev, arg) {
      var v = getGlobalRecOnProcessObject();
      var $76 = ev === reflectSymbol2(_exit);
      if ($76) {
        var exitCode2 = function() {
          var v1 = toMaybe(arg);
          if (v1 instanceof Nothing) {
            return processExitCode();
          }
          ;
          if (v1 instanceof Just) {
            unsafeWriteProcessProp("exit", v1.value0);
            return notNull(v1.value0);
          }
          ;
          throw new Error("Failed pattern match at Node.Library.Execa.SignalExit (line 173, column 19 - line 177, column 35): " + [v1.constructor.name]);
        }();
        var ret = runOriginalProcessEmit(v.originalProcessEmit);
        emitFn(reflectSymbol2(_exit), exitCode2, nullImpl);
        emitFn(reflectSymbol1(_afterexit), exitCode2, nullImpl);
        return ret;
      }
      ;
      return runOriginalProcessEmit(v.originalProcessEmit);
    });
    var load = function __do3() {
      var v = getGlobalRecOnProcessObject();
      return unlessM2(read(v.loadedRef))(function __do4() {
        write(true)(v.loadedRef)();
        modify_(function(v1) {
          return v1 + 1 | 0;
        })(v.countRef)();
        var signalListeners = $$for4(signals)(function(sig) {
          return map58(hush)($$try(function() {
            var listener = mkListener(sig)(v.countRef);
            return function __do5() {
              processOn(sig, listener);
              return $$void13($$try(function() {
                return processOff(sig, listener);
              }));
            };
          }()));
        })();
        write(signalListeners)(v.signalListenersRef)();
        unsafeWriteProcessProp("emit", processEmitFn);
        return unsafeWriteProcessProp("reallyExit", processReallyExitFn);
      })();
    };
    return function __do3() {
      var v = getGlobalRecOnProcessObject();
      load();
      var unSubscribe = function() {
        if (options.alwaysLast) {
          return subscribe1(_afterexit)(function(exitCode2) {
            return function(sig) {
              return cb(toMaybe(exitCode2))(toMaybe(sig));
            };
          })(v.emitter)();
        }
        ;
        return subscribe22(_exit)(function(exitCode2) {
          return function(sig) {
            return cb(toMaybe(exitCode2))(toMaybe(sig));
          };
        })(v.emitter)();
      }();
      return function __do4() {
        unSubscribe();
        var exitLen = listenersLength1(_exit)(v.emitter)();
        var afterExitLen = listenersLength22(_afterexit)(v.emitter)();
        return when6(exitLen === 0 && afterExitLen === 0)(unload)();
      };
    };
  };
};
var onExit2 = function(cb) {
  return onExit$prime(cb)({
    alwaysLast: false
  });
};

// output/Node.Library.Execa.StripFinalNewline/index.js
var stripFinalNewlineBuf = function(dictMutableBuffer) {
  var Monad0 = dictMutableBuffer.Monad0();
  var bind59 = bind(Monad0.Bind1());
  var size10 = size6(Monad0);
  var unsafeFreeze5 = unsafeFreeze2(dictMutableBuffer);
  var read7 = read4(Monad0);
  var slice6 = slice3(dictMutableBuffer);
  return function(b) {
    var charR = toNumber2(toCharCode2("\r"));
    var charN = toNumber2(toCharCode2("\n"));
    return bind59(size10(b))(function(len) {
      if (len === 0) {
        return unsafeFreeze5(b);
      }
      ;
      if (len === 1) {
        return bind59(read7(UInt8.value)(len - 1 | 0)(b))(function(lastChar) {
          var $15 = lastChar === charN || lastChar === charR;
          if ($15) {
            return unsafeFreeze5(slice6(0)(len - 1 | 0)(b));
          }
          ;
          return unsafeFreeze5(b);
        });
      }
      ;
      return bind59(read7(UInt8.value)(len - 1 | 0)(b))(function(lastChar) {
        return bind59(read7(UInt8.value)(len - 2 | 0)(b))(function(sndLastChar) {
          var $16 = lastChar === charN && sndLastChar === charR;
          if ($16) {
            return unsafeFreeze5(slice6(0)(len - 2 | 0)(b));
          }
          ;
          var $17 = lastChar === charN || lastChar === charR;
          if ($17) {
            return unsafeFreeze5(slice6(0)(len - 1 | 0)(b));
          }
          ;
          return unsafeFreeze5(b);
        });
      });
    });
  };
};

// output/Node.Library.HumanSignals/foreign.js
import { constants as constants3 } from "os";

// output/Node.Library.HumanSignals/index.js
var identity25 = /* @__PURE__ */ identity(categoryFn);
var eq21 = /* @__PURE__ */ eq(/* @__PURE__ */ eqMaybe(eqInt));
var eq111 = /* @__PURE__ */ eq(eqInt);
var insert10 = /* @__PURE__ */ insert3(ordInt);
var alt22 = /* @__PURE__ */ alt(altMaybe);
var Terminate = /* @__PURE__ */ function() {
  function Terminate2() {
  }
  ;
  Terminate2.value = new Terminate2();
  return Terminate2;
}();
var Core = /* @__PURE__ */ function() {
  function Core2() {
  }
  ;
  Core2.value = new Core2();
  return Core2;
}();
var Ignore2 = /* @__PURE__ */ function() {
  function Ignore3() {
  }
  ;
  Ignore3.value = new Ignore3();
  return Ignore3;
}();
var Pause = /* @__PURE__ */ function() {
  function Pause2() {
  }
  ;
  Pause2.value = new Pause2();
  return Pause2;
}();
var Unpause = /* @__PURE__ */ function() {
  function Unpause2() {
  }
  ;
  Unpause2.value = new Unpause2();
  return Unpause2;
}();
var Ansi = /* @__PURE__ */ function() {
  function Ansi2() {
  }
  ;
  Ansi2.value = new Ansi2();
  return Ansi2;
}();
var Posix = /* @__PURE__ */ function() {
  function Posix2() {
  }
  ;
  Posix2.value = new Posix2();
  return Posix2;
}();
var Bsd = /* @__PURE__ */ function() {
  function Bsd2() {
  }
  ;
  Bsd2.value = new Bsd2();
  return Bsd2;
}();
var Systemv = /* @__PURE__ */ function() {
  function Systemv2() {
  }
  ;
  Systemv2.value = new Systemv2();
  return Systemv2;
}();
var Other = /* @__PURE__ */ function() {
  function Other2() {
  }
  ;
  Other2.value = new Other2();
  return Other2;
}();
var signals2 = /* @__PURE__ */ function() {
  var normalizeSignal = function(v) {
    var mbConstantSignal = lookup2(v.name)(constants3.signals);
    return {
      name: v.name,
      number: fromMaybe(v.number)(mbConstantSignal),
      description: v.description,
      supported: isJust(mbConstantSignal),
      action: v.action,
      standard: v.standard,
      forced: v.forced
    };
  };
  var byName = {
    SIGHUP: normalizeSignal({
      name: "SIGHUP",
      number: 1,
      action: Terminate.value,
      description: "Terminal closed",
      standard: Posix.value,
      forced: false
    }),
    SIGINT: normalizeSignal({
      name: "SIGINT",
      number: 2,
      action: Terminate.value,
      description: "User interruption with CTRL-C",
      standard: Ansi.value,
      forced: false
    }),
    SIGQUIT: normalizeSignal({
      name: "SIGQUIT",
      number: 3,
      action: Core.value,
      description: "User interruption with CTRL-\\",
      standard: Posix.value,
      forced: false
    }),
    SIGILL: normalizeSignal({
      name: "SIGILL",
      number: 4,
      action: Core.value,
      description: "Invalid machine instruction",
      standard: Ansi.value,
      forced: false
    }),
    SIGTRAP: normalizeSignal({
      name: "SIGTRAP",
      number: 5,
      action: Core.value,
      description: "Debugger breakpoint",
      standard: Posix.value,
      forced: false
    }),
    SIGABRT: normalizeSignal({
      name: "SIGABRT",
      number: 6,
      action: Core.value,
      description: "Aborted",
      standard: Ansi.value,
      forced: false
    }),
    SIGIOT: normalizeSignal({
      name: "SIGIOT",
      number: 6,
      action: Core.value,
      description: "Aborted",
      standard: Bsd.value,
      forced: false
    }),
    SIGBUS: normalizeSignal({
      name: "SIGBUS",
      number: 7,
      action: Core.value,
      description: "Bus error due to misaligned, non-existing address or paging error",
      standard: Bsd.value,
      forced: false
    }),
    SIGEMT: normalizeSignal({
      name: "SIGEMT",
      number: 7,
      action: Terminate.value,
      description: "Command should be emulated but is not implemented",
      standard: Other.value,
      forced: false
    }),
    SIGFPE: normalizeSignal({
      name: "SIGFPE",
      number: 8,
      action: Core.value,
      description: "Floating point arithmetic error",
      standard: Ansi.value,
      forced: false
    }),
    SIGKILL: normalizeSignal({
      name: "SIGKILL",
      number: 9,
      action: Terminate.value,
      description: "Forced termination",
      standard: Posix.value,
      forced: true
    }),
    SIGUSR1: normalizeSignal({
      name: "SIGUSR1",
      number: 10,
      action: Terminate.value,
      description: "Application-specific signal",
      standard: Posix.value,
      forced: false
    }),
    SIGSEGV: normalizeSignal({
      name: "SIGSEGV",
      number: 11,
      action: Core.value,
      description: "Segmentation fault",
      standard: Ansi.value,
      forced: false
    }),
    SIGUSR2: normalizeSignal({
      name: "SIGUSR2",
      number: 12,
      action: Terminate.value,
      description: "Application-specific signal",
      standard: Posix.value,
      forced: false
    }),
    SIGPIPE: normalizeSignal({
      name: "SIGPIPE",
      number: 13,
      action: Terminate.value,
      description: "Broken pipe or socket",
      standard: Posix.value,
      forced: false
    }),
    SIGALRM: normalizeSignal({
      name: "SIGALRM",
      number: 14,
      action: Terminate.value,
      description: "Timeout or timer",
      standard: Posix.value,
      forced: false
    }),
    SIGTERM: normalizeSignal({
      name: "SIGTERM",
      number: 15,
      action: Terminate.value,
      description: "Termination",
      standard: Ansi.value,
      forced: false
    }),
    SIGSTKFLT: normalizeSignal({
      name: "SIGSTKFLT",
      number: 16,
      action: Terminate.value,
      description: "Stack is empty or overflowed",
      standard: Other.value,
      forced: false
    }),
    SIGCHLD: normalizeSignal({
      name: "SIGCHLD",
      number: 17,
      action: Ignore2.value,
      description: "Child process terminated, paused or unpaused",
      standard: Posix.value,
      forced: false
    }),
    SIGCLD: normalizeSignal({
      name: "SIGCLD",
      number: 17,
      action: Ignore2.value,
      description: "Child process terminated, paused or unpaused",
      standard: Other.value,
      forced: false
    }),
    SIGCONT: normalizeSignal({
      name: "SIGCONT",
      number: 18,
      action: Unpause.value,
      description: "Unpaused",
      standard: Posix.value,
      forced: true
    }),
    SIGSTOP: normalizeSignal({
      name: "SIGSTOP",
      number: 19,
      action: Pause.value,
      description: "Paused",
      standard: Posix.value,
      forced: true
    }),
    SIGTSTP: normalizeSignal({
      name: "SIGTSTP",
      number: 20,
      action: Pause.value,
      description: 'Paused using CTRL-Z or "suspend"',
      standard: Posix.value,
      forced: false
    }),
    SIGTTIN: normalizeSignal({
      name: "SIGTTIN",
      number: 21,
      action: Pause.value,
      description: "Background process cannot read terminal input",
      standard: Posix.value,
      forced: false
    }),
    SIGBREAK: normalizeSignal({
      name: "SIGBREAK",
      number: 21,
      action: Terminate.value,
      description: "User interruption with CTRL-BREAK",
      standard: Other.value,
      forced: false
    }),
    SIGTTOU: normalizeSignal({
      name: "SIGTTOU",
      number: 22,
      action: Pause.value,
      description: "Background process cannot write to terminal output",
      standard: Posix.value,
      forced: false
    }),
    SIGURG: normalizeSignal({
      name: "SIGURG",
      number: 23,
      action: Ignore2.value,
      description: "Socket received out-of-band data",
      standard: Bsd.value,
      forced: false
    }),
    SIGXCPU: normalizeSignal({
      name: "SIGXCPU",
      number: 24,
      action: Core.value,
      description: "Process timed out",
      standard: Bsd.value,
      forced: false
    }),
    SIGXFSZ: normalizeSignal({
      name: "SIGXFSZ",
      number: 25,
      action: Core.value,
      description: "File too big",
      standard: Bsd.value,
      forced: false
    }),
    SIGVTALRM: normalizeSignal({
      name: "SIGVTALRM",
      number: 26,
      action: Terminate.value,
      description: "Timeout or timer",
      standard: Bsd.value,
      forced: false
    }),
    SIGPROF: normalizeSignal({
      name: "SIGPROF",
      number: 27,
      action: Terminate.value,
      description: "Timeout or timer",
      standard: Bsd.value,
      forced: false
    }),
    SIGWINCH: normalizeSignal({
      name: "SIGWINCH",
      number: 28,
      action: Ignore2.value,
      description: "Terminal window size changed",
      standard: Bsd.value,
      forced: false
    }),
    SIGIO: normalizeSignal({
      name: "SIGIO",
      number: 29,
      action: Terminate.value,
      description: "I/O is available",
      standard: Other.value,
      forced: false
    }),
    SIGPOLL: normalizeSignal({
      name: "SIGPOLL",
      number: 29,
      action: Terminate.value,
      description: "Watched event",
      standard: Other.value,
      forced: false
    }),
    SIGINFO: normalizeSignal({
      name: "SIGINFO",
      number: 29,
      action: Ignore2.value,
      description: "Request for process information",
      standard: Other.value,
      forced: false
    }),
    SIGPWR: normalizeSignal({
      name: "SIGPWR",
      number: 30,
      action: Terminate.value,
      description: "Device running out of power",
      standard: Systemv.value,
      forced: false
    }),
    SIGSYS: normalizeSignal({
      name: "SIGSYS",
      number: 31,
      action: Core.value,
      description: "Invalid system call",
      standard: Other.value,
      forced: false
    }),
    SIGUNUSED: normalizeSignal({
      name: "SIGUNUSED",
      number: 31,
      action: Terminate.value,
      description: "Invalid system call",
      standard: Other.value,
      forced: false
    }),
    SIGRT1: normalizeSignal({
      name: "SIGRT1",
      number: 34,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT2: normalizeSignal({
      name: "SIGRT2",
      number: 35,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT3: normalizeSignal({
      name: "SIGRT3",
      number: 36,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT4: normalizeSignal({
      name: "SIGRT4",
      number: 37,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT5: normalizeSignal({
      name: "SIGRT5",
      number: 38,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT6: normalizeSignal({
      name: "SIGRT6",
      number: 39,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT7: normalizeSignal({
      name: "SIGRT7",
      number: 40,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT8: normalizeSignal({
      name: "SIGRT8",
      number: 41,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT9: normalizeSignal({
      name: "SIGRT9",
      number: 42,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT10: normalizeSignal({
      name: "SIGRT10",
      number: 43,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT11: normalizeSignal({
      name: "SIGRT11",
      number: 44,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT12: normalizeSignal({
      name: "SIGRT12",
      number: 45,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT13: normalizeSignal({
      name: "SIGRT13",
      number: 46,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT14: normalizeSignal({
      name: "SIGRT14",
      number: 47,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT15: normalizeSignal({
      name: "SIGRT15",
      number: 48,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT16: normalizeSignal({
      name: "SIGRT16",
      number: 49,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT17: normalizeSignal({
      name: "SIGRT17",
      number: 50,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT18: normalizeSignal({
      name: "SIGRT18",
      number: 51,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT19: normalizeSignal({
      name: "SIGRT19",
      number: 52,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT20: normalizeSignal({
      name: "SIGRT20",
      number: 53,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT21: normalizeSignal({
      name: "SIGRT21",
      number: 54,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT22: normalizeSignal({
      name: "SIGRT22",
      number: 55,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT23: normalizeSignal({
      name: "SIGRT23",
      number: 56,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT24: normalizeSignal({
      name: "SIGRT24",
      number: 57,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT25: normalizeSignal({
      name: "SIGRT25",
      number: 58,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT26: normalizeSignal({
      name: "SIGRT26",
      number: 59,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT27: normalizeSignal({
      name: "SIGRT27",
      number: 60,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT28: normalizeSignal({
      name: "SIGRT28",
      number: 61,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT29: normalizeSignal({
      name: "SIGRT29",
      number: 62,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT30: normalizeSignal({
      name: "SIGRT30",
      number: 63,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    }),
    SIGRT31: normalizeSignal({
      name: "SIGRT31",
      number: 64,
      action: Terminate.value,
      description: "Application-specific signal (realtime)",
      standard: Posix.value,
      forced: false
    })
  };
  var byString = fromHomogeneous()(byName);
  var signalsArray = toArrayWithKey(function(v) {
    return identity25;
  })(byString);
  var byNumber = flip(foldl2)(empty3)(function(acc) {
    return function(number2) {
      var byOsConstant = find2(function(v) {
        return eq21(new Just(number2))(lookup2(v.name)(constants3.signals));
      })(signalsArray);
      var byDefinedNumber = find2(function() {
        var $110 = eq111(number2);
        return function($111) {
          return $110(function(v) {
            return v.number;
          }($111));
        };
      }())(signalsArray);
      return maybe(acc)(function(sig) {
        return insert10(number2)(sig)(acc);
      })(alt22(byOsConstant)(byDefinedNumber));
    };
  })(range(0)(64));
  return {
    byName,
    byNumber,
    byString
  };
}();

// output/Node.Library.Execa/index.js
var append24 = /* @__PURE__ */ append(semigroupArray);
var map59 = /* @__PURE__ */ map(functorEffect);
var bind33 = /* @__PURE__ */ bind(bindMaybe);
var map120 = /* @__PURE__ */ map(functorMaybe);
var lookup6 = /* @__PURE__ */ lookup3(ordInt);
var append111 = /* @__PURE__ */ append(semigroupString);
var show24 = /* @__PURE__ */ show(showInt);
var show110 = /* @__PURE__ */ show(/* @__PURE__ */ showEither(showInt)(showString));
var show25 = /* @__PURE__ */ show(showNumber);
var bindFlipped8 = /* @__PURE__ */ bindFlipped(bindMaybe);
var intercalate9 = /* @__PURE__ */ intercalate2(monoidString);
var alt23 = /* @__PURE__ */ alt(altMaybe);
var bind115 = /* @__PURE__ */ bind(bindEffect);
var unsafeThaw4 = /* @__PURE__ */ unsafeThaw2(mutableBufferEffect);
var stripFinalNewlineBuf2 = /* @__PURE__ */ stripFinalNewlineBuf(mutableBufferEffect);
var pure48 = /* @__PURE__ */ pure(applicativeEffect);
var intercalate12 = /* @__PURE__ */ intercalate(foldableNonEmptyList)(monoidString);
var map213 = /* @__PURE__ */ map(functorNonEmptyList);
var identity26 = /* @__PURE__ */ identity(categoryFn);
var alt110 = /* @__PURE__ */ alt(/* @__PURE__ */ altExceptT(semigroupNonEmptyList)(monadIdentity));
var map310 = /* @__PURE__ */ map(/* @__PURE__ */ functorExceptT(functorIdentity));
var readInt2 = /* @__PURE__ */ readInt(monadIdentity);
var readString6 = /* @__PURE__ */ readString(monadIdentity);
var eq25 = /* @__PURE__ */ eq(eqString);
var discard11 = /* @__PURE__ */ discard(discardUnit);
var discard12 = /* @__PURE__ */ discard11(bindMaybe);
var guard8 = /* @__PURE__ */ guard2(alternativeMaybe);
var for_4 = /* @__PURE__ */ for_(applicativeEffect)(foldableMaybe);
var $$void14 = /* @__PURE__ */ $$void(functorEffect);
var map410 = /* @__PURE__ */ map(functorArray);
var bind210 = /* @__PURE__ */ bind(bindAff);
var liftEffect1 = /* @__PURE__ */ liftEffect(monadEffectAff);
var parOneOf2 = /* @__PURE__ */ parOneOf(parallelAff)(alternativeParAff)(foldableArray)(functorArray);
var pure116 = /* @__PURE__ */ pure(applicativeAff);
var sequence_2 = /* @__PURE__ */ sequence_(applicativeEffect)(foldableMaybe);
var discard32 = /* @__PURE__ */ discard11(bindAff);
var when7 = /* @__PURE__ */ when(applicativeEffect);
var apply17 = /* @__PURE__ */ apply2(applyAff);
var map510 = /* @__PURE__ */ map(functorAff);
var choiceForget2 = /* @__PURE__ */ choiceForget(monoidFirst);
var is2 = /* @__PURE__ */ is(heytingAlgebraBoolean);
var fromString9 = /* @__PURE__ */ fromString7(monadEffect);
var mempty11 = /* @__PURE__ */ mempty(/* @__PURE__ */ monoidFn(/* @__PURE__ */ monoidEffect(monoidUnit)));
var SerializeJson = /* @__PURE__ */ function() {
  function SerializeJson2() {
  }
  ;
  SerializeJson2.value = new SerializeJson2();
  return SerializeJson2;
}();
var SerializeAdvanced = /* @__PURE__ */ function() {
  function SerializeAdvanced2() {
  }
  ;
  SerializeAdvanced2.value = new SerializeAdvanced2();
  return SerializeAdvanced2;
}();
var ExitCode = /* @__PURE__ */ function() {
  function ExitCode2(value0) {
    this.value0 = value0;
  }
  ;
  ExitCode2.create = function(value0) {
    return new ExitCode2(value0);
  };
  return ExitCode2;
}();
var Killed = /* @__PURE__ */ function() {
  function Killed2(value0) {
    this.value0 = value0;
  }
  ;
  Killed2.create = function(value0) {
    return new Killed2(value0);
  };
  return Killed2;
}();
var SpawnError = /* @__PURE__ */ function() {
  function SpawnError2(value0) {
    this.value0 = value0;
  }
  ;
  SpawnError2.create = function(value0) {
    return new SpawnError2(value0);
  };
  return SpawnError2;
}();
var StdinError = /* @__PURE__ */ function() {
  function StdinError2(value0) {
    this.value0 = value0;
  }
  ;
  StdinError2.create = function(value0) {
    return new StdinError2(value0);
  };
  return StdinError2;
}();
var TimedOut = /* @__PURE__ */ function() {
  function TimedOut2(value0) {
    this.value0 = value0;
  }
  ;
  TimedOut2.create = function(value0) {
    return new TimedOut2(value0);
  };
  return TimedOut2;
}();
var unref = function(cp) {
  return function() {
    return unrefImpl(cp);
  };
};
var toJsSerialization = function(v) {
  if (v instanceof SerializeJson) {
    return "json";
  }
  ;
  if (v instanceof SerializeAdvanced) {
    return "advanced";
  }
  ;
  throw new Error("Failed pattern match at Node.Library.Execa (line 1112, column 21 - line 1114, column 34): " + [v.constructor.name]);
};
var stringKillSignal = unsafeCoerce2;
var stdio = function(cp) {
  return function() {
    return stdioImpl(cp);
  };
};
var spawn2 = function(cmd) {
  return function(args) {
    return function(options) {
      var pipe2 = unsafeToForeign("pipe");
      var ipc = unsafeToForeign("ipc");
      return function() {
        return spawn(cmd, args, {
          cwd: fromMaybe(_undefined2)(options.cwd),
          env: fromMaybe(_undefined2)(options.env),
          argv0: fromMaybe(_undefined2)(options.argv0),
          detached: fromMaybe(_undefined2)(options.detached),
          uid: fromMaybe(_undefined2)(options.uid),
          gid: fromMaybe(_undefined2)(options.gid),
          serialization: maybe(_undefined2)(toJsSerialization)(options.serialization),
          stdio: append24([pipe2, pipe2, pipe2, ipc])(fromMaybe([])(options.stdioExtra)),
          shell: fromMaybe(_undefined2)(options.shell),
          windowsHide: fromMaybe(_undefined2)(options.windowsHide),
          windowsVerbatimArguments: fromMaybe(_undefined2)(options.windowsVerbatimArguments)
        });
      };
    };
  };
};
var signalCode = function(cp) {
  return map59(toMaybe)(function() {
    return signalCodeImpl(cp);
  });
};
var send = function(cp) {
  return function(msg) {
    return function(handle) {
      return function(buildOptions) {
        return function(cb) {
          var options = buildOptions({
            keepOpen: Nothing.value
          });
          var jsOptions = {
            keepOpen: fromMaybe(_undefined2)(options.keepOpen)
          };
          return function() {
            return sendImpl(cp, msg, handle, jsOptions, cb);
          };
        };
      };
    };
  };
};
var ref = function(cp) {
  return function() {
    return refImpl(cp);
  };
};
var pidExists = function(cp) {
  return function() {
    return pidExistsImpl(cp);
  };
};
var pid2 = function(cp) {
  return map59(toMaybe)(function() {
    return pidImpl(cp);
  });
};
var onSpawn = function(cp) {
  return function(cb) {
    return function() {
      return onSpawnImpl(cp, cb);
    };
  };
};
var onMessage = function(cp) {
  return function(cb) {
    return function() {
      return onMessageImpl(cp, function(a, b) {
        return cb(a)(toMaybe(b))();
      });
    };
  };
};
var onExit3 = function(cp) {
  return function(cb) {
    return function() {
      return onExitImpl(cp, function(e, s) {
        return cb(toMaybe(e))(toMaybe(s))();
      });
    };
  };
};
var onError2 = function(cp) {
  return function(cb) {
    return function() {
      return onErrorImpl(cp, mkEffectFn1(cb));
    };
  };
};
var onDisconnect = function(cp) {
  return function(cb) {
    return function() {
      return onDisconnectImpl(cp, cb);
    };
  };
};
var onClose2 = function(cp) {
  return function(cb) {
    return function() {
      return onCloseImpl(cp, function(a, b) {
        return cb(toMaybe(a))(toMaybe(b))();
      });
    };
  };
};
var noEscapeRegex = /* @__PURE__ */ unsafeRegex("^[\\w.-]+$")(noFlags);
var mkError = function(r) {
  var signalDescription = bind33(r.signal)(function(v) {
    if (v instanceof Left) {
      return map120(function(v1) {
        return v1.description;
      })(lookup6(v.value0)(signals2.byNumber));
    }
    ;
    if (v instanceof Right) {
      return map120(function(v1) {
        return v1.description;
      })(lookup2(v.value0)(signals2.byString));
    }
    ;
    throw new Error("Failed pattern match at Node.Library.Execa (line 832, column 36 - line 834, column 68): " + [v.constructor.name]);
  });
  var errorCode = map120(function(v) {
    return v.code;
  })(r.error);
  var prefix4 = function() {
    var v = function(v1) {
      if (r.isCanceled) {
        return "was canceled";
      }
      ;
      var v2 = function(v3) {
        var v4 = function(v5) {
          var v6 = function(v7) {
            var v8 = function(v9) {
              var v10 = function(v11) {
                var v12 = function(v13) {
                  if (otherwise) {
                    return "failed";
                  }
                  ;
                  throw new Error("Failed pattern match at Node.Library.Execa (line 799, column 1 - line 815, column 16): " + []);
                };
                if (r.stderrErr instanceof Just) {
                  return "had error in `stderr`: " + message(r.stderrErr.value0);
                }
                ;
                return v12(true);
              };
              if (r.stdoutErr instanceof Just) {
                return "had error in `stdout`: " + message(r.stdoutErr.value0);
              }
              ;
              return v10(true);
            };
            if (r.stdinErr instanceof Just) {
              return "had error in `stdin`: " + message(r.stdinErr.value0);
            }
            ;
            return v8(true);
          };
          if (r.exitCode instanceof Just) {
            return "failed with exit code " + show24(r.exitCode.value0);
          }
          ;
          return v6(true);
        };
        if (r.signal instanceof Just) {
          if (signalDescription instanceof Just) {
            return "was killed with " + (show110(r.signal.value0) + (" (" + (signalDescription.value0 + ")")));
          }
          ;
          return v4(true);
        }
        ;
        return v4(true);
      };
      if (errorCode instanceof Just) {
        return "failed with " + errorCode.value0;
      }
      ;
      return v2(true);
    };
    if (r.timedOut) {
      if (r.parsed.options.timeout instanceof Just) {
        return "timed out after " + (show25(r.parsed.options.timeout.value0) + "milliseconds");
      }
      ;
      return v(true);
    }
    ;
    return v(true);
  }();
  var execaMessage = "Command " + (prefix4 + (": " + r.command));
  var shortMessage = execaMessage + maybe("")(append111("\n"))(bindFlipped8(function($219) {
    return toMaybe(function(v) {
      return v.message;
    }($219));
  })(r.error));
  var message2 = intercalate9("\n")([shortMessage, r.stderr, r.stdout]);
  return {
    originalMessage: alt23(bind33(r.error)(function($220) {
      return toMaybe(function(v) {
        return v.message;
      }($220));
    }))(map120(message)(alt23(r.stdinErr)(alt23(r.stdoutErr)(r.stderrErr)))),
    message: message2,
    shortMessage,
    escapedCommand: r.escapedCommand,
    exitCode: r.exitCode,
    signal: r.signal,
    signalDescription,
    stdout: r.stdout,
    stderr: r.stderr,
    failed: true,
    timedOut: r.timedOut,
    isCanceled: r.isCanceled,
    killed: r.killed && !r.timedOut
  };
};
var killed = function(cp) {
  return function() {
    return killedImpl(cp);
  };
};
var kill$prime$prime = function(sig) {
  return function(forceKillAfterTimeout) {
    return function(cp) {
      return function() {
        return killImpl(cp, sig, toNullable(forceKillAfterTimeout));
      };
    };
  };
};
var kill$prime = function(sig) {
  return function(cp) {
    return kill$prime$prime(sig)(Nothing.value)(cp);
  };
};
var kill = /* @__PURE__ */ kill$prime(/* @__PURE__ */ stringKillSignal("SIGTERM"));
var joinCommand = function(file) {
  return function(args) {
    return file + (" " + intercalate9(" ")(args));
  };
};
var intKillSignal = unsafeCoerce2;
var toKillSignal = /* @__PURE__ */ either(intKillSignal)(stringKillSignal);
var handleOutput = function(options) {
  return function(value4) {
    if (options.stripFinalNewline) {
      return bind115(unsafeThaw4(value4))(stripFinalNewlineBuf2);
    }
    ;
    if (otherwise) {
      return pure48(value4);
    }
    ;
    throw new Error("Failed pattern match at Node.Library.Execa (line 663, column 1 - line 663, column 108): " + [options.constructor.name, value4.constructor.name]);
  };
};
var getEnv2 = function(r) {
  return function __do3() {
    var processEnv = getEnv();
    var env3 = function() {
      if (r.extendEnv) {
        return union(r.env)(processEnv);
      }
      ;
      return r.env;
    }();
    if (r.preferLocal instanceof Nothing) {
      return env3;
    }
    ;
    if (r.preferLocal instanceof Just) {
      return npmRunPathEnv(env3)({
        cwd: r.preferLocal.value0.localDir,
        path: defaultNpmRunPathOptions.path,
        execPath: r.preferLocal.value0.execPath
      })();
    }
    ;
    throw new Error("Failed pattern match at Node.Library.Execa (line 90, column 3 - line 94, column 107): " + [r.preferLocal.constructor.name]);
  };
};
var fromKillSignal = function(ks) {
  var renderError2 = function(errs) {
    return unsafeCrashWith("Unexpected kill signal. Value should be String or Int but got these errors: " + intercalate12("; ")(map213(renderForeignError)(errs)));
  };
  return either(renderError2)(identity26)(runExcept(alt110(map310(Left.create)(readInt2(ks)))(map310(Right.create)(readString6(ks)))));
};
var spawnedKill = /* @__PURE__ */ function() {
  var isSigTerm = function(v) {
    if (v instanceof Left) {
      return maybe(false)(function() {
        var $221 = eq25("SIGTERM");
        return function($222) {
          return $221(toUpper(function(v1) {
            return v1.name;
          }($222)));
        };
      }())(lookup6(v.value0)(signals2.byNumber));
    }
    ;
    if (v instanceof Right) {
      return "SIGTERM" === toUpper(v.value0);
    }
    ;
    throw new Error("Failed pattern match at Node.Library.Execa (line 744, column 15 - line 746, column 47): " + [v.constructor.name]);
  };
  return function(killFn, numOrStringSignal, forceKillAfterTimeout) {
    var signal = function() {
      var v = toMaybe(numOrStringSignal);
      if (v instanceof Nothing) {
        return new Right("SIGTERM");
      }
      ;
      if (v instanceof Just) {
        return fromKillSignal(v.value0);
      }
      ;
      throw new Error("Failed pattern match at Node.Library.Execa (line 728, column 14 - line 730, column 47): " + [v.constructor.name]);
    }();
    var killSignalSucceeded = killFn(either(intKillSignal)(stringKillSignal)(signal));
    var mbTimeout = discard12(guard8(isSigTerm(signal)))(function() {
      return discard12(guard8(killSignalSucceeded))(function() {
        return toMaybe(forceKillAfterTimeout);
      });
    });
    for_4(mbTimeout)(function(v) {
      return function __do3() {
        var t = setTimeoutImpl(floor2(v), $$void14(function() {
          return killFn(stringKillSignal("SIGKILL"));
        }));
        return t.unref();
      };
    })();
    return killSignalSucceeded;
  };
}();
var exitCode = function(cp) {
  return map59(toMaybe)(function() {
    return exitCodeImpl(cp);
  });
};
var doubleQuotesregex = /* @__PURE__ */ unsafeRegex('"')(global2);
var getEscapedCommand = function(file) {
  return function(args) {
    var escapeArg = function(arg) {
      if (test(noEscapeRegex)(arg)) {
        return arg;
      }
      ;
      if (otherwise) {
        return '"' + (replace2(doubleQuotesregex)('\\"')(arg) + '"');
      }
      ;
      throw new Error("Failed pattern match at Node.Library.Execa (line 676, column 3 - line 678, column 87): " + [arg.constructor.name]);
    };
    return intercalate9(" ")(map410(escapeArg)(cons(file)(args)));
  };
};
var disconnect = function(cp) {
  return function() {
    return disconnectImpl(cp);
  };
};
var defaultOptions = /* @__PURE__ */ function() {
  return {
    cleanup: true,
    preferLocal: new Just({
      localDir: Nothing.value,
      execPath: Nothing.value
    }),
    stripFinalNewline: true,
    extendEnv: true,
    maxBuffer: toNumber2((1e3 * 1e3 | 0) * 100 | 0),
    encoding: UTF8.value,
    windowsVerbatimArguments: false,
    windowsHide: true,
    windowsEnableCmdEcho: false
  };
}();
var handleArguments = function(file) {
  return function(args) {
    return function(initOptions) {
      return function __do3() {
        var parsed = parse9(file)(args)({
          shell: initOptions.shell,
          env: initOptions.env,
          cwd: initOptions.cwd,
          windowsVerbatimArguments: Nothing.value,
          windowsEnableCmdEcho: fromMaybe(defaultOptions.windowsEnableCmdEcho)(initOptions.windowsEnableCmdEcho)
        })();
        var processCwd = cwd();
        var env3 = getEnv2({
          env: fromMaybe(empty2)(initOptions.env),
          extendEnv: fromMaybe(defaultOptions.extendEnv)(initOptions.extendEnv),
          preferLocal: initOptions.preferLocal
        })();
        var v = function() {
          if (initOptions.timeout instanceof Just && initOptions.timeout.value0.milliseconds > 0) {
            return {
              timeout: new Just(initOptions.timeout.value0.milliseconds),
              killSignal: new Just(initOptions.timeout.value0.killSignal),
              timeoutWithKillSignal: new Just(initOptions.timeout.value0)
            };
          }
          ;
          return {
            timeout: Nothing.value,
            killSignal: Nothing.value,
            timeoutWithKillSignal: Nothing.value
          };
        }();
        var options = {
          cleanup: fromMaybe(defaultOptions.cleanup)(initOptions.cleanup),
          stdioExtra: fromMaybe([])(initOptions.stdioExtra),
          maxBuffer: fromMaybe(defaultOptions.maxBuffer)(initOptions.maxBuffer),
          stripFinalNewline: fromMaybe(defaultOptions.stripFinalNewline)(initOptions.stripFinalNewline),
          cwd: fromMaybe(processCwd)(initOptions.cwd),
          encoding: fromMaybe(defaultOptions.encoding)(initOptions.encoding),
          env: env3,
          argv0: initOptions.argv0,
          detached: fromMaybe(false)(initOptions.detached),
          uid: initOptions.uid,
          gid: initOptions.gid,
          shell: initOptions.shell,
          timeout: v.timeout,
          killSignal: v.killSignal,
          timeoutWithKillSignal: v.timeoutWithKillSignal,
          windowsHide: fromMaybe(defaultOptions.windowsHide)(initOptions.windowsHide),
          windowsVerbatimArguments: fromMaybe(defaultOptions.windowsVerbatimArguments)(parsed.options.windowsVerbatimArguments)
        };
        return {
          file: parsed.command,
          args: parsed.args,
          options,
          parsed
        };
      };
    };
  };
};
var defaultExecaOptions = /* @__PURE__ */ function() {
  return {
    cleanup: Nothing.value,
    preferLocal: Nothing.value,
    stdioExtra: Nothing.value,
    stripFinalNewline: Nothing.value,
    extendEnv: Nothing.value,
    encoding: Nothing.value,
    cwd: Nothing.value,
    env: Nothing.value,
    argv0: Nothing.value,
    detached: Nothing.value,
    uid: Nothing.value,
    gid: Nothing.value,
    shell: Nothing.value,
    timeout: Nothing.value,
    maxBuffer: Nothing.value,
    windowsVerbatimArguments: Nothing.value,
    windowsHide: Nothing.value,
    windowsEnableCmdEcho: Nothing.value
  };
}();
var connected = function(cp) {
  return function() {
    return connectedImpl(cp);
  };
};
var channel = function(cp) {
  return map59(toMaybe)(function() {
    return channelImpl(cp);
  });
};
var _TimedOut = function(dictChoice) {
  return prism(TimedOut.create)(function(v) {
    if (v instanceof TimedOut) {
      return new Right(v.value0);
    }
    ;
    return new Left(v);
  })(dictChoice);
};
var _TimedOut1 = /* @__PURE__ */ _TimedOut(choiceForget2);
var _TimedOut2 = /* @__PURE__ */ _TimedOut(choiceMarket);
var _StdinError = function(dictChoice) {
  return prism(StdinError.create)(function(v) {
    if (v instanceof StdinError) {
      return new Right(v.value0);
    }
    ;
    return new Left(v);
  })(dictChoice);
};
var _StdinError1 = /* @__PURE__ */ _StdinError(choiceForget2);
var _SpawnError = function(dictChoice) {
  return prism(SpawnError.create)(function(v) {
    if (v instanceof SpawnError) {
      return new Right(v.value0);
    }
    ;
    return new Left(v);
  })(dictChoice);
};
var _SpawnError1 = /* @__PURE__ */ _SpawnError(choiceForget2);
var _Killed = function(dictChoice) {
  return prism(Killed.create)(function(v) {
    if (v instanceof Killed) {
      return new Right(v.value0);
    }
    ;
    return new Left(v);
  })(dictChoice);
};
var _Killed1 = /* @__PURE__ */ _Killed(choiceForget2);
var _ExitCode = function(dictChoice) {
  return prism(ExitCode.create)(function(v) {
    if (v instanceof ExitCode) {
      return new Right(v.value0);
    }
    ;
    return new Left(v);
  })(dictChoice);
};
var _ExitCode1 = /* @__PURE__ */ _ExitCode(choiceForget2);
var execa = function(file) {
  return function(args) {
    return function(buildOptions) {
      var options = buildOptions(defaultExecaOptions);
      return bind210(liftEffect1(handleArguments(file)(args)(options)))(function(parsed) {
        var escapedCommand = getEscapedCommand(file)(args);
        var command2 = joinCommand(file)(args);
        return bind210(liftEffect1(spawn2(parsed.file)(parsed.args)({
          cwd: options.cwd,
          env: options.env,
          argv0: options.argv0,
          stdioExtra: options.stdioExtra,
          detached: options.detached,
          uid: options.uid,
          gid: options.gid,
          serialization: Nothing.value,
          shell: options.shell,
          windowsVerbatimArguments: options.windowsVerbatimArguments,
          windowsHide: options.windowsHide
        })))(function(spawned) {
          return bind210(suspendAff(makeAff(function(cb) {
            return function __do3() {
              onExit3(spawned)(function(e) {
                return function(s) {
                  if (e instanceof Just) {
                    return cb(new Right(new ExitCode(e.value0)));
                  }
                  ;
                  if (s instanceof Just) {
                    return cb(new Right(new Killed(fromKillSignal(s.value0))));
                  }
                  ;
                  return unsafeCrashWith("Impossible: either exit code or signal code must be non-null");
                };
              })();
              onError2(spawned)(function(error4) {
                return cb(new Right(new SpawnError(error4)));
              })();
              onError(stdin2(spawned))(function(error4) {
                return cb(new Right(new StdinError(error4)));
              })();
              return nonCanceler;
            };
          })))(function(spawnedFiber) {
            return bind210(suspendAff(function() {
              if (parsed.options.timeoutWithKillSignal instanceof Just) {
                return makeAff(function(cb) {
                  return function __do3() {
                    var tid = setTimeout2(parsed.options.timeoutWithKillSignal.value0.milliseconds)(function __do4() {
                      $$void14(kill$prime$prime(toKillSignal(parsed.options.timeoutWithKillSignal.value0.killSignal))(Nothing.value)(spawned))();
                      $$void14(destroy(stdin2(spawned)))();
                      $$void14(destroy(stdout2(spawned)))();
                      $$void14(destroy(stderr2(spawned)))();
                      return cb(new Right(new TimedOut(parsed.options.timeoutWithKillSignal.value0.killSignal)))();
                    })();
                    return effectCanceler(clearTimeout2(tid));
                  };
                });
              }
              ;
              return never;
            }()))(function(timeoutFiber) {
              return bind210(suspendAff(parOneOf2([joinFiber(spawnedFiber), joinFiber(timeoutFiber)])))(function(mainFiber) {
                return bind210(function() {
                  var $210 = !parsed.options.cleanup || parsed.options.detached;
                  if ($210) {
                    return pure116(mainFiber);
                  }
                  ;
                  return suspendAff(bind210(liftEffect1($$new(Nothing.value)))(function(removeHandlerRef) {
                    return $$finally(liftEffect1(bind115(read(removeHandlerRef))(sequence_2)))(discard32(liftEffect1(function __do3() {
                      var removal = onExit2(function(v) {
                        return function(v1) {
                          return $$void14(kill$prime$prime(stringKillSignal("SIGTERM"))(Nothing.value)(spawned));
                        };
                      })();
                      return write(new Just(removal))(removeHandlerRef)();
                    }))(function() {
                      return joinFiber(mainFiber);
                    }));
                  }));
                }())(function(processDoneFiber) {
                  return discard32(liftEffect1(function() {
                    return monkeyPatchKill(spawned, spawnedKill);
                  }))(function() {
                    return bind210(liftEffect1($$new(false)))(function(isCanceledRef) {
                      var cancel = liftEffect1(function __do3() {
                        var killSucceeded = kill(spawned)();
                        return when7(killSucceeded)(write(true)(isCanceledRef))();
                      });
                      var bufferToString = toString5(parsed.options.encoding);
                      var mkStdIoFiber = function(stream3) {
                        return forkAff(bind210(getStreamBuffer(stream3)({
                          maxBuffer: new Just(parsed.options.maxBuffer)
                        }))(function(streamResult) {
                          return bind210(liftEffect1(function __do3() {
                            var text3 = map59(bufferToString)(handleOutput({
                              stripFinalNewline: parsed.options.stripFinalNewline
                            })(streamResult.buffer))();
                            when7(isJust(streamResult.inputError))(destroy(stream3))();
                            return text3;
                          }))(function(text3) {
                            return pure116({
                              text: text3,
                              error: streamResult.inputError
                            });
                          });
                        }));
                      };
                      return bind210(forkAff(joinFiber(processDoneFiber)))(function(runFiber) {
                        return bind210(mkStdIoFiber(stdout2(spawned)))(function(stdoutFiber) {
                          return bind210(mkStdIoFiber(stderr2(spawned)))(function(stderrFiber) {
                            var getSpawnResult = apply17(apply17(map510(function(v) {
                              return function(v1) {
                                return function(v2) {
                                  return {
                                    main: v,
                                    stdout: v1,
                                    stderr: v2
                                  };
                                };
                              };
                            })(joinFiber(runFiber)))(joinFiber(stdoutFiber)))(joinFiber(stderrFiber));
                            return bind210(forkAff(bind210(getSpawnResult)(function(result) {
                              if (result.main instanceof ExitCode && (result.main.value0 === 0 && (result.stdout.error instanceof Nothing && result.stderr.error instanceof Nothing))) {
                                return pure116(new Right({
                                  command: command2,
                                  escapedCommand,
                                  exitCode: 0,
                                  stdout: result.stdout.text,
                                  stderr: result.stderr.text
                                }));
                              }
                              ;
                              return liftEffect1(function __do3() {
                                var isCanceled = read(isCanceledRef)();
                                var killed$prime = killed(spawned)();
                                return new Left(mkError({
                                  error: preview(_SpawnError1)(result.main),
                                  stdinErr: preview(_StdinError1)(result.main),
                                  stdoutErr: result.stdout.error,
                                  stderrErr: result.stderr.error,
                                  exitCode: preview(_ExitCode1)(result.main),
                                  signal: alt23(preview(_Killed1)(result.main))(preview(_TimedOut1)(result.main)),
                                  stdout: result.stdout.text,
                                  stderr: result.stderr.text,
                                  command: command2,
                                  escapedCommand,
                                  parsed,
                                  timedOut: is2(_TimedOut2)(result.main),
                                  isCanceled,
                                  killed: killed$prime
                                }));
                              });
                            })))(function(run13) {
                              return pure116({
                                channel: liftEffect1(channel(spawned)),
                                connected: liftEffect1(connected(spawned)),
                                disconnect: liftEffect1(disconnect(spawned)),
                                exitCode: liftEffect1(exitCode(spawned)),
                                kill: liftEffect1(kill(spawned)),
                                killWithSignal: function(signal) {
                                  return liftEffect1(kill$prime(toKillSignal(signal))(spawned));
                                },
                                killForced: function(forceKillAfterTimeout) {
                                  return liftEffect1(kill$prime$prime(stringKillSignal("SIGTERM"))(new Just(forceKillAfterTimeout))(spawned));
                                },
                                killForcedWithSignal: function(signal) {
                                  return function(forceKillAfterTimeout) {
                                    return liftEffect1(kill$prime$prime(toKillSignal(signal))(new Just(forceKillAfterTimeout))(spawned));
                                  };
                                },
                                pidExists: liftEffect1(pidExists(spawned)),
                                killed: liftEffect1(killed(spawned)),
                                pid: liftEffect1(pid2(spawned)),
                                unref: liftEffect1(unref(spawned)),
                                ref: liftEffect1(ref(spawned)),
                                send: function(foreignData) {
                                  return function(handle) {
                                    return function(mkOptions) {
                                      return function(cb) {
                                        return liftEffect1(send(spawned)(foreignData)(handle)(mkOptions)(cb));
                                      };
                                    };
                                  };
                                },
                                signalCode: liftEffect1(signalCode(spawned)),
                                spawnArgs: spawnArgs(spawned),
                                spawnFile: spawnFile(spawned),
                                onClose: function(cb) {
                                  return liftEffect1(onClose2(spawned)(cb));
                                },
                                onDisconnect: function(cb) {
                                  return liftEffect1(onDisconnect(spawned)(cb));
                                },
                                onError: function(cb) {
                                  return liftEffect1(onError2(spawned)(cb));
                                },
                                onMessage: function(cb) {
                                  return liftEffect1(onMessage(spawned)(cb));
                                },
                                onSpawn: function(cb) {
                                  return liftEffect1(onSpawn(spawned)(cb));
                                },
                                stdin: {
                                  stream: stdin2(spawned),
                                  writeUtf8: function(string7) {
                                    return liftEffect1(function __do3() {
                                      var buf = fromString9(string7)(UTF8.value)();
                                      return $$void14(write5(stdin2(spawned))(buf)(mempty11))();
                                    });
                                  },
                                  writeUtf8End: function(string7) {
                                    return liftEffect1(function __do3() {
                                      var buf = fromString9(string7)(UTF8.value)();
                                      $$void14(write5(stdin2(spawned))(buf)(mempty11))();
                                      return $$void14(end(stdin2(spawned))(mempty11))();
                                    });
                                  },
                                  end: liftEffect1($$void14(end(stdin2(spawned))(mempty11))),
                                  shareParentProcessStdin: liftEffect1($$void14(pipe(stdin)(stdin2(spawned))))
                                },
                                stdout: {
                                  stream: stdout2(spawned),
                                  output: joinFiber(stdoutFiber),
                                  pipeToParentStdout: liftEffect1($$void14(pipe(stdout2(spawned))(stdout)))
                                },
                                stderr: {
                                  stream: stderr2(spawned),
                                  output: joinFiber(stderrFiber),
                                  pipeToParentStderr: liftEffect1($$void14(pipe(stderr2(spawned))(stderr)))
                                },
                                stdio: liftEffect1(stdio(spawned)),
                                cancel,
                                result: joinFiber(run13)
                              });
                            });
                          });
                        });
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    };
  };
};

// output/Spago.Cmd/index.js
var bind34 = /* @__PURE__ */ bind(bindAff);
var discard13 = /* @__PURE__ */ discard(discardUnit)(bindAff);
var pure49 = /* @__PURE__ */ pure(applicativeAff);
var when8 = /* @__PURE__ */ when(applicativeAff);
var StdinPipeParent = /* @__PURE__ */ function() {
  function StdinPipeParent2() {
  }
  ;
  StdinPipeParent2.value = new StdinPipeParent2();
  return StdinPipeParent2;
}();
var StdinNewPipe = /* @__PURE__ */ function() {
  function StdinNewPipe2() {
  }
  ;
  StdinNewPipe2.value = new StdinNewPipe2();
  return StdinNewPipe2;
}();
var StdinWrite = /* @__PURE__ */ function() {
  function StdinWrite2(value0) {
    this.value0 = value0;
  }
  ;
  StdinWrite2.create = function(value0) {
    return new StdinWrite2(value0);
  };
  return StdinWrite2;
}();
var spawn3 = function(dictMonadAff) {
  var liftAff1 = liftAff(dictMonadAff);
  return function(cmd) {
    return function(args) {
      return function(opts) {
        return liftAff1(bind34(execa(cmd)(args)(function(v) {
          return {
            cleanup: v.cleanup,
            preferLocal: v.preferLocal,
            stripFinalNewline: v.stripFinalNewline,
            extendEnv: v.extendEnv,
            cwd: opts.cwd,
            env: v.env,
            encoding: v.encoding,
            argv0: v.argv0,
            stdioExtra: v.stdioExtra,
            detached: v.detached,
            uid: v.uid,
            gid: v.gid,
            shell: v.shell,
            timeout: v.timeout,
            maxBuffer: v.maxBuffer,
            windowsVerbatimArguments: v.windowsVerbatimArguments,
            windowsHide: v.windowsHide,
            windowsEnableCmdEcho: v.windowsEnableCmdEcho
          };
        }))(function(subprocess) {
          return discard13(function() {
            if (opts.pipeStdin instanceof StdinPipeParent) {
              return subprocess.stdin.shareParentProcessStdin;
            }
            ;
            if (opts.pipeStdin instanceof StdinWrite) {
              return subprocess.stdin.writeUtf8End(opts.pipeStdin.value0);
            }
            ;
            return pure49(unit);
          }())(function() {
            return discard13(when8(opts.pipeStderr)(subprocess.stderr.pipeToParentStderr))(function() {
              return discard13(when8(opts.pipeStdout)(subprocess.stdout.pipeToParentStdout))(function() {
                return pure49(subprocess);
              });
            });
          });
        }));
      };
    };
  };
};
var spawn1 = /* @__PURE__ */ spawn3(monadAffAff);
var findFlag = function($copy_v) {
  var $tco_done = false;
  var $tco_result;
  function $tco_loop(v) {
    var words4 = split(" ");
    var splitOnEqual = split("=");
    var isFlag = function(word) {
      return isJust(find2(function(v12) {
        return v12 === word;
      })(v.flags));
    };
    var hasFlag2 = function(a) {
      var firstWord = fromMaybe("")(function() {
        var v12 = uncons(words4(a));
        if (v12 instanceof Just) {
          if (v12.value0.tail.length === 0) {
            var v22 = uncons(splitOnEqual(v12.value0.head));
            if (v22 instanceof Just) {
              return new Just(v22.value0.head);
            }
            ;
            return Nothing.value;
          }
          ;
          return new Just(v12.value0.head);
        }
        ;
        return Nothing.value;
      }());
      return isJust(find2(function(v12) {
        return v12 === firstWord;
      })(v.flags));
    };
    var v1 = uncons(v.args);
    if (v1 instanceof Just) {
      var $65 = isFlag(v1.value0.head);
      if ($65) {
        var v2 = uncons(v1.value0.tail);
        if (v2 instanceof Just) {
          $tco_done = true;
          return new Just(v2.value0.head);
        }
        ;
        $tco_done = true;
        return Nothing.value;
      }
      ;
      var $69 = hasFlag2(v1.value0.head);
      if ($69) {
        var v2 = words4(v1.value0.head);
        if (v2.length === 1) {
          var v3 = splitOnEqual(v2[0]);
          if (v3.length === 2) {
            $tco_done = true;
            return new Just(v3[1]);
          }
          ;
          $tco_done = true;
          return Nothing.value;
        }
        ;
        if (v2.length === 3) {
          $tco_done = true;
          return new Just(v2[1]);
        }
        ;
        $tco_done = true;
        return Nothing.value;
      }
      ;
      $copy_v = {
        flags: v.flags,
        args: v1.value0.tail
      };
      return;
    }
    ;
    $tco_done = true;
    return Nothing.value;
  }
  ;
  while (!$tco_done) {
    $tco_result = $tco_loop($copy_v);
  }
  ;
  return $tco_result;
};
var exec = function(dictMonadAff) {
  var liftAff1 = liftAff(dictMonadAff);
  return function(cmd) {
    return function(args) {
      return function(opts) {
        return liftAff1(bind34(spawn1(cmd)(args)(opts))(function(subprocess) {
          return subprocess.result;
        }));
      };
    };
  };
};
var defaultExecOptions = /* @__PURE__ */ function() {
  return {
    pipeStdin: StdinNewPipe.value,
    pipeStdout: true,
    pipeStderr: true,
    cwd: Nothing.value
  };
}();

// output/Spago.Git/index.js
var bind35 = /* @__PURE__ */ bind(bindSpago);
var ask3 = /* @__PURE__ */ ask(monadAskSpago);
var exec2 = /* @__PURE__ */ exec(monadAffSpago);
var pure50 = /* @__PURE__ */ pure(applicativeSpago);
var toDoc3 = /* @__PURE__ */ toDoc2(loggableString);
var bimap3 = /* @__PURE__ */ bimap(bifunctorEither);
var $$void15 = /* @__PURE__ */ $$void(/* @__PURE__ */ functorExceptT(functorSpago));
var loggableArray2 = /* @__PURE__ */ loggableArray(loggableString);
var toDoc12 = /* @__PURE__ */ toDoc2(loggableArray2);
var liftEffect5 = /* @__PURE__ */ liftEffect(monadEffectSpago);
var getInBetweenPaths2 = /* @__PURE__ */ getInBetweenPaths(monadEffectEffect);
var map60 = /* @__PURE__ */ map(functorSpago);
var identity27 = /* @__PURE__ */ identity(categoryFn);
var traverse7 = /* @__PURE__ */ traverse(traversableArray)(applicativeSpago);
var isLink2 = /* @__PURE__ */ isLink(monadEffectSpago);
var discard14 = /* @__PURE__ */ discard(discardUnit);
var discard15 = /* @__PURE__ */ discard14(bindSpago);
var logDebug3 = /* @__PURE__ */ logDebug(monadEffectSpago)(monadAskSpago)(loggableString);
var showRecord2 = /* @__PURE__ */ showRecord()();
var showRecordFieldsCons2 = /* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "escapedCommand";
  }
});
var showRecordFieldsCons1 = /* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "exitCode";
  }
});
var showRecordFieldsCons22 = /* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "stderr";
  }
});
var stdoutIsSymbol = {
  reflectSymbol: function() {
    return "stdout";
  }
};
var showMaybe2 = /* @__PURE__ */ showMaybe(showString);
var showRecord1 = /* @__PURE__ */ showRecord2(/* @__PURE__ */ showRecordFieldsCons2(/* @__PURE__ */ showRecordFieldsCons1(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "failed";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "isCanceled";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "killed";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "message";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "originalMessage";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "shortMessage";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "signal";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "signalDescription";
  }
})(/* @__PURE__ */ showRecordFieldsCons22(/* @__PURE__ */ showRecordFieldsCons(stdoutIsSymbol)(/* @__PURE__ */ showRecordFieldsConsNil({
  reflectSymbol: function() {
    return "timedOut";
  }
})(showBoolean))(showString))(showString))(showMaybe2))(/* @__PURE__ */ showMaybe(/* @__PURE__ */ showEither(showInt)(showString))))(showString))(showMaybe2))(showString))(showBoolean))(showBoolean))(showBoolean))(/* @__PURE__ */ showMaybe(showInt)))(showString));
var show26 = /* @__PURE__ */ show(/* @__PURE__ */ showEither(showRecord1)(/* @__PURE__ */ showRecord2(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "command";
  }
})(/* @__PURE__ */ showRecordFieldsCons2(/* @__PURE__ */ showRecordFieldsCons1(/* @__PURE__ */ showRecordFieldsCons22(/* @__PURE__ */ showRecordFieldsConsNil(stdoutIsSymbol)(showString))(showString))(showInt))(showString))(showString))));
var show111 = /* @__PURE__ */ show(showRecord1);
var die2 = /* @__PURE__ */ die(monadEffectSpago)(monadAskSpago)(loggableArray2);
var toDoc22 = /* @__PURE__ */ toDoc2(/* @__PURE__ */ loggableArray(loggableDocc));
var exists4 = /* @__PURE__ */ exists2(monadEffectSpago);
var logInfo2 = /* @__PURE__ */ logInfo(monadEffectSpago)(monadAskSpago)(loggableString);
var bindExceptT2 = /* @__PURE__ */ bindExceptT(monadSpago);
var discard22 = /* @__PURE__ */ discard14(bindExceptT2);
var bind211 = /* @__PURE__ */ bind(bindExceptT2);
var tagCheckedOut = function(cwd3) {
  var opts = {
    pipeStdout: false,
    pipeStderr: false,
    cwd: cwd3,
    pipeStdin: defaultExecOptions.pipeStdin
  };
  return bind35(ask3)(function(v) {
    return bind35(exec2(v.git.cmd)(["describe", "--tags"])(opts))(function(v1) {
      if (v1 instanceof Left) {
        return pure50(new Left(toDoc3("The git ref currently checked out is not a tag.")));
      }
      ;
      if (v1 instanceof Right) {
        return pure50(new Right(v1.value0.stdout));
      }
      ;
      throw new Error("Failed pattern match at Spago.Git (line 104, column 54 - line 106, column 43): " + [v1.constructor.name]);
    });
  });
};
var runGit = function(args) {
  return function(cwd3) {
    return bind35(ask3)(function(v) {
      return bind35(exec2(v.git.cmd)(args)({
        pipeStdin: defaultExecOptions.pipeStdin,
        pipeStdout: false,
        pipeStderr: false,
        cwd: cwd3
      }))(function(result) {
        return pure50(bimap3(function(v1) {
          return v1.stderr;
        })(function(v1) {
          return v1.stdout;
        })(result));
      });
    });
  };
};
var runGit_ = function(args) {
  return function(cwd3) {
    return $$void15(runGit(args)(cwd3));
  };
};
var pushTag = function(cwd3) {
  return function(version) {
    var opts = {
      pipeStdout: false,
      pipeStderr: false,
      cwd: cwd3,
      pipeStdin: defaultExecOptions.pipeStdin
    };
    return bind35(ask3)(function(v) {
      return bind35(exec2(v.git.cmd)(["push", "origin", "v" + print3(version)])(opts))(function(v1) {
        if (v1 instanceof Left) {
          return pure50(new Left(toDoc12(["Could not push the tag 'v" + (print3(version) + "' to the remote."), "Error:", v1.value0.shortMessage])));
        }
        ;
        if (v1 instanceof Right) {
          return pure50(new Right(unit));
        }
        ;
        throw new Error("Failed pattern match at Spago.Git (line 112, column 80 - line 118, column 33): " + [v1.constructor.name]);
      });
    });
  };
};
var isIgnored = function(path5) {
  return bind35(ask3)(function(v) {
    return bind35(exec2(v.git.cmd)(["check-ignore", "--quiet", path5])({
      pipeStdin: defaultExecOptions.pipeStdin,
      pipeStdout: false,
      pipeStderr: false,
      cwd: defaultExecOptions.cwd
    }))(function(result) {
      if (result instanceof Right && result.value0.exitCode === 0) {
        return pure50(true);
      }
      ;
      if (result instanceof Left && (result.value0.exitCode instanceof Just && result.value0.exitCode.value0 === 128)) {
        return bind35(liftEffect5(function __do3() {
          var cwd3 = cwd();
          var absolutePath = resolve([])(path5)();
          return getInBetweenPaths2(cwd3)(absolutePath)();
        }))(function(paths2) {
          return map60(any(identity27))(traverse7(isLink2)(paths2));
        });
      }
      ;
      if (result instanceof Left && (result.value0.exitCode instanceof Just && result.value0.exitCode.value0 === 1)) {
        return pure50(false);
      }
      ;
      return discard15(logDebug3("IsIgnored encountered an interesting exitCode"))(function() {
        return discard15(logDebug3(show26(result)))(function() {
          return pure50(false);
        });
      });
    });
  });
};
var getRef = function(cwd3) {
  var opts = {
    pipeStdout: false,
    pipeStderr: false,
    cwd: cwd3,
    pipeStdin: defaultExecOptions.pipeStdin
  };
  return bind35(ask3)(function(v) {
    return bind35(exec2(v.git.cmd)(["rev-parse", "HEAD"])(opts))(function(v1) {
      if (v1 instanceof Left) {
        return pure50(new Left(toDoc12(["Could not run `git rev-parse HEAD` to determine the current ref. Error:", v1.value0.shortMessage])));
      }
      ;
      if (v1 instanceof Right) {
        return pure50(new Right(v1.value0.stdout));
      }
      ;
      throw new Error("Failed pattern match at Spago.Git (line 93, column 53 - line 98, column 43): " + [v1.constructor.name]);
    });
  });
};
var getGit = /* @__PURE__ */ function() {
  return bind35(exec2("git")(["--version"])({
    pipeStdin: defaultExecOptions.pipeStdin,
    pipeStdout: false,
    pipeStderr: false,
    cwd: defaultExecOptions.cwd
  }))(function(v) {
    if (v instanceof Right) {
      return pure50({
        cmd: "git",
        version: v.value0.stdout
      });
    }
    ;
    if (v instanceof Left) {
      return discard15(logDebug3(show111(v.value0)))(function() {
        return die2(["Failed to find git. Have you installed it, and is it in your PATH?"]);
      });
    }
    ;
    throw new Error("Failed pattern match at Spago.Git (line 152, column 104 - line 156, column 83): " + [v.constructor.name]);
  });
}();
var getCleanTag = function(cwd3) {
  var opts = {
    pipeStdout: false,
    pipeStderr: false,
    cwd: cwd3,
    pipeStdin: defaultExecOptions.pipeStdin
  };
  return bind35(ask3)(function(v) {
    return bind35(exec2(v.git.cmd)(["status", "--porcelain"])(opts))(function(v1) {
      if (v1 instanceof Left) {
        return pure50(new Left(toDoc12(["Could not run `git status`. Error:", v1.value0.shortMessage])));
      }
      ;
      if (v1 instanceof Right) {
        if (v1.value0.stdout === "") {
          return tagCheckedOut(cwd3);
        }
        ;
        return pure50(new Left(toDoc22([toDoc3("Git tree is not clean, aborting. Commit or stash these files:"), indent(toDoc12(split("\n")(v1.value0.stdout)))])));
      }
      ;
      throw new Error("Failed pattern match at Spago.Git (line 74, column 57 - line 87, column 12): " + [v1.constructor.name]);
    });
  });
};
var fetchRepo = function(v) {
  return function(path5) {
    return bind35(exists4(path5))(function(repoExists) {
      return bind35(function() {
        if (repoExists) {
          return discard15(logDebug3("Found " + (v.git + " locally, pulling...")))(function() {
            return runExceptT(runGit_(["fetch", "origin"])(new Just(path5)));
          });
        }
        ;
        if (!repoExists) {
          return discard15(logInfo2("Cloning " + v.git))(function() {
            return runExceptT(runGit_(["clone", "--filter=tree:0", v.git, path5])(Nothing.value));
          });
        }
        ;
        throw new Error("Failed pattern match at Spago.Git (line 42, column 25 - line 50, column 84): " + [repoExists.constructor.name]);
      }())(function(cloneOrFetchResult) {
        return bind35(runExceptT(discard22(pure50(cloneOrFetchResult))(function() {
          return bind211(runGit(["checkout", v.ref])(new Just(path5)))(function() {
            return mapExceptT(function(a) {
              return bind35(a)(function(v1) {
                if (v1 instanceof Left) {
                  return pure50(new Right(unit));
                }
                ;
                if (v1 instanceof Right) {
                  return runExceptT(runGit_(["pull", "--rebase", "--autostash"])(new Just(path5)));
                }
                ;
                throw new Error("Failed pattern match at Spago.Git (line 57, column 21 - line 59, column 99): " + [v1.constructor.name]);
              });
            })(runGit_(["symbolic-ref", "-q", "HEAD"])(new Just(path5)));
          });
        })))(function(result) {
          if (result instanceof Left) {
            return die2(["Error while fetching the repo '" + (v.git + ("' at ref '" + (v.ref + "':"))), result.value0]);
          }
          ;
          if (result instanceof Right) {
            return pure50(unit);
          }
          ;
          throw new Error("Failed pattern match at Spago.Git (line 63, column 3 - line 68, column 25): " + [result.constructor.name]);
        });
      });
    });
  };
};

// output/Spago.Lock/index.js
var recordProp2 = /* @__PURE__ */ recordProp({
  reflectSymbol: function() {
    return "path";
  }
})();
var recordProp1 = /* @__PURE__ */ recordProp({
  reflectSymbol: function() {
    return "dependencies";
  }
})();
var recordProp22 = /* @__PURE__ */ recordProp({
  reflectSymbol: function() {
    return "packages";
  }
})();
var bind36 = /* @__PURE__ */ bind(bindEither);
var pure51 = /* @__PURE__ */ pure(applicativeEither);
var typeIsSymbol = {
  reflectSymbol: function() {
    return "type";
  }
};
var insert11 = /* @__PURE__ */ insert5(typeIsSymbol)()();
var $$delete7 = /* @__PURE__ */ $$delete5(typeIsSymbol)()();
var dimap4 = /* @__PURE__ */ dimap(/* @__PURE__ */ profunctorCodec(functorEither));
var recordProp3 = /* @__PURE__ */ recordProp(typeIsSymbol)();
var alt24 = /* @__PURE__ */ alt(altEither);
var map61 = /* @__PURE__ */ map(functorEither);
var FromPath = /* @__PURE__ */ function() {
  function FromPath2(value0) {
    this.value0 = value0;
  }
  ;
  FromPath2.create = function(value0) {
    return new FromPath2(value0);
  };
  return FromPath2;
}();
var FromGit = /* @__PURE__ */ function() {
  function FromGit2(value0) {
    this.value0 = value0;
  }
  ;
  FromGit2.create = function(value0) {
    return new FromGit2(value0);
  };
  return FromGit2;
}();
var FromRegistry = /* @__PURE__ */ function() {
  function FromRegistry2(value0) {
    this.value0 = value0;
  }
  ;
  FromRegistry2.create = function(value0) {
    return new FromRegistry2(value0);
  };
  return FromRegistry2;
}();
var workspaceLockCodec = /* @__PURE__ */ function() {
  var dependenciesCodec2 = object("Dependencies")(recordProp2($$Proxy.value)(string)(recordProp1($$Proxy.value)(dependenciesCodec)(recordProp({
    reflectSymbol: function() {
      return "test_dependencies";
    }
  })()($$Proxy.value)(dependenciesCodec)(record))));
  return object("WorkspaceLock")(recordProp22($$Proxy.value)(packageMap(dependenciesCodec2))(recordPropOptional({
    reflectSymbol: function() {
      return "package_set";
    }
  })()($$Proxy.value)(setAddressCodec)(recordProp({
    reflectSymbol: function() {
      return "extra_packages";
    }
  })()($$Proxy.value)(packageMap(extraPackageCodec))(record))));
}();
var registryLockType = "registry";
var pathLockType = "local";
var gitLockType = "git";
var constant = function(val) {
  var encode3 = encode(string);
  var decode2 = function(json4) {
    return bind36(decode(string)(json4))(function(v) {
      if (v === val) {
        return pure51(val);
      }
      ;
      return new Left(new UnexpectedValue(json4));
    });
  };
  return codec$prime(decode2)(encode3);
};
var gitLockCodec = /* @__PURE__ */ function() {
  var toRep = insert11($$Proxy.value)(gitLockType);
  var fromRep = $$delete7($$Proxy.value);
  return dimap4(toRep)(fromRep)(object("GitLock")(recordProp3($$Proxy.value)(constant(gitLockType))(recordProp({
    reflectSymbol: function() {
      return "url";
    }
  })()($$Proxy.value)(string)(recordProp({
    reflectSymbol: function() {
      return "rev";
    }
  })()($$Proxy.value)(string)(recordPropOptional({
    reflectSymbol: function() {
      return "subdir";
    }
  })()($$Proxy.value)(string)(recordProp1($$Proxy.value)(array(codec2))(record)))))));
}();
var pathLockCodec = /* @__PURE__ */ function() {
  var toRep = insert11($$Proxy.value)(pathLockType);
  var fromRep = $$delete7($$Proxy.value);
  return dimap4(toRep)(fromRep)(object("PathLock")(recordProp3($$Proxy.value)(constant(pathLockType))(recordProp2($$Proxy.value)(string)(recordProp1($$Proxy.value)(array(codec2))(record)))));
}();
var registryLockCodec = /* @__PURE__ */ function() {
  var toRep = insert11($$Proxy.value)(registryLockType);
  var fromRep = $$delete7($$Proxy.value);
  return dimap4(toRep)(fromRep)(object("RegistryLock")(recordProp3($$Proxy.value)(constant(registryLockType))(recordProp({
    reflectSymbol: function() {
      return "version";
    }
  })()($$Proxy.value)(codec3)(recordProp({
    reflectSymbol: function() {
      return "integrity";
    }
  })()($$Proxy.value)(codec9)(recordProp1($$Proxy.value)(array(codec2))(record))))));
}();
var lockEntryCodec = /* @__PURE__ */ function() {
  var encode3 = function(v) {
    if (v instanceof FromPath) {
      return encode(pathLockCodec)(v.value0);
    }
    ;
    if (v instanceof FromGit) {
      return encode(gitLockCodec)(v.value0);
    }
    ;
    if (v instanceof FromRegistry) {
      return encode(registryLockCodec)(v.value0);
    }
    ;
    throw new Error("Failed pattern match at Spago.Lock (line 72, column 12 - line 75, column 58): " + [v.constructor.name]);
  };
  var decode2 = function(json4) {
    return alt24(map61(FromPath.create)(decode(pathLockCodec)(json4)))(alt24(map61(FromGit.create)(decode(gitLockCodec)(json4)))(map61(FromRegistry.create)(decode(registryLockCodec)(json4))));
  };
  return codec$prime(decode2)(encode3);
}();
var lockfileCodec = /* @__PURE__ */ function() {
  return object("Lockfile")(recordProp({
    reflectSymbol: function() {
      return "workspace";
    }
  })()($$Proxy.value)(workspaceLockCodec)(recordProp22($$Proxy.value)(packageMap(lockEntryCodec))(record)));
}();

// node_modules/env-paths/index.js
import path3 from "node:path";
import os2 from "node:os";
import process6 from "node:process";
var homedir = os2.homedir();
var tmpdir = os2.tmpdir();
var { env: env2 } = process6;
var macos = (name4) => {
  const library = path3.join(homedir, "Library");
  return {
    data: path3.join(library, "Application Support", name4),
    config: path3.join(library, "Preferences", name4),
    cache: path3.join(library, "Caches", name4),
    log: path3.join(library, "Logs", name4),
    temp: path3.join(tmpdir, name4)
  };
};
var windows = (name4) => {
  const appData = env2.APPDATA || path3.join(homedir, "AppData", "Roaming");
  const localAppData = env2.LOCALAPPDATA || path3.join(homedir, "AppData", "Local");
  return {
    // Data/config/cache/log are invented by me as Windows isn't opinionated about this
    data: path3.join(localAppData, name4, "Data"),
    config: path3.join(appData, name4, "Config"),
    cache: path3.join(localAppData, name4, "Cache"),
    log: path3.join(localAppData, name4, "Log"),
    temp: path3.join(tmpdir, name4)
  };
};
var linux = (name4) => {
  const username = path3.basename(homedir);
  return {
    data: path3.join(env2.XDG_DATA_HOME || path3.join(homedir, ".local", "share"), name4),
    config: path3.join(env2.XDG_CONFIG_HOME || path3.join(homedir, ".config"), name4),
    cache: path3.join(env2.XDG_CACHE_HOME || path3.join(homedir, ".cache"), name4),
    // https://wiki.debian.org/XDGBaseDirectorySpecification#state
    log: path3.join(env2.XDG_STATE_HOME || path3.join(homedir, ".local", "state"), name4),
    temp: path3.join(tmpdir, username, name4)
  };
};
function envPaths(name4, { suffix: suffix2 = "nodejs" } = {}) {
  if (typeof name4 !== "string") {
    throw new TypeError(`Expected a string, got ${typeof name4}`);
  }
  if (suffix2) {
    name4 += `-${suffix2}`;
  }
  if (process6.platform === "darwin") {
    return macos(name4);
  }
  if (process6.platform === "win32") {
    return windows(name4);
  }
  return linux(name4);
}

// output/Spago.Paths/foreign.js
var paths = envPaths("spago");

// output/Spago.Paths/index.js
var globalCachePath = /* @__PURE__ */ function() {
  return paths.cache;
}();
var registryIndexPath = /* @__PURE__ */ concat2([globalCachePath, "registry-index"]);
var registryPath = /* @__PURE__ */ concat2([globalCachePath, "registry"]);
var cwd2 = /* @__PURE__ */ unsafePerformEffect(cwd);
var localCachePath = /* @__PURE__ */ concat2([cwd2, ".spago"]);
var localCachePackagesPath = /* @__PURE__ */ concat2([localCachePath, "packages"]);
var localCachePersistedWarningsPath = /* @__PURE__ */ concat2([localCachePath, "persisted-warnings"]);
var mkLocalCachesPersistentWarningsFile = function(fileName) {
  return concat2([localCachePersistedWarningsPath, fileName + ".stash"]);
};
var localCachesPersistedWarningsEntireWorkspace = /* @__PURE__ */ mkLocalCachesPersistentWarningsFile("entire-workspace");
var mkRelative = /* @__PURE__ */ relative(cwd2);

// output/Spago.Prelude/foreign.js
import url from "node:url";
var parseUrlImpl = (onError3, onSuccess, rawUrl) => {
  try {
    return onSuccess(new url.URL(rawUrl));
  } catch (err) {
    return onError3(err);
  }
};

// output/Effect.Now/foreign.js
function now2() {
  return Date.now();
}

// output/Spago.Prelude/index.js
var bind37 = /* @__PURE__ */ bind(bindAff);
var pure52 = /* @__PURE__ */ pure(applicativeAff);
var sequential2 = /* @__PURE__ */ sequential(parallelAff);
var oneOf4 = /* @__PURE__ */ oneOf(foldableArray)(plusParAff);
var parallel2 = /* @__PURE__ */ parallel(parallelAff);
var map62 = /* @__PURE__ */ map(functorAff);
var fromString10 = /* @__PURE__ */ fromString5(mutableBufferEffect);
var toString10 = /* @__PURE__ */ toString4(mutableBufferEffect);
var map121 = /* @__PURE__ */ map(functorMaybe);
var map214 = /* @__PURE__ */ map(functorArray);
var bind212 = /* @__PURE__ */ bind(bindSpago);
var ask4 = /* @__PURE__ */ ask(monadAskSpago);
var liftAff3 = /* @__PURE__ */ liftAff(monadAffSpago);
var parSequence2 = /* @__PURE__ */ parSequence(parallelAff)(traversableArray);
var runSpago2 = /* @__PURE__ */ runSpago(monadAffAff);
var for_5 = /* @__PURE__ */ for_(applicativeAff)(foldableArray);
var liftEffect6 = /* @__PURE__ */ liftEffect(monadEffectAff);
var hashString2 = /* @__PURE__ */ hashString(monadEffectEffect);
var show27 = /* @__PURE__ */ show(showInstant);
var withBackoff = function(v) {
  var runTimeout = function(attempt2) {
    return function(ms) {
      return bind37(delay(toNumber2(ms)))(function() {
        return bind37(v.shouldCancel(attempt2))(function(v1) {
          if (v1) {
            return pure52(Nothing.value);
          }
          ;
          return runTimeout(attempt2)(ms * 2 | 0);
        });
      });
    };
  };
  var runAction = function(attempt2) {
    return function(action$prime) {
      return function(ms) {
        return sequential2(oneOf4([parallel2(map62(Just.create)(action$prime)), parallel2(runTimeout(attempt2)(ms))]));
      };
    };
  };
  var loop = function(attempt2) {
    return function(v1) {
      if (v1 instanceof Nothing) {
        return bind37(v.shouldRetry(attempt2))(function(maybeRetry) {
          if (maybeRetry instanceof Nothing) {
            return pure52(Nothing.value);
          }
          ;
          if (maybeRetry instanceof Just) {
            var newTimeout = pow(floor2(v.delay))(attempt2 + 1 | 0);
            return bind37(runAction(attempt2)(maybeRetry.value0)(newTimeout))(function(maybeResult) {
              return loop(attempt2 + 1 | 0)(maybeResult);
            });
          }
          ;
          throw new Error("Failed pattern match at Spago.Prelude (line 126, column 9 - line 131, column 43): " + [maybeRetry.constructor.name]);
        });
      }
      ;
      if (v1 instanceof Just) {
        return pure52(new Just(v1.value0));
      }
      ;
      throw new Error("Failed pattern match at Spago.Prelude (line 123, column 20 - line 133, column 33): " + [v1.constructor.name]);
    };
  };
  return bind37(runAction(0)(v.action)(floor2(v.delay)))(function(maybeResult) {
    return loop(1)(maybeResult);
  });
};
var withBackoff$prime = function(action) {
  return withBackoff({
    delay: 5e3,
    action,
    shouldCancel: function(v) {
      return pure52(true);
    },
    shouldRetry: function(attempt2) {
      var $64 = attempt2 > 3;
      if ($64) {
        return pure52(Nothing.value);
      }
      ;
      return pure52(new Just(action));
    }
  });
};
var unsafeStringify = function(a) {
  return stringify(a);
};
var unsafeFromRight = function(v) {
  return fromRight$prime(function(v1) {
    return unsafeCrashWith("Unexpected Left: " + unsafeStringify(v));
  })(v);
};
var shaToHex = function(s) {
  return function __do3() {
    var v = fromString10(print6(s))(UTF8.value)();
    var string7 = toString10(Hex.value)(v)();
    return string7;
  };
};
var partitionEithers = /* @__PURE__ */ foldMap2(/* @__PURE__ */ monoidRecord()(/* @__PURE__ */ monoidRecordCons({
  reflectSymbol: function() {
    return "fail";
  }
})(monoidArray)()(/* @__PURE__ */ monoidRecordCons({
  reflectSymbol: function() {
    return "success";
  }
})(monoidArray)()(monoidRecordNil))))(function(v) {
  if (v instanceof Left) {
    return {
      fail: [v.value0],
      success: []
    };
  }
  ;
  if (v instanceof Right) {
    return {
      fail: [],
      success: [v.value0]
    };
  }
  ;
  throw new Error("Failed pattern match at Spago.Prelude (line 67, column 34 - line 69, column 53): " + [v.constructor.name]);
});
var parseUrl = /* @__PURE__ */ function() {
  return runFn3(parseUrlImpl)(Left.create)(function($70) {
    return Right.create($70);
  });
}();
var parseLenientVersion = function(input) {
  var maybeIdentity = function(k) {
    return function(x) {
      return fromMaybe(x)(k(x));
    };
  };
  var dropLeadingZeros = function() {
    var $71 = map121(toStringAs(decimal));
    return function($72) {
      return $71(fromString2($72));
    };
  }();
  return parse4(joinWith(".")(map214(maybeIdentity(dropLeadingZeros))(split(".")(maybeIdentity(stripPrefix("v"))(trim(input))))));
};
var parallelise = function(actions) {
  return bind212(ask4)(function(env3) {
    return bind212(liftAff3(parSequence2(map214(function() {
      var $73 = runSpago2(env3);
      return function($74) {
        return forkAff($73($74));
      };
    }())(actions))))(function(fibers) {
      return liftAff3(for_5(fibers)(joinFiber));
    });
  });
};
var mkTemp$prime = function(dictMonadAff) {
  var liftAff1 = liftAff(dictMonadAff);
  return function(maybeSuffix) {
    return liftAff1(bind37(liftEffect6(function __do3() {
      var now3 = now2();
      var sha = hashString2(show27(now3) + fromMaybe("")(maybeSuffix))();
      return shaToHex(sha)();
    }))(function(v) {
      var tempDirPath = concat2([paths.temp, v]);
      return pure52(tempDirPath);
    }));
  };
};
var mkTemp = function(dictMonadAff) {
  return mkTemp$prime(dictMonadAff)(Nothing.value);
};

// output/Spago.Config/index.js
var versionIsSymbol = {
  reflectSymbol: function() {
    return "version";
  }
};
var packagesIsSymbol = {
  reflectSymbol: function() {
    return "packages";
  }
};
var compilerIsSymbol = {
  reflectSymbol: function() {
    return "compiler";
  }
};
var wrapIso2 = /* @__PURE__ */ wrapIso(/* @__PURE__ */ profunctorCodec(functorEither))();
var object6 = /* @__PURE__ */ object2();
var rowListCodecCons5 = /* @__PURE__ */ rowListCodecCons(rowListCodecNil)()();
var bind38 = /* @__PURE__ */ bind(bindSpago);
var liftEffect7 = /* @__PURE__ */ liftEffect(monadEffectSpago);
var discard16 = /* @__PURE__ */ discard(discardUnit)(bindSpago);
var logDebug4 = /* @__PURE__ */ logDebug(monadEffectSpago)(monadAskSpago);
var logDebug1 = /* @__PURE__ */ logDebug4(loggableString);
var exists5 = /* @__PURE__ */ exists2(monadEffectSpago);
var pure53 = /* @__PURE__ */ pure(applicativeSpago);
var liftAff4 = /* @__PURE__ */ liftAff(monadAffSpago);
var hashString3 = /* @__PURE__ */ hashString(monadEffectEffect);
var mkdirp2 = /* @__PURE__ */ mkdirp(monadAffSpago);
var writeTextFile4 = /* @__PURE__ */ writeTextFile3(monadAffSpago);
var toUnfoldable15 = /* @__PURE__ */ toUnfoldable5(unfoldableArray);
var map63 = /* @__PURE__ */ map(functorArray);
var fromFoldable20 = /* @__PURE__ */ fromFoldable6(ordPackageName)(foldableArray);
var logInfo3 = /* @__PURE__ */ logInfo(monadEffectSpago)(monadAskSpago)(loggableString);
var die3 = /* @__PURE__ */ die(monadEffectSpago)(monadAskSpago);
var die1 = /* @__PURE__ */ die3(loggableString);
var eq42 = /* @__PURE__ */ eq(/* @__PURE__ */ eqMaybe(eqBoolean));
var match$prime2 = /* @__PURE__ */ match$prime(monadAffAff)(/* @__PURE__ */ defaultsRecord()());
var map122 = /* @__PURE__ */ map(functorSpago);
var partitionMap3 = /* @__PURE__ */ partitionMap(filterableArray);
var identity28 = /* @__PURE__ */ identity(categoryFn);
var traverse8 = /* @__PURE__ */ traverse(traversableArray)(applicativeSpago);
var unless3 = /* @__PURE__ */ unless(applicativeSpago);
var loggableArray3 = /* @__PURE__ */ loggableArray(loggableDocc);
var logDebug22 = /* @__PURE__ */ logDebug4(loggableArray3);
var toDoc4 = /* @__PURE__ */ toDoc2(loggableString);
var lines4 = /* @__PURE__ */ lines(foldableArray);
var show28 = /* @__PURE__ */ show(/* @__PURE__ */ showArray(showString));
var logWarn2 = /* @__PURE__ */ logWarn(monadEffectSpago)(monadAskSpago);
var loggableArray1 = /* @__PURE__ */ loggableArray(loggableString);
var logWarn1 = /* @__PURE__ */ logWarn2(loggableArray1);
var append112 = /* @__PURE__ */ append(semigroupArray);
var voidRight7 = /* @__PURE__ */ voidRight(functorMaybe);
var mapFlipped8 = /* @__PURE__ */ mapFlipped(functorTuple);
var $$delete8 = /* @__PURE__ */ $$delete5({
  reflectSymbol: function() {
    return "configWorkspace";
  }
})()();
var logDebug32 = /* @__PURE__ */ logDebug4(loggableArray1);
var sort3 = /* @__PURE__ */ sort(ordString);
var lookup7 = /* @__PURE__ */ lookup3(ordPackageName);
var die22 = /* @__PURE__ */ die3(loggableArray3);
var fromFoldable110 = /* @__PURE__ */ fromFoldable(foldableSet);
var toDoc13 = /* @__PURE__ */ toDoc2(/* @__PURE__ */ loggableArray(loggablePackageName));
var show112 = /* @__PURE__ */ show(showString);
var notEq5 = /* @__PURE__ */ notEq(eqStatusCode);
var show29 = /* @__PURE__ */ show(showStatusCode);
var show32 = /* @__PURE__ */ show(showJsonDecodeError);
var map215 = /* @__PURE__ */ map(functorMap);
var logWarn22 = /* @__PURE__ */ logWarn2(loggableString);
var union6 = /* @__PURE__ */ union3(ordPackageName);
var logSuccess2 = /* @__PURE__ */ logSuccess(monadEffectSpago)(monadAskSpago);
var logSuccess1 = /* @__PURE__ */ logSuccess2(loggableString);
var logSuccess22 = /* @__PURE__ */ logSuccess2(loggableArray3);
var show42 = /* @__PURE__ */ show(showInt);
var toUnfoldable16 = /* @__PURE__ */ toUnfoldable6(unfoldableArray);
var bindFlipped9 = /* @__PURE__ */ bindFlipped(bindMaybe);
var ls2 = /* @__PURE__ */ ls(monadAffSpago);
var eq52 = /* @__PURE__ */ eq(eqVersion);
var sort1 = /* @__PURE__ */ sort(ordVersion);
var find3 = /* @__PURE__ */ find(foldableArray);
var greaterThan3 = /* @__PURE__ */ greaterThan(ordVersion);
var insert12 = /* @__PURE__ */ insert3(ordVersion);
var foldM4 = /* @__PURE__ */ foldM(monadSpago);
var ask5 = /* @__PURE__ */ ask(monadAskSpago);
var lookup1 = /* @__PURE__ */ lookup3(ordVersion);
var fromFoldable23 = /* @__PURE__ */ fromFoldable3(foldableArray);
var WithTestGlobs = /* @__PURE__ */ function() {
  function WithTestGlobs2() {
  }
  ;
  WithTestGlobs2.value = new WithTestGlobs2();
  return WithTestGlobs2;
}();
var NoTestGlobs = /* @__PURE__ */ function() {
  function NoTestGlobs2() {
  }
  ;
  NoTestGlobs2.value = new NoTestGlobs2();
  return NoTestGlobs2;
}();
var OnlyTestGlobs = /* @__PURE__ */ function() {
  function OnlyTestGlobs2() {
  }
  ;
  OnlyTestGlobs2.value = new OnlyTestGlobs2();
  return OnlyTestGlobs2;
}();
var RemotePackageSet = function(x) {
  return x;
};
var RegistryVersion = /* @__PURE__ */ function() {
  function RegistryVersion2(value0) {
    this.value0 = value0;
  }
  ;
  RegistryVersion2.create = function(value0) {
    return new RegistryVersion2(value0);
  };
  return RegistryVersion2;
}();
var GitPackage = /* @__PURE__ */ function() {
  function GitPackage2(value0) {
    this.value0 = value0;
  }
  ;
  GitPackage2.create = function(value0) {
    return new GitPackage2(value0);
  };
  return GitPackage2;
}();
var LocalPackage = /* @__PURE__ */ function() {
  function LocalPackage2(value0) {
    this.value0 = value0;
  }
  ;
  LocalPackage2.create = function(value0) {
    return new LocalPackage2(value0);
  };
  return LocalPackage2;
}();
var WorkspacePackage = /* @__PURE__ */ function() {
  function WorkspacePackage2(value0) {
    this.value0 = value0;
  }
  ;
  WorkspacePackage2.create = function(value0) {
    return new WorkspacePackage2(value0);
  };
  return WorkspacePackage2;
}();
var PackageSet2 = /* @__PURE__ */ function() {
  function PackageSet3(value0) {
    this.value0 = value0;
  }
  ;
  PackageSet3.create = function(value0) {
    return new PackageSet3(value0);
  };
  return PackageSet3;
}();
var Registry = /* @__PURE__ */ function() {
  function Registry2(value0) {
    this.value0 = value0;
  }
  ;
  Registry2.create = function(value0) {
    return new Registry2(value0);
  };
  return Registry2;
}();
var UseLockfile = /* @__PURE__ */ function() {
  function UseLockfile2(value0) {
    this.value0 = value0;
  }
  ;
  UseLockfile2.create = function(value0) {
    return new UseLockfile2(value0);
  };
  return UseLockfile2;
}();
var GenerateLockfile = /* @__PURE__ */ function() {
  function GenerateLockfile2() {
  }
  ;
  GenerateLockfile2.value = new GenerateLockfile2();
  return GenerateLockfile2;
}();
var SkipLockfile = /* @__PURE__ */ function() {
  function SkipLockfile2() {
  }
  ;
  SkipLockfile2.value = new SkipLockfile2();
  return SkipLockfile2;
}();
var LegacyPackageSet = function(x) {
  return x;
};
var updatePackageSetHashInConfig = function(doc) {
  return function(sha) {
    return function() {
      return updatePackageSetHashInConfigImpl(doc, print6(sha));
    };
  };
};
var testGlob = "test/**/*.purs";
var srcGlob = "src/**/*.purs";
var remotePackageSetCodec = /* @__PURE__ */ wrapIso2(RemotePackageSet)(/* @__PURE__ */ object6(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons5(versionIsSymbol))()()(packagesIsSymbol))()()(compilerIsSymbol))("PackageSet")({
  version: codec3,
  compiler: codec3,
  packages: /* @__PURE__ */ packageMap(remotePackageCodec)
}));
var packageSetsCachePath = /* @__PURE__ */ concat2([globalCachePath, "setsCAS"]);
var packageSetResultCodec = /* @__PURE__ */ object6(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons5({
  reflectSymbol: function() {
    return "remotePackageSet";
  }
}))()()(compilerIsSymbol))("PackageSetResult")({
  compiler: codec3,
  remotePackageSet: /* @__PURE__ */ packageMap(remotePackageCodec)
});
var packageSetCachePath = function(v) {
  return concat2([packageSetsCachePath, v]);
};
var readPackageSetFromHash = function(hash3) {
  return bind38(liftEffect7(shaToHex(hash3)))(function(hex) {
    var path5 = packageSetCachePath(hex);
    return discard16(logDebug1("Reading cached package set entry from " + path5))(function() {
      return bind38(exists5(path5))(function(v) {
        if (!v) {
          return pure53(new Left("Did not find a package set cached with hash " + print6(hash3)));
        }
        ;
        if (v) {
          return bind38(liftAff4(readJsonFile(packageSetResultCodec)(path5)))(function(v1) {
            if (v1 instanceof Left) {
              return pure53(new Left("Error while reading cached package set " + (print6(hash3) + (": " + v1.value0))));
            }
            ;
            if (v1 instanceof Right) {
              return pure53(new Right(v1.value0));
            }
            ;
            throw new Error("Failed pattern match at Spago.Config (line 431, column 72 - line 433, column 36): " + [v1.constructor.name]);
          });
        }
        ;
        throw new Error("Failed pattern match at Spago.Config (line 429, column 22 - line 433, column 36): " + [v.constructor.name]);
      });
    });
  });
};
var writePackageSetToHash = function(result) {
  var serialised = printJson(packageSetResultCodec)(result);
  return bind38(liftEffect7(hashString3(serialised)))(function(hash3) {
    return bind38(liftEffect7(shaToHex(hash3)))(function(hex) {
      return discard16(mkdirp2(packageSetsCachePath))(function() {
        return discard16(writeTextFile4(packageSetCachePath(hex))(serialised))(function() {
          return pure53(hash3);
        });
      });
    });
  });
};
var legacyPackageSetCodec = /* @__PURE__ */ wrapIso2(LegacyPackageSet)(/* @__PURE__ */ packageMap(legacyPackageSetEntryCodec));
var getWorkspacePackages = /* @__PURE__ */ function() {
  var extractWorkspacePackage = function(v) {
    if (v.value1 instanceof WorkspacePackage) {
      return new Just(v.value1.value0);
    }
    ;
    return Nothing.value;
  };
  var $392 = mapMaybe(extractWorkspacePackage);
  return function($393) {
    return $392(toUnfoldable15(function(v) {
      if (v instanceof PackageSet2) {
        return v.value0;
      }
      ;
      if (v instanceof Registry) {
        return v.value0;
      }
      ;
      throw new Error("Failed pattern match at Spago.Config (line 408, column 88 - line 410, column 18): " + [v.constructor.name]);
    }($393)));
  };
}();
var getPackageLocation = function(name4) {
  return function($394) {
    return mkRelative(function(v) {
      if (v instanceof RegistryVersion) {
        return concat2([localCachePackagesPath, print2(name4) + ("-" + print3(v.value0))]);
      }
      ;
      if (v instanceof GitPackage) {
        return concat2([localCachePackagesPath, print2(name4), v.value0.ref]);
      }
      ;
      if (v instanceof LocalPackage) {
        return v.value0.path;
      }
      ;
      if (v instanceof WorkspacePackage) {
        return v.value0.path;
      }
      ;
      throw new Error("Failed pattern match at Spago.Config (line 377, column 48 - line 381, column 36): " + [v.constructor.name]);
    }($394));
  };
};
var sourceGlob = function(withTestGlobs) {
  return function(name4) {
    return function($$package2) {
      return map63(function(p) {
        return concat2([getPackageLocation(name4)($$package2), p]);
      })(function() {
        if ($$package2 instanceof WorkspacePackage) {
          if (!$$package2.value0.hasTests && withTestGlobs instanceof OnlyTestGlobs) {
            return [];
          }
          ;
          if (!$$package2.value0.hasTests) {
            return [srcGlob];
          }
          ;
          if ($$package2.value0.hasTests && withTestGlobs instanceof OnlyTestGlobs) {
            return [testGlob];
          }
          ;
          if ($$package2.value0.hasTests && withTestGlobs instanceof NoTestGlobs) {
            return [srcGlob];
          }
          ;
          if ($$package2.value0.hasTests && withTestGlobs instanceof WithTestGlobs) {
            return [srcGlob, testGlob];
          }
          ;
          throw new Error("Failed pattern match at Spago.Config (line 392, column 7 - line 397, column 53): " + [$$package2.value0.hasTests.constructor.name, withTestGlobs.constructor.name]);
        }
        ;
        if ($$package2 instanceof GitPackage && $$package2.value0.subdir instanceof Just) {
          return [concat2([$$package2.value0.subdir.value0, srcGlob])];
        }
        ;
        return [srcGlob];
      }());
    };
  };
};
var fromRemotePackage = function(v) {
  if (v instanceof RemoteGitPackage) {
    return new GitPackage(v.value0);
  }
  ;
  if (v instanceof RemoteRegistryVersion) {
    return new RegistryVersion(v.value0);
  }
  ;
  if (v instanceof RemoteLegacyPackage) {
    return new GitPackage({
      git: v.value0.repo,
      ref: v.value0.version,
      subdir: Nothing.value,
      dependencies: new Just(fromFoldable20(map63(function(p) {
        return new Tuple(p, Nothing.value);
      })(v.value0.dependencies)))
    });
  }
  ;
  throw new Error("Failed pattern match at Spago.Config (line 91, column 21 - line 99, column 6): " + [v.constructor.name]);
};
var fromExtraPackage = function(v) {
  if (v instanceof ExtraLocalPackage) {
    return new LocalPackage(v.value0);
  }
  ;
  if (v instanceof ExtraRemotePackage) {
    return fromRemotePackage(v.value0);
  }
  ;
  throw new Error("Failed pattern match at Spago.Config (line 86, column 20 - line 88, column 53): " + [v.constructor.name]);
};
var readWorkspace = function(maybeSelectedPackage) {
  return discard16(logInfo3("Reading Spago workspace configuration..."))(function() {
    return bind38(bind38(readConfig("spago.yaml"))(function(v) {
      if (v instanceof Left) {
        return die1("Couldn't parse Spago config, error:\n  " + v.value0);
      }
      ;
      if (v instanceof Right && v.value0.yaml.workspace instanceof Nothing) {
        return die1("Your spago.yaml doesn't contain a workspace section");
      }
      ;
      if (v instanceof Right && v.value0.yaml.workspace instanceof Just) {
        return pure53({
          workspace: v.value0.yaml.workspace.value0,
          "package": v["value0"]["yaml"]["package"],
          workspaceDoc: v.value0.doc
        });
      }
      ;
      throw new Error("Failed pattern match at Spago.Config (line 155, column 90 - line 158, column 114): " + [v.constructor.name]);
    }))(function(v) {
      return bind38(bind38(exists5("spago.lock"))(function(v1) {
        if (v1) {
          return bind38(liftAff4(readYamlFile(lockfileCodec)("spago.lock")))(function(v2) {
            if (v2 instanceof Left) {
              return die1("Your project contains a spago.lock file, but it cannot be decoded:\n" + v2.value0);
            }
            ;
            if (v2 instanceof Right) {
              if (eq42(v.workspace.lock)(new Just(false))) {
                return die1("Your workspace specifies 'lock: false', but there is a spago.lock file in the workspace.");
              }
              ;
              if (otherwise) {
                return pure53(new UseLockfile(v2.value0));
              }
              ;
            }
            ;
            throw new Error("Failed pattern match at Spago.Config (line 161, column 75 - line 169, column 40): " + [v2.constructor.name]);
          });
        }
        ;
        if (!v1) {
          if (eq42(v.workspace.lock)(new Just(true))) {
            return pure53(GenerateLockfile.value);
          }
          ;
          if (eq42(v.workspace.lock)(new Just(false))) {
            return pure53(SkipLockfile.value);
          }
          ;
          if (otherwise) {
            if (v.workspace.package_set instanceof Nothing) {
              return pure53(GenerateLockfile.value);
            }
            ;
            if (v.workspace.package_set instanceof Just) {
              return pure53(SkipLockfile.value);
            }
            ;
            throw new Error("Failed pattern match at Spago.Config (line 177, column 22 - line 179, column 38): " + [v.workspace.package_set.constructor.name]);
          }
          ;
        }
        ;
        throw new Error("Failed pattern match at Spago.Config (line 160, column 42 - line 179, column 38): " + [v1.constructor.name]);
      }))(function(lockfile) {
        return bind38(exists5("test"))(function(rootPackageHasTests) {
          return bind38(bind38(liftAff4(match$prime2(cwd2)(["**/spago.yaml"])({
            ignore: [".spago", "spago.yaml"]
          })))(function(result) {
            var filterGitignored = function(path5) {
              return bind38(isIgnored(path5))(function(v1) {
                if (v1) {
                  return pure53(new Left(path5));
                }
                ;
                if (!v1) {
                  return pure53(new Right(path5));
                }
                ;
                throw new Error("Failed pattern match at Spago.Config (line 190, column 32 - line 192, column 37): " + [v1.constructor.name]);
              });
            };
            return bind38(map122(partitionMap3(identity28))(traverse8(filterGitignored)(result.succeeded)))(function(v1) {
              return pure53({
                succeeded: v1.right,
                failed: result.failed,
                ignored: v1.left
              });
            });
          }))(function(v1) {
            return discard16(unless3($$null(v1.succeeded))(logDebug22([toDoc4("Found packages at these paths:"), indent(lines4(map63(toDoc4)(v1.succeeded)))])))(function() {
              return discard16(unless3($$null(v1.failed))(logDebug1("Failed to sanitise some of the glob matches: " + show28(v1.failed))))(function() {
                return discard16(unless3($$null(v1.ignored))(logDebug1("Ignored some of the glob matches as they are gitignored: " + show28(v1.ignored))))(function() {
                  var readWorkspaceConfig = function(path5) {
                    return bind38(readConfig(path5))(function(maybeConfig) {
                      return bind38(exists5(concat2([dirname(path5), "test"])))(function(hasTests) {
                        return pure53(function() {
                          if (maybeConfig instanceof Left) {
                            return new Left("Could not read config at path " + (path5 + ("\nError was: " + maybeConfig.value0)));
                          }
                          ;
                          if (maybeConfig instanceof Right && maybeConfig["value0"]["yaml"]["package"] instanceof Nothing) {
                            return new Left("No package found for config at path: " + path5);
                          }
                          ;
                          if (maybeConfig instanceof Right && maybeConfig["value0"]["yaml"]["package"] instanceof Just) {
                            return new Right(new Tuple(maybeConfig["value0"]["yaml"]["package"].value0.name, {
                              path: dirname(path5),
                              "package": maybeConfig["value0"]["yaml"]["package"].value0,
                              configWorkspace: maybeConfig.value0.yaml.workspace,
                              doc: maybeConfig.value0.doc,
                              hasTests
                            }));
                          }
                          ;
                          throw new Error("Failed pattern match at Spago.Config (line 208, column 14 - line 213, column 106): " + [maybeConfig.constructor.name]);
                        }());
                      });
                    });
                  };
                  return bind38(map122(partitionMap3(identity28))(traverse8(readWorkspaceConfig)(v1.succeeded)))(function(v2) {
                    return discard16(unless3($$null(v2.left))(logWarn1(append112(["Failed to read some configs:"])(v2.left))))(function() {
                      var configPathsWithWorkspaces = mapMaybe(function(v32) {
                        return voidRight7(v32.value1.path)(v32.value1.configWorkspace);
                      })(v2.right);
                      var v3 = partitionMap3(function(config) {
                        var configPath = snd(config).path;
                        var $297 = any(function(p) {
                          return isJust(stripPrefix(p)(configPath));
                        })(configPathsWithWorkspaces);
                        if ($297) {
                          return new Left(configPath);
                        }
                        ;
                        return new Right(mapFlipped8(config)($$delete8($$Proxy.value)));
                      })(v2.right);
                      return discard16(unless3($$null(v3.left))(logDebug32(append112(["Excluding configs that use a different workspace (directly or implicitly via parent directory's config):"])(sort3(v2.left)))))(function() {
                        var workspacePackages = fromFoldable20(append112(v3.right)(function() {
                          if (v["package"] instanceof Nothing) {
                            return [];
                          }
                          ;
                          if (v["package"] instanceof Just) {
                            return [new Tuple(v["package"].value0.name, {
                              path: "./",
                              "package": v["package"].value0,
                              doc: v.workspaceDoc,
                              hasTests: rootPackageHasTests
                            })];
                          }
                          ;
                          throw new Error("Failed pattern match at Spago.Config (line 234, column 67 - line 236, column 119): " + [v["package"].constructor.name]);
                        }()));
                        return bind38(function() {
                          if (maybeSelectedPackage instanceof Nothing) {
                            var v4 = uncons(toUnfoldable15(workspacePackages));
                            if (v4 instanceof Nothing) {
                              return die1("No valid packages found in the current project, halting.");
                            }
                            ;
                            if (v4 instanceof Just && v4.value0.tail.length === 0) {
                              return discard16(logDebug1("Selecting package " + (print2(v4.value0.head.value0) + (" from " + v4.value0.head.value1.path))))(function() {
                                return pure53(new Just(v4.value0.head.value1));
                              });
                            }
                            ;
                            return pure53(Nothing.value);
                          }
                          ;
                          if (maybeSelectedPackage instanceof Just) {
                            var v4 = lookup7(maybeSelectedPackage.value0)(workspacePackages);
                            if (v4 instanceof Nothing) {
                              return die22(append112([toDoc4("Selected package " + (print2(maybeSelectedPackage.value0) + " was not found in the local packages."))])(function() {
                                var v5 = fromFoldable110(keys3(workspacePackages));
                                if (v5.length === 0) {
                                  return [toDoc4("No available packages.")];
                                }
                                ;
                                return [toDoc4("Available packages:"), indent(toDoc13(v5))];
                              }()));
                            }
                            ;
                            if (v4 instanceof Just) {
                              return pure53(new Just(v4.value0));
                            }
                            ;
                            throw new Error("Failed pattern match at Spago.Config (line 248, column 18 - line 254, column 30): " + [v4.constructor.name]);
                          }
                          ;
                          throw new Error("Failed pattern match at Spago.Config (line 239, column 20 - line 254, column 30): " + [maybeSelectedPackage.constructor.name]);
                        }())(function(maybeSelected) {
                          return bind38(function() {
                            if (v.workspace.package_set instanceof Nothing) {
                              return discard16(logDebug1("Did not find a package set in your config, using Registry solver"))(function() {
                                return pure53({
                                  compatibleCompiler: widestRange,
                                  remotePackageSet: Nothing.value
                                });
                              });
                            }
                            ;
                            if (v.workspace.package_set instanceof Just && v.workspace.package_set.value0 instanceof SetFromRegistry) {
                              return discard16(logDebug1("Reading the package set from the Registry repo..."))(function() {
                                var packageSetPath = concat2([registryPath, "package-sets", print3(v.workspace.package_set.value0.value0.registry) + ".json"]);
                                return bind38(liftAff4(readJsonFile(remotePackageSetCodec)(packageSetPath)))(function(v5) {
                                  if (v5 instanceof Left) {
                                    return die1("Couldn't read the package set: " + v5.value0);
                                  }
                                  ;
                                  if (v5 instanceof Right) {
                                    return discard16(logInfo3("Read the package set from the registry"))(function() {
                                      return pure53({
                                        compatibleCompiler: caret(v5.value0.compiler),
                                        remotePackageSet: new Just(v5.value0.packages)
                                      });
                                    });
                                  }
                                  ;
                                  throw new Error("Failed pattern match at Spago.Config (line 267, column 74 - line 274, column 14): " + [v5.constructor.name]);
                                });
                              });
                            }
                            ;
                            if (v.workspace.package_set instanceof Just && v.workspace.package_set.value0 instanceof SetFromUrl) {
                              var fetchPackageSet = discard16(logDebug1("Reading the package set from URL: " + v.workspace.package_set.value0.value0.url))(function() {
                                return bind38(function() {
                                  var v4 = parseUrl(v.workspace.package_set.value0.value0.url);
                                  if (v4 instanceof Left) {
                                    return die1("Could not parse URL for the package set, error: " + show112(v4.value0));
                                  }
                                  ;
                                  if (v4 instanceof Right) {
                                    return pure53(v4.value0.href);
                                  }
                                  ;
                                  throw new Error("Failed pattern match at Spago.Config (line 280, column 18 - line 282, column 35): " + [v4.constructor.name]);
                                }())(function(url2) {
                                  return bind38(liftAff4(request2({
                                    method: new Left(GET.value),
                                    url: url2,
                                    headers: defaultRequest.headers,
                                    content: defaultRequest.content,
                                    username: defaultRequest.username,
                                    password: defaultRequest.password,
                                    withCredentials: defaultRequest.withCredentials,
                                    responseFormat: string4,
                                    timeout: defaultRequest.timeout
                                  })))(function(response) {
                                    if (response instanceof Left) {
                                      return die1("Couldn't fetch package set:\n  " + printError2(response.value0));
                                    }
                                    ;
                                    if (response instanceof Right && notEq5(response.value0.status)(200)) {
                                      return die1("Couldn't fetch package set, status was not ok " + (show29(response.value0.status) + (", got answer:\n  " + response.value0.body)));
                                    }
                                    ;
                                    if (response instanceof Right) {
                                      return discard16(logDebug1("Fetching package set - got status: " + show29(response.value0.status)))(function() {
                                        var v4 = parseJson(remotePackageSetCodec)(response.value0.body);
                                        if (v4 instanceof Right) {
                                          return discard16(logDebug1("Read a new-format package set from URL"))(function() {
                                            return pure53({
                                              compiler: v4.value0.compiler,
                                              remotePackageSet: v4.value0.packages
                                            });
                                          });
                                        }
                                        ;
                                        if (v4 instanceof Left) {
                                          return discard16(logDebug32(["Couldn't parse remote package set in modern format, error:", "  " + show32(v4.value0), "Trying with the legacy format..."]))(function() {
                                            var v5 = parseJson(legacyPackageSetCodec)(response.value0.body);
                                            if (v5 instanceof Left) {
                                              return die1("Couldn't parse remote package set, error: " + show32(v5.value0));
                                            }
                                            ;
                                            if (v5 instanceof Right) {
                                              return discard16(logDebug1("Read legacy package set from URL"))(function() {
                                                return bind38(function() {
                                                  var v6 = lookup7(unsafeFromRight(parse3("metadata")))(v5.value0);
                                                  if (v6 instanceof Just) {
                                                    return pure53(unsafeFromRight(parseLenientVersion(v6.value0.version)));
                                                  }
                                                  ;
                                                  if (v6 instanceof Nothing) {
                                                    return die1("Couldn't find 'metadata' package in legacy package set.");
                                                  }
                                                  ;
                                                  throw new Error("Failed pattern match at Spago.Config (line 300, column 34 - line 302, column 99): " + [v6.constructor.name]);
                                                }())(function(version) {
                                                  return pure53({
                                                    compiler: version,
                                                    remotePackageSet: map215(RemoteLegacyPackage.create)(v5.value0)
                                                  });
                                                });
                                              });
                                            }
                                            ;
                                            throw new Error("Failed pattern match at Spago.Config (line 296, column 19 - line 303, column 101): " + [v5.constructor.name]);
                                          });
                                        }
                                        ;
                                        throw new Error("Failed pattern match at Spago.Config (line 290, column 15 - line 303, column 101): " + [v4.constructor.name]);
                                      });
                                    }
                                    ;
                                    throw new Error("Failed pattern match at Spago.Config (line 284, column 11 - line 303, column 101): " + [response.constructor.name]);
                                  });
                                });
                              });
                              return bind38(function() {
                                if (v.workspace.package_set.value0.value0.hash instanceof Just) {
                                  return bind38(readPackageSetFromHash(v.workspace.package_set.value0.value0.hash.value0))(function(v4) {
                                    if (v4 instanceof Left) {
                                      return discard16(logDebug1(show112(v4.value0)))(function() {
                                        return fetchPackageSet;
                                      });
                                    }
                                    ;
                                    if (v4 instanceof Right) {
                                      return pure53(v4.value0);
                                    }
                                    ;
                                    throw new Error("Failed pattern match at Spago.Config (line 305, column 54 - line 309, column 28): " + [v4.constructor.name]);
                                  });
                                }
                                ;
                                if (v.workspace.package_set.value0.value0.hash instanceof Nothing) {
                                  return discard16(logWarn22("Did not find a hash for your package set import, adding it to your config..."))(function() {
                                    return fetchPackageSet;
                                  });
                                }
                                ;
                                throw new Error("Failed pattern match at Spago.Config (line 304, column 17 - line 312, column 26): " + [v.workspace.package_set.value0.value0.hash.constructor.name]);
                              }())(function(result) {
                                return bind38(writePackageSetToHash(result))(function(newHash) {
                                  return discard16(logDebug1("Package set hash: " + print6(newHash)))(function() {
                                    return discard16(liftEffect7(updatePackageSetHashInConfig(v.workspaceDoc)(newHash)))(function() {
                                      return discard16(liftAff4(writeYamlDocFile("spago.yaml")(v.workspaceDoc)))(function() {
                                        return pure53({
                                          compatibleCompiler: caret(result.compiler),
                                          remotePackageSet: new Just(result.remotePackageSet)
                                        });
                                      });
                                    });
                                  });
                                });
                              });
                            }
                            ;
                            throw new Error("Failed pattern match at Spago.Config (line 257, column 47 - line 320, column 10): " + [v.workspace.package_set.constructor.name]);
                          }())(function(v4) {
                            var packageSet = function() {
                              var overrides = union6(map215(WorkspacePackage.create)(workspacePackages))(map215(fromExtraPackage)(fromMaybe(empty3)(v.workspace.extra_packages)));
                              if (v4.remotePackageSet instanceof Nothing) {
                                return new Registry(overrides);
                              }
                              ;
                              if (v4.remotePackageSet instanceof Just) {
                                return new PackageSet2(union6(overrides)(map215(fromRemotePackage)(v4.remotePackageSet.value0)));
                              }
                              ;
                              throw new Error("Failed pattern match at Spago.Config (line 335, column 9 - line 339, column 40): " + [v4.remotePackageSet.constructor.name]);
                            }();
                            return discard16(function() {
                              if (maybeSelected instanceof Just) {
                                return discard16(logSuccess1("Selecting package to build: " + print2(maybeSelected["value0"]["package"].name)))(function() {
                                  return logDebug1("Package path: " + maybeSelected.value0.path);
                                });
                              }
                              ;
                              if (maybeSelected instanceof Nothing) {
                                return logSuccess22([toDoc4("Selecting " + (show42(size2(workspacePackages)) + " packages to build:")), indent22(toDoc13(toUnfoldable16(keys3(workspacePackages))))]);
                              }
                              ;
                              throw new Error("Failed pattern match at Spago.Config (line 341, column 3 - line 349, column 10): " + [maybeSelected.constructor.name]);
                            }())(function() {
                              var buildOptions = {
                                output: bindFlipped9(function(v5) {
                                  return v5.output;
                                })(v.workspace.build_opts),
                                pedanticPackages: fromMaybe(false)(bindFlipped9(function(v5) {
                                  return v5.pedantic_packages;
                                })(v.workspace.build_opts)),
                                censorBuildWarnings: bindFlipped9(function(v5) {
                                  return v5.censor_warnings;
                                })(v.workspace.build_opts),
                                censorCodes: bindFlipped9(function(v5) {
                                  return v5.censor_codes;
                                })(v.workspace.build_opts),
                                filterCodes: bindFlipped9(function(v5) {
                                  return v5.filter_codes;
                                })(v.workspace.build_opts),
                                statVerbosity: bindFlipped9(function(v5) {
                                  return v5.stat_verbosity;
                                })(v.workspace.build_opts),
                                showSource: bindFlipped9(function(v5) {
                                  return v5.show_source;
                                })(v.workspace.build_opts),
                                strict: bindFlipped9(function(v5) {
                                  return v5.strict;
                                })(v.workspace.build_opts),
                                persistWarnings: bindFlipped9(function(v5) {
                                  return v5.persist_warnings;
                                })(v.workspace.build_opts)
                              };
                              return pure53({
                                selected: maybeSelected,
                                packageSet,
                                compatibleCompiler: v4.compatibleCompiler,
                                backend: v.workspace.backend,
                                buildOptions,
                                doc: v.workspaceDoc,
                                originalConfig: v.workspace,
                                lockfile
                              });
                            });
                          });
                        });
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
  });
};
var findPackageSet = function(maybeSet) {
  var parseSetVersion = function(str2) {
    return parse4(function() {
      var v = stripSuffix(".json")(str2);
      if (v instanceof Nothing) {
        return str2;
      }
      ;
      if (v instanceof Just) {
        return v.value0;
      }
      ;
      throw new Error("Failed pattern match at Spago.Config (line 472, column 41 - line 474, column 18): " + [v.constructor.name]);
    }());
  };
  var packageSetsPath = concat2([registryPath, "package-sets"]);
  return bind38(map122(function() {
    var $395 = map63(parseSetVersion);
    return function($396) {
      return partitionEithers($395($396));
    };
  }())(ls2(packageSetsPath)))(function(v) {
    return discard16(unless3($$null(v.fail))(logDebug22(append112([toDoc4("Failed to parse some package-sets versions:")])(map63(function($397) {
      return indent(toDoc4(show112($397)));
    })(v.fail)))))(function() {
      if (maybeSet instanceof Just) {
        var v1 = find2(function(v2) {
          return eq52(v2)(maybeSet.value0);
        })(v.success);
        if (v1 instanceof Just) {
          return pure53(maybeSet.value0);
        }
        ;
        if (v1 instanceof Nothing) {
          return die22(append112([toDoc4("Could not find desired set " + (print3(maybeSet.value0) + " in the list of available set versions:"))])(map63(function($398) {
            return indent(toDoc4(print3($398)));
          })(sort1(v.success))));
        }
        ;
        throw new Error("Failed pattern match at Spago.Config (line 483, column 24 - line 486, column 77): " + [v1.constructor.name]);
      }
      ;
      if (maybeSet instanceof Nothing) {
        var readPackageSet = function(setVersion) {
          return discard16(logDebug1("Reading the package set from the Registry repo..."))(function() {
            var packageSetPath = concat2([packageSetsPath, print3(setVersion) + ".json"]);
            return bind38(liftAff4(readJsonFile(remotePackageSetCodec)(packageSetPath)))(function(v12) {
              if (v12 instanceof Left) {
                return die1("Couldn't read the package set: " + v12.value0);
              }
              ;
              if (v12 instanceof Right) {
                return discard16(logDebug1("Read the package set " + (print3(setVersion) + " from the registry")))(function() {
                  return pure53(v12.value0);
                });
              }
              ;
              throw new Error("Failed pattern match at Spago.Config (line 495, column 78 - line 499, column 38): " + [v12.constructor.name]);
            });
          });
        };
        var accVersions = function(index4) {
          return function(newSetVersion) {
            var maybeResult = find3(function(v12) {
              return major(v12.value1) === major(newSetVersion);
            })(toUnfoldable15(index4));
            if (maybeResult instanceof Just) {
              var $378 = greaterThan3(newSetVersion)(maybeResult.value0.value1);
              if ($378) {
                return discard16(logDebug1("Updating to package set " + (print3(newSetVersion) + (" for compiler " + print3(maybeResult.value0.value0)))))(function() {
                  return pure53(insert12(maybeResult.value0.value0)(newSetVersion)(index4));
                });
              }
              ;
              return pure53(index4);
            }
            ;
            if (maybeResult instanceof Nothing) {
              return bind38(readPackageSet(newSetVersion))(function(packageSet) {
                return discard16(logDebug1("Inserting package set " + (print3(newSetVersion) + (" for compiler " + print3(packageSet.compiler)))))(function() {
                  return pure53(insert12(packageSet.compiler)(newSetVersion)(index4));
                });
              });
            }
            ;
            throw new Error("Failed pattern match at Spago.Config (line 503, column 11 - line 516, column 72): " + [maybeResult.constructor.name]);
          };
        };
        return bind38(foldM4(accVersions)(empty3)(v.success))(function(v12) {
          return discard16(logDebug32(["Package set index", printJson(versionMap(codec3))(v12)]))(function() {
            return bind38(ask5)(function(v2) {
              var v3 = lookup1(v2.purs.version)(v12);
              if (v3 instanceof Just) {
                return pure53(v3.value0);
              }
              ;
              if (v3 instanceof Nothing) {
                return die22(append112([toDoc4("No package set is compatible with your compiler version " + print3(v2.purs.version)), toDoc4("Compatible versions:")])(map63(function($399) {
                  return indent(toDoc4(print3($399)));
                })(fromFoldable110(keys3(v12)))));
              }
              ;
              throw new Error("Failed pattern match at Spago.Config (line 522, column 7 - line 527, column 92): " + [v3.constructor.name]);
            });
          });
        });
      }
      ;
      throw new Error("Failed pattern match at Spago.Config (line 481, column 3 - line 527, column 92): " + [maybeSet.constructor.name]);
    });
  });
};
var addRangesToConfig = function(doc) {
  var $400 = runEffectFn2(addRangesToConfigImpl)(doc);
  var $401 = map63(function(v) {
    return new Tuple(print2(v.value0), printSpagoRange(v.value1));
  });
  return function($402) {
    return $400(fromFoldable23($401(toUnfoldable15($402))));
  };
};
var addPackagesToConfig = function(doc) {
  return function(pkgs) {
    return function() {
      return addPackagesToConfigImpl(doc, map63(print2)(pkgs));
    };
  };
};

// output/Spago.Generated.BuildInfo/index.js
var buildInfo = {
  packages: [{
    name: "spago-bin",
    version: "0.93.10"
  }],
  pursVersion: "0.15.10",
  spagoVersion: "0.93.9"
};

// output/Spago.BuildInfo/index.js
var map64 = /* @__PURE__ */ map(functorMaybe);
var map123 = /* @__PURE__ */ map(functorArray);
var bind39 = /* @__PURE__ */ bind(bindSpago);
var writeTextFile5 = /* @__PURE__ */ writeTextFile3(monadAffSpago);
var exists6 = /* @__PURE__ */ exists2(monadEffectSpago);
var readTextFile4 = /* @__PURE__ */ readTextFile3(monadAffSpago);
var when9 = /* @__PURE__ */ when(applicativeSpago);
var mkPackageBuildInfo = function(v) {
  return {
    name: print2(v["package"].name),
    version: fromMaybe("0.0.0")(map64(print3)(map64(function(v1) {
      return v1.version;
    })(v["package"].publish)))
  };
};
var currentSpagoVersion = /* @__PURE__ */ function() {
  return fromMaybe("0.0.0")(map64(function(v) {
    return v.version;
  })(head(buildInfo.packages)));
}();
var mkBuildInfo = function(v) {
  var renderPackage = function(p) {
    return '{ name: "' + (p.name + ('", version: "' + (p.version + '"}')));
  };
  return joinWith("\n")(["module Spago.Generated.BuildInfo where", "", "buildInfo :: { packages :: Array { name :: String, version :: String }, pursVersion :: String, spagoVersion :: String }", "buildInfo =", "  { packages: [" + (joinWith(", ")(map123(renderPackage)(v.packages)) + "]"), '  , pursVersion: "' + (v.pursVersion + '"'), '  , spagoVersion: "' + (currentSpagoVersion + '"'), "  }", ""]);
};
var buildInfoPath = /* @__PURE__ */ concat2([localCachePath, "BuildInfo.purs"]);
var writeBuildInfo = /* @__PURE__ */ bind39(/* @__PURE__ */ ask(monadAskSpago))(function(v) {
  var buildInfo2 = {
    pursVersion: print3(v.purs.version),
    packages: map123(mkPackageBuildInfo)(function() {
      if (v.workspace.selected instanceof Just) {
        return [v.workspace.selected.value0];
      }
      ;
      if (v.workspace.selected instanceof Nothing) {
        return getWorkspacePackages(v.workspace.packageSet);
      }
      ;
      throw new Error("Failed pattern match at Spago.BuildInfo (line 42, column 42 - line 44, column 70): " + [v.workspace.selected.constructor.name]);
    }())
  };
  var buildInfoString = mkBuildInfo(buildInfo2);
  var writeIt = writeTextFile5(buildInfoPath)(buildInfoString);
  return bind39(exists6(buildInfoPath))(function(v1) {
    if (!v1) {
      return writeIt;
    }
    ;
    if (v1) {
      return bind39(readTextFile4(buildInfoPath))(function(currentContent) {
        return when9(currentContent !== buildInfoString)(writeIt);
      });
    }
    ;
    throw new Error("Failed pattern match at Spago.BuildInfo (line 49, column 31 - line 54, column 16): " + [v1.constructor.name]);
  });
});

// output/Data.Codec.Argonaut.Compat/index.js
var pure54 = /* @__PURE__ */ pure(applicativeEither);
var bimap4 = /* @__PURE__ */ bimap(bifunctorEither);
var maybe2 = function(codec11) {
  var enc = function(v) {
    if (v instanceof Nothing) {
      return jsonNull;
    }
    ;
    if (v instanceof Just) {
      return encode(codec11)(v.value0);
    }
    ;
    throw new Error("Failed pattern match at Data.Codec.Argonaut.Compat (line 35, column 9 - line 37, column 28): " + [v.constructor.name]);
  };
  var dec = function(j) {
    if (isNull(j)) {
      return pure54(Nothing.value);
    }
    ;
    if (otherwise) {
      return bimap4(Named.create("Maybe"))(Just.create)(decode(codec11)(j));
    }
    ;
    throw new Error("Failed pattern match at Data.Codec.Argonaut.Compat (line 29, column 3 - line 29, column 50): " + [j.constructor.name]);
  };
  return codec$prime(dec)(enc);
};

// output/Spago.Psa.Types/index.js
var compare8 = /* @__PURE__ */ compare(ordString);
var object7 = /* @__PURE__ */ object2();
var rowListCodecCons6 = /* @__PURE__ */ rowListCodecCons(rowListCodecNil)()();
var compare16 = /* @__PURE__ */ compare(/* @__PURE__ */ ordTuple(ordInt)(ordInt));
var Unknown = /* @__PURE__ */ function() {
  function Unknown2() {
  }
  ;
  Unknown2.value = new Unknown2();
  return Unknown2;
}();
var Lib = /* @__PURE__ */ function() {
  function Lib2(value0) {
    this.value0 = value0;
  }
  ;
  Lib2.create = function(value0) {
    return new Lib2(value0);
  };
  return Lib2;
}();
var Src = /* @__PURE__ */ function() {
  function Src2(value0) {
    this.value0 = value0;
  }
  ;
  Src2.create = function(value0) {
    return new Src2(value0);
  };
  return Src2;
}();
var eqPsaPath = {
  eq: function(x) {
    return function(y) {
      if (x instanceof Unknown && y instanceof Unknown) {
        return true;
      }
      ;
      if (x instanceof Lib && y instanceof Lib) {
        return x.value0 === y.value0;
      }
      ;
      if (x instanceof Src && y instanceof Src) {
        return x.value0 === y.value0;
      }
      ;
      return false;
    };
  }
};
var ordPsaPath = {
  compare: function(x) {
    return function(y) {
      if (x instanceof Unknown && y instanceof Unknown) {
        return EQ.value;
      }
      ;
      if (x instanceof Unknown) {
        return LT.value;
      }
      ;
      if (y instanceof Unknown) {
        return GT.value;
      }
      ;
      if (x instanceof Lib && y instanceof Lib) {
        return compare8(x.value0)(y.value0);
      }
      ;
      if (x instanceof Lib) {
        return LT.value;
      }
      ;
      if (y instanceof Lib) {
        return GT.value;
      }
      ;
      if (x instanceof Src && y instanceof Src) {
        return compare8(x.value0)(y.value0);
      }
      ;
      throw new Error("Failed pattern match at Spago.Psa.Types (line 0, column 0 - line 0, column 0): " + [x.constructor.name, y.constructor.name]);
    };
  },
  Eq0: function() {
    return eqPsaPath;
  }
};
var compare24 = /* @__PURE__ */ compare(ordPsaPath);
var positionCodec = /* @__PURE__ */ object7(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons6({
  reflectSymbol: function() {
    return "startLine";
  }
}))()()({
  reflectSymbol: function() {
    return "startColumn";
  }
}))()()({
  reflectSymbol: function() {
    return "endLine";
  }
}))()()({
  reflectSymbol: function() {
    return "endColumn";
  }
}))("Position")({
  startLine: $$int,
  startColumn: $$int,
  endLine: $$int,
  endColumn: $$int
});
var suggestionCodec = /* @__PURE__ */ object7(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons6({
  reflectSymbol: function() {
    return "replacement";
  }
}))()()({
  reflectSymbol: function() {
    return "replaceRange";
  }
}))("Suggestion")({
  replacement: string,
  replaceRange: /* @__PURE__ */ maybe2(positionCodec)
});
var psaErrorCodec = /* @__PURE__ */ object7(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons6({
  reflectSymbol: function() {
    return "suggestion";
  }
}))()()({
  reflectSymbol: function() {
    return "position";
  }
}))()()({
  reflectSymbol: function() {
    return "moduleName";
  }
}))()()({
  reflectSymbol: function() {
    return "message";
  }
}))()()({
  reflectSymbol: function() {
    return "filename";
  }
}))()()({
  reflectSymbol: function() {
    return "errorLink";
  }
}))()()({
  reflectSymbol: function() {
    return "errorCode";
  }
}))("PsaError")({
  moduleName: /* @__PURE__ */ maybe2(string),
  errorCode: string,
  errorLink: string,
  message: string,
  filename: /* @__PURE__ */ maybe2(string),
  position: /* @__PURE__ */ maybe2(positionCodec),
  suggestion: /* @__PURE__ */ maybe2(suggestionCodec)
});
var psaResultCodec = /* @__PURE__ */ object7(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons6({
  reflectSymbol: function() {
    return "warnings";
  }
}))()()({
  reflectSymbol: function() {
    return "errors";
  }
}))("PsaResult")({
  warnings: /* @__PURE__ */ array(psaErrorCodec),
  errors: /* @__PURE__ */ array(psaErrorCodec)
});
var compareByLocation = function(err1) {
  return function(err2) {
    var v = compare24(err1.path)(err2.path);
    if (v instanceof EQ) {
      if (err1.position instanceof Nothing && err2.position instanceof Nothing) {
        return EQ.value;
      }
      ;
      if (err1.position instanceof Nothing) {
        return LT.value;
      }
      ;
      if (err2.position instanceof Nothing) {
        return GT.value;
      }
      ;
      if (err1.position instanceof Just && err2.position instanceof Just) {
        return compare16(new Tuple(err1.position.value0.startLine, err1.position.value0.startColumn))(new Tuple(err2.position.value0.startLine, err2.position.value0.startColumn));
      }
      ;
      throw new Error("Failed pattern match at Spago.Psa.Types (line 101, column 7 - line 107, column 46): " + [err1.position.constructor.name, err2.position.constructor.name]);
    }
    ;
    return v;
  };
};

// output/Spago.Psa.Output/index.js
var disj2 = /* @__PURE__ */ disj(/* @__PURE__ */ heytingAlgebraFunction(heytingAlgebraBoolean));
var eq26 = /* @__PURE__ */ eq(eqCodePoint);
var foldl9 = /* @__PURE__ */ foldl(foldableArray);
var identity29 = /* @__PURE__ */ identity(categoryFn);
var any5 = /* @__PURE__ */ any2(foldableArray)(heytingAlgebraBoolean);
var member4 = /* @__PURE__ */ member2(ordString);
var apply18 = /* @__PURE__ */ apply2(applyMaybe);
var map66 = /* @__PURE__ */ map(functorMaybe);
var append25 = /* @__PURE__ */ append(semigroupArray);
var map124 = /* @__PURE__ */ map(functorArray);
var $$Error2 = /* @__PURE__ */ function() {
  function $$Error4() {
  }
  ;
  $$Error4.value = new $$Error4();
  return $$Error4;
}();
var Warning = /* @__PURE__ */ function() {
  function Warning2() {
  }
  ;
  Warning2.value = new Warning2();
  return Warning2;
}();
var trimPosition = function($copy_lines) {
  return function($copy_pos) {
    var $tco_var_lines = $copy_lines;
    var $tco_done = false;
    var $tco_result;
    function $tco_loop(lines6, pos) {
      var isPunc = disj2(function(v2) {
        return eq26(v2)(codePointFromChar(" "));
      })(function(v2) {
        return eq26(v2)(codePointFromChar(","));
      });
      var trimComment = function(col) {
        return function(l) {
          var v2 = indexOf2("--")(l);
          if (v2 instanceof Just && v2.value0 === 0) {
            return Nothing.value;
          }
          ;
          if (v2 instanceof Just && v2.value0 < (col - 1 | 0)) {
            return trimCol(v2.value0 + 1 | 0)(l);
          }
          ;
          return new Just(col);
        };
      };
      var trimCol = function($copy_col) {
        return function($copy_l) {
          var $tco_var_col = $copy_col;
          var $tco_done1 = false;
          var $tco_result2;
          function $tco_loop2(col, l) {
            var v2 = codePointAt(col - 2 | 0)(l);
            if (v2 instanceof Just && isPunc(v2.value0)) {
              $tco_var_col = col - 1 | 0;
              $copy_l = l;
              return;
            }
            ;
            if (v2 instanceof Just) {
              $tco_done1 = true;
              return trimComment(col)(l);
            }
            ;
            $tco_done1 = true;
            return Nothing.value;
          }
          ;
          while (!$tco_done1) {
            $tco_result2 = $tco_loop2($tco_var_col, $copy_l);
          }
          ;
          return $tco_result2;
        };
      };
      var trimPos = function($copy_v) {
        var $tco_done2 = false;
        var $tco_result2;
        function $tco_loop2(v2) {
          if (v2.col <= 1) {
            var v1 = index(lines6)((v2.row - pos.startLine | 0) - 1 | 0);
            if (v1 instanceof Just) {
              $copy_v = {
                row: v2.row - 1 | 0,
                col: length4(v1.value0) + 1 | 0
              };
              return;
            }
            ;
            $tco_done2 = true;
            return Nothing.value;
          }
          ;
          if (otherwise) {
            var v1 = index(lines6)(v2.row - pos.startLine | 0);
            if (v1 instanceof Just) {
              var v22 = trimCol(v2.col)(v1.value0);
              if (v22 instanceof Just) {
                $tco_done2 = true;
                return new Just({
                  row: v2.row,
                  col: v22.value0
                });
              }
              ;
              if (v22 instanceof Nothing) {
                $copy_v = {
                  row: v2.row,
                  col: 1
                };
                return;
              }
              ;
              throw new Error("Failed pattern match at Spago.Psa.Output (line 232, column 13 - line 234, column 49): " + [v22.constructor.name]);
            }
            ;
            $tco_done2 = true;
            return Nothing.value;
          }
          ;
          throw new Error("Failed pattern match at Spago.Psa.Output (line 223, column 3 - line 236, column 23): " + [v2.constructor.name]);
        }
        ;
        while (!$tco_done2) {
          $tco_result2 = $tco_loop2($copy_v);
        }
        ;
        return $tco_result2;
      };
      if (lines6.length === 0) {
        $tco_done = true;
        return {
          startLine: pos.startLine,
          startColumn: pos.startColumn,
          endLine: pos.startLine,
          endColumn: pos.startColumn
        };
      }
      ;
      if (lines6.length === 1) {
        var v = trimCol(pos.endColumn)(lines6[0]);
        if (v instanceof Just) {
          $tco_done = true;
          return {
            startLine: pos.startLine,
            startColumn: pos.startColumn,
            endLine: pos.startLine,
            endColumn: v.value0
          };
        }
        ;
        if (v instanceof Nothing) {
          $tco_done = true;
          return {
            startLine: pos.startLine,
            startColumn: pos.startColumn,
            endLine: pos.startLine,
            endColumn: pos.startColumn
          };
        }
        ;
        throw new Error("Failed pattern match at Spago.Psa.Output (line 211, column 7 - line 213, column 80): " + [v.constructor.name]);
      }
      ;
      var v = trimPos({
        row: pos.endLine,
        col: pos.endColumn
      });
      if (v instanceof Just) {
        $tco_done = true;
        return {
          startLine: pos.startLine,
          startColumn: pos.startColumn,
          endLine: v.value0.row,
          endColumn: v.value0.col
        };
      }
      ;
      if (v instanceof Nothing) {
        $tco_var_lines = [];
        $copy_pos = pos;
        return;
      }
      ;
      throw new Error("Failed pattern match at Spago.Psa.Output (line 216, column 7 - line 218, column 39): " + [v.constructor.name]);
    }
    ;
    while (!$tco_done) {
      $tco_result = $tco_loop($tco_var_lines, $copy_pos);
    }
    ;
    return $tco_result;
  };
};
var trimMessage = /* @__PURE__ */ function() {
  var dedent = function(v) {
    return function(l) {
      if (l === "") {
        return {
          lines: snoc(v.lines)(l),
          indent: v.indent
        };
      }
      ;
      if (otherwise) {
        var indent$prime = length4(takeWhile3(function(v1) {
          return eq26(v1)(codePointFromChar(" "));
        })(l));
        var $95 = indent$prime < v.indent;
        if ($95) {
          return {
            lines: snoc(v.lines)(drop3(indent$prime)(l)),
            indent: indent$prime
          };
        }
        ;
        return {
          lines: snoc(v.lines)(drop3(v.indent)(l)),
          indent: v.indent
        };
      }
      ;
      throw new Error("Failed pattern match at Spago.Psa.Output (line 265, column 3 - line 272, column 71): " + [v.constructor.name, l.constructor.name]);
    };
  };
  var collapse = function(lines6) {
    return function(l) {
      var v = last(lines6);
      if (v instanceof Just && (v.value0 === "" && l === "")) {
        return lines6;
      }
      ;
      return snoc(lines6)(l);
    };
  };
  var $141 = joinWith("\n");
  var $142 = foldl9(collapse)([]);
  var $143 = foldl9(dedent)({
    lines: [],
    indent: top(boundedInt)
  });
  var $144 = split("\n");
  return function($145) {
    return trim($141($142(function(v) {
      return v.lines;
    }($143($144($145))))));
  };
}();
var onTag = function(v) {
  return function(v1) {
    return function(v2) {
      return function(v3) {
        if (v2 instanceof $$Error2) {
          return v(v3);
        }
        ;
        if (v2 instanceof Warning) {
          return v1(v3);
        }
        ;
        throw new Error("Failed pattern match at Spago.Psa.Output (line 180, column 1 - line 180, column 64): " + [v.constructor.name, v1.constructor.name, v2.constructor.name, v3.constructor.name]);
      };
    };
  };
};
var onPath = function(v) {
  return function(v1) {
    return function(v2) {
      return function(v3) {
        if (v2 instanceof Src) {
          return v(v3);
        }
        ;
        if (v2 instanceof Lib) {
          return v1(v3);
        }
        ;
        return v3;
      };
    };
  };
};
var updateStats = function(tag) {
  return function(path5) {
    return function(code) {
      return function(printed) {
        return function(s) {
          var bump = function(v) {
            return new Tuple(function() {
              if (printed) {
                return v.value0 + 1 | 0;
              }
              ;
              return v.value0;
            }(), v.value1 + 1 | 0);
          };
          var alterStat = function(v) {
            if (v instanceof Nothing) {
              return new Just(bump(new Tuple(0, 0)));
            }
            ;
            if (v instanceof Just) {
              return new Just(bump(v.value0));
            }
            ;
            throw new Error("Failed pattern match at Spago.Psa.Output (line 148, column 3 - line 148, column 46): " + [v.constructor.name]);
          };
          var bumpCode = alter(alterStat)(code);
          return {
            allWarnings: onTag(identity29)(bumpCode)(tag)(s.allWarnings),
            allErrors: onTag(bumpCode)(identity29)(tag)(s.allErrors),
            srcWarnings: onTag(identity29)(onPath(bumpCode)(identity29)(path5))(tag)(s.srcWarnings),
            srcErrors: onTag(onPath(bumpCode)(identity29)(path5))(identity29)(tag)(s.srcErrors),
            libWarnings: onTag(identity29)(onPath(identity29)(bumpCode)(path5))(tag)(s.libWarnings),
            libErrors: onTag(onPath(identity29)(bumpCode)(path5))(identity29)(tag)(s.libErrors)
          };
        };
      };
    };
  };
};
var isSrc = function(v) {
  if (v instanceof Src) {
    return true;
  }
  ;
  return false;
};
var isLib = function(v) {
  if (v instanceof Lib) {
    return true;
  }
  ;
  return false;
};
var initialStats = {
  allWarnings: empty2,
  allErrors: empty2,
  srcWarnings: empty2,
  srcErrors: empty2,
  libWarnings: empty2,
  libErrors: empty2
};
var errorPath = function(libDirs) {
  return function(path5) {
    return function($$short3) {
      var startsWith2 = function(s$prime) {
        return function(s) {
          var v = indexOf2(s)(s$prime);
          if (v instanceof Just && v.value0 === 0) {
            return true;
          }
          ;
          return false;
        };
      };
      var $122 = any5(function(dir) {
        return startsWith2(path5)(dir);
      })(libDirs);
      if ($122) {
        return new Lib($$short3);
      }
      ;
      return new Src($$short3);
    };
  };
};
var censorSrc = function(v) {
  if (v instanceof CensorAllWarnings) {
    return true;
  }
  ;
  if (v instanceof CensorProjectWarnings) {
    return true;
  }
  ;
  return false;
};
var censorLib = function(v) {
  if (v instanceof CensorAllWarnings) {
    return true;
  }
  ;
  if (v instanceof CensorProjectWarnings) {
    return true;
  }
  ;
  return false;
};
var shouldShowError = function(v) {
  return function(v1) {
    return function(v2) {
      return function(v3) {
        if (v1 instanceof $$Error2) {
          return true;
        }
        ;
        return !(censorSrc(v.censorBuildWarnings) && isSrc(v2) || censorLib(v.censorBuildWarnings) && isLib(v2)) && ((isEmpty3(v.filterCodes) || member4(v3)(v.filterCodes)) && (isEmpty3(v.censorCodes) || !member4(v3)(v.censorCodes)));
      };
    };
  };
};
var annotatedError = function(path5) {
  return function(lines6) {
    return function(error4) {
      var position2 = apply18(map66(trimPosition)(lines6))(error4.position);
      var source2 = apply18(map66(function(p) {
        return take((p.endLine - p.startLine | 0) + 1 | 0);
      })(position2))(lines6);
      var message2 = trimMessage(error4.message);
      return {
        path: path5,
        position: position2,
        message: message2,
        source: source2,
        error: error4
      };
    };
  };
};
var buildOutput = function(dictMonad) {
  var pure75 = pure(dictMonad.Applicative0());
  var bind59 = bind(dictMonad.Bind1());
  var foldM5 = foldM(dictMonad);
  return function(loadLines) {
    return function(options) {
      return function(result) {
        var pathOf = function(x) {
          if (x.filename instanceof Just && x.filename.value0 !== "") {
            var path5 = function() {
              if (isAbsolute(x.filename.value0)) {
                return x.filename.value0;
              }
              ;
              if (otherwise) {
                return concat2([cwd2, x.filename.value0]);
              }
              ;
              throw new Error("Failed pattern match at Spago.Psa.Output (line 94, column 11 - line 96, column 55): " + []);
            }();
            return new Tuple(errorPath(options.libraryDirs)(path5)(x.filename.value0), x);
          }
          ;
          return new Tuple(Unknown.value, x);
        };
        var onError3 = function(tag) {
          return function(state2) {
            return function(v) {
              var update2 = function(log5) {
                var printed = !$$null(log5);
                var tag$prime = function() {
                  var $137 = printed && (options.strict && isSrc(v.value0));
                  if ($137) {
                    return $$Error2.value;
                  }
                  ;
                  return tag;
                }();
                var stats = updateStats(tag$prime)(v.value0)(v.value1.errorCode)(printed)(state2.stats);
                return pure75(onTag(function(v1) {
                  return {
                    stats,
                    errors: append25(state2.errors)(log5),
                    warnings: v1.warnings
                  };
                })(function(v1) {
                  return {
                    stats,
                    errors: v1.errors,
                    warnings: append25(state2.warnings)(log5)
                  };
                })(tag$prime)(state2));
              };
              var $138 = shouldShowError(options)(tag)(v.value0)(v.value1.errorCode);
              if ($138) {
                return bind59(fromMaybe(pure75(Nothing.value))(apply18(map66(loadLines)(v.value1.filename))(v.value1.position)))(function(source2) {
                  return update2([annotatedError(v.value0)(source2)(v.value1)]);
                });
              }
              ;
              return update2([]);
            };
          };
        };
        var result$prime = {
          warnings: map124(pathOf)(result.warnings),
          errors: map124(pathOf)(result.errors)
        };
        var initialState = {
          warnings: [],
          errors: [],
          stats: initialStats
        };
        return bind59(foldM5(onError3(Warning.value))(initialState)(result$prime.warnings))(function(state2) {
          return bind59(foldM5(onError3($$Error2.value))(state2)(result$prime.errors))(function(state$prime) {
            return pure75({
              warnings: sortBy(compareByLocation)(state$prime.warnings),
              errors: sortBy(compareByLocation)(state$prime.errors),
              stats: state$prime.stats
            });
          });
        });
      };
    };
  };
};

// output/Spago.Psa.Printer/index.js
var lines5 = /* @__PURE__ */ lines(foldableArray);
var map67 = /* @__PURE__ */ map(functorArray);
var show30 = /* @__PURE__ */ show(showInt);
var maximum2 = /* @__PURE__ */ maximum(ordInt)(foldableArray);
var maximumBy2 = /* @__PURE__ */ maximumBy(foldableArray);
var comparing2 = /* @__PURE__ */ comparing(ordInt);
var foldWithSeparator2 = /* @__PURE__ */ foldWithSeparator(foldableArray);
var bind40 = /* @__PURE__ */ bind(bindMaybe);
var power4 = /* @__PURE__ */ power(monoidString);
var pure55 = /* @__PURE__ */ pure(applicativeMaybe);
var append113 = /* @__PURE__ */ append(semigroupDoc);
var discard17 = /* @__PURE__ */ discard(discardUnit);
var discard18 = /* @__PURE__ */ discard17(bindMaybe);
var guard9 = /* @__PURE__ */ guard2(alternativeMaybe);
var unfoldr3 = /* @__PURE__ */ unfoldr(unfoldableArray);
var mempty15 = /* @__PURE__ */ mempty(monoidDoc);
var fold16 = /* @__PURE__ */ fold(foldableArray)(monoidDoc);
var sort4 = /* @__PURE__ */ sort(ordString);
var append26 = /* @__PURE__ */ append(semigroupArray);
var words3 = /* @__PURE__ */ words(foldableArray);
var foldMap7 = /* @__PURE__ */ foldMap(foldableMaybe)(monoidDoc);
var apply19 = /* @__PURE__ */ apply2(applyMaybe);
var map125 = /* @__PURE__ */ map(functorMaybe);
var mempty16 = /* @__PURE__ */ mempty(/* @__PURE__ */ monoidFn(monoidDoc));
var forWithIndex_3 = /* @__PURE__ */ forWithIndex_(applicativeEffect)(foldableWithIndexArray);
var toLines = /* @__PURE__ */ function() {
  var $95 = map67(text);
  var $96 = split("\n");
  return function($97) {
    return lines5($95($96($97)));
  };
}();
var renderStatus = function(color) {
  return function(total) {
    return function(index4) {
      return function(code) {
        return foreground(color)(text("[" + (show30(index4) + ("/" + (show30(total) + (" " + (code + "]")))))));
      };
    };
  };
};
var renderStatCols$prime = function(v) {
  var numOfRows = fromMaybe(0)(maximum2(map67(length)([v.col1, v.col2, v.col3, v.col4])));
  var maxColWidth = function() {
    var $98 = maybe(0)(function(v1) {
      return v1.width;
    });
    var $99 = maximumBy2(comparing2(function(v1) {
      return v1.width;
    }));
    return function($100) {
      return $98($99($100));
    };
  }();
  var guttered = foldWithSeparator2(text("   "));
  var col4Width = maxColWidth(v.col4);
  var col3Width = maxColWidth(v.col3);
  var col2Width = maxColWidth(v.col2);
  var col1Width = maxColWidth(v.col1);
  var buildColumn = function(column2) {
    return function(colWidth) {
      return function(rowIdx) {
        return bind40(index(column2)(rowIdx))(function(v1) {
          var padding = colWidth - v1.width | 0;
          var padText = text(power4(" ")(padding));
          var $55 = padding === 0;
          if ($55) {
            return pure55(v1.doc);
          }
          ;
          if (v1.alignLeft) {
            return pure55(append113(v1.doc)(padText));
          }
          ;
          return pure55(append113(padText)(v1.doc));
        });
      };
    };
  };
  var buildRow = function(rowIdx) {
    return discard18(guard9(rowIdx !== numOfRows))(function() {
      return bind40(buildColumn(v.col1)(col1Width)(rowIdx))(function(c1) {
        return bind40(buildColumn(v.col2)(col2Width)(rowIdx))(function(c2) {
          return bind40(buildColumn(v.col3)(col3Width)(rowIdx))(function(c3) {
            return bind40(buildColumn(v.col4)(col4Width)(rowIdx))(function(c4) {
              return pure55(flip(Tuple.create)(rowIdx + 1 | 0)(guttered([c1, c2, c3, c4])));
            });
          });
        });
      });
    });
  };
  var rows = flip(unfoldr3)(0)(buildRow);
  return lines5(rows);
};
var renderStatCols = function(columns) {
  return renderStatCols$prime({
    col1: cons({
      width: 0,
      alignLeft: true,
      doc: mempty15
    })(columns.col1),
    col2: cons({
      width: 3,
      alignLeft: true,
      doc: text("Src")
    })(columns.col2),
    col3: cons({
      width: 3,
      alignLeft: true,
      doc: text("Lib")
    })(columns.col3),
    col4: cons({
      width: 3,
      alignLeft: true,
      doc: text("All")
    })(columns.col4)
  });
};
var renderStat = function(v) {
  if (v.value0 === 0 && v.value1 === 0) {
    return {
      width: 1,
      alignLeft: false,
      doc: foreground(BrightGreen.value)(text("0"))
    };
  }
  ;
  if (v.value0 === v.value1) {
    var aText = show30(v.value0);
    return {
      width: length4(aText),
      alignLeft: false,
      doc: text(aText)
    };
  }
  ;
  if (otherwise) {
    var aText = show30(v.value0);
    var bText = show30(v.value1);
    var width2 = (1 + length4(aText) | 0) + length4(bText) | 0;
    return {
      width: width2,
      alignLeft: false,
      doc: fold16([text(aText), dim(text("/")), text(bText)])
    };
  }
  ;
  throw new Error("Failed pattern match at Spago.Psa.Printer (line 232, column 1 - line 232, column 41): " + [v.constructor.name]);
};
var renderStats = function(stats) {
  var sumRatio = function(v) {
    return function(v1) {
      return function(v2) {
        return new Tuple(v.value0 + v2.value0 | 0, v.value1 + v2.value1 | 0);
      };
    };
  };
  var srcWarnings = fold3(sumRatio)(new Tuple(0, 0))(stats.srcWarnings);
  var srcErrors = fold3(sumRatio)(new Tuple(0, 0))(stats.srcErrors);
  var renderLabel = function(color) {
    return function(lbl) {
      return {
        width: length4(lbl),
        alignLeft: true,
        doc: foreground(color)(text(lbl))
      };
    };
  };
  var libWarnings = fold3(sumRatio)(new Tuple(0, 0))(stats.libWarnings);
  var libErrors = fold3(sumRatio)(new Tuple(0, 0))(stats.libErrors);
  var allWarnings = fold3(sumRatio)(new Tuple(0, 0))(stats.allWarnings);
  var allErrors = fold3(sumRatio)(new Tuple(0, 0))(stats.allErrors);
  return renderStatCols({
    col1: [renderLabel(BrightYellow.value)("Warnings"), renderLabel(BrightRed.value)("Errors")],
    col2: [renderStat(srcWarnings), renderStat(srcErrors)],
    col3: [renderStat(libWarnings), renderStat(libErrors)],
    col4: [renderStat(allWarnings), renderStat(allErrors)]
  });
};
var renderVerboseStats = function(stats) {
  var warnings = sort4(keys(stats.allWarnings));
  var renderLabel = function(color) {
    return function(lbl) {
      return {
        width: length4(lbl),
        alignLeft: true,
        doc: foreground(color)(text(lbl))
      };
    };
  };
  var warningLabels = map67(renderLabel(BrightYellow.value))(warnings);
  var getStat = function(key) {
    return function(x) {
      return fromMaybe(new Tuple(0, 0))(lookup2(key)(x));
    };
  };
  var getStats = function(ks) {
    return function(x) {
      return map67(function(k) {
        return renderStat(getStat(k)(x));
      })(ks);
    };
  };
  var libWarnings = getStats(warnings)(stats.libWarnings);
  var srcWarnings = getStats(warnings)(stats.srcWarnings);
  var errors = sort4(keys(stats.allErrors));
  var libErrors = getStats(errors)(stats.libErrors);
  var srcErrors = getStats(errors)(stats.srcErrors);
  var errorLabels = map67(renderLabel(BrightRed.value))(errors);
  var allWarnings = getStats(warnings)(stats.allWarnings);
  var allErrors = getStats(errors)(stats.allErrors);
  return renderStatCols({
    col1: append26(warningLabels)(errorLabels),
    col2: append26(srcWarnings)(srcErrors),
    col3: append26(libWarnings)(libErrors),
    col4: append26(allWarnings)(allErrors)
  });
};
var renderPosition = function(pos) {
  return fold16([dim(text(":")), text(show30(pos.startLine)), dim(text(":")), text(show30(pos.startColumn))]);
};
var renderModuleName = function(v) {
  if (v instanceof Nothing) {
    return dim(text("(unknown module)"));
  }
  ;
  if (v instanceof Just) {
    return text(v.value0);
  }
  ;
  throw new Error("Failed pattern match at Spago.Psa.Printer (line 99, column 1 - line 99, column 61): " + [v.constructor.name]);
};
var renderPath = function(v) {
  return function(v1) {
    if (v instanceof Src) {
      return text(v.value0);
    }
    ;
    if (v instanceof Lib) {
      return text(v.value0);
    }
    ;
    return renderModuleName(v1);
  };
};
var renderErrorTick = function(start) {
  return function($$char5) {
    return fold16([text(power4(" ")(start - 1 | 0)), foreground(BrightRed.value)(text($$char5))]);
  };
};
var renderErrorRange = function(start) {
  return function(len) {
    return fold16([text(power4(" ")(start - 1 | 0)), foreground(BrightRed.value)(text(power4("^")(len)))]);
  };
};
var renderAnnotation = function(offset) {
  return function(pos) {
    return function(lines1) {
      return lines5(function() {
        if (lines1.length === 1) {
          return [lines1[0], renderErrorRange(pos.startColumn + offset | 0)(pos.endColumn - pos.startColumn | 0)];
        }
        ;
        return [renderErrorTick(pos.startColumn + offset | 0)("v"), lines5(lines1), renderErrorTick((pos.endColumn + offset | 0) - 1 | 0)("^")];
      }());
    };
  };
};
var printJsonOutputToOut = function(output5) {
  var result = encode(psaResultCodec)({
    warnings: map67(function(v) {
      return v.error;
    })(output5.warnings),
    errors: map67(function(v) {
      return v.error;
    })(output5.errors)
  });
  return log2(stringify(result));
};
var padLeft = function(width2) {
  return function(str2) {
    return power4(" ")(width2 - length4(str2) | 0) + str2;
  };
};
var sourceLine = function(gutter) {
  return function(sep2) {
    return function(num) {
      return function(code) {
        return fold16([dim(text(padLeft(gutter)(show30(num)) + sep2)), text(code)]);
      };
    };
  };
};
var renderSource = function(pos) {
  return function(lines1) {
    var lineNums = range(pos.startLine)(pos.endLine);
    var gutter = length4(show30(pos.endLine));
    var source2 = map67(uncurry(sourceLine(gutter)("  ")))(zip(lineNums)(lines1));
    var source$prime = function() {
      var $84 = length(source2) > 7;
      if ($84) {
        return append26(take(3)(source2))(append26([append113(text(power4(" ")(gutter + 2 | 0)))(dim(text("...")))])(drop(length(source2) - 3 | 0)(source2)));
      }
      ;
      return source2;
    }();
    return renderAnnotation(gutter + 2 | 0)(pos)(source$prime);
  };
};
var renderSource$prime = function(pos) {
  return function(lines1) {
    return append113(renderSource(pos)(lines1))($$break);
  };
};
var renderWrapper = function(color) {
  return function(total) {
    return function(index4) {
      return function(v) {
        return foldWithSeparator2(append113($$break)($$break))([words3([renderStatus(color)(total)(index4)(v.error.errorCode), append113(renderPath(v.path)(v.error.moduleName))(foldMap7(renderPosition)(v.position))]), indent(lines5([fromMaybe(mempty15)(apply19(map125(renderSource$prime)(v.position))(v.source)), toLines(v.message)]))]);
      };
    };
  };
};
var renderError = /* @__PURE__ */ function() {
  return renderWrapper(BrightRed.value);
}();
var renderWarning = /* @__PURE__ */ function() {
  return renderWrapper(BrightYellow.value);
}();
var printDefaultOutputToErr = function(options) {
  return function(output5) {
    var renderStats$prime = function() {
      if (options.statVerbosity instanceof NoStats) {
        return mempty16;
      }
      ;
      if (options.statVerbosity instanceof CompactStats) {
        return renderStats;
      }
      ;
      if (options.statVerbosity instanceof VerboseStats) {
        return renderVerboseStats;
      }
      ;
      throw new Error("Failed pattern match at Spago.Psa.Printer (line 68, column 18 - line 71, column 44): " + [options.statVerbosity.constructor.name]);
    }();
    var printDoc = function() {
      if (options.color) {
        return print(ansiGraphics)(twoSpaces);
      }
      ;
      if (otherwise) {
        return print(plainText)(twoSpaces);
      }
      ;
      throw new Error("Failed pattern match at Spago.Psa.Printer (line 63, column 3 - line 65, column 50): " + []);
    }();
    var lenWarnings = length(output5.warnings);
    var lenErrors = length(output5.errors);
    return function __do3() {
      forWithIndex_3(output5.warnings)(function(i) {
        return function(warning) {
          return function __do4() {
            error2(printDoc(renderWarning(lenWarnings)(i + 1 | 0)(warning)))();
            return error2("")();
          };
        };
      })();
      forWithIndex_3(output5.errors)(function(i) {
        return function(error4) {
          return function __do4() {
            error2(printDoc(renderError(lenErrors)(i + 1 | 0)(error4)))();
            return error2("")();
          };
        };
      })();
      return error2(printDoc(renderStats$prime(output5.stats)))();
    };
  };
};

// output/Spago.Purs/index.js
var bind41 = /* @__PURE__ */ bind(bindSpago);
var ask6 = /* @__PURE__ */ ask(monadAskSpago);
var append27 = /* @__PURE__ */ append(semigroupArray);
var toUnfoldable17 = /* @__PURE__ */ toUnfoldable6(unfoldableArray);
var exec3 = /* @__PURE__ */ exec(monadAffSpago);
var discard19 = /* @__PURE__ */ discard(discardUnit)(bindSpago);
var logDebug5 = /* @__PURE__ */ logDebug(monadEffectSpago)(monadAskSpago);
var loggableArray4 = /* @__PURE__ */ loggableArray(loggableString);
var logDebug12 = /* @__PURE__ */ logDebug5(loggableArray4);
var logDebug23 = /* @__PURE__ */ logDebug5(loggableString);
var pure56 = /* @__PURE__ */ pure(applicativeSpago);
var showMaybe3 = /* @__PURE__ */ showMaybe(showString);
var show31 = /* @__PURE__ */ show(/* @__PURE__ */ showRecord()()(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "escapedCommand";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "exitCode";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "failed";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "isCanceled";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "killed";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "message";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "originalMessage";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "shortMessage";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "signal";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "signalDescription";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "stderr";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "stdout";
  }
})(/* @__PURE__ */ showRecordFieldsConsNil({
  reflectSymbol: function() {
    return "timedOut";
  }
})(showBoolean))(showString))(showString))(showMaybe3))(/* @__PURE__ */ showMaybe(/* @__PURE__ */ showEither(showInt)(showString))))(showString))(showMaybe3))(showString))(showBoolean))(showBoolean))(showBoolean))(/* @__PURE__ */ showMaybe(showInt)))(showString)));
var die4 = /* @__PURE__ */ die(monadEffectSpago)(monadAskSpago);
var die12 = /* @__PURE__ */ die4(loggableArray4);
var die23 = /* @__PURE__ */ die4(loggableString);
var ModuleGraph = function(x) {
  return x;
};
var repl = function(globs) {
  return function(pursArgs2) {
    return bind41(ask6)(function(v) {
      var args = append27(["repl"])(append27(pursArgs2)(toUnfoldable17(globs)));
      return exec3(v.purs.cmd)(args)({
        pipeStdin: StdinPipeParent.value,
        pipeStdout: true,
        pipeStderr: true,
        cwd: defaultExecOptions.cwd
      });
    });
  };
};
var moduleGraphNodeCodec = /* @__PURE__ */ object2()(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(rowListCodecNil)()()({
  reflectSymbol: function() {
    return "path";
  }
}))()()({
  reflectSymbol: function() {
    return "depends";
  }
}))("ModuleGraphNode")({
  path: string,
  depends: /* @__PURE__ */ array(string)
});
var moduleGraphCodec = /* @__PURE__ */ function() {
  return wrapIso(profunctorCodec(functorEither))()(ModuleGraph)(strMap(ordString)("ModuleGraph")(Just.create)(identity(categoryFn))(moduleGraphNodeCodec));
}();
var graph = function(globs) {
  return function(pursArgs2) {
    return bind41(ask6)(function(v) {
      var args = append27(["graph"])(append27(pursArgs2)(toUnfoldable17(globs)));
      return discard19(logDebug12(["Running command:", "purs " + joinWith(" ")(args)]))(function() {
        var execOpts = {
          pipeStdout: false,
          pipeStderr: false,
          cwd: defaultExecOptions.cwd,
          pipeStdin: defaultExecOptions.pipeStdin
        };
        return bind41(exec3(v.purs.cmd)(args)(execOpts))(function(v1) {
          if (v1 instanceof Right) {
            return discard19(logDebug23("Called `purs graph`, decoding.."))(function() {
              return pure56(parseJson(moduleGraphCodec)(v1.value0.stdout));
            });
          }
          ;
          if (v1 instanceof Left) {
            return discard19(logDebug23(show31(v1.value0)))(function() {
              return die12(["Failed to call `purs graph`, error: " + v1.value0.shortMessage]);
            });
          }
          ;
          throw new Error("Failed pattern match at Spago.Purs (line 118, column 39 - line 124, column 73): " + [v1.constructor.name]);
        });
      });
    });
  };
};
var getPurs = /* @__PURE__ */ function() {
  var pursVersion = function(cmd) {
    return exec3(cmd)(["--version"])({
      pipeStdin: defaultExecOptions.pipeStdin,
      pipeStdout: false,
      pipeStderr: false,
      cwd: defaultExecOptions.cwd
    });
  };
  var dropStuff = function(pattern) {
    var $136 = fromMaybe("");
    var $137 = split(pattern);
    return function($138) {
      return $136(head($137($138)));
    };
  };
  var parseVersionOutput = function(cmd) {
    return function(result) {
      var v = parseLenientVersion(dropStuff("-")(dropStuff(" ")(result.stdout)));
      if (v instanceof Left) {
        return die23("Failed to parse purs version. Was: " + result.stdout);
      }
      ;
      if (v instanceof Right) {
        var $121 = minor(v.value0) >= 15 && patch(v.value0) >= 4;
        if ($121) {
          return pure56({
            cmd,
            version: v.value0
          });
        }
        ;
        return die12(["Unsupported PureScript version " + print3(v.value0), "Please install PureScript v0.15.4 or higher."]);
      }
      ;
      throw new Error("Failed pattern match at Spago.Purs (line 57, column 35 - line 64, column 117): " + [v.constructor.name]);
    };
  };
  var complain = function(err) {
    return discard19(logDebug23(show31(err)))(function() {
      return die12(["Failed to find purs. Have you installed it, and is it in your PATH?"]);
    });
  };
  if (platform instanceof Just && platform.value0 instanceof Win32) {
    return bind41(pursVersion("purs.cmd"))(function(v) {
      if (v instanceof Right) {
        return parseVersionOutput("purs.cmd")(v.value0);
      }
      ;
      if (v instanceof Left) {
        return discard19(logDebug12(["Failed to find purs.cmd. Trying with just purs...", show31(v.value0)]))(function() {
          return bind41(pursVersion("purs"))(function(v1) {
            if (v1 instanceof Right) {
              return parseVersionOutput("purs")(v1.value0);
            }
            ;
            if (v1 instanceof Left) {
              return complain(v1.value0);
            }
            ;
            throw new Error("Failed pattern match at Spago.Purs (line 37, column 34 - line 39, column 37): " + [v1.constructor.name]);
          });
        });
      }
      ;
      throw new Error("Failed pattern match at Spago.Purs (line 33, column 34 - line 39, column 37): " + [v.constructor.name]);
    });
  }
  ;
  return bind41(pursVersion("purs"))(function(v) {
    if (v instanceof Right) {
      return parseVersionOutput("purs")(v.value0);
    }
    ;
    if (v instanceof Left) {
      return complain(v.value0);
    }
    ;
    throw new Error("Failed pattern match at Spago.Purs (line 42, column 30 - line 44, column 33): " + [v.constructor.name]);
  });
}();
var compile = function(globs) {
  return function(pursArgs2) {
    return bind41(ask6)(function(v) {
      var args = append27(["compile"])(append27(pursArgs2)(toUnfoldable17(globs)));
      return discard19(logDebug12(["Running command:", "purs " + joinWith(" ")(args)]))(function() {
        return exec3(v.purs.cmd)(args)({
          pipeStdin: defaultExecOptions.pipeStdin,
          pipeStdout: false,
          pipeStderr: defaultExecOptions.pipeStderr,
          cwd: defaultExecOptions.cwd
        });
      });
    });
  };
};

// output/Spago.Psa/index.js
var bind42 = /* @__PURE__ */ bind(bindSpago);
var liftEffect8 = /* @__PURE__ */ liftEffect(monadEffectSpago);
var filterA2 = /* @__PURE__ */ filterA(applicativeSpago);
var pure57 = /* @__PURE__ */ pure(applicativeSpago);
var member5 = /* @__PURE__ */ member2(ordString);
var map68 = /* @__PURE__ */ map(functorEffect);
var liftAff5 = /* @__PURE__ */ liftAff(monadAffSpago);
var $$try7 = /* @__PURE__ */ $$try2(monadErrorAff);
var map126 = /* @__PURE__ */ map(functorAff);
var greaterThan4 = /* @__PURE__ */ greaterThan(ordDateTime);
var identity30 = /* @__PURE__ */ identity(categoryFn);
var append28 = /* @__PURE__ */ append(semigroupArray);
var try12 = /* @__PURE__ */ $$try2(monadErrorErrorSpago);
var discard20 = /* @__PURE__ */ discard(discardUnit)(bindSpago);
var foldr10 = /* @__PURE__ */ foldr(foldableArray);
var insert13 = /* @__PURE__ */ insert4(ordString);
var logDebug6 = /* @__PURE__ */ logDebug(monadEffectSpago)(monadAskSpago)(loggableString);
var unless4 = /* @__PURE__ */ unless(applicativeSpago);
var map216 = /* @__PURE__ */ map(functorFn);
var bind116 = /* @__PURE__ */ bind(bindEither);
var lmap13 = /* @__PURE__ */ lmap(bifunctorEither);
var forWithIndex2 = /* @__PURE__ */ forWithIndex(applicativeSpago)(traversableWithIndexArray);
var logWarn3 = /* @__PURE__ */ logWarn(monadEffectSpago)(monadAskSpago)(loggableString);
var intercalate10 = /* @__PURE__ */ intercalate2(monoidString);
var show33 = /* @__PURE__ */ show(showInt);
var eq27 = /* @__PURE__ */ eq(eqShowSourceCode);
var for_6 = /* @__PURE__ */ for_(applicativeSpago)(foldableMaybe);
var buildOutput2 = /* @__PURE__ */ buildOutput(monadSpago);
var logSuccess3 = /* @__PURE__ */ logSuccess(monadEffectSpago)(monadAskSpago)(loggableString);
var showMaybe4 = /* @__PURE__ */ showMaybe(showString);
var show113 = /* @__PURE__ */ show(/* @__PURE__ */ showRecord()()(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "escapedCommand";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "exitCode";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "failed";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "isCanceled";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "killed";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "message";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "originalMessage";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "shortMessage";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "signal";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "signalDescription";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "stderr";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "stdout";
  }
})(/* @__PURE__ */ showRecordFieldsConsNil({
  reflectSymbol: function() {
    return "timedOut";
  }
})(showBoolean))(showString))(showString))(showMaybe4))(/* @__PURE__ */ showMaybe(/* @__PURE__ */ showEither(showInt)(showString))))(showString))(showMaybe4))(showString))(showBoolean))(showBoolean))(showBoolean))(/* @__PURE__ */ showMaybe(showInt)))(showString)));
var die5 = /* @__PURE__ */ die(monadEffectSpago)(monadAskSpago)(/* @__PURE__ */ loggableArray(loggableString));
var toOutputOptions = function(v) {
  return function(options) {
    return {
      color: v.color,
      censorBuildWarnings: options.censorBuildWarnings,
      censorCodes: options.censorCodes,
      filterCodes: options.filterCodes,
      statVerbosity: options.statVerbosity,
      libraryDirs: v.libraryDirs,
      strict: options.strict
    };
  };
};
var psaCompile = function(globs) {
  return function(pursArgs2) {
    return function(psaArgs) {
      return function(v) {
        var mergeWarnings = function(filenames) {
          return function(date2) {
            return function(old) {
              return function($$new4) {
                return bind42(liftEffect8($$new(empty2)))(function(fileStat) {
                  return bind42(flip(filterA2)(old)(function(x) {
                    if (x.filename instanceof Nothing) {
                      return pure57(false);
                    }
                    ;
                    if (x.filename instanceof Just) {
                      var $128 = member5(x.filename.value0)(filenames);
                      if ($128) {
                        return pure57(false);
                      }
                      ;
                      return bind42(liftEffect8(map68(lookup2(x.filename.value0))(read(fileStat))))(function(stat6) {
                        if (stat6 instanceof Just) {
                          return pure57(stat6.value0);
                        }
                        ;
                        if (stat6 instanceof Nothing) {
                          return bind42(liftAff5($$try7(map126(function($156) {
                            return function(v1) {
                              return greaterThan4(date2)(v1);
                            }(modifiedTime($156));
                          })(stat3(x.filename.value0)))))(function(s) {
                            var s$prime = either($$const(false))(identity30)(s);
                            return bind42(liftEffect8(modify_(insert2(x.filename.value0)(s$prime))(fileStat)))(function() {
                              return pure57(s$prime);
                            });
                          });
                        }
                        ;
                        throw new Error("Failed pattern match at Spago.Psa (line 183, column 13 - line 189, column 24): " + [stat6.constructor.name]);
                      });
                    }
                    ;
                    throw new Error("Failed pattern match at Spago.Psa (line 177, column 7 - line 189, column 24): " + [x.filename.constructor.name]);
                  }))(function(old$prime) {
                    return pure57(append28(old$prime)($$new4));
                  });
                });
              };
            };
          };
        };
        var loadNothing = function(v1) {
          return function(v2) {
            return pure57(Nothing.value);
          };
        };
        var isEmptySpan = function(filename) {
          return function(pos) {
            return filename === "" || pos.startLine === 0 && (pos.endLine === 0 && (pos.startColumn === 0 && pos.endColumn === 0));
          };
        };
        var loadLines = function(files) {
          return function(filename) {
            return function(pos) {
              if (isEmptySpan(filename)(pos)) {
                return pure57(Nothing.value);
              }
              ;
              if (otherwise) {
                return bind42(try12(bind42(liftEffect8(map68(lookup2(filename))(read(files))))(function(cache) {
                  return bind42(function() {
                    if (cache instanceof Just) {
                      return pure57(cache.value0);
                    }
                    ;
                    if (cache instanceof Nothing) {
                      return bind42(liftAff5(map126(split("\n"))(readTextFile2(UTF8.value)(filename))))(function(lines6) {
                        return discard20(liftEffect8(modify_(insert2(filename)(lines6))(files)))(function() {
                          return pure57(lines6);
                        });
                      });
                    }
                    ;
                    throw new Error("Failed pattern match at Spago.Psa (line 129, column 13 - line 134, column 27): " + [cache.constructor.name]);
                  }())(function(contents) {
                    var source2 = slice(pos.startLine - 1 | 0)(pos.endLine)(contents);
                    return pure57(new Just(source2));
                  });
                })))(function(result) {
                  return either($$const(pure57(Nothing.value)))(pure57)(result);
                });
              }
              ;
              throw new Error("Failed pattern match at Spago.Psa (line 123, column 3 - line 137, column 50): " + [files.constructor.name, filename.constructor.name, pos.constructor.name]);
            };
          };
        };
        var insertFilenames = foldr10(function(x) {
          return function(s) {
            return maybe(s)(flip(insert13)(s))(x.filename);
          };
        });
        var encodeStash = function(s) {
          return encode(array(psaErrorCodec))(s);
        };
        var writeStashFile = function(stashFile$prime) {
          return function(warnings) {
            return discard20(logDebug6("Writing stash file: " + stashFile$prime))(function() {
              var file = stringify(encodeStash(warnings));
              var dir = dirname(stashFile$prime);
              return bind42(liftEffect8(exists(dir)))(function(dirExists) {
                return discard20(unless4(dirExists)(liftAff5(mkdir$prime2(dir)({
                  recursive: true,
                  mode: permsAll
                }))))(function() {
                  return liftAff5(writeTextFile2(UTF8.value)(stashFile$prime)(file));
                });
              });
            });
          };
        };
        var emptyStash = discard20(logDebug6("Using empty stash"))(function() {
          return liftEffect8(map68(map216(function(v1) {
            return {
              date: v1,
              stash: []
            };
          })(toDateTime))(now2));
        });
        var decodeStash = function(s) {
          return bind116(jsonParser(s))(function() {
            var $157 = lmap13(printJsonDecodeError);
            var $158 = decode(array(psaErrorCodec));
            return function($159) {
              return $157($158($159));
            };
          }());
        };
        var readStashFile = function(stashFile$prime) {
          return discard20(logDebug6("About to read stash file: " + stashFile$prime))(function() {
            return bind42(try12(bind42(liftAff5(stat3(stashFile$prime)))(function(stat6) {
              return bind42(liftAff5(readTextFile2(UTF8.value)(stashFile$prime)))(function(file) {
                var v1 = decodeStash(file);
                if (v1 instanceof Left) {
                  return discard20(logDebug6("Error decoding stash file: " + v1.value0))(function() {
                    return emptyStash;
                  });
                }
                ;
                if (v1 instanceof Right) {
                  return discard20(logDebug6("Successfully decoded stash file"))(function() {
                    return pure57({
                      date: modifiedTime(stat6),
                      stash: v1.value0
                    });
                  });
                }
                ;
                throw new Error("Failed pattern match at Spago.Psa (line 151, column 7 - line 157, column 64): " + [v1.constructor.name]);
              });
            })))(function(result) {
              if (result instanceof Left) {
                return discard20(logDebug6("Reading stash file failed: " + message(result.value0)))(function() {
                  return emptyStash;
                });
              }
              ;
              if (result instanceof Right) {
                return pure57(result.value0);
              }
              ;
              throw new Error("Failed pattern match at Spago.Psa (line 158, column 5 - line 162, column 32): " + [result.constructor.name]);
            });
          });
        };
        var outputOptions = toOutputOptions(psaArgs)(v);
        return bind42(function() {
          if (v.stashFile instanceof Just) {
            return readStashFile(v.stashFile.value0);
          }
          ;
          if (v.stashFile instanceof Nothing) {
            return emptyStash;
          }
          ;
          throw new Error("Failed pattern match at Spago.Psa (line 76, column 16 - line 78, column 26): " + [v.stashFile.constructor.name]);
        }())(function(stashData) {
          return bind42(compile(globs)(snoc(pursArgs2)("--json-errors")))(function(result) {
            var result$prime = function() {
              if (result instanceof Left) {
                return {
                  output: result.value0.stdout,
                  exitCode: result.value0.exitCode,
                  err: new Just(result.value0)
                };
              }
              ;
              if (result instanceof Right) {
                return {
                  output: result.value0.stdout,
                  exitCode: new Just(result.value0.exitCode),
                  err: Nothing.value
                };
              }
              ;
              throw new Error("Failed pattern match at Spago.Psa (line 82, column 15 - line 84, column 97): " + [result.constructor.name]);
            }();
            return bind42(forWithIndex2(split("\n")(result$prime.output))(function(idx) {
              return function(err) {
                var v1 = bind116(jsonParser(err))(function() {
                  var $160 = lmap13(printJsonDecodeError);
                  var $161 = decode(psaResultCodec);
                  return function($162) {
                    return $160($161($162));
                  };
                }());
                if (v1 instanceof Left) {
                  return discard20(logWarn3(intercalate10("\n")(["Failed to decode PsaResult at index '" + (show33(idx) + ("': " + v1.value0)), "Json was: " + err])))(function() {
                    return pure57(true);
                  });
                }
                ;
                if (v1 instanceof Right) {
                  return bind42(liftEffect8($$new(empty2)))(function(files) {
                    var loadLinesImpl = function() {
                      var $150 = eq27(v.showSource)(ShowSourceCode.value);
                      if ($150) {
                        return loadLines(files);
                      }
                      ;
                      return loadNothing;
                    }();
                    var filenames = insertFilenames(insertFilenames(empty4)(v1.value0.errors))(v1.value0.warnings);
                    return bind42(mergeWarnings(filenames)(stashData.date)(stashData.stash)(v1.value0.warnings))(function(merged) {
                      return discard20(for_6(v.stashFile)(function(f) {
                        return writeStashFile(f)(merged);
                      }))(function() {
                        return bind42(buildOutput2(loadLinesImpl)(outputOptions)({
                          warnings: merged,
                          errors: v1.value0.errors
                        }))(function(out$prime) {
                          return discard20(liftEffect8(function() {
                            if (psaArgs.jsonErrors) {
                              return printJsonOutputToOut(out$prime);
                            }
                            ;
                            return printDefaultOutputToErr(outputOptions)(out$prime);
                          }()))(function() {
                            return pure57(isEmpty(out$prime.stats.allErrors));
                          });
                        });
                      });
                    });
                  });
                }
                ;
                throw new Error("Failed pattern match at Spago.Psa (line 86, column 5 - line 107, column 47): " + [v1.constructor.name]);
              };
            }))(function(arrErrorsIsEmpty) {
              var $153 = all(identity30)(arrErrorsIsEmpty);
              if ($153) {
                return logSuccess3("Build succeeded.");
              }
              ;
              return discard20(for_6(result$prime.err)(function($163) {
                return logDebug6(show113($163));
              }))(function() {
                return die5(["Failed to build."]);
              });
            });
          });
        });
      };
    };
  };
};
var defaultParseOptions = /* @__PURE__ */ function() {
  return {
    showSource: ShowSourceCode.value,
    stashFile: Nothing.value,
    censorBuildWarnings: CensorNoWarnings.value,
    censorCodes: empty4,
    filterCodes: empty4,
    statVerbosity: CompactStats.value,
    strict: false
  };
}();

// output/Spago.Purs.Graph/index.js
var loggableArray5 = /* @__PURE__ */ loggableArray(loggableDocc);
var toDoc5 = /* @__PURE__ */ toDoc2(loggableArray5);
var toDoc14 = /* @__PURE__ */ toDoc2(loggableString);
var toDoc23 = /* @__PURE__ */ toDoc2(/* @__PURE__ */ loggableArray(loggableString));
var map69 = /* @__PURE__ */ map(functorArray);
var toUnfoldable18 = /* @__PURE__ */ toUnfoldable6(unfoldableArray);
var fromFoldable21 = /* @__PURE__ */ fromFoldable(foldableSet);
var toUnfoldable19 = /* @__PURE__ */ toUnfoldable5(unfoldableArray);
var bind43 = /* @__PURE__ */ bind(bindSpago);
var match3 = /* @__PURE__ */ match2(monadAffSpago);
var discard21 = /* @__PURE__ */ discard(discardUnit)(bindSpago);
var unless5 = /* @__PURE__ */ unless(applicativeSpago);
var logDebug7 = /* @__PURE__ */ logDebug(monadEffectSpago)(monadAskSpago)(loggableArray5);
var pure58 = /* @__PURE__ */ pure(applicativeSpago);
var append114 = /* @__PURE__ */ append(semigroupArray);
var ask7 = /* @__PURE__ */ ask(monadAskSpago);
var unwrap14 = /* @__PURE__ */ unwrap();
var insert14 = /* @__PURE__ */ insert3(ordPackageName);
var map127 = /* @__PURE__ */ map(functorSpago);
var fromFoldable111 = /* @__PURE__ */ fromFoldable6(ordString)(foldableArray);
var fold17 = /* @__PURE__ */ fold2(monoidArray);
var $$for5 = /* @__PURE__ */ $$for(applicativeSpago)(traversableArray);
var eq28 = /* @__PURE__ */ eq(eqPackageName);
var traverse9 = /* @__PURE__ */ traverse(traversableArray)(applicativeSpago);
var fromFoldable24 = /* @__PURE__ */ fromFoldable7(foldableArray)(ordString);
var mapMaybe5 = /* @__PURE__ */ mapMaybe3(ordPackageName);
var union7 = /* @__PURE__ */ union3(ordPackageName);
var bind117 = /* @__PURE__ */ bind(bindMaybe);
var lookup8 = /* @__PURE__ */ lookup3(ordString);
var pure117 = /* @__PURE__ */ pure(applicativeMaybe);
var insert1 = /* @__PURE__ */ insert3(ordString);
var foldl10 = /* @__PURE__ */ foldl(foldableArray);
var filterWithKey2 = /* @__PURE__ */ filterWithKey(ordString);
var member6 = /* @__PURE__ */ member2(ordString);
var alter3 = /* @__PURE__ */ alter2(ordPackageName);
var alter1 = /* @__PURE__ */ alter2(ordString);
var insert22 = /* @__PURE__ */ insert4(ordString);
var difference4 = /* @__PURE__ */ difference2(ordPackageName);
var logWarn4 = /* @__PURE__ */ logWarn(monadEffectSpago)(monadAskSpago)(loggableString);
var runSpago3 = /* @__PURE__ */ runSpago(monadAffSpago);
var union1 = /* @__PURE__ */ union5();
var unusedError = function(isTest) {
  return function(selected) {
    return function(unused) {
      return toDoc5([toDoc14(function() {
        if (isTest) {
          return "Tests for package '";
        }
        ;
        return "Sources for package '";
      }() + (print2(selected["package"].name) + "' declares unused dependencies - please remove them from the project config:")), indent(toDoc23(map69(function(p) {
        return print2(p);
      })(toUnfoldable18(unused))))]);
    };
  };
};
var transitiveError = function(isTest) {
  return function(selected) {
    return function(transitive2) {
      return toDoc5([toDoc14(function() {
        if (isTest) {
          return "Tests for package '";
        }
        ;
        return "Sources for package '";
      }() + (print2(selected["package"].name) + "' import the following transitive dependencies - please add them to the project dependencies, or remove the imports:")), indent(toDoc5(map69(function(v) {
        return toDoc5([toDoc14(print2(v.value0)), indent(toDoc5(map69(function(v1) {
          return toDoc5([toDoc14("from `" + (v1.value0 + "`, which imports:")), indent(toDoc23(fromFoldable21(v1.value1)))]);
        })(toUnfoldable19(v.value1))))]);
      })(toUnfoldable19(transitive2)))), $$break, toDoc14("Run the following command to install them all:"), indent(toDoc14("spago install " + (function() {
        if (isTest) {
          return "--test-deps ";
        }
        ;
        return "";
      }() + ("-p " + (print2(selected["package"].name) + (" " + joinWith(" ")(map69(print2)(toUnfoldable18(keys3(transitive2))))))))))]);
    };
  };
};
var compileGlob = function(sourcePath) {
  return bind43(match3(cwd2)([sourcePath]))(function(v) {
    return discard21(unless5($$null(v.failed))(logDebug7([toDoc14("Encountered some globs that are not in cwd, proceeding anyways:"), indent(toDoc23(v.failed))])))(function() {
      return pure58(append114(v.succeeded)(v.failed));
    });
  });
};
var checkImports = /* @__PURE__ */ bind43(ask7)(function(v) {
  var declaredDependencies = unwrap14(v["selected"]["package"].dependencies);
  var declaredTestDependencies = maybe(empty3)(function($137) {
    return unwrap14(function(v1) {
      return v1.dependencies;
    }($137));
  })(v["selected"]["package"].test);
  var testPackageName = print2(v["selected"]["package"].name) + ":test";
  var allPackages = insert14(v["selected"]["package"].name)(new WorkspacePackage(v.selected))(insert14(testPackageName)(new WorkspacePackage(v.selected))(v.dependencies));
  return bind43(map127(function($138) {
    return fromFoldable111(fold17($138));
  })($$for5(toUnfoldable19(allPackages))(function(v1) {
    var withTestGlobs = function() {
      var $87 = eq28(v1.value0)(testPackageName);
      if ($87) {
        return OnlyTestGlobs.value;
      }
      ;
      return NoTestGlobs.value;
    }();
    return bind43(map127(fold17)(traverse9(compileGlob)(sourceGlob(withTestGlobs)(v1.value0)(v1.value1))))(function(v2) {
      return pure58(map69(function(p) {
        return new Tuple(p, v1.value0);
      })(v2));
    });
  })))(function(v1) {
    return bind43(map127(fromFoldable24)(map127(fold17)(traverse9(compileGlob)(sourceGlob(NoTestGlobs.value)(v["selected"]["package"].name)(new WorkspacePackage(v.selected))))))(function(v2) {
      return bind43(map127(fromFoldable24)(map127(fold17)(traverse9(compileGlob)(sourceGlob(OnlyTestGlobs.value)(v["selected"]["package"].name)(new WorkspacePackage(v.selected))))))(function(v3) {
        var dependencyTestPackages = mapMaybe5($$const(new Just(empty3)))(union7(declaredDependencies)(declaredTestDependencies));
        var dependencyPackages = mapMaybe5($$const(new Just(empty3)))(declaredDependencies);
        var addPackageInfo = function(pkgGraph) {
          return function(v4) {
            var newVal = bind117(lookup8(v4.value1.path)(v1))(function($$package2) {
              return pure117({
                path: v4.value1.path,
                depends: v4.value1.depends,
                "package": $$package2
              });
            });
            return maybe(pkgGraph)(function(v5) {
              return insert1(v4.value0)(v5)(pkgGraph);
            })(newVal);
          };
        };
        var packageGraph = foldl10(addPackageInfo)(empty3)(toUnfoldable19(v.graph));
        var projectGraph = filterWithKey2(function(v4) {
          return function(v5) {
            return member6(v5.path)(v2);
          };
        })(packageGraph);
        var projectTestsGraph = filterWithKey2(function(v4) {
          return function(v5) {
            return member6(v5.path)(v3);
          };
        })(packageGraph);
        var accumulateImported = function(importedPkgs$prime) {
          return function(v4) {
            var accumulateDep = function(importedPkgs) {
              return function(importedModule) {
                var v5 = lookup8(importedModule)(packageGraph);
                if (v5 instanceof Nothing) {
                  return importedPkgs;
                }
                ;
                if (v5 instanceof Just && eq28(v5["value0"]["package"])(v["selected"]["package"].name)) {
                  return importedPkgs;
                }
                ;
                if (v5 instanceof Just && eq28(v5["value0"]["package"])(testPackageName)) {
                  return importedPkgs;
                }
                ;
                if (v5 instanceof Just) {
                  return alter3(function(v6) {
                    if (v6 instanceof Nothing) {
                      return new Just(singleton10(v4.value0)(singleton11(importedModule)));
                    }
                    ;
                    if (v6 instanceof Just) {
                      return new Just(alter1(function(v7) {
                        if (v7 instanceof Nothing) {
                          return new Just(singleton11(importedModule));
                        }
                        ;
                        if (v7 instanceof Just) {
                          return new Just(insert22(importedModule)(v7.value0));
                        }
                        ;
                        throw new Error("Failed pattern match at Spago.Purs.Graph (line 123, column 21 - line 125, column 71): " + [v7.constructor.name]);
                      })(v4.value0)(v6.value0));
                    }
                    ;
                    throw new Error("Failed pattern match at Spago.Purs.Graph (line 120, column 15 - line 128, column 20): " + [v6.constructor.name]);
                  })(v5["value0"]["package"])(importedPkgs);
                }
                ;
                throw new Error("Failed pattern match at Spago.Purs.Graph (line 114, column 53 - line 131, column 25): " + [v5.constructor.name]);
              };
            };
            return foldl10(accumulateDep)(importedPkgs$prime)(v4.value1.depends);
          };
        };
        var importedPackages = foldl10(accumulateImported)(empty3)(toUnfoldable19(projectGraph));
        var transitive2 = difference4(importedPackages)(dependencyPackages);
        var unused = keys3(difference4(dependencyPackages)(importedPackages));
        var importedTestPackages = foldl10(accumulateImported)(empty3)(toUnfoldable19(projectTestsGraph));
        var transitiveTest = function() {
          var $120 = isEmpty3(v3);
          if ($120) {
            return empty3;
          }
          ;
          return difference4(importedTestPackages)(dependencyTestPackages);
        }();
        var unusedTest = function() {
          var $121 = isEmpty3(v3);
          if ($121) {
            return empty4;
          }
          ;
          return keys3(difference4(difference4(dependencyTestPackages)(dependencyPackages))(importedTestPackages));
        }();
        return pure58({
          unused,
          transitive: transitive2,
          unusedTest,
          transitiveTest
        });
      });
    });
  });
});
var runGraphCheck = function(selected) {
  return function(globs) {
    return function(pursArgs2) {
      return bind43(ask7)(function(env3) {
        return bind43(graph(globs)(pursArgs2))(function(maybeGraph) {
          if (maybeGraph instanceof Left) {
            return discard21(logWarn4("Could not decode the output of `purs graph`, error: " + printJsonDecodeError(maybeGraph.value0)))(function() {
              return pure58([]);
            });
          }
          ;
          if (maybeGraph instanceof Right) {
            return bind43(runSpago3(union1({
              graph: maybeGraph.value0,
              selected
            })(env3))(checkImports))(function(v) {
              var result = append114(function() {
                var $128 = isEmpty3(v.unused);
                if ($128) {
                  return [];
                }
                ;
                return [unusedError(false)(selected)(v.unused)];
              }())(append114(function() {
                var $129 = isEmpty2(v.transitive);
                if ($129) {
                  return [];
                }
                ;
                return [transitiveError(false)(selected)(v.transitive)];
              }())(append114(function() {
                var $130 = isEmpty3(v.unusedTest);
                if ($130) {
                  return [];
                }
                ;
                return [unusedError(true)(selected)(v.unusedTest)];
              }())(function() {
                var $131 = isEmpty2(v.transitiveTest);
                if ($131) {
                  return [];
                }
                ;
                return [transitiveError(true)(selected)(v.transitiveTest)];
              }())));
              return pure58(result);
            });
          }
          ;
          throw new Error("Failed pattern match at Spago.Purs.Graph (line 161, column 3 - line 175, column 18): " + [maybeGraph.constructor.name]);
        });
      });
    };
  };
};

// output/Spago.Command.Build/index.js
var join3 = /* @__PURE__ */ join(bindArray);
var map70 = /* @__PURE__ */ map(functorArray);
var partition4 = /* @__PURE__ */ partition3(filterableArray);
var toUnfoldable20 = /* @__PURE__ */ toUnfoldable5(unfoldableArray);
var bindFlipped10 = /* @__PURE__ */ bindFlipped(bindArray);
var fromFoldable25 = /* @__PURE__ */ fromFoldable7(foldableArray)(ordString);
var append29 = /* @__PURE__ */ append(semigroupArray);
var discard23 = /* @__PURE__ */ discard(discardUnit);
var discard110 = /* @__PURE__ */ discard23(bindSpago);
var logInfo4 = /* @__PURE__ */ logInfo(monadEffectSpago)(monadAskSpago)(loggableString);
var bind44 = /* @__PURE__ */ bind(bindSpago);
var ask8 = /* @__PURE__ */ ask(monadAskSpago);
var when10 = /* @__PURE__ */ when(applicativeSpago);
var die6 = /* @__PURE__ */ die(monadEffectSpago)(monadAskSpago)(/* @__PURE__ */ loggableArray(loggableString));
var discard24 = /* @__PURE__ */ discard23(bindMaybe);
var guard10 = /* @__PURE__ */ guard2(alternativeMaybe);
var bind118 = /* @__PURE__ */ bind(bindMaybe);
var pure59 = /* @__PURE__ */ pure(applicativeSpago);
var logDebug8 = /* @__PURE__ */ logDebug(monadEffectSpago)(monadAskSpago)(loggableString);
var exec4 = /* @__PURE__ */ exec(monadAffSpago);
var showMaybe5 = /* @__PURE__ */ showMaybe(showString);
var show34 = /* @__PURE__ */ show(/* @__PURE__ */ showRecord()()(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "escapedCommand";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "exitCode";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "failed";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "isCanceled";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "killed";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "message";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "originalMessage";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "shortMessage";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "signal";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "signalDescription";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "stderr";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "stdout";
  }
})(/* @__PURE__ */ showRecordFieldsConsNil({
  reflectSymbol: function() {
    return "timedOut";
  }
})(showBoolean))(showString))(showString))(showMaybe5))(/* @__PURE__ */ showMaybe(/* @__PURE__ */ showEither(showInt)(showString))))(showString))(showMaybe5))(showString))(showBoolean))(showBoolean))(showBoolean))(/* @__PURE__ */ showMaybe(showInt)))(showString)));
var logSuccess4 = /* @__PURE__ */ logSuccess(monadEffectSpago)(monadAskSpago)(loggableString);
var map128 = /* @__PURE__ */ map(functorSpago);
var fold18 = /* @__PURE__ */ fold2(monoidArray);
var $$for6 = /* @__PURE__ */ $$for(applicativeSpago)(traversableArray);
var unless6 = /* @__PURE__ */ unless(applicativeSpago);
var die$prime2 = /* @__PURE__ */ die$prime(monadEffectSpago)(monadAskSpago)(loggableDocc);
var isWorkspacePackage = function(v) {
  if (v.value1 instanceof WorkspacePackage) {
    return true;
  }
  ;
  return false;
};
var getBuildGlobs = function(v) {
  var testGlobs = function() {
    if (v.withTests) {
      return WithTestGlobs.value;
    }
    ;
    if (!v.withTests) {
      return NoTestGlobs.value;
    }
    ;
    throw new Error("Failed pattern match at Spago.Command.Build (line 173, column 15 - line 175, column 25): " + [v.withTests.constructor.name]);
  }();
  var workspacePackageGlob = function(p) {
    return sourceGlob(testGlobs)(p["package"].name)(new WorkspacePackage(p));
  };
  var projectGlobs = join3(function() {
    if (v.depsOnly) {
      return [];
    }
    ;
    if (!v.depsOnly) {
      return map70(workspacePackageGlob)(v.selected);
    }
    ;
    throw new Error("Failed pattern match at Spago.Command.Build (line 167, column 23 - line 171, column 40): " + [v.depsOnly.constructor.name]);
  }());
  var v1 = partition4(isWorkspacePackage)(toUnfoldable20(v.dependencies));
  var monorepoPkgGlobs = function() {
    if (v.depsOnly) {
      return [];
    }
    ;
    if (otherwise) {
      return bindFlipped10(uncurry(sourceGlob(testGlobs)))(v1.yes);
    }
    ;
    throw new Error("Failed pattern match at Spago.Command.Build (line 183, column 3 - line 185, column 81): " + []);
  }();
  var dependencyGlobs = bindFlipped10(uncurry(sourceGlob(NoTestGlobs.value)))(v1.no);
  return fromFoldable25(append29(projectGlobs)(append29(monorepoPkgGlobs)(append29(dependencyGlobs)([buildInfoPath]))));
};
var run3 = function(opts) {
  return discard110(logInfo4("Building..."))(function() {
    return bind44(ask8)(function(v) {
      var v1 = partition4(isWorkspacePackage)(toUnfoldable20(v.dependencies));
      var dependencyLibs = map70(uncurry(getPackageLocation))(v1.no);
      return discard110(writeBuildInfo)(function() {
        return discard110(when10(isJust(findFlag({
          flags: ["-o", "--output"],
          args: opts.pursArgs
        })))(die6(["Can't pass `--output` option directly to purs.", "Use the --output flag for Spago, or add it to your config file."])))(function() {
          var addOutputArgs = function(args) {
            if (v.workspace.buildOptions.output instanceof Nothing) {
              return args;
            }
            ;
            if (v.workspace.buildOptions.output instanceof Just) {
              return append29(args)(["--output", v.workspace.buildOptions.output.value0]);
            }
            ;
            throw new Error("Failed pattern match at Spago.Command.Build (line 61, column 26 - line 63, column 52): " + [v.workspace.buildOptions.output.constructor.name]);
          };
          return discard110(when10(isJust(findFlag({
            flags: ["--json-errors"],
            args: opts.pursArgs
          })))(die6(["Can't pass `--json-errors` option directly to purs.", "Use the --json-errors flag for Spago."])))(function() {
            var psaOptions = {
              strict: fromMaybe(defaultParseOptions.strict)(v.workspace.buildOptions.strict),
              censorBuildWarnings: fromMaybe(defaultParseOptions.censorBuildWarnings)(v.workspace.buildOptions.censorBuildWarnings),
              showSource: fromMaybe(defaultParseOptions.showSource)(v.workspace.buildOptions.showSource),
              censorCodes: maybe(defaultParseOptions.censorCodes)(toSet)(v.workspace.buildOptions.censorCodes),
              filterCodes: maybe(defaultParseOptions.filterCodes)(toSet)(v.workspace.buildOptions.filterCodes),
              statVerbosity: fromMaybe(defaultParseOptions.statVerbosity)(v.workspace.buildOptions.statVerbosity),
              stashFile: discard24(guard10(!opts.depsOnly))(function() {
                return bind118(v.workspace.buildOptions.persistWarnings)(function(shouldStashWarnings) {
                  return discard24(guard10(shouldStashWarnings))(function() {
                    if (v.workspace.selected instanceof Just) {
                      return new Just(mkLocalCachesPersistentWarningsFile(print2(v["workspace"]["selected"]["value0"]["package"].name)));
                    }
                    ;
                    if (v.workspace.selected instanceof Nothing) {
                      return new Just(localCachesPersistedWarningsEntireWorkspace);
                    }
                    ;
                    throw new Error("Failed pattern match at Spago.Command.Build (line 89, column 11 - line 91, column 78): " + [v.workspace.selected.constructor.name]);
                  });
                });
              })
            };
            var psaArgs = {
              libraryDirs: dependencyLibs,
              color: v.logOptions.color,
              jsonErrors: opts.jsonErrors
            };
            var buildBackend = function() {
              if (v.workspace.backend instanceof Nothing) {
                return pure59(unit);
              }
              ;
              if (v.workspace.backend instanceof Just) {
                return discard110(logInfo4('Compiling with backend "' + (v.workspace.backend.value0.cmd + '"')))(function() {
                  return discard110(logDebug8("Running command `" + (v.workspace.backend.value0.cmd + "`")))(function() {
                    var moreBackendArgs = function() {
                      if (v.workspace.backend.value0.args instanceof Just && length(v.workspace.backend.value0.args.value0) > 0) {
                        return v.workspace.backend.value0.args.value0;
                      }
                      ;
                      return [];
                    }();
                    return bind44(exec4(v.workspace.backend.value0.cmd)(addOutputArgs(moreBackendArgs))(defaultExecOptions))(function(v2) {
                      if (v2 instanceof Left) {
                        return discard110(logDebug8(show34(v2.value0)))(function() {
                          return die6(["Failed to build with backend " + v.workspace.backend.value0.cmd]);
                        });
                      }
                      ;
                      if (v2 instanceof Right) {
                        return logSuccess4("Backend build succeeded.");
                      }
                      ;
                      throw new Error("Failed pattern match at Spago.Command.Build (line 103, column 91 - line 108, column 52): " + [v2.constructor.name]);
                    });
                  });
                });
              }
              ;
              throw new Error("Failed pattern match at Spago.Command.Build (line 94, column 7 - line 108, column 52): " + [v.workspace.backend.constructor.name]);
            }();
            var globs = getBuildGlobs({
              dependencies: v.dependencies,
              depsOnly: opts.depsOnly,
              withTests: true,
              selected: function() {
                if (v.workspace.selected instanceof Just) {
                  return [v.workspace.selected.value0];
                }
                ;
                if (v.workspace.selected instanceof Nothing) {
                  return getWorkspacePackages(v.workspace.packageSet);
                }
                ;
                throw new Error("Failed pattern match at Spago.Command.Build (line 124, column 19 - line 126, column 70): " + [v.workspace.selected.constructor.name]);
              }()
            });
            return discard110(when10(isJust(findFlag({
              flags: ["-g", "--codegen"],
              args: opts.pursArgs
            })))(die6(["Can't pass `--codegen` option to build when using a backend", "Hint: No need to pass `--codegen corefn` explicitly when using the `backend` option.", "Remove the argument to solve the error"])))(function() {
              var args = append29(addOutputArgs(opts.pursArgs))(["--codegen", "corefn,docs,js,sourcemaps"]);
              return discard110(psaCompile(globs)(args)(psaArgs)(psaOptions))(function() {
                return discard110(buildBackend)(function() {
                  return when10(v.workspace.buildOptions.pedanticPackages)(discard110(logInfo4("Looking for unused and undeclared transitive dependencies..."))(function() {
                    return bind44(function() {
                      if (v.workspace.selected instanceof Just) {
                        return runGraphCheck(v.workspace.selected.value0)(globs)(opts.pursArgs);
                      }
                      ;
                      if (v.workspace.selected instanceof Nothing) {
                        return map128(fold18)($$for6(getWorkspacePackages(v.workspace.packageSet))(function(selected) {
                          return runGraphCheck(selected)(globs)(opts.pursArgs);
                        }));
                      }
                      ;
                      throw new Error("Failed pattern match at Spago.Command.Build (line 142, column 15 - line 148, column 59): " + [v.workspace.selected.constructor.name]);
                    }())(function(errors) {
                      return unless6($$null(errors))(die$prime2(errors));
                    });
                  }));
                });
              });
            });
          });
        });
      });
    });
  });
};

// output/Spago.Command.Bundle/index.js
var bind45 = /* @__PURE__ */ bind(bindSpago);
var discard25 = /* @__PURE__ */ discard(discardUnit)(bindSpago);
var logDebug9 = /* @__PURE__ */ logDebug(monadEffectSpago)(monadAskSpago)(loggableString);
var showRecord3 = /* @__PURE__ */ showRecord()();
var show35 = /* @__PURE__ */ show(/* @__PURE__ */ showRecord3(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "minify";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "module";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "outfile";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "platform";
  }
})(/* @__PURE__ */ showRecordFieldsConsNil({
  reflectSymbol: function() {
    return "type";
  }
})(showBundleType))(showBundlePlatform))(showString))(showString))(showBoolean)));
var append115 = /* @__PURE__ */ append(semigroupArray);
var show114 = /* @__PURE__ */ show(showBundlePlatform);
var logInfo5 = /* @__PURE__ */ logInfo(monadEffectSpago)(monadAskSpago)(loggableString);
var show210 = /* @__PURE__ */ show(/* @__PURE__ */ showArray(showString));
var exec5 = /* @__PURE__ */ exec(monadAffSpago);
var logSuccess5 = /* @__PURE__ */ logSuccess(monadEffectSpago)(monadAskSpago)(loggableString);
var showMaybe6 = /* @__PURE__ */ showMaybe(showString);
var show36 = /* @__PURE__ */ show(/* @__PURE__ */ showRecord3(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "escapedCommand";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "exitCode";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "failed";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "isCanceled";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "killed";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "message";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "originalMessage";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "shortMessage";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "signal";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "signalDescription";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "stderr";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "stdout";
  }
})(/* @__PURE__ */ showRecordFieldsConsNil({
  reflectSymbol: function() {
    return "timedOut";
  }
})(showBoolean))(showString))(showString))(showMaybe6))(/* @__PURE__ */ showMaybe(/* @__PURE__ */ showEither(showInt)(showString))))(showString))(showMaybe6))(showString))(showBoolean))(showBoolean))(showBoolean))(/* @__PURE__ */ showMaybe(showInt)))(showString)));
var die7 = /* @__PURE__ */ die(monadEffectSpago)(monadAskSpago)(/* @__PURE__ */ loggableArray(loggableString));
var run4 = /* @__PURE__ */ bind45(/* @__PURE__ */ ask(monadAskSpago))(function(v) {
  return discard25(logDebug9("Bundle options: " + show35(v.bundleOptions)))(function() {
    var output5 = function() {
      if (v.workspace.buildOptions.output instanceof Nothing) {
        return "output";
      }
      ;
      if (v.workspace.buildOptions.output instanceof Just) {
        return v.workspace.buildOptions.output.value0;
      }
      ;
      throw new Error("Failed pattern match at Spago.Command.Bundle (line 53, column 14 - line 55, column 18): " + [v.workspace.buildOptions.output.constructor.name]);
    }();
    var outfile2 = concat2([v.selected.path, v.bundleOptions.outfile]);
    var nodePatch = function() {
      if (v.bundleOptions.platform instanceof BundleNode) {
        return ["--banner:js=import __module from 'module';import __path from 'path';import __url from 'url';const require = __module.createRequire(import.meta.url);const __dirname = __path.dirname(__url.fileURLToPath(import.meta.url));"];
      }
      ;
      return [];
    }();
    var minify2 = function() {
      if (v.bundleOptions.minify) {
        return ["--minify"];
      }
      ;
      return [];
    }();
    var mainPath = replaceAll("\\")("/")(concat2([output5, v.bundleOptions.module, "index.js"]));
    var format2 = function() {
      if (v.bundleOptions.platform instanceof BundleBrowser && v.bundleOptions.type instanceof BundleApp) {
        return "--format=iife";
      }
      ;
      return "--format=esm";
    }();
    var v1 = function() {
      if (v.bundleOptions.type instanceof BundleApp) {
        return {
          entrypoint: [],
          input: new StdinWrite("#!/usr/bin/env node\n\nimport { main } from './" + (mainPath + "'; main();"))
        };
      }
      ;
      if (v.bundleOptions.type instanceof BundleModule) {
        return {
          entrypoint: [mainPath],
          input: StdinNewPipe.value
        };
      }
      ;
      throw new Error("Failed pattern match at Spago.Command.Bundle (line 61, column 29 - line 63, column 76): " + [v.bundleOptions.type.constructor.name]);
    }();
    var execOptions = {
      pipeStdin: v1.input,
      cwd: defaultExecOptions.cwd,
      pipeStderr: defaultExecOptions.pipeStderr,
      pipeStdout: defaultExecOptions.pipeStdout
    };
    var args = append115(["--bundle", "--outfile=" + outfile2, "--platform=" + show114(v.bundleOptions.platform), "--loader:.node=file", format2])(append115(minify2)(append115(v1.entrypoint)(nodePatch)));
    return discard25(logInfo5("Bundling..."))(function() {
      return discard25(logDebug9("Running esbuild: " + show210(args)))(function() {
        return bind45(exec5(v.esbuild.cmd)(args)(execOptions))(function(v2) {
          if (v2 instanceof Right) {
            return logSuccess5("Bundle succeeded.");
          }
          ;
          if (v2 instanceof Left) {
            return discard25(logDebug9(show36(v2.value0)))(function() {
              return die7(["Failed to bundle."]);
            });
          }
          ;
          throw new Error("Failed pattern match at Spago.Command.Bundle (line 76, column 45 - line 80, column 34): " + [v2.constructor.name]);
        });
      });
    });
  });
});

// output/Registry.Solver/index.js
var $runtime_lazy11 = function(name4, moduleName2, init4) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2)
      return val;
    if (state2 === 1)
      throw new ReferenceError(name4 + " was needed before it finished initializing (module " + moduleName2 + ", line " + lineNumber + ")", moduleName2, lineNumber);
    state2 = 1;
    val = init4();
    state2 = 2;
    return val;
  };
};
var versionIsSymbol2 = {
  reflectSymbol: function() {
    return "version";
  }
};
var packageIsSymbol = {
  reflectSymbol: function() {
    return "package";
  }
};
var append30 = /* @__PURE__ */ append(/* @__PURE__ */ semigroupNonEmptySet(/* @__PURE__ */ ordRecord()(/* @__PURE__ */ ordRecordCons(/* @__PURE__ */ ordRecordCons(ordRecordNil)()(versionIsSymbol2)(ordVersion))()(packageIsSymbol)(ordPackageName))));
var append116 = /* @__PURE__ */ append(/* @__PURE__ */ semigroupSet(ordPackageName));
var compare9 = /* @__PURE__ */ compare(ordVersion);
var semigroupRecord3 = /* @__PURE__ */ semigroupRecord();
var lowerIsSymbol = {
  reflectSymbol: function() {
    return "lower";
  }
};
var semigroupRecordCons2 = /* @__PURE__ */ semigroupRecordCons(lowerIsSymbol)();
var upperIsSymbol = {
  reflectSymbol: function() {
    return "upper";
  }
};
var semigroupRecordCons1 = /* @__PURE__ */ semigroupRecordCons(upperIsSymbol)()(semigroupRecordNil);
var over7 = /* @__PURE__ */ over()();
var map71 = /* @__PURE__ */ map(functorFn);
var lmap14 = /* @__PURE__ */ lmap(bifunctorEither);
var eqRec3 = /* @__PURE__ */ eqRec();
var eqRowCons2 = /* @__PURE__ */ eqRowCons(eqRowNil)();
var eq29 = /* @__PURE__ */ eq(/* @__PURE__ */ eqNonEmptySet(/* @__PURE__ */ eqRec3(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons2(versionIsSymbol2)(eqVersion))()(packageIsSymbol)(eqPackageName))));
var eq112 = /* @__PURE__ */ eq(/* @__PURE__ */ eqSet(eqPackageName));
var eq210 = /* @__PURE__ */ eq(eqVersion);
var intercalateMap2 = /* @__PURE__ */ intercalateMap(foldable1NonEmptySet)(semigroupString);
var fromFoldable26 = /* @__PURE__ */ fromFoldable2(foldableSet);
var difference5 = /* @__PURE__ */ difference3(ordPackageName);
var map129 = /* @__PURE__ */ map16(ordPackageName);
var mempty17 = /* @__PURE__ */ mempty(monoidString);
var intercalateMap1 = /* @__PURE__ */ intercalateMap(foldable1NonEmptyArray)(semigroupString);
var unwrap15 = /* @__PURE__ */ unwrap();
var greaterThanOrEq3 = /* @__PURE__ */ greaterThanOrEq(ordVersion);
var fold19 = /* @__PURE__ */ fold2(monoidString);
var intercalate11 = /* @__PURE__ */ intercalate(foldableMap)(monoidString);
var mapWithIndex4 = /* @__PURE__ */ mapWithIndex(functorWithIndexMap);
var fold110 = /* @__PURE__ */ fold(foldableMap)(monoidString);
var foldMapWithIndex2 = /* @__PURE__ */ foldMapWithIndex(foldableWithIndexSemigroupMap);
var monoidSemigroupMap2 = /* @__PURE__ */ monoidSemigroupMap(ordPackageName);
var semigroupSemigroupMap2 = /* @__PURE__ */ semigroupSemigroupMap(ordPackageName);
var lookup9 = /* @__PURE__ */ lookup3(ordPackageName);
var lessThan3 = /* @__PURE__ */ lessThan(ordVersion);
var greaterThan5 = /* @__PURE__ */ greaterThan(ordVersion);
var mapWithIndex1 = /* @__PURE__ */ mapWithIndex(functorWithIndexSemigroupMap);
var filterWithKey3 = /* @__PURE__ */ filterWithKey(ordVersion);
var coerce7 = /* @__PURE__ */ coerce();
var map217 = /* @__PURE__ */ map(functorMap);
var pure60 = /* @__PURE__ */ pure(applicativeArray);
var filterKeys2 = /* @__PURE__ */ filterKeys(ordVersion);
var heytingAlgebraFunction2 = /* @__PURE__ */ heytingAlgebraFunction(heytingAlgebraBoolean);
var not1 = /* @__PURE__ */ not(/* @__PURE__ */ heytingAlgebraFunction(heytingAlgebraFunction2));
var member7 = /* @__PURE__ */ member2(ordVersion);
var foldMap8 = /* @__PURE__ */ foldMap(foldableMap)(/* @__PURE__ */ monoidSemigroupMap2(semigroupArray));
var append33 = /* @__PURE__ */ append(/* @__PURE__ */ semigroupSet(ordVersion));
var $$delete9 = /* @__PURE__ */ $$delete3(ordPackageName);
var insert15 = /* @__PURE__ */ insert3(ordPackageName);
var append42 = /* @__PURE__ */ append(/* @__PURE__ */ semigroupSemigroupMap2(semigroupArray));
var wrap3 = /* @__PURE__ */ wrap();
var map311 = /* @__PURE__ */ map(functorSemigroupMap);
var anyWithIndex2 = /* @__PURE__ */ anyWithIndex(foldableWithIndexSemigroupMap)(/* @__PURE__ */ heytingAlgebraRecord()(/* @__PURE__ */ heytingAlgebraRecordCons({
  reflectSymbol: function() {
    return "added";
  }
})()(/* @__PURE__ */ heytingAlgebraRecordCons({
  reflectSymbol: function() {
    return "failedAlready";
  }
})()(/* @__PURE__ */ heytingAlgebraRecordCons({
  reflectSymbol: function() {
    return "failedNow";
  }
})()(heytingAlgebraRecordNil)(heytingAlgebraBoolean))(heytingAlgebraBoolean))(heytingAlgebraBoolean)));
var not22 = /* @__PURE__ */ not(heytingAlgebraFunction2);
var $$for7 = /* @__PURE__ */ $$for(applicativeMaybe)(traversableMap);
var bind46 = /* @__PURE__ */ bind(bindMaybe);
var pure118 = /* @__PURE__ */ pure(applicativeMaybe);
var discard26 = /* @__PURE__ */ discard(discardUnit);
var discard111 = /* @__PURE__ */ discard26(bindMaybe);
var forWithIndex_4 = /* @__PURE__ */ forWithIndex_(applicativeMaybe)(foldableWithIndexSemigroupMap);
var guard11 = /* @__PURE__ */ guard2(alternativeMaybe);
var join4 = /* @__PURE__ */ join(bindFn);
var eqSemigroupMap2 = /* @__PURE__ */ eqSemigroupMap(eqPackageName);
var insert16 = /* @__PURE__ */ insert3(ordVersion);
var alter4 = /* @__PURE__ */ alter2(ordPackageName);
var traverseWithIndex3 = /* @__PURE__ */ traverseWithIndex(traversableWithIndexMap)(applicativeEither);
var pure210 = /* @__PURE__ */ pure(applicativeEither);
var forWithIndex3 = /* @__PURE__ */ forWithIndex(applicativeEither)(traversableWithIndexMap);
var filterWithKey1 = /* @__PURE__ */ filterWithKey(ordPackageName);
var foldlWithIndex3 = /* @__PURE__ */ foldlWithIndex(foldableWithIndexSemigroupMap);
var traverse10 = /* @__PURE__ */ traverse(traversableSemigroupMap)(applicativeMaybe);
var fromFoldable112 = /* @__PURE__ */ fromFoldable(foldableSemigroupMap);
var map411 = /* @__PURE__ */ map(functorNonEmptyArray);
var un10 = /* @__PURE__ */ un();
var mapFlipped9 = /* @__PURE__ */ mapFlipped(functorMap);
var mapMaybeWithKey2 = /* @__PURE__ */ mapMaybeWithKey(ordPackageName);
var monoidEndo2 = /* @__PURE__ */ monoidEndo(categoryFn);
var traverseWithIndex1 = /* @__PURE__ */ traverseWithIndex(traversableWithIndexSemigroupMap)(/* @__PURE__ */ applicativeTuple(monoidEndo2));
var mempty18 = /* @__PURE__ */ mempty(monoidEndo2);
var discard27 = /* @__PURE__ */ discard26(bindEither);
var pure310 = /* @__PURE__ */ pure(applicativeNonEmptyList);
var Root = /* @__PURE__ */ function() {
  function Root2() {
  }
  ;
  Root2.value = new Root2();
  return Root2;
}();
var Trial = /* @__PURE__ */ function() {
  function Trial2() {
  }
  ;
  Trial2.value = new Trial2();
  return Trial2;
}();
var Solving = /* @__PURE__ */ function() {
  function Solving2(value0) {
    this.value0 = value0;
  }
  ;
  Solving2.create = function(value0) {
    return new Solving2(value0);
  };
  return Solving2;
}();
var Pos = /* @__PURE__ */ function() {
  function Pos2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Pos2.create = function(value0) {
    return function(value12) {
      return new Pos2(value0, value12);
    };
  };
  return Pos2;
}();
var Sourced = /* @__PURE__ */ function() {
  function Sourced2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Sourced2.create = function(value0) {
    return function(value12) {
      return new Sourced2(value0, value12);
    };
  };
  return Sourced2;
}();
var LastSuccess = function(x) {
  return x;
};
var Conflicts = /* @__PURE__ */ function() {
  function Conflicts2(value0) {
    this.value0 = value0;
  }
  ;
  Conflicts2.create = function(value0) {
    return new Conflicts2(value0);
  };
  return Conflicts2;
}();
var WhileSolving = /* @__PURE__ */ function() {
  function WhileSolving2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  WhileSolving2.create = function(value0) {
    return function(value12) {
      return new WhileSolving2(value0, value12);
    };
  };
  return WhileSolving2;
}();
var semigroupLocalSolverPosit = {
  append: function(v) {
    return function(v1) {
      if (v instanceof Trial) {
        return Trial.value;
      }
      ;
      if (v1 instanceof Trial) {
        return Trial.value;
      }
      ;
      if (v instanceof Root) {
        return Root.value;
      }
      ;
      if (v1 instanceof Root) {
        return Root.value;
      }
      ;
      if (v instanceof Solving && v1 instanceof Solving) {
        return new Solving(append30(v.value0)(v1.value0));
      }
      ;
      throw new Error("Failed pattern match at Registry.Solver (line 573, column 1 - line 578, column 56): " + [v.constructor.name, v1.constructor.name]);
    };
  }
};
var append52 = /* @__PURE__ */ append(semigroupLocalSolverPosit);
var semigroupSolverPosition = {
  append: function(v) {
    return function(v1) {
      return new Pos(append52(v.value0)(v1.value0), append116(v.value1)(v1.value1));
    };
  }
};
var append62 = /* @__PURE__ */ append(semigroupSolverPosition);
var semigroupMaxSourced = {
  append: function(v) {
    return function(v1) {
      var v2 = compare9(v.value0)(v1.value0);
      if (v2 instanceof GT) {
        return v;
      }
      ;
      if (v2 instanceof LT) {
        return v1;
      }
      ;
      if (v2 instanceof EQ) {
        return new Sourced(v.value0, append62(v.value1)(v1.value1));
      }
      ;
      throw new Error("Failed pattern match at Registry.Solver (line 632, column 5 - line 635, column 47): " + [v2.constructor.name]);
    };
  }
};
var semigroupMinSourced = {
  append: function(v) {
    return function(v1) {
      var v2 = compare9(v.value0)(v1.value0);
      if (v2 instanceof LT) {
        return v;
      }
      ;
      if (v2 instanceof GT) {
        return v1;
      }
      ;
      if (v2 instanceof EQ) {
        return new Sourced(v.value0, append62(v.value1)(v1.value1));
      }
      ;
      throw new Error("Failed pattern match at Registry.Solver (line 621, column 5 - line 624, column 47): " + [v2.constructor.name]);
    };
  }
};
var semigroupLoose = /* @__PURE__ */ semigroupRecord3(/* @__PURE__ */ semigroupRecordCons2(/* @__PURE__ */ semigroupRecordCons1(semigroupMaxSourced))(semigroupMinSourced));
var foldMap16 = /* @__PURE__ */ foldMap13(/* @__PURE__ */ semigroupApp(/* @__PURE__ */ applyMap(ordPackageName))(semigroupLoose));
var semigroupIntersection = /* @__PURE__ */ semigroupRecord3(/* @__PURE__ */ semigroupRecordCons2(/* @__PURE__ */ semigroupRecordCons1(semigroupMinSourced))(semigroupMaxSourced));
var semigroupSemigroupMap1 = /* @__PURE__ */ semigroupSemigroupMap2(semigroupIntersection);
var semigroupSemigroupMap22 = /* @__PURE__ */ semigroupSemigroupMap(ordVersion)(semigroupSemigroupMap1);
var monoidSemigroupMap1 = /* @__PURE__ */ monoidSemigroupMap2(semigroupSemigroupMap22);
var foldMapWithIndex1 = /* @__PURE__ */ foldMapWithIndex2(monoidSemigroupMap1);
var mempty25 = /* @__PURE__ */ mempty(monoidSemigroupMap1);
var foldMap23 = /* @__PURE__ */ foldMap(foldableSemigroupMap)(monoidSemigroupMap1);
var semigroupSemigroupMap3 = /* @__PURE__ */ semigroupSemigroupMap2(semigroupSemigroupMap22);
var mempty32 = /* @__PURE__ */ mempty(/* @__PURE__ */ monoidSemigroupMap(ordVersion)(semigroupSemigroupMap1));
var monoidSemigroupMap22 = /* @__PURE__ */ monoidSemigroupMap2(semigroupIntersection);
var mempty42 = /* @__PURE__ */ mempty(monoidSemigroupMap22);
var append72 = /* @__PURE__ */ append(semigroupIntersection);
var monoidTuple2 = /* @__PURE__ */ monoidTuple(/* @__PURE__ */ monoidDisj(heytingAlgebraBoolean))(monoidSemigroupMap22);
var mempty52 = /* @__PURE__ */ mempty(monoidTuple2);
var foldMapWithIndex22 = /* @__PURE__ */ foldMapWithIndex2(monoidTuple2);
var append82 = /* @__PURE__ */ append(semigroupSemigroupMap1);
var foldMapWithIndex3 = /* @__PURE__ */ foldMapWithIndex2(monoidSemigroupMap22);
var append92 = /* @__PURE__ */ append(semigroupSemigroupMap3);
var functorLastSuccess = {
  map: function(f) {
    return over7(LastSuccess)(map71(lmap14(f)));
  }
};
var eqLocalSolverPosition = {
  eq: function(x) {
    return function(y) {
      if (x instanceof Root && y instanceof Root) {
        return true;
      }
      ;
      if (x instanceof Trial && y instanceof Trial) {
        return true;
      }
      ;
      if (x instanceof Solving && y instanceof Solving) {
        return eq29(x.value0)(y.value0);
      }
      ;
      return false;
    };
  }
};
var eq43 = /* @__PURE__ */ eq(eqLocalSolverPosition);
var eqSolverPosition = {
  eq: function(x) {
    return function(y) {
      return eq43(x.value0)(y.value0) && eq112(x.value1)(y.value1);
    };
  }
};
var eq53 = /* @__PURE__ */ eq(eqSolverPosition);
var eqSourced = {
  eq: function(x) {
    return function(y) {
      return eq210(x.value0)(y.value0) && eq53(x.value1)(y.value1);
    };
  }
};
var eqMaxSourced = eqSourced;
var eqMinSourced = eqSourced;
var eqIntersection = /* @__PURE__ */ eqRec3(/* @__PURE__ */ eqRowCons(/* @__PURE__ */ eqRowCons2(upperIsSymbol)(eqMinSourced))()(lowerIsSymbol)(eqMaxSourced));
var applyLastSuccess = {
  apply: function(v) {
    return function(v1) {
      return function(u) {
        var v2 = v1(u);
        if (v2 instanceof Right) {
          return new Right(v2.value0);
        }
        ;
        if (v2 instanceof Left) {
          var v3 = v(u);
          if (v3 instanceof Right) {
            return new Right(v3.value0);
          }
          ;
          if (v3 instanceof Left) {
            return new Left(v3.value0(v2.value0));
          }
          ;
          throw new Error("Failed pattern match at Registry.Solver (line 730, column 9 - line 732, column 31): " + [v3.constructor.name]);
        }
        ;
        throw new Error("Failed pattern match at Registry.Solver (line 727, column 5 - line 732, column 31): " + [v2.constructor.name]);
      };
    };
  },
  Functor0: function() {
    return functorLastSuccess;
  }
};
var applicativeLastSuccess = {
  pure: /* @__PURE__ */ function() {
    var $601 = pure(applicativeFn);
    return function($602) {
      return LastSuccess($601(Left.create($602)));
    };
  }(),
  Apply0: function() {
    return applyLastSuccess;
  }
};
var sequence3 = /* @__PURE__ */ sequence(traversableMap)(applicativeLastSuccess);
var upperBound = function(v) {
  return v.upper.value0;
};
var solveSeed = function(v) {
  return {
    registry: v.registry,
    required: v.required,
    updated: v.registry
  };
};
var soleVersion = function(v) {
  return {
    lower: new Sourced(v, new Pos(Trial.value, empty4)),
    upper: new Sourced(bumpPatch(v), new Pos(Trial.value, empty4))
  };
};
var soleVersionOf = function($$package2) {
  return function(v) {
    return singleton10($$package2)(soleVersion(v));
  };
};
var printPackageVersion = function(v) {
  return print2(v["package"]) + ("@" + print3(v.version));
};
var printSolverPosition = function(v) {
  if (v.value0 instanceof Root) {
    return " (declared dependency)";
  }
  ;
  if (v.value0 instanceof Trial) {
    return " (attempted version)";
  }
  ;
  if (v.value0 instanceof Solving) {
    return " seen in " + (intercalateMap2(", ")(printPackageVersion)(v.value0.value0) + function() {
      var v1 = fromFoldable26(difference5(v.value1)(map129(function(v2) {
        return v2["package"];
      })(toSet(v.value0.value0))));
      if (v1 instanceof Nothing) {
        return mempty17;
      }
      ;
      if (v1 instanceof Just) {
        return " from declared dependencies " + intercalateMap1(", ")(print2)(v1.value0);
      }
      ;
      throw new Error("Failed pattern match at Registry.Solver (line 165, column 10 - line 167, column 94): " + [v1.constructor.name]);
    }());
  }
  ;
  throw new Error("Failed pattern match at Registry.Solver (line 160, column 23 - line 167, column 94): " + [v.constructor.name]);
};
var printSourced = function() {
  return function($603) {
    return function(v) {
      return print3(v.value0) + printSolverPosition(v.value1);
    }(unwrap15($603));
  };
};
var printSourced1 = /* @__PURE__ */ printSourced();
var noUpdates = function(v) {
  return isEmpty2(v.updated);
};
var lowerBound = function(v) {
  return v.lower.value0;
};
var printConflict = function(v) {
  return function(v1) {
    return function(v2) {
      if (greaterThanOrEq3(lowerBound(v2))(upperBound(v2))) {
        return fold19(["Conflict in version ranges for ", print2(v1), ":", "\n", v, "  >=", printSourced1(unwrap15(v2).lower), "\n", v, "  <", printSourced1(unwrap15(v2).upper)]);
      }
      ;
      return fold19(["No versions found in the registry for ", print2(v1), " in range", "\n", v, "  >=", printSourced1(unwrap15(v2).lower), "\n", v, "  <", printSourced1(unwrap15(v2).upper)]);
    };
  };
};
var printErrorAt = function(indent3) {
  return function(v) {
    if (v instanceof Conflicts) {
      return intercalate11("\n" + indent3)(mapWithIndex4(printConflict(indent3))(v.value0));
    }
    ;
    if (v instanceof WhileSolving) {
      return fold19(["While solving ", print2(v.value0), " each version could not be solved:", fold110(mapWithIndex4(function(version) {
        return function(nested) {
          return fold19(["\n", indent3, "- ", print3(version), ": ", "\n", indent3 + "  ", printErrorAt(indent3 + "  ")(nested)]);
        };
      })(v.value1))]);
    }
    ;
    throw new Error("Failed pattern match at Registry.Solver (line 181, column 23 - line 199, column 6): " + [v.constructor.name]);
  };
};
var printSolverError = /* @__PURE__ */ printErrorAt("");
var requirementUpdates = function(v) {
  return foldMapWithIndex1(function($$package2) {
    return function(newRange) {
      var changed = function() {
        var v12 = lookup9($$package2)(v.required);
        if (v12 instanceof Nothing) {
          return true;
        }
        ;
        if (v12 instanceof Just) {
          return lessThan3(lowerBound(v12.value0))(lowerBound(newRange)) || greaterThan5(upperBound(v12.value0))(upperBound(newRange));
        }
        ;
        throw new Error("Failed pattern match at Registry.Solver (line 514, column 9 - line 520, column 56): " + [v12.constructor.name]);
      }();
      var $471 = !changed;
      if ($471) {
        return mempty25;
      }
      ;
      var v1 = lookup9($$package2)(v.registry);
      if (v1 instanceof Just) {
        return singleton10($$package2)(v1.value0);
      }
      ;
      if (v1 instanceof Nothing) {
        return mempty25;
      }
      ;
      throw new Error("Failed pattern match at Registry.Solver (line 527, column 9 - line 529, column 28): " + [v1.constructor.name]);
    };
  });
};
var satisfies = function(v) {
  return function(r) {
    return greaterThanOrEq3(v)(lowerBound(r)) && lessThan3(v)(upperBound(r));
  };
};
var trimReachable = function(r) {
  var $478 = {};
  for (var $479 in r) {
    if ({}.hasOwnProperty.call(r, $479)) {
      $478[$479] = r[$479];
    }
    ;
  }
  ;
  $478.registry = mapWithIndex1(function($$package2) {
    return over7(SemigroupMap)(filterWithKey3(function(version) {
      return function(v1) {
        var v2 = lookup9($$package2)(unwrap15(r.required));
        if (v2 instanceof Nothing) {
          return true;
        }
        ;
        if (v2 instanceof Just) {
          return satisfies(version)(v2.value0);
        }
        ;
        throw new Error("Failed pattern match at Registry.Solver (line 549, column 9 - line 551, column 48): " + [v2.constructor.name]);
      };
    }));
  })(r.registry);
  return $478;
};
var toLoose = function(v) {
  if (lessThan3(lowerBound(v))(upperBound(v))) {
    return new Just(coerce7(v));
  }
  ;
  return Nothing.value;
};
var wouldUpdate = function(j) {
  return function(i) {
    return greaterThan5(lowerBound(j))(lowerBound(i)) || lessThan3(upperBound(j))(upperBound(i));
  };
};
var loadIndex = function(dictMonad) {
  var Bind1 = dictMonad.Bind1();
  var map511 = map(Bind1.Apply0().Functor0());
  var pure410 = pure(dictMonad.Applicative0());
  var bind122 = bind(Bind1);
  return function(loader) {
    return function(required) {
      var need = function() {
        var $604 = map217(pure60);
        return function($605) {
          return SemigroupMap($604($605));
        };
      }();
      var needMore = function(v) {
        return function(needed) {
          var isNeeded = function(k) {
            return any(function(r) {
              return includes(r)(k);
            })(needed);
          };
          var more = filterKeys2(function(k) {
            return not1(member7)(k)(v.found) && isNeeded(k);
          })(v.known);
          return {
            needed: foldMap8(need)(more),
            found: append33(v.found)(keys3(more))
          };
        };
      };
      var loadNew = function($$package2) {
        return function(v) {
          return map511(function(v1) {
            return {
              found: empty4,
              known: v1
            };
          })(loader($$package2));
        };
      };
      var go = function(v) {
        return function(v1) {
          var v2 = function(v3) {
            return pure410(v);
          };
          var $492 = findMin(v1);
          if ($492 instanceof Just) {
            return bind122(maybe$prime(loadNew($492.value0.key))(pure410)(lookup9($492.value0.key)(v)))(function(loaded) {
              var needed$prime = $$delete9($492.value0.key)(v1);
              var v3 = needMore(loaded)($492.value0.value);
              var loaded$prime = {
                found: append33(loaded.found)(v3.found),
                known: loaded.known
              };
              var acc$prime = insert15($492.value0.key)(loaded$prime)(v);
              return go(acc$prime)(append42(needed$prime)(v3.needed));
            });
          }
          ;
          return v2(true);
        };
      };
      return map511(map217(function(v) {
        return v.known;
      }))(go(empty3)(need(required)));
    };
  };
};
var intersectionFromRange$prime = function($$package2) {
  return function(range3) {
    var mkSourced = function(v) {
      return new Sourced(v, new Pos(Root.value, singleton11($$package2)));
    };
    return {
      lower: wrap3(mkSourced(greaterThanOrEq2(range3))),
      upper: wrap3(mkSourced(lessThan2(range3)))
    };
  };
};
var intersectionFromRange = function($$package2) {
  return function(version) {
    return function(range3) {
      var mkSourced = function(v) {
        return new Sourced(v, new Pos(new Solving(singleton12({
          "package": $$package2,
          version
        })), empty4));
      };
      return {
        lower: wrap3(mkSourced(greaterThanOrEq2(range3))),
        upper: wrap3(mkSourced(lessThan2(range3)))
      };
    };
  };
};
var initializeRequired = /* @__PURE__ */ function() {
  var $606 = mapWithIndex1(intersectionFromRange$prime);
  return function($607) {
    return $606(coerce7($607));
  };
}();
var initializeRegistry = /* @__PURE__ */ function() {
  var $608 = mapWithIndex1(function($$package2) {
    return mapWithIndex1(function(version) {
      return map311(intersectionFromRange($$package2)(version));
    });
  });
  return function($609) {
    return $608(coerce7($609));
  };
}();
var good = function(i) {
  return greaterThan5(upperBound(i))(lowerBound(i));
};
var majorUpdate = function(v) {
  return function(v1) {
    return function(updated) {
      var minor2 = {
        added: false,
        failedAlready: false,
        failedNow: false
      };
      var info4 = anyWithIndex2(function($$package2) {
        return function(range3) {
          var v2 = lookup9($$package2)(v1);
          if (v2 instanceof Nothing) {
            var v3 = lookup9($$package2)(v);
            if (v3 instanceof Nothing) {
              return {
                added: true,
                failedAlready: minor2.failedAlready,
                failedNow: minor2.failedNow
              };
            }
            ;
            if (v3 instanceof Just) {
              return {
                added: greaterThan5(lowerBound(range3))(lowerBound(v3.value0)) || lessThan3(upperBound(range3))(upperBound(v3.value0)),
                failedAlready: minor2.failedAlready,
                failedNow: minor2.failedNow
              };
            }
            ;
            throw new Error("Failed pattern match at Registry.Solver (line 493, column 11 - line 495, column 122): " + [v3.constructor.name]);
          }
          ;
          if (v2 instanceof Just) {
            return {
              failedAlready: not22(good)(v2.value0),
              failedNow: not22(good)(range3),
              added: minor2.added
            };
          }
          ;
          throw new Error("Failed pattern match at Registry.Solver (line 491, column 7 - line 496, column 83): " + [v2.constructor.name]);
        };
      })(updated);
      if (info4.added) {
        return true;
      }
      ;
      if (info4.failedNow && !info4.failedAlready) {
        return true;
      }
      ;
      return false;
    };
  };
};
var getPos = function() {
  return function($610) {
    return function(v) {
      return v.value1;
    }(unwrap15($610));
  };
};
var getPos1 = /* @__PURE__ */ getPos();
var getPackageRange = function(v) {
  return function($$package2) {
    return function(range3) {
      var v1 = lookup9($$package2)(v);
      if (v1 instanceof Nothing) {
        return empty3;
      }
      ;
      if (v1 instanceof Just) {
        return filterKeys2(function(v2) {
          return satisfies(v2)(range3);
        })(v1.value0);
      }
      ;
      throw new Error("Failed pattern match at Registry.Solver (line 676, column 3 - line 679, column 73): " + [v1.constructor.name]);
    };
  };
};
var withInRange = function(r) {
  return {
    registry: r.registry,
    required: r.required,
    inRange: mapWithIndex1(getPackageRange(r.registry))(r.required)
  };
};
var getLatest = function(v) {
  return $$for7(v.inRange)(function(v1) {
    return bind46(findMax(v1))(function(v2) {
      return pure118({
        version: v2.key,
        dependencies: v2.value
      });
    });
  });
};
var tryLatest = function(r) {
  return bind46(getLatest(r))(function(sol) {
    return $$for7(sol)(function(v) {
      return discard111(forWithIndex_4(v.dependencies)(function(dep) {
        return function(range3) {
          return bind46(lookup9(dep)(sol))(function(v1) {
            return guard11(satisfies(v1.version)(range3));
          });
        };
      }))(function() {
        return pure118(v.version);
      });
    });
  });
};
var fromLoose = coerce7;
var fixEqM = function(dictSemigroup) {
  var append102 = append(dictSemigroup);
  return function(dictEq) {
    var eq72 = eq(dictEq);
    return function(f) {
      var go = function($copy_acc) {
        return function($copy_lastAdded) {
          var $tco_var_acc = $copy_acc;
          var $tco_done = false;
          var $tco_result;
          function $tco_loop(acc, lastAdded) {
            var moreAdded = f(lastAdded);
            var moreAcc = append102(acc)(moreAdded);
            var $529 = eq72(moreAcc)(acc);
            if ($529) {
              $tco_done = true;
              return acc;
            }
            ;
            $tco_var_acc = moreAcc;
            $copy_lastAdded = moreAdded;
            return;
          }
          ;
          while (!$tco_done) {
            $tco_result = $tco_loop($tco_var_acc, $copy_lastAdded);
          }
          ;
          return $tco_result;
        };
      };
      return join4(go);
    };
  };
};
var fixEqM1 = /* @__PURE__ */ fixEqM(semigroupSemigroupMap3)(/* @__PURE__ */ eqSemigroupMap2(/* @__PURE__ */ eqSemigroupMap(eqVersion)(/* @__PURE__ */ eqSemigroupMap2(eqIntersection))));
var gatherReachable = function(v) {
  var reachable0 = mapWithIndex1(getPackageRange(v.registry))(v.required);
  var moreReachable = foldMap23(foldMap23(mapWithIndex1(getPackageRange(v.registry))));
  var reachable = fixEqM1(moreReachable)(reachable0);
  return reachable;
};
var doubleton = function($$package2) {
  return function(version) {
    return function(dat) {
      var helper2 = function(v) {
        if (v instanceof Nothing) {
          return singleton10(version)(dat);
        }
        ;
        if (v instanceof Just) {
          return insert16(version)(dat)(v.value0);
        }
        ;
        throw new Error("Failed pattern match at Registry.Solver (line 743, column 3 - line 743, column 45): " + [v.constructor.name]);
      };
      return coerce7(alter4(function($611) {
        return Just.create(helper2($611));
      })($$package2));
    };
  };
};
var dependency = function(v) {
  return function(v1) {
    return new Pos(v1.value0, append116(v.value1)(v1.value1));
  };
};
var dependencyOf = function() {
  return function(p1) {
    return coerce7(function(v) {
      return new Sourced(v.value0, dependency(p1)(v.value1));
    });
  };
};
var dependencyOf1 = /* @__PURE__ */ dependencyOf();
var checkSolved = function(v) {
  var v1 = function(v2) {
    return traverseWithIndex3(function($$package2) {
      return function(v3) {
        var v4 = findMax(v3);
        var v5 = size2(v3);
        if (v5 === 1 && v4 instanceof Just) {
          return pure210(v4.value0.key);
        }
        ;
        return new Left({
          "package": $$package2,
          versions: v3
        });
      };
    })(v.inRange);
  };
  var $553 = tryLatest(v);
  if ($553 instanceof Just) {
    return pure210($553.value0);
  }
  ;
  return v1(true);
};
var checkRequired = function(v) {
  var checkRequirementShallow = function($$package2) {
    return function(range3) {
      var versions = unwrap15(getPackageRange(v.registry)($$package2)(range3));
      return isEmpty2(versions);
    };
  };
  var checkRequirement = function($$package2) {
    return function(range3) {
      return function(previous) {
        var versions = unwrap15(map311(unwrap15)(fromMaybe(mempty32)(lookup9($$package2)(v.inRange))));
        var noVersions = isEmpty2(versions);
        var hasErrored = forWithIndex3(versions)(function(v1) {
          return function(deps) {
            var failedDeps = filterWithKey1(checkRequirementShallow)(deps);
            var $556 = isEmpty2(failedDeps);
            if ($556) {
              return new Left(unit);
            }
            ;
            return new Right(failedDeps);
          };
        });
        if (noVersions && (previous instanceof Left && previous.value0 instanceof Conflicts)) {
          return new Left(new Conflicts(insert15($$package2)(range3)(previous.value0.value0)));
        }
        ;
        if (noVersions) {
          return new Left(new Conflicts(singleton10($$package2)(range3)));
        }
        ;
        if (!noVersions && (hasErrored instanceof Right && previous instanceof Right)) {
          return new Left(new WhileSolving($$package2, map217(Conflicts.create)(hasErrored.value0)));
        }
        ;
        if (!noVersions) {
          return previous;
        }
        ;
        throw new Error("Failed pattern match at Registry.Solver (line 322, column 7 - line 327, column 32): " + [noVersions.constructor.name, hasErrored.constructor.name, previous.constructor.name]);
      };
    };
  };
  return foldlWithIndex3(function(i) {
    return function(b) {
      return function(a) {
        return checkRequirement(i)(a)(b);
      };
    };
  })(new Right(unit))(v.required);
};
var asDependencyOf = function(v) {
  return function(v1) {
    var pos = append62(getPos1(v.lower))(getPos1(v.upper));
    return {
      lower: dependencyOf1(pos)(v1.lower),
      upper: dependencyOf1(pos)(v1.upper)
    };
  };
};
var commonDependencies = function(registry) {
  return function($$package2) {
    return function(range3) {
      var inRange = getPackageRange(registry)($$package2)(range3);
      var solvableInRange = mapMaybe(traverse10(toLoose))(fromFoldable112(inRange));
      var v = fromArray(solvableInRange);
      if (v instanceof Nothing) {
        return mempty42;
      }
      ;
      if (v instanceof Just) {
        var v1 = foldMap16(App)(map411(un10(SemigroupMap))(v.value0));
        return mapFlipped9(v1)(function() {
          var $612 = asDependencyOf(range3);
          return function($613) {
            return $612(fromLoose($613));
          };
        }());
      }
      ;
      throw new Error("Failed pattern match at Registry.Solver (line 424, column 5 - line 429, column 71): " + [v.constructor.name]);
    };
  };
};
var addFrom = function(v) {
  return over7(SemigroupMap)(mapMaybeWithKey2(function($$package2) {
    var v1 = lookup9($$package2)(v);
    if (v1 instanceof Nothing) {
      return Just.create;
    }
    ;
    if (v1 instanceof Just) {
      return function(j) {
        var $574 = wouldUpdate(j)(v1.value0);
        if ($574) {
          return new Just(append72(j)(v1.value0));
        }
        ;
        return Nothing.value;
      };
    }
    ;
    throw new Error("Failed pattern match at Registry.Solver (line 391, column 87 - line 395, column 17): " + [v1.constructor.name]);
  }));
};
var withReachable = function(r) {
  var $576 = {};
  for (var $577 in r) {
    if ({}.hasOwnProperty.call(r, $577)) {
      $576[$577] = r[$577];
    }
    ;
  }
  ;
  $576.registry = map311(map311(addFrom(r.required)))(gatherReachable(r));
  return $576;
};
var accumulated = function(dictMonoid) {
  var mempty62 = mempty(dictMonoid);
  return function(v) {
    return v(mempty62);
  };
};
var accumulated1 = /* @__PURE__ */ accumulated(monoidSemigroupMap1);
var exploreTransitiveDependencies = function(lastTick) {
  return function(t) {
    return {
      required: lastTick.required,
      updated: accumulated1(fst(t)),
      registry: snd(t)
    };
  }(traverseWithIndex1(function($$package2) {
    return traverseWithIndex1(function(version) {
      return function(deps) {
        var updateOne = function(depName) {
          return function(depRange) {
            var v2 = isEmpty2(unwrap15(getPackageRange(lastTick.updated)(depName)(depRange)));
            if (v2) {
              return mempty52;
            }
            ;
            if (!v2) {
              return new Tuple(true, commonDependencies(lastTick.registry)(depName)(depRange));
            }
            ;
            throw new Error("Failed pattern match at Registry.Solver (line 466, column 36 - line 468, column 91): " + [v2.constructor.name]);
          };
        };
        var v = foldMapWithIndex22(updateOne)(deps);
        var dependencies = function() {
          if (v.value0) {
            return append82(deps)(v.value1);
          }
          ;
          return deps;
        }();
        var updated = function() {
          var v1 = v.value0 && majorUpdate(lastTick.required)(deps)(dependencies);
          if (v1) {
            return doubleton($$package2)(version)(dependencies);
          }
          ;
          if (!v1) {
            return mempty18;
          }
          ;
          throw new Error("Failed pattern match at Registry.Solver (line 472, column 17 - line 474, column 24): " + [v1.constructor.name]);
        }();
        return new Tuple(updated, dependencies);
      };
    });
  })(lastTick.registry));
};
var solveStep = function(initial) {
  var moreRequired = foldMapWithIndex3(commonDependencies(initial.registry))(initial.required);
  var updatedOfReqs = requirementUpdates(initial)(moreRequired);
  var v = exploreTransitiveDependencies({
    registry: map311(map311(addFrom(moreRequired)))(initial.registry),
    required: initial.required,
    updated: initial.updated
  });
  return {
    required: append82(initial.required)(moreRequired),
    registry: v.registry,
    updated: append92(v.updated)(updatedOfReqs)
  };
};
var solveSteps = function(r0) {
  var go = function($copy_v) {
    var $tco_done = false;
    var $tco_result;
    function $tco_loop(v) {
      if (noUpdates(v)) {
        $tco_done = true;
        return {
          registry: v.registry,
          required: v.required
        };
      }
      ;
      $copy_v = solveStep(v);
      return;
    }
    ;
    while (!$tco_done) {
      $tco_result = $tco_loop($copy_v);
    }
    ;
    return $tco_result;
  };
  return go(r0);
};
var solveFull = /* @__PURE__ */ function() {
  var applyPackage = function(r) {
    return function($$package2) {
      return function(version) {
        return function(dependencies) {
          var updated = maybe(empty3)(singleton10($$package2))(lookup9($$package2)(unwrap15(r.registry)));
          var required = append82(r.required)(append82(soleVersionOf($$package2)(version))(dependencies));
          return {
            required,
            registry: r.registry,
            updated
          };
        };
      };
    };
  };
  var solvePackage = function(r) {
    return function($$package2) {
      return function(version) {
        return function(dependencies) {
          return $lazy_solveAux(289)(trimReachable(applyPackage(r)($$package2)(version)(dependencies)));
        };
      };
    };
  };
  var $lazy_solveAux = $runtime_lazy11("solveAux", "Registry.Solver", function() {
    return function($614) {
      return function(r) {
        var rScanned = withInRange(r);
        return discard27(lmap14(pure310)(checkRequired(rScanned)))(function() {
          var v = checkSolved(rScanned);
          if (v instanceof Right) {
            return new Right(v.value0);
          }
          ;
          if (v instanceof Left) {
            var sols = mapWithIndex4(function(version) {
              return function(deps) {
                return function(v12) {
                  return solvePackage(r)(v["value0"]["package"])(version)(deps);
                };
              };
            })(v.value0.versions);
            var v1 = unwrap15(sequence3(sols))(unit);
            if (v1 instanceof Right) {
              return new Right(v1.value0);
            }
            ;
            if (v1 instanceof Left) {
              return new Left(pure310(new WhileSolving(v["value0"]["package"], map217(head4)(v1.value0))));
            }
            ;
            throw new Error("Failed pattern match at Registry.Solver (line 274, column 11 - line 281, column 36): " + [v1.constructor.name]);
          }
          ;
          throw new Error("Failed pattern match at Registry.Solver (line 267, column 5 - line 281, column 36): " + [v.constructor.name]);
        });
      }(solveSteps($614));
    };
  });
  var solveAux = $lazy_solveAux(258);
  return function($615) {
    return solveAux(solveSeed(withReachable($615)));
  };
}();
var loadAndSolve = function(dictMonad) {
  var mapFlipped1 = mapFlipped(dictMonad.Bind1().Apply0().Functor0());
  var loadIndex1 = loadIndex(dictMonad);
  return function(loader) {
    return function(required) {
      return mapFlipped1(loadIndex1(loader)(required))(function(index4) {
        return solveFull({
          registry: initializeRegistry(index4),
          required: initializeRequired(required)
        });
      });
    };
  };
};

// output/Spago.Command.Repl/index.js
var bind47 = /* @__PURE__ */ bind(bindSpago);
var ask9 = /* @__PURE__ */ ask(monadAskSpago);
var pure61 = /* @__PURE__ */ pure(applicativeSpago);
var filterWithKey4 = /* @__PURE__ */ filterWithKey(ordPackageName);
var eq30 = /* @__PURE__ */ eq(eqPackageName);
var runSpago4 = /* @__PURE__ */ runSpago(monadAffSpago);
var $$void16 = /* @__PURE__ */ $$void(functorSpago);
var supportPackageName = /* @__PURE__ */ unsafeFromRight(/* @__PURE__ */ parse3("psci-support"));
var supportPackage = function(packageSet) {
  return bind47(ask9)(function(v) {
    if (packageSet instanceof PackageSet2) {
      return pure61(filterWithKey4(function(k) {
        return function(_v) {
          return eq30(k)(supportPackageName);
        };
      })(packageSet.value0));
    }
    ;
    if (packageSet instanceof Registry) {
      return bind47(runSpago4({
        logOptions: v.logOptions
      })(v.getMetadata(supportPackageName)))(function(maybeMetadata) {
        return pure61(function() {
          if (maybeMetadata instanceof Right) {
            var v1 = findMax(maybeMetadata.value0.published);
            if (v1 instanceof Nothing) {
              return empty3;
            }
            ;
            if (v1 instanceof Just) {
              return singleton10(supportPackageName)(new RegistryVersion(v1.value0.key));
            }
            ;
            throw new Error("Failed pattern match at Spago.Command.Repl (line 53, column 38 - line 55, column 81): " + [v1.constructor.name]);
          }
          ;
          if (maybeMetadata instanceof Left) {
            return empty3;
          }
          ;
          throw new Error("Failed pattern match at Spago.Command.Repl (line 52, column 12 - line 56, column 31): " + [maybeMetadata.constructor.name]);
        }());
      });
    }
    ;
    throw new Error("Failed pattern match at Spago.Command.Repl (line 47, column 3 - line 56, column 31): " + [packageSet.constructor.name]);
  });
};
var run5 = /* @__PURE__ */ bind47(ask9)(function(v) {
  var globs = getBuildGlobs({
    selected: v.selected,
    dependencies: v.dependencies,
    depsOnly: v.depsOnly,
    withTests: true
  });
  return $$void16(runSpago4({
    purs: v.purs,
    logOptions: v.logOptions
  })(repl(globs)(v.pursArgs)));
});

// output/Spago.Tar/foreign.js
var import_tar = __toESM(require_tar(), 1);
var extractImpl = (onError3, onSuccess, cwd3, filename) => () => {
  try {
    (0, import_tar.extract)({
      sync: true,
      cwd: cwd3,
      file: filename
    });
    return onSuccess({});
  } catch (err) {
    return onError3(err);
  }
};

// output/Spago.Tar/index.js
var extract3 = function(v) {
  return extractImpl(Left.create, Right.create, v.cwd, v.filename);
};

// output/Spago.Command.Fetch/index.js
var append31 = /* @__PURE__ */ append(semigroupDependencies);
var mempty19 = /* @__PURE__ */ mempty(monoidDependencies);
var map72 = /* @__PURE__ */ map(functorMaybe);
var bind48 = /* @__PURE__ */ bind(bindSpago);
var mkTemp$prime2 = /* @__PURE__ */ mkTemp$prime(monadAffSpago);
var discard28 = /* @__PURE__ */ discard(discardUnit);
var discard112 = /* @__PURE__ */ discard28(bindSpago);
var logDebug10 = /* @__PURE__ */ logDebug(monadEffectSpago)(monadAskSpago)(loggableString);
var mkdirp3 = /* @__PURE__ */ mkdirp(monadAffSpago);
var moveSync3 = /* @__PURE__ */ moveSync2(monadEffectSpago);
var pure62 = /* @__PURE__ */ pure(applicativeSpago);
var map130 = /* @__PURE__ */ map(functorMap);
var die8 = /* @__PURE__ */ die(monadEffectSpago)(monadAskSpago);
var loggableArray6 = /* @__PURE__ */ loggableArray(loggableString);
var die13 = /* @__PURE__ */ die8(loggableArray6);
var ask10 = /* @__PURE__ */ ask(monadAskSpago);
var runSpago5 = /* @__PURE__ */ runSpago(monadAffSpago);
var unwrap16 = /* @__PURE__ */ unwrap();
var unlessM3 = /* @__PURE__ */ unlessM(monadSpago);
var exists7 = /* @__PURE__ */ exists2(monadEffectSpago);
var liftEffect9 = /* @__PURE__ */ liftEffect(monadEffectSpago);
var union8 = /* @__PURE__ */ union3(ordPackageName);
var cycleIsSymbol = {
  reflectSymbol: function() {
    return "cycle";
  }
};
var notInIndexIsSymbol = {
  reflectSymbol: function() {
    return "notInIndex";
  }
};
var notInPackageSetIsSymbol = {
  reflectSymbol: function() {
    return "notInPackageSet";
  }
};
var semigroupSet2 = /* @__PURE__ */ semigroupSet(ordPackageName);
var append210 = /* @__PURE__ */ append(/* @__PURE__ */ semigroupRecord()(/* @__PURE__ */ semigroupRecordCons(cycleIsSymbol)()(/* @__PURE__ */ semigroupRecordCons(notInIndexIsSymbol)()(/* @__PURE__ */ semigroupRecordCons(notInPackageSetIsSymbol)()(semigroupRecordNil)(semigroupSet2))(semigroupSet2))(semigroupSet2)));
var lookup10 = /* @__PURE__ */ lookup3(ordPackageName);
var insert17 = /* @__PURE__ */ insert3(ordPackageName);
var monoidSet2 = /* @__PURE__ */ monoidSet(ordPackageName);
var mempty110 = /* @__PURE__ */ mempty(/* @__PURE__ */ monoidRecord()(/* @__PURE__ */ monoidRecordCons(cycleIsSymbol)(monoidSet2)()(/* @__PURE__ */ monoidRecordCons(notInIndexIsSymbol)(monoidSet2)()(/* @__PURE__ */ monoidRecordCons(notInPackageSetIsSymbol)(monoidSet2)()(monoidRecordNil)))));
var member8 = /* @__PURE__ */ member2(ordPackageName);
var applicativeStateT2 = /* @__PURE__ */ applicativeStateT(monadSpago);
var pure119 = /* @__PURE__ */ pure(applicativeStateT2);
var bindStateT2 = /* @__PURE__ */ bindStateT(monadSpago);
var bind119 = /* @__PURE__ */ bind(bindStateT2);
var monadStateStateT3 = /* @__PURE__ */ monadStateStateT(monadSpago);
var get6 = /* @__PURE__ */ get(monadStateStateT3);
var lift8 = /* @__PURE__ */ lift(monadTransStateT)(monadSpago);
var $$for8 = /* @__PURE__ */ $$for(applicativeStateT2)(traversableArray);
var toUnfoldable21 = /* @__PURE__ */ toUnfoldable5(unfoldableArray);
var insert18 = /* @__PURE__ */ insert4(ordPackageName);
var foldl11 = /* @__PURE__ */ foldl(foldableArray);
var discard29 = /* @__PURE__ */ discard28(bindStateT2);
var when11 = /* @__PURE__ */ when(applicativeStateT2);
var append34 = /* @__PURE__ */ append(semigroupSet2);
var modify_5 = /* @__PURE__ */ modify_2(monadStateStateT3);
var for1 = /* @__PURE__ */ $$for(applicativeSpago)(traversableArray);
var evalStateT2 = /* @__PURE__ */ evalStateT(functorSpago);
var mempty26 = /* @__PURE__ */ mempty(monoidSet2);
var when1 = /* @__PURE__ */ when(applicativeSpago);
var die24 = /* @__PURE__ */ die8(loggableString);
var foldMap9 = /* @__PURE__ */ foldMap(foldableArray);
var foldMap17 = /* @__PURE__ */ foldMap9(monoidString);
var toUnfoldable110 = /* @__PURE__ */ toUnfoldable6(unfoldableArray);
var foldMap24 = /* @__PURE__ */ foldMap(foldableSet)(monoidString);
var map218 = /* @__PURE__ */ map(functorSpago);
var fromFoldable27 = /* @__PURE__ */ fromFoldable(foldableSet);
var fromFoldable113 = /* @__PURE__ */ fromFoldable6(ordVersion)(foldableArray);
var loadAndSolve2 = /* @__PURE__ */ loadAndSolve(monadSpago);
var die32 = /* @__PURE__ */ die8(/* @__PURE__ */ loggableArray(loggableDocc));
var toDoc6 = /* @__PURE__ */ toDoc2(loggableString);
var toDoc15 = /* @__PURE__ */ toDoc2(loggableArray6);
var fromFoldable28 = /* @__PURE__ */ fromFoldable(foldableNonEmptyList);
var map312 = /* @__PURE__ */ map(functorNonEmptyList);
var foldMap32 = /* @__PURE__ */ foldMap9(monoidDependencies);
var fromFoldable32 = /* @__PURE__ */ fromFoldable6(ordPackageName)(foldableArray);
var map412 = /* @__PURE__ */ map(functorArray);
var unless7 = /* @__PURE__ */ unless(applicativeSpago);
var logInfo6 = /* @__PURE__ */ logInfo(monadEffectSpago)(monadAskSpago)(loggableString);
var show37 = /* @__PURE__ */ show(showInt);
var liftAff6 = /* @__PURE__ */ liftAff(monadAffSpago);
var foldMap42 = /* @__PURE__ */ foldMap(foldableMaybe)(monoidDependencies);
var catMaybes4 = /* @__PURE__ */ catMaybes3(ordPackageName);
var forWithIndex4 = /* @__PURE__ */ forWithIndex(applicativeSpago)(traversableWithIndexMap);
var die42 = /* @__PURE__ */ die8(loggableDocc);
var bind213 = /* @__PURE__ */ bind(bindEither);
var lookup12 = /* @__PURE__ */ lookup3(ordVersion);
var mkTemp2 = /* @__PURE__ */ mkTemp(monadAffSpago);
var notEq6 = /* @__PURE__ */ notEq(eqStatusCode);
var fromArrayBuffer4 = /* @__PURE__ */ fromArrayBuffer(mutableBufferEffect);
var toString11 = /* @__PURE__ */ toString4(mutableBufferEffect);
var show115 = /* @__PURE__ */ show(showStatusCode);
var size9 = /* @__PURE__ */ size4(mutableBufferEffect);
var hashBuffer2 = /* @__PURE__ */ hashBuffer(monadEffectEffect);
var show211 = /* @__PURE__ */ show(showNumber);
var eq113 = /* @__PURE__ */ eq(eqSha256);
var writeFile5 = /* @__PURE__ */ writeFile4(monadAffSpago);
var show38 = /* @__PURE__ */ show(/* @__PURE__ */ showRecord()()(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "code";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "cwd";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "file";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "recoverable";
  }
})(/* @__PURE__ */ showRecordFieldsConsNil({
  reflectSymbol: function() {
    return "tarCode";
  }
})(showString))(showBoolean))(showString))(showString))(showString)));
var getWorkspacePackageDeps = function(pkg) {
  if (pkg.hasTests) {
    return append31(pkg["package"].dependencies)(fromMaybe(mempty19)(map72(function(v) {
      return v.dependencies;
    })(pkg["package"].test)));
  }
  ;
  return pkg["package"].dependencies;
};
var getVersionFromPackage = function(v) {
  if (v instanceof RegistryVersion) {
    return v.value0;
  }
  ;
  return unsafeFromRight(parse4("0.0.0"));
};
var getRangeFromPackage = function(v) {
  if (v instanceof RegistryVersion) {
    return caret(v.value0);
  }
  ;
  return widestRange;
};
var getGitPackageInLocalCache = function(name4) {
  return function($$package2) {
    var localPackageLocation = getPackageLocation(name4)(new GitPackage($$package2));
    return bind48(mkTemp$prime2(new Just(printJson(gitPackageCodec)($$package2))))(function(tempDir) {
      return discard112(logDebug10("Cloning repo in " + tempDir))(function() {
        return discard112(fetchRepo($$package2)(tempDir))(function() {
          return discard112(logDebug10("Repo cloned. Moving to " + localPackageLocation))(function() {
            return discard112(mkdirp3(concat2([localCachePackagesPath, print2(name4)])))(function() {
              return moveSync3({
                src: tempDir,
                dst: localPackageLocation
              });
            });
          });
        });
      });
    });
  };
};
var getPackageDependencies = function(packageName) {
  return function($$package2) {
    var readLocalDependencies = function(configLocation) {
      return bind48(readConfig(concat2([configLocation, "spago.yaml"])))(function(v) {
        if (v instanceof Right && v["value0"]["yaml"]["package"] instanceof Just) {
          return pure62(new Just(map130(fromMaybe(widestRange))(v["value0"]["yaml"]["package"].value0.dependencies)));
        }
        ;
        if (v instanceof Right) {
          return die13(["Read valid configuration from " + configLocation, "However, there was no `package` section to be read."]);
        }
        ;
        if (v instanceof Left) {
          return die13(["Could not read config at " + configLocation, "Error: " + v.value0]);
        }
        ;
        throw new Error("Failed pattern match at Spago.Command.Fetch (line 271, column 74 - line 275, column 90): " + [v.constructor.name]);
      });
    };
    if ($$package2 instanceof RegistryVersion) {
      return bind48(ask10)(function(v1) {
        return bind48(runSpago5({
          logOptions: v1.logOptions
        })(v1.getManifestFromIndex(packageName)($$package2.value0)))(function(maybeManifest) {
          return pure62(map72(function($320) {
            return function(v2) {
              return v2.dependencies;
            }(unwrap16($320));
          })(maybeManifest));
        });
      });
    }
    ;
    if ($$package2 instanceof GitPackage) {
      var packageLocation = getPackageLocation(packageName)($$package2);
      return discard112(unlessM3(exists7(packageLocation))(getGitPackageInLocalCache(packageName)($$package2.value0)))(function() {
        if ($$package2.value0.dependencies instanceof Just) {
          return pure62(new Just(map130(fromMaybe(widestRange))($$package2.value0.dependencies.value0)));
        }
        ;
        if ($$package2.value0.dependencies instanceof Nothing) {
          return readLocalDependencies(function() {
            if ($$package2.value0.subdir instanceof Nothing) {
              return packageLocation;
            }
            ;
            if ($$package2.value0.subdir instanceof Just) {
              return concat2([packageLocation, $$package2.value0.subdir.value0]);
            }
            ;
            throw new Error("Failed pattern match at Spago.Command.Fetch (line 259, column 31 - line 261, column 55): " + [$$package2.value0.subdir.constructor.name]);
          }());
        }
        ;
        throw new Error("Failed pattern match at Spago.Command.Fetch (line 256, column 5 - line 261, column 55): " + [$$package2.value0.dependencies.constructor.name]);
      });
    }
    ;
    if ($$package2 instanceof LocalPackage) {
      return readLocalDependencies($$package2.value0.path);
    }
    ;
    if ($$package2 instanceof WorkspacePackage) {
      return pure62(new Just(map130(fromMaybe(widestRange))(unwrap16(getWorkspacePackageDeps($$package2.value0)))));
    }
    ;
    throw new Error("Failed pattern match at Spago.Command.Fetch (line 245, column 46 - line 265, column 90): " + [$$package2.constructor.name]);
  };
};
var getTransitiveDepsFromPackageSet = function(packageSet) {
  return function(deps) {
    return discard112(logDebug10("Getting transitive deps"))(function() {
      return bind48(liftEffect9($$new(empty3)))(function(packageDependenciesCache) {
        var printPackageError = function(p) {
          return "  - " + (print2(p) + "\n");
        };
        var mergeResults = function(r1) {
          return function(r2) {
            return {
              packages: union8(r1.packages)(r2.packages),
              errors: append210(r1.errors)(r2.errors)
            };
          };
        };
        var memoisedGetPackageDependencies = function(packageName) {
          return function($$package2) {
            return bind48(liftEffect9(read(packageDependenciesCache)))(function(cache) {
              var v = lookup10(packageName)(cache);
              if (v instanceof Just) {
                return pure62(v.value0);
              }
              ;
              if (v instanceof Nothing) {
                return bind48(getPackageDependencies(packageName)($$package2))(function(res) {
                  return discard112(liftEffect9(modify_(insert17(packageName)(res))(packageDependenciesCache)))(function() {
                    return pure62(res);
                  });
                });
              }
              ;
              throw new Error("Failed pattern match at Spago.Command.Fetch (line 341, column 7 - line 347, column 19): " + [v.constructor.name]);
            });
          };
        };
        var init4 = {
          packages: empty3,
          errors: mempty110
        };
        var go = function(seen) {
          return function(dep) {
            var $222 = member8(dep)(seen);
            if ($222) {
              return pure119({
                errors: {
                  cycle: singleton11(dep),
                  notInIndex: init4.errors.notInIndex,
                  notInPackageSet: init4.errors.notInPackageSet
                },
                packages: init4.packages
              });
            }
            ;
            return bind119(get6)(function(cache) {
              var v = lookup10(dep)(cache);
              if (v instanceof Just) {
                return pure119({
                  packages: v.value0,
                  errors: init4.errors
                });
              }
              ;
              if (v instanceof Nothing) {
                var v1 = lookup10(dep)(packageSet);
                if (v1 instanceof Nothing) {
                  return pure119({
                    errors: {
                      notInPackageSet: singleton11(dep),
                      cycle: init4.errors.cycle,
                      notInIndex: init4.errors.notInIndex
                    },
                    packages: init4.packages
                  });
                }
                ;
                if (v1 instanceof Just) {
                  return bind119(lift8(memoisedGetPackageDependencies(dep)(v1.value0)))(function(maybeDeps) {
                    if (maybeDeps instanceof Nothing) {
                      return pure119({
                        errors: {
                          notInIndex: singleton11(dep),
                          cycle: init4.errors.cycle,
                          notInPackageSet: init4.errors.notInPackageSet
                        },
                        packages: init4.packages
                      });
                    }
                    ;
                    if (maybeDeps instanceof Just) {
                      return bind119(bind119($$for8(toUnfoldable21(maybeDeps.value0))(function(v2) {
                        return go(insert18(dep)(seen))(v2.value0);
                      }))(function() {
                        var $321 = foldl11(mergeResults)(init4);
                        return function($322) {
                          return pure119($321($322));
                        };
                      }()))(function(v2) {
                        var allDeps = insert17(dep)(v1.value0)(v2.packages);
                        return discard29(when11(isEmpty3(append34(v2.errors.cycle)(append34(v2.errors.notInIndex)(v2.errors.notInPackageSet))))(modify_5(insert17(dep)(allDeps))))(function() {
                          return pure119({
                            packages: allDeps,
                            errors: v2.errors
                          });
                        });
                      });
                    }
                    ;
                    throw new Error("Failed pattern match at Spago.Command.Fetch (line 377, column 17 - line 387, column 55): " + [maybeDeps.constructor.name]);
                  });
                }
                ;
                throw new Error("Failed pattern match at Spago.Command.Fetch (line 373, column 13 - line 387, column 55): " + [v1.constructor.name]);
              }
              ;
              throw new Error("Failed pattern match at Spago.Command.Fetch (line 367, column 9 - line 387, column 55): " + [v.constructor.name]);
            });
          };
        };
        return bind48(bind48(for1(deps)(function(d) {
          return evalStateT2(go(mempty26)(d))(empty3);
        }))(function() {
          var $323 = foldl11(mergeResults)(init4);
          return function($324) {
            return pure62($323($324));
          };
        }()))(function(v) {
          return discard112(when1(!isEmpty3(v.errors.cycle))(die24("The following packages have circular dependencies:\n" + foldMap17(printPackageError)(toUnfoldable110(v.errors.cycle)))))(function() {
            return discard112(when1(!isEmpty3(v.errors.notInPackageSet))(die24("The following packages do not exist in your package set:\n" + foldMap24(printPackageError)(v.errors.notInPackageSet))))(function() {
              return discard112(when1(!isEmpty3(v.errors.notInIndex))(die24("The following packages do not exist in the package index:\n" + foldMap24(printPackageError)(v.errors.notInIndex))))(function() {
                return pure62(v.packages);
              });
            });
          });
        });
      });
    });
  };
};
var getTransitiveDepsFromRegistry = function(depsRanges) {
  return function(extraPackages) {
    return bind48(ask10)(function(v) {
      var loader = function(packageName) {
        var v1 = lookup10(packageName)(extraPackages);
        if (v1 instanceof Just) {
          return map218(function() {
            var $325 = singleton10(getVersionFromPackage(v1.value0));
            var $326 = fromMaybe(empty3);
            return function($327) {
              return $325($326($327));
            };
          }())(getPackageDependencies(packageName)(v1.value0));
        }
        ;
        if (v1 instanceof Nothing) {
          return bind48(runSpago5({
            logOptions: v.logOptions
          })(v.getMetadata(packageName)))(function(maybeMetadata) {
            var versions = function() {
              if (maybeMetadata instanceof Right) {
                return fromFoldable27(keys3(maybeMetadata.value0.published));
              }
              ;
              if (maybeMetadata instanceof Left) {
                return [];
              }
              ;
              throw new Error("Failed pattern match at Spago.Command.Fetch (line 315, column 24 - line 317, column 30): " + [maybeMetadata.constructor.name]);
            }();
            return map218(fromFoldable113)(for1(versions)(function(v2) {
              return bind48(runSpago5({
                logOptions: v.logOptions
              })(v.getManifestFromIndex(packageName)(v2)))(function(maybeManifest) {
                var deps = fromMaybe(empty3)(map72(function($328) {
                  return function(v3) {
                    return v3.dependencies;
                  }(unwrap16($328));
                })(maybeManifest));
                return pure62(new Tuple(v2, deps));
              });
            }));
          });
        }
        ;
        throw new Error("Failed pattern match at Spago.Command.Fetch (line 310, column 7 - line 321, column 32): " + [v1.constructor.name]);
      };
      return bind48(loadAndSolve2(loader)(depsRanges))(function(maybePlan) {
        if (maybePlan instanceof Left) {
          return die32([toDoc6("Could not solve the package dependencies, errors:"), indent(toDoc15(fromFoldable28(map312(printSolverError)(maybePlan.value0))))]);
        }
        ;
        if (maybePlan instanceof Right) {
          return pure62(maybePlan.value0);
        }
        ;
        throw new Error("Failed pattern match at Spago.Command.Fetch (line 323, column 3 - line 329, column 21): " + [maybePlan.constructor.name]);
      });
    });
  };
};
var getTransitiveDeps = function(v) {
  var depsRanges = map130(fromMaybe(widestRange))(v);
  return bind48(ask10)(function(v1) {
    if (v1.workspace.packageSet instanceof Registry) {
      return bind48(getTransitiveDepsFromRegistry(depsRanges)(v1.workspace.packageSet.value0))(function(plan) {
        return discard112(logDebug10("Got a plan from the Solver: " + printJson(packageMap(codec3))(plan)))(function() {
          return pure62(map130(RegistryVersion.create)(plan));
        });
      });
    }
    ;
    if (v1.workspace.packageSet instanceof PackageSet2) {
      return getTransitiveDepsFromPackageSet(v1.workspace.packageSet.value0)(fromFoldable27(keys3(depsRanges)));
    }
    ;
    throw new Error("Failed pattern match at Spago.Command.Fetch (line 296, column 3 - line 301, column 101): " + [v1.workspace.packageSet.constructor.name]);
  });
};
var run6 = function(v) {
  return discard112(logDebug10("Requested to install these packages: " + printJson(array(codec2))(v.packages)))(function() {
    return bind48(ask10)(function(v1) {
      var deps = function() {
        if (v1.workspace.selected instanceof Just) {
          return getWorkspacePackageDeps(v1.workspace.selected.value0);
        }
        ;
        if (v1.workspace.selected instanceof Nothing) {
          return foldMap32(getWorkspacePackageDeps)(getWorkspacePackages(v1.workspace.packageSet));
        }
        ;
        throw new Error("Failed pattern match at Spago.Command.Fetch (line 70, column 12 - line 74, column 91): " + [v1.workspace.selected.constructor.name]);
      }();
      return bind48(getTransitiveDeps(append31(deps)(fromFoldable32(map412(function(v2) {
        return new Tuple(v2, Nothing.value);
      })(v.packages)))))(function(transitivePackages) {
        var v2 = function() {
          if (v1.workspace.selected instanceof Nothing) {
            return {
              configPath: "spago.yaml",
              yamlDoc: v1.workspace.doc
            };
          }
          ;
          if (v1.workspace.selected instanceof Just) {
            return {
              configPath: concat2([v1.workspace.selected.value0.path, "spago.yaml"]),
              yamlDoc: v1.workspace.selected.value0.doc
            };
          }
          ;
          throw new Error("Failed pattern match at Spago.Command.Fetch (line 83, column 31 - line 85, column 93): " + [v1.workspace.selected.constructor.name]);
        }();
        return discard112(unless7($$null(v.packages))(discard112(logInfo6("Adding " + (show37(length(v.packages)) + (" packages to the config in " + v2.configPath))))(function() {
          return discard112(liftEffect9(addPackagesToConfig(v2.yamlDoc)(v.packages)))(function() {
            return liftAff6(writeYamlDocFile(v2.configPath)(v2.yamlDoc));
          });
        })))(function() {
          return discard112(when1(v.ensureRanges)(discard112(logInfo6("Adding ranges to dependencies to the config in " + v2.configPath))(function() {
            var rangeMap = map130(getRangeFromPackage)(transitivePackages);
            return discard112(liftEffect9(addRangesToConfig(v2.yamlDoc)(rangeMap)))(function() {
              return liftAff6(writeYamlDocFile(v2.configPath)(v2.yamlDoc));
            });
          })))(function() {
            return bind48(function() {
              var fromWorkspacePackage = function(v3) {
                var test_dependencies = foldMap42(function(v4) {
                  return v4.dependencies;
                })(v3["package"].test);
                return new Tuple(v3["package"].name, {
                  path: v3.path,
                  dependencies: v3["package"].dependencies,
                  test_dependencies
                });
              };
              var lockfileWorkspace = {
                package_set: v1.workspace.originalConfig.package_set,
                packages: fromFoldable32(map412(fromWorkspacePackage)(getWorkspacePackages(v1.workspace.packageSet))),
                extra_packages: fromMaybe(empty3)(v1.workspace.originalConfig.extra_packages)
              };
              return bind48(map218(catMaybes4)(forWithIndex4(transitivePackages)(function(packageName) {
                return function($$package2) {
                  return bind48(map218(function() {
                    var $329 = fromMaybe(empty3);
                    return function($330) {
                      return fromFoldable27(keys3($329($330)));
                    };
                  }())(getPackageDependencies(packageName)($$package2)))(function(v3) {
                    if ($$package2 instanceof GitPackage) {
                      var packageLocation = getPackageLocation(packageName)($$package2);
                      return bind48(getRef(new Just(packageLocation)))(function(v4) {
                        if (v4 instanceof Left) {
                          return die42(v4.value0);
                        }
                        ;
                        if (v4 instanceof Right) {
                          return pure62(new Just(new FromGit({
                            rev: v4.value0,
                            dependencies: v3,
                            url: $$package2.value0.git,
                            subdir: $$package2.value0.subdir
                          })));
                        }
                        ;
                        throw new Error("Failed pattern match at Spago.Command.Fetch (line 127, column 51 - line 129, column 140): " + [v4.constructor.name]);
                      });
                    }
                    ;
                    if ($$package2 instanceof RegistryVersion) {
                      return bind48(runSpago5({
                        logOptions: v1.logOptions
                      })(v1.getMetadata(packageName)))(function(metadata) {
                        return bind48(function() {
                          var v4 = bind213(metadata)(function(v5) {
                            return note("Didn't find version in the metadata file")(lookup12($$package2.value0)(v5.published));
                          });
                          if (v4 instanceof Left) {
                            return die24("Couldn't read metadata, reason:\n  " + v4.value0);
                          }
                          ;
                          if (v4 instanceof Right) {
                            return pure62({
                              version: $$package2.value0,
                              integrity: v4.value0.hash,
                              dependencies: v3
                            });
                          }
                          ;
                          throw new Error("Failed pattern match at Spago.Command.Fetch (line 132, column 32 - line 135, column 79): " + [v4.constructor.name]);
                        }())(function(registryVersion) {
                          return pure62(new Just(new FromRegistry(registryVersion)));
                        });
                      });
                    }
                    ;
                    if ($$package2 instanceof LocalPackage) {
                      return pure62(new Just(new FromPath({
                        path: $$package2.value0.path,
                        dependencies: v3
                      })));
                    }
                    ;
                    if ($$package2 instanceof WorkspacePackage) {
                      return pure62(Nothing.value);
                    }
                    ;
                    throw new Error("Failed pattern match at Spago.Command.Fetch (line 124, column 9 - line 138, column 47): " + [$$package2.constructor.name]);
                  });
                };
              })))(function(v3) {
                return pure62({
                  workspace: lockfileWorkspace,
                  packages: v3
                });
              });
            }())(function(lockfile) {
              var shouldWriteLockFile = function() {
                if (v1.workspace.selected instanceof Nothing && v1.workspace.lockfile instanceof GenerateLockfile) {
                  return true;
                }
                ;
                if (v1.workspace.selected instanceof Nothing && v1.workspace.lockfile instanceof UseLockfile) {
                  return true;
                }
                ;
                return false;
              }();
              return discard112(when1(shouldWriteLockFile)(discard112(logInfo6("Writing a new lockfile"))(function() {
                return liftAff6(writeYamlFile(lockfileCodec)("spago.lock")(lockfile));
              })))(function() {
                return discard112(logInfo6("Downloading dependencies..."))(function() {
                  return bind48(supportPackage(v1.workspace.packageSet))(function(supportPackage2) {
                    var transitivePackages$prime = union8(transitivePackages)(supportPackage2);
                    return discard112(parallelise(flip(map412)(toUnfoldable21(transitivePackages$prime))(function(v3) {
                      var localPackageLocation = getPackageLocation(v3.value0)(v3.value1);
                      return unlessM3(exists7(localPackageLocation))(function() {
                        if (v3.value1 instanceof GitPackage) {
                          return getGitPackageInLocalCache(v3.value0)(v3.value1.value0);
                        }
                        ;
                        if (v3.value1 instanceof RegistryVersion) {
                          var versionString = print3(v3.value1.value0);
                          var packageVersion = print2(v3.value0) + ("@" + versionString);
                          return bind48(runSpago5({
                            logOptions: v1.logOptions
                          })(v1.getMetadata(v3.value0)))(function(metadata) {
                            var v5 = bind213(metadata)(function(v6) {
                              return note("Didn't find version in the metadata file")(lookup12(v3.value1.value0)(v6.published));
                            });
                            if (v5 instanceof Left) {
                              return die24("Couldn't read metadata, reason:\n  " + v5.value0);
                            }
                            ;
                            if (v5 instanceof Right) {
                              return discard112(logDebug10("Metadata read: " + printJson(publishedMetadataCodec)(v5.value0)))(function() {
                                var globalCachePackagePath = concat2([globalCachePath, "packages", print2(v3.value0)]);
                                var archivePath = concat2([globalCachePackagePath, versionString + ".tar.gz"]);
                                return discard112(mkdirp3(globalCachePackagePath))(function() {
                                  return bind48(exists7(archivePath))(function(tarExists) {
                                    var tarInnerFolder = print2(v3.value0) + ("-" + print3(v3.value1.value0));
                                    return bind48(mkTemp2)(function(tempDir) {
                                      return discard112(mkdirp3(tempDir))(function() {
                                        return bind48(function() {
                                          if (tarExists) {
                                            return discard112(logDebug10("Trying to unpack archive to temp folder: " + tempDir))(function() {
                                              return map218(either($$const(false))($$const(true)))(liftEffect9(extract3({
                                                filename: archivePath,
                                                cwd: tempDir
                                              })));
                                            });
                                          }
                                          ;
                                          return pure62(false);
                                        }())(function(tarIsGood) {
                                          return discard112(function() {
                                            if (tarExists && tarIsGood) {
                                              return pure62(unit);
                                            }
                                            ;
                                            return discard112(logInfo6("Fetching package " + packageVersion))(function() {
                                              return bind48(liftAff6(request2({
                                                method: new Left(GET.value),
                                                url: "https://packages.registry.purescript.org/" + (print2(v3.value0) + ("/" + (versionString + ".tar.gz"))),
                                                headers: defaultRequest.headers,
                                                content: defaultRequest.content,
                                                username: defaultRequest.username,
                                                password: defaultRequest.password,
                                                withCredentials: defaultRequest.withCredentials,
                                                responseFormat: arrayBuffer,
                                                timeout: defaultRequest.timeout
                                              })))(function(response) {
                                                if (response instanceof Left) {
                                                  return die24("Couldn't fetch package " + (packageVersion + (":\n  " + printError2(response.value0))));
                                                }
                                                ;
                                                if (response instanceof Right && notEq6(response.value0.status)(200)) {
                                                  return bind48(liftEffect9(fromArrayBuffer4(response.value0.body)))(function(v6) {
                                                    return bind48(liftEffect9(toString11(UTF8.value)(v6)))(function(bodyString) {
                                                      return die24("Couldn't fetch package " + (packageVersion + (", status was not ok " + (show115(response.value0.status) + (", got answer:\n  " + bodyString)))));
                                                    });
                                                  });
                                                }
                                                ;
                                                if (response instanceof Right) {
                                                  return discard112(logDebug10("Got status: " + show115(response.value0.status)))(function() {
                                                    return bind48(liftEffect9(fromArrayBuffer4(response.value0.body)))(function(archiveBuffer) {
                                                      return bind48(liftEffect9(size9(archiveBuffer)))(function(archiveSize) {
                                                        return bind48(liftEffect9(hashBuffer2(archiveBuffer)))(function(archiveSha) {
                                                          return discard112(unless7(toNumber2(archiveSize) === v5.value0.bytes)(die24("Archive fetched for " + (packageVersion + (" has a different size (" + (show37(archiveSize) + (") than expected (" + (show211(v5.value0.bytes) + ")"))))))))(function() {
                                                            return discard112(unless7(eq113(archiveSha)(v5.value0.hash))(die24("Archive fetched for " + (packageVersion + (" has a different hash (" + (print6(archiveSha) + (") than expected (" + (print6(v5.value0.hash) + ")"))))))))(function() {
                                                              return discard112(logDebug10("Fetched archive for " + (packageVersion + (", saving it in the global cache: " + archivePath))))(function() {
                                                                return discard112(writeFile5(archivePath)(archiveBuffer))(function() {
                                                                  return discard112(logDebug10("Unpacking archive to temp folder: " + tempDir))(function() {
                                                                    return bind48(liftEffect9(extract3({
                                                                      filename: archivePath,
                                                                      cwd: tempDir
                                                                    })))(function(v6) {
                                                                      if (v6 instanceof Right) {
                                                                        return pure62(unit);
                                                                      }
                                                                      ;
                                                                      if (v6 instanceof Left) {
                                                                        return die13(["Failed to decode downloaded package " + (packageVersion + ", error:"), show38(v6.value0)]);
                                                                      }
                                                                      ;
                                                                      throw new Error("Failed pattern match at Spago.Command.Fetch (line 223, column 92 - line 225, column 123): " + [v6.constructor.name]);
                                                                    });
                                                                  });
                                                                });
                                                              });
                                                            });
                                                          });
                                                        });
                                                      });
                                                    });
                                                  });
                                                }
                                                ;
                                                throw new Error("Failed pattern match at Spago.Command.Fetch (line 203, column 17 - line 225, column 123): " + [response.constructor.name]);
                                              });
                                            });
                                          }())(function() {
                                            return discard112(logDebug10("Moving extracted file to local cache:" + localPackageLocation))(function() {
                                              return moveSync3({
                                                src: concat2([tempDir, tarInnerFolder]),
                                                dst: localPackageLocation
                                              });
                                            });
                                          });
                                        });
                                      });
                                    });
                                  });
                                });
                              });
                            }
                            ;
                            throw new Error("Failed pattern match at Spago.Command.Fetch (line 170, column 9 - line 227, column 102): " + [v5.constructor.name]);
                          });
                        }
                        ;
                        if (v3.value1 instanceof LocalPackage) {
                          return pure62(unit);
                        }
                        ;
                        if (v3.value1 instanceof WorkspacePackage) {
                          return pure62(unit);
                        }
                        ;
                        throw new Error("Failed pattern match at Spago.Command.Fetch (line 162, column 46 - line 230, column 38): " + [v3.value1.constructor.name]);
                      }());
                    })))(function() {
                      return pure62(transitivePackages);
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
  });
};

// output/Spago.Command.Init/index.js
var show39 = /* @__PURE__ */ show(showString);
var fromFoldable29 = /* @__PURE__ */ fromFoldable6(ordPackageName)(foldableArray);
var map73 = /* @__PURE__ */ map(functorMaybe);
var bind49 = /* @__PURE__ */ bind(bindSpago);
var exists8 = /* @__PURE__ */ exists2(monadEffectSpago);
var logInfo7 = /* @__PURE__ */ logInfo(monadEffectSpago)(monadAskSpago)(loggableString);
var applySecond6 = /* @__PURE__ */ applySecond(applySpago);
var mkdirp4 = /* @__PURE__ */ mkdirp(monadAffSpago);
var writeTextFile6 = /* @__PURE__ */ writeTextFile3(monadAffSpago);
var discard30 = /* @__PURE__ */ discard(discardUnit)(bindSpago);
var ask11 = /* @__PURE__ */ ask(monadAskSpago);
var liftAff7 = /* @__PURE__ */ liftAff(monadAffSpago);
var pure63 = /* @__PURE__ */ pure(applicativeSpago);
var testMainTemplate = function(moduleName2) {
  return "module " + (moduleName2 + ' where\n\nimport Prelude\n\nimport Effect (Effect)\nimport Effect.Class.Console (log)\n\nmain :: Effect Unit\nmain = do\n  log "\u{1F355}"\n  log "You should add some tests."\n\n');
};
var srcMainTemplate = function(moduleName2) {
  return "module " + (moduleName2 + ' where\n\nimport Prelude\n\nimport Effect (Effect)\nimport Effect.Console (log)\n\nmain :: Effect Unit\nmain = do\n  log "\u{1F35D}"\n\n');
};
var pursReplTemplate = "\nimport Prelude\n";
var gitignoreTemplate = "\nbower_components/\nnode_modules/\n.pulp-cache/\noutput/\ngenerated-docs/\n.psc-package/\n.psc*\n.purs*\n.psa*\n.spago\n";
var foundExistingProject = function(path5) {
  return "Found a " + (show39(path5) + " file, skipping copy.");
};
var foundExistingFile = function(file) {
  return "Found existing file " + (show39(file) + ", not overwriting it");
};
var foundExistingDirectory = function(dir) {
  return "Found existing directory " + (show39(dir) + ", skipping copy of sample sources");
};
var defaultConfig = function(name4) {
  return function(setVersion) {
    return function(testModuleName) {
      var mkDep = function(p) {
        return new Tuple(unsafeFromRight(parse3(p)), Nothing.value);
      };
      return {
        "package": new Just({
          name: name4,
          dependencies: fromFoldable29([mkDep("effect"), mkDep("console"), mkDep("prelude")]),
          description: Nothing.value,
          run: Nothing.value,
          test: new Just({
            dependencies: empty3,
            execArgs: Nothing.value,
            main: testModuleName
          }),
          publish: Nothing.value,
          bundle: Nothing.value
        }),
        workspace: map73(function(set2) {
          return {
            extra_packages: new Just(empty3),
            package_set: new Just(new SetFromRegistry({
              registry: set2
            })),
            build_opts: Nothing.value,
            backend: Nothing.value,
            lock: Nothing.value
          };
        })(setVersion)
      };
    };
  };
};
var run7 = function(opts) {
  var whenDirNotExists = function(dirPath) {
    return function(action) {
      return bind49(exists8(dirPath))(function(v) {
        if (v) {
          return logInfo7(foundExistingDirectory(dirPath));
        }
        ;
        if (!v) {
          return applySecond6(mkdirp4(dirPath))(action);
        }
        ;
        throw new Error("Failed pattern match at Spago.Command.Init (line 63, column 29 - line 65, column 43): " + [v.constructor.name]);
      });
    };
  };
  var copyIfNotExists = function(dest) {
    return function(srcTemplate) {
      return bind49(exists8(dest))(function(v) {
        if (v) {
          return logInfo7(foundExistingFile(dest));
        }
        ;
        if (!v) {
          return writeTextFile6(dest)(srcTemplate);
        }
        ;
        throw new Error("Failed pattern match at Spago.Command.Init (line 68, column 26 - line 70, column 49): " + [v.constructor.name]);
      });
    };
  };
  return discard30(logInfo7("Initializing a new project..."))(function() {
    return bind49(findPackageSet(opts.setVersion))(function(packageSetVersion) {
      return bind49(ask11)(function(v) {
        return discard30(logInfo7("Found PureScript " + (print3(v.purs.version) + (", will use package set " + print3(packageSetVersion)))))(function() {
          var config = defaultConfig(opts.packageName)(new Just(packageSetVersion))("Test.Main");
          return discard30(bind49(exists8("spago.yaml"))(function(v1) {
            if (v1) {
              return logInfo7(foundExistingProject("spago.yaml"));
            }
            ;
            if (!v1) {
              return liftAff7(writeYamlFile(configCodec)("spago.yaml")(config));
            }
            ;
            throw new Error("Failed pattern match at Spago.Command.Init (line 40, column 30 - line 42, column 77): " + [v1.constructor.name]);
          }))(function() {
            return discard30(whenDirNotExists("src")(copyIfNotExists("src/Main.purs")(srcMainTemplate("Main"))))(function() {
              return discard30(whenDirNotExists("test")(discard30(mkdirp4("test/Test"))(function() {
                return copyIfNotExists("test/Test/Main.purs")(testMainTemplate("Test.Main"));
              })))(function() {
                return discard30(copyIfNotExists(".gitignore")(gitignoreTemplate))(function() {
                  return discard30(copyIfNotExists(".purs-repl")(pursReplTemplate))(function() {
                    return pure63(config);
                  });
                });
              });
            });
          });
        });
      });
    });
  });
};

// output/Spago.Command.Ls/index.js
var map74 = /* @__PURE__ */ map(functorArray);
var object8 = /* @__PURE__ */ object2();
var rowListCodecCons7 = /* @__PURE__ */ rowListCodecCons(rowListCodecNil)()();
var object1 = /* @__PURE__ */ object8(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons7({
  reflectSymbol: function() {
    return "path";
  }
}))()()({
  reflectSymbol: function() {
    return "package";
  }
}))()()({
  reflectSymbol: function() {
    return "hasTests";
  }
}));
var $$delete10 = /* @__PURE__ */ $$delete5({
  reflectSymbol: function() {
    return "doc";
  }
})()();
var object22 = /* @__PURE__ */ object8(/* @__PURE__ */ rowListCodecCons7({
  reflectSymbol: function() {
    return "version";
  }
}));
var alt25 = /* @__PURE__ */ alt(altEither);
var map131 = /* @__PURE__ */ map(functorEither);
var object32 = /* @__PURE__ */ object8(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons7({
  reflectSymbol: function() {
    return "value";
  }
}))()()({
  reflectSymbol: function() {
    return "type";
  }
}));
var map219 = /* @__PURE__ */ map(functorMap);
var fromFoldable30 = /* @__PURE__ */ fromFoldable6(ordPackageName)(foldableArray);
var discard31 = /* @__PURE__ */ discard(discardUnit)(bindSpago);
var logDebug11 = /* @__PURE__ */ logDebug(monadEffectSpago)(monadAskSpago)(loggableString);
var bind50 = /* @__PURE__ */ bind(bindSpago);
var ask12 = /* @__PURE__ */ ask(monadAskSpago);
var die9 = /* @__PURE__ */ die(monadEffectSpago)(monadAskSpago)(loggableString);
var toUnfoldable24 = /* @__PURE__ */ toUnfoldable5(unfoldableArray);
var unwrap17 = /* @__PURE__ */ unwrap();
var filterKeys3 = /* @__PURE__ */ filterKeys(ordPackageName);
var elem5 = /* @__PURE__ */ elem(foldableSet)(eqPackageName);
var logWarn5 = /* @__PURE__ */ logWarn(monadEffectSpago)(monadAskSpago)(loggableString);
var formatPackagesTable = function(dictMonadEffect) {
  var output5 = output(dictMonadEffect);
  return function(pkgs) {
    var showVersion = function(v) {
      if (v instanceof RegistryVersion) {
        return print3(v.value0);
      }
      ;
      if (v instanceof GitPackage) {
        return v.value0.ref;
      }
      ;
      if (v instanceof LocalPackage) {
        return "local";
      }
      ;
      if (v instanceof WorkspacePackage) {
        return "workspace";
      }
      ;
      throw new Error("Failed pattern match at Spago.Command.Ls (line 138, column 17 - line 142, column 38): " + [v.constructor.name]);
    };
    var showLocation = function(v) {
      if (v instanceof RegistryVersion) {
        return "-";
      }
      ;
      if (v instanceof GitPackage) {
        return v.value0.git;
      }
      ;
      if (v instanceof LocalPackage) {
        return v.value0.path;
      }
      ;
      if (v instanceof WorkspacePackage) {
        return v.value0.path;
      }
      ;
      throw new Error("Failed pattern match at Spago.Command.Ls (line 131, column 18 - line 135, column 38): " + [v.constructor.name]);
    };
    var toRow = function(v) {
      return [print2(v.value0), showVersion(v.value1), showLocation(v.value1)];
    };
    return output5(new OutputTable({
      titles: ["Package", "Version", "Location"],
      rows: map74(toRow)(pkgs)
    }));
  };
};
var formatPackagesTable1 = /* @__PURE__ */ formatPackagesTable(monadEffectSpago);
var formatPackagesJson = function(dictMonadEffect) {
  var output5 = output(dictMonadEffect);
  return function(packages2) {
    var wrapPackage = function(value4) {
      return {
        value: value4,
        type: function() {
          if (value4 instanceof RegistryVersion) {
            return "registry";
          }
          ;
          if (value4 instanceof GitPackage) {
            return "git";
          }
          ;
          if (value4 instanceof LocalPackage) {
            return "local";
          }
          ;
          if (value4 instanceof WorkspacePackage) {
            return "workspace";
          }
          ;
          throw new Error("Failed pattern match at Spago.Command.Ls (line 79, column 13 - line 83, column 42): " + [value4.constructor.name]);
        }()
      };
    };
    var workspacePackageCodec = function() {
      var encode3 = function() {
        var $119 = encode(object1("WorkspacePackage")({
          path: string,
          "package": packageConfigCodec,
          hasTests: $$boolean
        }));
        var $120 = $$delete10($$Proxy.value);
        return function($121) {
          return $119($120($121));
        };
      }();
      var decode2 = function(_json) {
        return new Left(MissingValue.value);
      };
      return codec$prime(decode2)(encode3);
    }();
    var packageCodec = function() {
      var registryVersionCodec = object22("RegistryVersion")({
        version: codec3
      });
      var encode3 = function(v) {
        if (v instanceof RegistryVersion) {
          return encode(registryVersionCodec)({
            version: v.value0
          });
        }
        ;
        if (v instanceof GitPackage) {
          return encode(gitPackageCodec)(v.value0);
        }
        ;
        if (v instanceof LocalPackage) {
          return encode(localPackageCodec)(v.value0);
        }
        ;
        if (v instanceof WorkspacePackage) {
          return encode(workspacePackageCodec)(v.value0);
        }
        ;
        throw new Error("Failed pattern match at Spago.Command.Ls (line 93, column 14 - line 97, column 62): " + [v.constructor.name]);
      };
      var decode2 = function(json4) {
        return alt25(map131(function($122) {
          return RegistryVersion.create(function(v) {
            return v.version;
          }($122));
        })(decode(registryVersionCodec)(json4)))(alt25(map131(GitPackage.create)(decode(gitPackageCodec)(json4)))(alt25(map131(LocalPackage.create)(decode(localPackageCodec)(json4)))(map131(WorkspacePackage.create)(decode(workspacePackageCodec)(json4)))));
      };
      var innerCodec = codec$prime(decode2)(encode3);
      return object32("Package")({
        type: string,
        value: innerCodec
      });
    }();
    return output5(new OutputJson(packageMap(packageCodec), map219(wrapPackage)(fromFoldable30(packages2))));
  };
};
var formatPackagesJson1 = /* @__PURE__ */ formatPackagesJson(monadEffectSpago);
var listPackageSet = function(v) {
  return discard31(logDebug11("Running `listPackageSet`"))(function() {
    return bind50(ask12)(function(v1) {
      if (v1.workspace.packageSet instanceof Registry) {
        return die9("No package set in the project");
      }
      ;
      if (v1.workspace.packageSet instanceof PackageSet2) {
        var packages2 = toUnfoldable24(v1.workspace.packageSet.value0);
        if (v.json) {
          return formatPackagesJson1(packages2);
        }
        ;
        if (!v.json) {
          return formatPackagesTable1(packages2);
        }
        ;
        throw new Error("Failed pattern match at Spago.Command.Ls (line 55, column 7 - line 57, column 46): " + [v.json.constructor.name]);
      }
      ;
      throw new Error("Failed pattern match at Spago.Command.Ls (line 51, column 3 - line 57, column 46): " + [v1.workspace.packageSet.constructor.name]);
    });
  });
};
var listPackages = function(v) {
  return discard31(logDebug11("Running `listPackages`"))(function() {
    return bind50(ask12)(function(v1) {
      var direct = keys3(unwrap17(function(v2) {
        return v2.dependencies;
      }(function(v2) {
        return v2["package"];
      }(v1.selected))));
      var directDependencies = filterKeys3(function(v2) {
        return elem5(v2)(direct);
      })(v1.dependencies);
      var packages2 = toUnfoldable24(function() {
        if (v.transitive) {
          return v1.dependencies;
        }
        ;
        return directDependencies;
      }());
      if (packages2.length === 0) {
        return logWarn5("There are no dependencies listed in your configuration");
      }
      ;
      if (v.json) {
        return formatPackagesJson1(packages2);
      }
      ;
      if (!v.json) {
        return formatPackagesTable1(packages2);
      }
      ;
      throw new Error("Failed pattern match at Spago.Command.Ls (line 70, column 10 - line 72, column 44): " + [v.json.constructor.name]);
    });
  });
};

// output/Data.Lens.Iso/index.js
var coerce8 = /* @__PURE__ */ coerce();
var iso = function(f) {
  return function(g) {
    return function(dictProfunctor) {
      var dimap6 = dimap(dictProfunctor);
      return function(pab) {
        return dimap6(f)(g)(pab);
      };
    };
  };
};
var coerced = function() {
  return function() {
    return function(dictProfunctor) {
      return iso(coerce8)(coerce8)(dictProfunctor);
    };
  };
};

// output/Data.Lens.Iso.Newtype/index.js
var coerced2 = /* @__PURE__ */ coerced()();
var _Newtype = function() {
  return function() {
    return function(dictProfunctor) {
      return coerced2(dictProfunctor);
    };
  };
};

// output/Routing.Duplex.Types/index.js
var emptyRouteState = {
  segments: [],
  params: [],
  hash: ""
};

// output/Routing.Duplex.Parser/index.js
var $runtime_lazy12 = function(name4, moduleName2, init4) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2)
      return val;
    if (state2 === 1)
      throw new ReferenceError(name4 + " was needed before it finished initializing (module " + moduleName2 + ", line " + lineNumber + ")", moduleName2, lineNumber);
    state2 = 1;
    val = init4();
    state2 = 2;
    return val;
  };
};
var lookup11 = /* @__PURE__ */ lookup(foldableArray)(eqString);
var map75 = /* @__PURE__ */ map(functorNonEmptyArray);
var map132 = /* @__PURE__ */ map(functorFn);
var foldl14 = /* @__PURE__ */ foldl(foldableNonEmptyArray);
var append35 = /* @__PURE__ */ append(semigroupNonEmptyArray);
var Expected = /* @__PURE__ */ function() {
  function Expected2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Expected2.create = function(value0) {
    return function(value12) {
      return new Expected2(value0, value12);
    };
  };
  return Expected2;
}();
var ExpectedEndOfPath = /* @__PURE__ */ function() {
  function ExpectedEndOfPath2(value0) {
    this.value0 = value0;
  }
  ;
  ExpectedEndOfPath2.create = function(value0) {
    return new ExpectedEndOfPath2(value0);
  };
  return ExpectedEndOfPath2;
}();
var MissingParam = /* @__PURE__ */ function() {
  function MissingParam2(value0) {
    this.value0 = value0;
  }
  ;
  MissingParam2.create = function(value0) {
    return new MissingParam2(value0);
  };
  return MissingParam2;
}();
var EndOfPath = /* @__PURE__ */ function() {
  function EndOfPath2() {
  }
  ;
  EndOfPath2.value = new EndOfPath2();
  return EndOfPath2;
}();
var Fail2 = /* @__PURE__ */ function() {
  function Fail3(value0) {
    this.value0 = value0;
  }
  ;
  Fail3.create = function(value0) {
    return new Fail3(value0);
  };
  return Fail3;
}();
var Success3 = /* @__PURE__ */ function() {
  function Success4(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Success4.create = function(value0) {
    return function(value12) {
      return new Success4(value0, value12);
    };
  };
  return Success4;
}();
var Alt = /* @__PURE__ */ function() {
  function Alt2(value0) {
    this.value0 = value0;
  }
  ;
  Alt2.create = function(value0) {
    return new Alt2(value0);
  };
  return Alt2;
}();
var Chomp = /* @__PURE__ */ function() {
  function Chomp2(value0) {
    this.value0 = value0;
  }
  ;
  Chomp2.create = function(value0) {
    return new Chomp2(value0);
  };
  return Chomp2;
}();
var Prefix = /* @__PURE__ */ function() {
  function Prefix2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Prefix2.create = function(value0) {
    return function(value12) {
      return new Prefix2(value0, value12);
    };
  };
  return Prefix2;
}();
var take5 = /* @__PURE__ */ function() {
  return new Chomp(function(state2) {
    var v = uncons(state2.segments);
    if (v instanceof Just) {
      return new Success3({
        segments: v.value0.tail,
        params: state2.params,
        hash: state2.hash
      }, v.value0.head);
    }
    ;
    return new Fail2(EndOfPath.value);
  });
}();
var prefix2 = /* @__PURE__ */ function() {
  return Prefix.create;
}();
var param = function(key) {
  return new Chomp(function(state2) {
    var v = lookup11(key)(state2.params);
    if (v instanceof Just) {
      return new Success3(state2, v.value0);
    }
    ;
    return new Fail2(new MissingParam(key));
  });
};
var functorRouteResult = {
  map: function(f) {
    return function(m) {
      if (m instanceof Fail2) {
        return new Fail2(m.value0);
      }
      ;
      if (m instanceof Success3) {
        return new Success3(m.value0, f(m.value1));
      }
      ;
      throw new Error("Failed pattern match at Routing.Duplex.Parser (line 0, column 0 - line 0, column 0): " + [m.constructor.name]);
    };
  }
};
var map220 = /* @__PURE__ */ map(functorRouteResult);
var functorRouteParser = {
  map: function(f) {
    return function(m) {
      if (m instanceof Alt) {
        return new Alt(map75(map(functorRouteParser)(f))(m.value0));
      }
      ;
      if (m instanceof Chomp) {
        return new Chomp(map132(map220(f))(m.value0));
      }
      ;
      if (m instanceof Prefix) {
        return new Prefix(m.value0, map(functorRouteParser)(f)(m.value1));
      }
      ;
      throw new Error("Failed pattern match at Routing.Duplex.Parser (line 0, column 0 - line 0, column 0): " + [m.constructor.name]);
    };
  }
};
var map313 = /* @__PURE__ */ map(functorRouteParser);
var end2 = /* @__PURE__ */ function() {
  return new Chomp(function(state2) {
    var v = head(state2.segments);
    if (v instanceof Nothing) {
      return new Success3(state2, unit);
    }
    ;
    if (v instanceof Just) {
      return new Fail2(new ExpectedEndOfPath(v.value0));
    }
    ;
    throw new Error("Failed pattern match at Routing.Duplex.Parser (line 266, column 3 - line 268, column 45): " + [v.constructor.name]);
  });
}();
var chompPrefix = function(pre) {
  return function(state2) {
    var v = head(state2.segments);
    if (v instanceof Just && pre === v.value0) {
      return new Success3({
        segments: drop(1)(state2.segments),
        params: state2.params,
        hash: state2.hash
      }, unit);
    }
    ;
    if (v instanceof Just) {
      return new Fail2(new Expected(pre, v.value0));
    }
    ;
    return new Fail2(EndOfPath.value);
  };
};
var $lazy_runRouteParser = /* @__PURE__ */ $runtime_lazy12("runRouteParser", "Routing.Duplex.Parser", function() {
  var goAlt = function(v) {
    return function(v1) {
      return function(v2) {
        if (v1 instanceof Fail2) {
          return $lazy_runRouteParser(161)(v)(v2);
        }
        ;
        return v1;
      };
    };
  };
  var go = function($copy_state) {
    return function($copy_v) {
      var $tco_var_state = $copy_state;
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(state2, v) {
        if (v instanceof Alt) {
          $tco_done = true;
          return foldl14(goAlt(state2))(new Fail2(EndOfPath.value))(v.value0);
        }
        ;
        if (v instanceof Chomp) {
          $tco_done = true;
          return v.value0(state2);
        }
        ;
        if (v instanceof Prefix) {
          var v1 = chompPrefix(v.value0)(state2);
          if (v1 instanceof Fail2) {
            $tco_done = true;
            return new Fail2(v1.value0);
          }
          ;
          if (v1 instanceof Success3) {
            $tco_var_state = v1.value0;
            $copy_v = v.value1;
            return;
          }
          ;
          throw new Error("Failed pattern match at Routing.Duplex.Parser (line 157, column 7 - line 159, column 40): " + [v1.constructor.name]);
        }
        ;
        throw new Error("Failed pattern match at Routing.Duplex.Parser (line 153, column 14 - line 159, column 40): " + [v.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($tco_var_state, $copy_v);
      }
      ;
      return $tco_result;
    };
  };
  return go;
});
var runRouteParser = /* @__PURE__ */ $lazy_runRouteParser(150);
var as = function(print9) {
  return function(decode2) {
    return function(p) {
      return new Chomp(function(state2) {
        var v = runRouteParser(state2)(p);
        if (v instanceof Fail2) {
          return new Fail2(v.value0);
        }
        ;
        if (v instanceof Success3) {
          var v1 = decode2(v.value1);
          if (v1 instanceof Left) {
            return new Fail2(new Expected(v1.value0, print9(v.value1)));
          }
          ;
          if (v1 instanceof Right) {
            return new Success3(v.value0, v1.value0);
          }
          ;
          throw new Error("Failed pattern match at Routing.Duplex.Parser (line 254, column 7 - line 256, column 36): " + [v1.constructor.name]);
        }
        ;
        throw new Error("Failed pattern match at Routing.Duplex.Parser (line 251, column 3 - line 256, column 36): " + [v.constructor.name]);
      });
    };
  };
};
var applyRouteParser = {
  apply: function(fx) {
    return function(x) {
      return new Chomp(function(state2) {
        var v = runRouteParser(state2)(fx);
        if (v instanceof Fail2) {
          return new Fail2(v.value0);
        }
        ;
        if (v instanceof Success3) {
          return map220(v.value1)(runRouteParser(v.value0)(x));
        }
        ;
        throw new Error("Failed pattern match at Routing.Duplex.Parser (line 81, column 5 - line 83, column 56): " + [v.constructor.name]);
      });
    };
  },
  Functor0: function() {
    return functorRouteParser;
  }
};
var applicativeRouteParser = {
  pure: /* @__PURE__ */ function() {
    var $368 = flip(Success3.create);
    return function($369) {
      return Chomp.create($368($369));
    };
  }(),
  Apply0: function() {
    return applyRouteParser;
  }
};
var pure64 = /* @__PURE__ */ pure(applicativeRouteParser);
var altSnoc = function(v) {
  return function(v1) {
    var v2 = function(v3) {
      return snoc2(v)(v1);
    };
    if (v1 instanceof Prefix) {
      var $310 = last2(v);
      if ($310 instanceof Prefix) {
        var $311 = v1.value0 === $310.value0;
        if ($311) {
          return snoc$prime(init2(v))(new Prefix(v1.value0, alt(altRouteParser)($310.value1)(v1.value1)));
        }
        ;
        return v2(true);
      }
      ;
      return v2(true);
    }
    ;
    return v2(true);
  };
};
var altRouteParser = {
  alt: function(v) {
    return function(v1) {
      if (v instanceof Alt && v1 instanceof Alt) {
        return new Alt(altAppend(v.value0)(v1.value0));
      }
      ;
      if (v instanceof Alt) {
        return new Alt(altSnoc(v.value0)(v1));
      }
      ;
      if (v1 instanceof Alt) {
        return new Alt(altCons(v)(v1.value0));
      }
      ;
      if (v instanceof Prefix && (v1 instanceof Prefix && v.value0 === v1.value0)) {
        return new Prefix(v.value0, alt(altRouteParser)(v.value1)(v1.value1));
      }
      ;
      return new Alt(cons2(v)(singleton4(v1)));
    };
  },
  Functor0: function() {
    return functorRouteParser;
  }
};
var altCons = function(v) {
  return function(v1) {
    var v2 = function(v3) {
      return cons2(v)(v1);
    };
    if (v instanceof Prefix) {
      var $330 = head2(v1);
      if ($330 instanceof Prefix) {
        var $331 = v.value0 === $330.value0;
        if ($331) {
          return cons$prime(new Prefix(v.value0, alt(altRouteParser)(v.value1)($330.value1)))(tail2(v1));
        }
        ;
        return v2(true);
      }
      ;
      return v2(true);
    }
    ;
    return v2(true);
  };
};
var altAppend = function($copy_ls) {
  return function($copy_rs) {
    var $tco_var_ls = $copy_ls;
    var $tco_done = false;
    var $tco_result;
    function $tco_loop(ls4, rs) {
      var v = function(v12) {
        if (otherwise) {
          return append35(ls4)(rs);
        }
        ;
        throw new Error("Failed pattern match at Routing.Duplex.Parser (line 103, column 1 - line 107, column 35): " + [ls4.constructor.name, rs.constructor.name]);
      };
      var $340 = last2(ls4);
      if ($340 instanceof Prefix) {
        var $341 = head2(rs);
        if ($341 instanceof Prefix) {
          var $342 = $340.value0 === $341.value0;
          if ($342) {
            var rs$prime = cons$prime(new Prefix($340.value0, alt(altRouteParser)($340.value1)($341.value1)))(tail2(rs));
            var v1 = fromArray(init2(ls4));
            if (v1 instanceof Just) {
              $tco_var_ls = v1.value0;
              $copy_rs = rs$prime;
              return;
            }
            ;
            if (v1 instanceof Nothing) {
              $tco_done = true;
              return rs$prime;
            }
            ;
            throw new Error("Failed pattern match at Routing.Duplex.Parser (line 116, column 9 - line 118, column 25): " + [v1.constructor.name]);
          }
          ;
          $tco_done = true;
          return v(true);
        }
        ;
        $tco_done = true;
        return v(true);
      }
      ;
      $tco_done = true;
      return v(true);
    }
    ;
    while (!$tco_done) {
      $tco_result = $tco_loop($tco_var_ls, $copy_rs);
    }
    ;
    return $tco_result;
  };
};
var alt26 = /* @__PURE__ */ alt(altRouteParser);
var $$default = /* @__PURE__ */ function() {
  var $370 = flip(alt26);
  return function($371) {
    return $370(pure64($371));
  };
}();
var optional6 = /* @__PURE__ */ function() {
  var $375 = $$default(Nothing.value);
  var $376 = map313(Just.create);
  return function($377) {
    return $375($376($377));
  };
}();

// output/Routing.Duplex.Printer/index.js
var append36 = /* @__PURE__ */ append(/* @__PURE__ */ semigroupMaybe(semigroupString));
var semigroupRoutePrinter = {
  append: function(v) {
    return function(v1) {
      return function($33) {
        return v1(v($33));
      };
    };
  }
};
var put4 = function(str2) {
  return function(state2) {
    return {
      segments: snoc(state2.segments)(str2),
      params: state2.params,
      hash: state2.hash
    };
  };
};
var printPath = function(v) {
  var printSegments = function(v1) {
    if (v1.length === 1 && v1[0] === "") {
      return "/";
    }
    ;
    return joinWith("/")(mapMaybe($$encodeURIComponent)(v1));
  };
  var printParam = function(v1) {
    return function(v2) {
      if (v2 === "") {
        return $$encodeURIComponent(v1);
      }
      ;
      return append36($$encodeURIComponent(v1))(append36(new Just("="))($$encodeURIComponent(v2)));
    };
  };
  var printParams = function(v1) {
    if (v1.length === 0) {
      return "";
    }
    ;
    return "?" + joinWith("&")(mapMaybe(uncurry(printParam))(v1));
  };
  var printHash = function(v1) {
    if (v1 === "") {
      return "";
    }
    ;
    return "#" + v1;
  };
  return printSegments(v.segments) + (printParams(v.params) + printHash(v.hash));
};
var param2 = function(key) {
  return function(val) {
    return function(state2) {
      return {
        segments: state2.segments,
        params: cons(new Tuple(key, val))(state2.params),
        hash: state2.hash
      };
    };
  };
};
var run8 = /* @__PURE__ */ function() {
  var $34 = applyFlipped(emptyRouteState);
  var $35 = unwrap();
  return function($36) {
    return printPath($34($35($36)));
  };
}();
var monoidRoutePRinter = {
  mempty: /* @__PURE__ */ identity(categoryFn),
  Semigroup0: function() {
    return semigroupRoutePrinter;
  }
};

// output/Routing.Duplex/index.js
var append37 = /* @__PURE__ */ append(semigroupRoutePrinter);
var applyFirst3 = /* @__PURE__ */ applyFirst(applyRouteParser);
var pure65 = /* @__PURE__ */ pure(applicativeRouteParser);
var identity31 = /* @__PURE__ */ identity(categoryFn);
var apply20 = /* @__PURE__ */ apply2(applyRouteParser);
var map76 = /* @__PURE__ */ map(functorRouteParser);
var foldMap10 = /* @__PURE__ */ foldMap(foldableMaybe)(monoidRoutePRinter);
var mempty20 = /* @__PURE__ */ mempty(monoidRoutePRinter);
var apply110 = /* @__PURE__ */ apply2(applyFn);
var map133 = /* @__PURE__ */ map(functorFn);
var RouteDuplex = /* @__PURE__ */ function() {
  function RouteDuplex2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  RouteDuplex2.create = function(value0) {
    return function(value12) {
      return new RouteDuplex2(value0, value12);
    };
  };
  return RouteDuplex2;
}();
var string5 = identity31;
var segment = /* @__PURE__ */ function() {
  return new RouteDuplex(put4, take5);
}();
var record3 = /* @__PURE__ */ function() {
  return new RouteDuplex(mempty(monoidFn(monoidRoutePRinter)), pure65({}));
}();
var prop2 = function(dictIsSymbol) {
  var get7 = get3(dictIsSymbol)();
  var insert20 = insert5(dictIsSymbol)()();
  return function() {
    return function() {
      return function() {
        return function(sym) {
          return function(v) {
            return function(v1) {
              return new RouteDuplex(function(r) {
                return append37(v1.value0(r))(v.value0(get7(sym)(r)));
              }, apply20(map76(flip(insert20(sym)))(v1.value1))(v.value1));
            };
          };
        };
      };
    };
  };
};
var profunctorRouteDuplex = {
  dimap: function(f) {
    return function(g) {
      return function(v) {
        return new RouteDuplex(function($137) {
          return v.value0(f($137));
        }, map76(g)(v.value1));
      };
    };
  }
};
var print8 = function(v) {
  return function($138) {
    return run8(v.value0($138));
  };
};
var prefix3 = function(s) {
  return function(v) {
    return new RouteDuplex(function(a) {
      return append37(put4(s))(v.value0(a));
    }, prefix2(s)(v.value1));
  };
};
var path4 = /* @__PURE__ */ function() {
  var $139 = flip(foldr(foldableArray)(prefix3));
  var $140 = split("/");
  return function($141) {
    return $139($140($141));
  };
}();
var root = /* @__PURE__ */ path4("");
var params = function(dict) {
  return dict.params;
};
var param3 = function(p) {
  return new RouteDuplex(param2(p), param(p));
};
var optional7 = function(v) {
  return new RouteDuplex(foldMap10(v.value0), optional6(v.value1));
};
var functorRouteDuplex = {
  map: function(f) {
    return function(m) {
      return new RouteDuplex(m.value0, map76(f)(m.value1));
    };
  }
};
var end3 = function(v) {
  return new RouteDuplex(v.value0, applyFirst3(v.value1)(end2));
};
var buildParamsNil = {
  buildParams: function(v) {
    return function(v1) {
      return identity31;
    };
  }
};
var buildParams = function(dict) {
  return dict.buildParams;
};
var buildParamsCons = function(dictIsSymbol) {
  var prop1 = prop2(dictIsSymbol)()()();
  var get7 = get3(dictIsSymbol)();
  var reflectSymbol3 = reflectSymbol(dictIsSymbol);
  return function() {
    return function() {
      return function() {
        return function() {
          return function(dictRouteDuplexBuildParams) {
            var buildParams1 = buildParams(dictRouteDuplexBuildParams);
            return {
              buildParams: function(v) {
                return function(r) {
                  return function(prev) {
                    return buildParams1($$Proxy.value)(r)(prop1($$Proxy.value)(get7($$Proxy.value)(r)(param3(reflectSymbol3($$Proxy.value))))(prev));
                  };
                };
              }
            };
          };
        };
      };
    };
  };
};
var routeDuplexParams = function() {
  return function(dictRouteDuplexBuildParams) {
    var buildParams1 = buildParams(dictRouteDuplexBuildParams);
    return {
      params: function(r) {
        return buildParams1($$Proxy.value)(r)(record3);
      }
    };
  };
};
var as2 = function(f) {
  return function(g) {
    return function(v) {
      return new RouteDuplex(function($142) {
        return v.value0(f($142));
      }, as(identity31)(g)(v.value1));
    };
  };
};
var applyRouteDuplex = {
  apply: function(v) {
    return function(v1) {
      return new RouteDuplex(apply110(map133(append37)(v.value0))(v1.value0), apply20(v.value1)(v1.value1));
    };
  },
  Functor0: function() {
    return functorRouteDuplex;
  }
};
var applicativeRouteDuplex = {
  pure: /* @__PURE__ */ function() {
    var $143 = RouteDuplex.create($$const(mempty20));
    return function($144) {
      return $143(pure65($144));
    };
  }(),
  Apply0: function() {
    return applyRouteDuplex;
  }
};

// output/Routing.Duplex.Generic/index.js
var identity32 = /* @__PURE__ */ identity(categoryFn);
var append38 = /* @__PURE__ */ append(semigroupRoutePrinter);
var apply21 = /* @__PURE__ */ apply2(applyRouteParser);
var map77 = /* @__PURE__ */ map(functorRouteParser);
var alt27 = /* @__PURE__ */ alt(altRouteParser);
var dimap5 = /* @__PURE__ */ dimap(profunctorRouteDuplex);
var noArgs = /* @__PURE__ */ function() {
  return pure(applicativeRouteDuplex)(NoArguments.value);
}();
var gRouteProduct = {
  gRouteDuplexCtr: identity32
};
var gRouteNoArguments = {
  gRouteDuplexCtr: identity32
};
var gRouteDuplexCtr = function(dict) {
  return dict.gRouteDuplexCtr;
};
var product2 = function(dictGRouteDuplexCtr) {
  var gRouteDuplexCtr1 = gRouteDuplexCtr(dictGRouteDuplexCtr);
  return function(v) {
    return function(l) {
      var v1 = gRouteDuplexCtr1(l);
      var enc = function(v2) {
        return append38(v.value0(v2.value0))(v1.value0(v2.value1));
      };
      var dec = apply21(map77(Product.create)(map77(Argument)(v.value1)))(v1.value1);
      return new RouteDuplex(enc, dec);
    };
  };
};
var gRouteDuplex = function(dict) {
  return dict.gRouteDuplex;
};
var gRouteSum = function(dictGRouteDuplex) {
  var gRouteDuplex1 = gRouteDuplex(dictGRouteDuplex);
  return function(dictGRouteDuplex1) {
    var gRouteDuplex2 = gRouteDuplex(dictGRouteDuplex1);
    return {
      gRouteDuplex: function(end$prime) {
        return function(r) {
          var v = gRouteDuplex1(end$prime)(r);
          var v1 = gRouteDuplex2(end$prime)(r);
          var enc = function(v2) {
            if (v2 instanceof Inl) {
              return v.value0(v2.value0);
            }
            ;
            if (v2 instanceof Inr) {
              return v1.value0(v2.value0);
            }
            ;
            throw new Error("Failed pattern match at Routing.Duplex.Generic (line 51, column 11 - line 53, column 22): " + [v2.constructor.name]);
          };
          var dec = alt27(map77(Inl.create)(v.value1))(map77(Inr.create)(v1.value1));
          return new RouteDuplex(enc, dec);
        };
      }
    };
  };
};
var sum2 = function(dictGeneric) {
  var from3 = from(dictGeneric);
  var to2 = to(dictGeneric);
  return function(dictGRouteDuplex) {
    var $71 = dimap5(from3)(to2);
    var $72 = gRouteDuplex(dictGRouteDuplex)(end3);
    return function($73) {
      return $71($72($73));
    };
  };
};
var gRouteConstructor = function(dictIsSymbol) {
  var get7 = get3(dictIsSymbol)();
  return function() {
    return function(dictGRouteDuplexCtr) {
      var gRouteDuplexCtr1 = gRouteDuplexCtr(dictGRouteDuplexCtr);
      return {
        gRouteDuplex: function(end$prime) {
          return function(r) {
            var v = end$prime(gRouteDuplexCtr1(get7($$Proxy.value)(r)));
            var enc = function(v1) {
              return v.value0(v1);
            };
            var dec = map77(Constructor)(v.value1);
            return new RouteDuplex(enc, dec);
          };
        }
      };
    };
  };
};
var gRouteAll = {
  gRouteDuplexCtr: function(v) {
    return new RouteDuplex(function(v1) {
      return v.value0(v1);
    }, map77(Argument)(v.value1));
  }
};

// output/Routing.Duplex.Generic.Syntax/index.js
var product3 = /* @__PURE__ */ product2(gRouteAll);
var gsepStringRoute = function(dictGRouteDuplexCtr) {
  var gRouteDuplexCtr2 = gRouteDuplexCtr(dictGRouteDuplexCtr);
  return {
    gsep: function(a) {
      var $15 = prefix3(a);
      return function($16) {
        return $15(gRouteDuplexCtr2($16));
      };
    }
  };
};
var gsep = function(dict) {
  return dict.gsep;
};
var gparamsRoute = function(dictRouteDuplexParams) {
  var params2 = params(dictRouteDuplexParams);
  return {
    gparams: function(a) {
      var $21 = product3(a);
      return function($22) {
        return $21(params2($22));
      };
    }
  };
};
var gparams = function(dict) {
  return dict.gparams;
};

// output/Registry.API.V1/index.js
var show40 = /* @__PURE__ */ show(showString);
var gsep2 = /* @__PURE__ */ gsep(/* @__PURE__ */ gsepStringRoute(gRouteNoArguments));
var levelIsSymbol = {
  reflectSymbol: function() {
    return "level";
  }
};
var object9 = /* @__PURE__ */ object2();
var rowListCodecCons8 = /* @__PURE__ */ rowListCodecCons(rowListCodecNil)()();
var jobIdIsSymbol = {
  reflectSymbol: function() {
    return "jobId";
  }
};
var Debug = /* @__PURE__ */ function() {
  function Debug2() {
  }
  ;
  Debug2.value = new Debug2();
  return Debug2;
}();
var Info = /* @__PURE__ */ function() {
  function Info2() {
  }
  ;
  Info2.value = new Info2();
  return Info2;
}();
var Warn = /* @__PURE__ */ function() {
  function Warn2() {
  }
  ;
  Warn2.value = new Warn2();
  return Warn2;
}();
var $$Error3 = /* @__PURE__ */ function() {
  function $$Error4() {
  }
  ;
  $$Error4.value = new $$Error4();
  return $$Error4;
}();
var PublishJob = /* @__PURE__ */ function() {
  function PublishJob2() {
  }
  ;
  PublishJob2.value = new PublishJob2();
  return PublishJob2;
}();
var UnpublishJob = /* @__PURE__ */ function() {
  function UnpublishJob2() {
  }
  ;
  UnpublishJob2.value = new UnpublishJob2();
  return UnpublishJob2;
}();
var TransferJob = /* @__PURE__ */ function() {
  function TransferJob2() {
  }
  ;
  TransferJob2.value = new TransferJob2();
  return TransferJob2;
}();
var JobId = function(x) {
  return x;
};
var Publish = /* @__PURE__ */ function() {
  function Publish3() {
  }
  ;
  Publish3.value = new Publish3();
  return Publish3;
}();
var Unpublish = /* @__PURE__ */ function() {
  function Unpublish2() {
  }
  ;
  Unpublish2.value = new Unpublish2();
  return Unpublish2;
}();
var Transfer = /* @__PURE__ */ function() {
  function Transfer2() {
  }
  ;
  Transfer2.value = new Transfer2();
  return Transfer2;
}();
var Jobs = /* @__PURE__ */ function() {
  function Jobs2() {
  }
  ;
  Jobs2.value = new Jobs2();
  return Jobs2;
}();
var Job = /* @__PURE__ */ function() {
  function Job2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Job2.create = function(value0) {
    return function(value12) {
      return new Job2(value0, value12);
    };
  };
  return Job2;
}();
var genericRoute_ = {
  to: function(x) {
    if (x instanceof Inl) {
      return Publish.value;
    }
    ;
    if (x instanceof Inr && x.value0 instanceof Inl) {
      return Unpublish.value;
    }
    ;
    if (x instanceof Inr && (x.value0 instanceof Inr && x.value0.value0 instanceof Inl)) {
      return Transfer.value;
    }
    ;
    if (x instanceof Inr && (x.value0 instanceof Inr && (x.value0.value0 instanceof Inr && x.value0.value0.value0 instanceof Inl))) {
      return Jobs.value;
    }
    ;
    if (x instanceof Inr && (x.value0 instanceof Inr && (x.value0.value0 instanceof Inr && x.value0.value0.value0 instanceof Inr))) {
      return new Job(x.value0.value0.value0.value0.value0, x.value0.value0.value0.value0.value1);
    }
    ;
    throw new Error("Failed pattern match at Registry.API.V1 (line 37, column 1 - line 37, column 32): " + [x.constructor.name]);
  },
  from: function(x) {
    if (x instanceof Publish) {
      return new Inl(NoArguments.value);
    }
    ;
    if (x instanceof Unpublish) {
      return new Inr(new Inl(NoArguments.value));
    }
    ;
    if (x instanceof Transfer) {
      return new Inr(new Inr(new Inl(NoArguments.value)));
    }
    ;
    if (x instanceof Jobs) {
      return new Inr(new Inr(new Inr(new Inl(NoArguments.value))));
    }
    ;
    if (x instanceof Job) {
      return new Inr(new Inr(new Inr(new Inr(new Product(x.value0, x.value1)))));
    }
    ;
    throw new Error("Failed pattern match at Registry.API.V1 (line 37, column 1 - line 37, column 32): " + [x.constructor.name]);
  }
};
var timestampP = /* @__PURE__ */ function() {
  var printTimestamp = function(t) {
    return format(iso8601DateTime)(t);
  };
  var parseTimestamp = function(s) {
    return unformat(iso8601DateTime)(s);
  };
  return as2(printTimestamp)(parseTimestamp);
}();
var printLogLevel = function(v) {
  if (v instanceof Debug) {
    return "DEBUG";
  }
  ;
  if (v instanceof Info) {
    return "INFO";
  }
  ;
  if (v instanceof Warn) {
    return "WARN";
  }
  ;
  if (v instanceof $$Error3) {
    return "ERROR";
  }
  ;
  throw new Error("Failed pattern match at Registry.API.V1 (line 141, column 17 - line 145, column 19): " + [v.constructor.name]);
};
var printJobType = function(v) {
  if (v instanceof PublishJob) {
    return "publish";
  }
  ;
  if (v instanceof UnpublishJob) {
    return "unpublish";
  }
  ;
  if (v instanceof TransferJob) {
    return "transfer";
  }
  ;
  throw new Error("Failed pattern match at Registry.API.V1 (line 112, column 16 - line 115, column 28): " + [v.constructor.name]);
};
var parseLogLevel = function(v) {
  if (v === "DEBUG") {
    return new Right(Debug.value);
  }
  ;
  if (v === "INFO") {
    return new Right(Info.value);
  }
  ;
  if (v === "WARN") {
    return new Right(Warn.value);
  }
  ;
  if (v === "ERROR") {
    return new Right($$Error3.value);
  }
  ;
  return new Left("Invalid log level: " + v);
};
var parseJobType = function(v) {
  if (v === "publish") {
    return new Right(PublishJob.value);
  }
  ;
  if (v === "unpublish") {
    return new Right(UnpublishJob.value);
  }
  ;
  if (v === "transfer") {
    return new Right(TransferJob.value);
  }
  ;
  return new Left("Invalid job type " + show40(v));
};
var logLevelP = /* @__PURE__ */ as2(printLogLevel)(parseLogLevel);
var jobTypeCodec = /* @__PURE__ */ enumSum(printJobType)(function($174) {
  return hush(parseJobType($174));
});
var jobIdS = /* @__PURE__ */ _Newtype()()(profunctorRouteDuplex)(segment);
var routes = /* @__PURE__ */ root(/* @__PURE__ */ prefix3("api")(/* @__PURE__ */ prefix3("v1")(/* @__PURE__ */ sum2(genericRoute_)(/* @__PURE__ */ gRouteSum(/* @__PURE__ */ gRouteConstructor({
  reflectSymbol: function() {
    return "Publish";
  }
})()(gRouteNoArguments))(/* @__PURE__ */ gRouteSum(/* @__PURE__ */ gRouteConstructor({
  reflectSymbol: function() {
    return "Unpublish";
  }
})()(gRouteNoArguments))(/* @__PURE__ */ gRouteSum(/* @__PURE__ */ gRouteConstructor({
  reflectSymbol: function() {
    return "Transfer";
  }
})()(gRouteNoArguments))(/* @__PURE__ */ gRouteSum(/* @__PURE__ */ gRouteConstructor({
  reflectSymbol: function() {
    return "Jobs";
  }
})()(gRouteNoArguments))(/* @__PURE__ */ gRouteConstructor({
  reflectSymbol: function() {
    return "Job";
  }
})()(gRouteProduct))))))({
  Publish: /* @__PURE__ */ gsep2("publish")(noArgs),
  Unpublish: /* @__PURE__ */ gsep2("unpublish")(noArgs),
  Transfer: /* @__PURE__ */ gsep2("transfer")(noArgs),
  Jobs: /* @__PURE__ */ gsep2("jobs")(noArgs),
  Job: /* @__PURE__ */ gsep(/* @__PURE__ */ gsepStringRoute(gRouteProduct))("jobs")(/* @__PURE__ */ gparams(/* @__PURE__ */ gparamsRoute(/* @__PURE__ */ routeDuplexParams()(/* @__PURE__ */ buildParamsCons(levelIsSymbol)()()()()(/* @__PURE__ */ buildParamsCons({
    reflectSymbol: function() {
      return "since";
    }
  })()()()()(buildParamsNil)))))(jobIdS)({
    level: function($175) {
      return optional7(logLevelP(string5($175)));
    },
    since: function($176) {
      return optional7(timestampP(string5($176)));
    }
  }))
}))));
var jobIdCodec = /* @__PURE__ */ wrapIso(/* @__PURE__ */ profunctorCodec(functorEither))()(JobId)(string);
var logLineCodec = /* @__PURE__ */ object9(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons8({
  reflectSymbol: function() {
    return "timestamp";
  }
}))()()({
  reflectSymbol: function() {
    return "message";
  }
}))()()(levelIsSymbol))()()(jobIdIsSymbol))("LogLine")({
  level: /* @__PURE__ */ enumSum(printLogLevel)(function($177) {
    return hush(parseLogLevel($177));
  }),
  message: string,
  jobId: jobIdCodec,
  timestamp: iso8601DateTime2
});
var jobCreatedResponseCodec = /* @__PURE__ */ object9(/* @__PURE__ */ rowListCodecCons8(jobIdIsSymbol))("JobCreatedResponse")({
  jobId: jobIdCodec
});
var jobCodec = /* @__PURE__ */ object9(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecConsOptional(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons8({
  reflectSymbol: function() {
    return "success";
  }
}))()()({
  reflectSymbol: function() {
    return "ref";
  }
}))()()({
  reflectSymbol: function() {
    return "packageName";
  }
}))()()({
  reflectSymbol: function() {
    return "logs";
  }
}))()()({
  reflectSymbol: function() {
    return "jobType";
  }
}))()()(jobIdIsSymbol))()()({
  reflectSymbol: function() {
    return "finishedAt";
  }
}))()()({
  reflectSymbol: function() {
    return "createdAt";
  }
}))("Job")({
  jobId: jobIdCodec,
  jobType: jobTypeCodec,
  packageName: codec2,
  ref: string,
  createdAt: iso8601DateTime2,
  finishedAt: /* @__PURE__ */ optional3(iso8601DateTime2),
  success: $$boolean,
  logs: /* @__PURE__ */ array(logLineCodec)
});

// output/Registry.SSH/foreign.js
var import_ssh2 = __toESM(require_lib4(), 1);

// output/Registry.Operation/index.js
var object10 = /* @__PURE__ */ object2();
var nameIsSymbol = {
  reflectSymbol: function() {
    return "name";
  }
};
var compilerIsSymbol2 = {
  reflectSymbol: function() {
    return "compiler";
  }
};
var publishCodec = /* @__PURE__ */ object10(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecConsOptional(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecCons(/* @__PURE__ */ rowListCodecConsOptional(rowListCodecNil)()()({
  reflectSymbol: function() {
    return "resolutions";
  }
}))()()({
  reflectSymbol: function() {
    return "ref";
  }
}))()()(nameIsSymbol))()()({
  reflectSymbol: function() {
    return "location";
  }
}))()()(compilerIsSymbol2))("Publish")({
  name: codec2,
  location: /* @__PURE__ */ optional3(codec5),
  ref: string,
  compiler: codec3,
  resolutions: /* @__PURE__ */ optional3(/* @__PURE__ */ packageMap(codec3))
});

// output/PureScript.CST.Types/index.js
var ASCII2 = /* @__PURE__ */ function() {
  function ASCII3() {
  }
  ;
  ASCII3.value = new ASCII3();
  return ASCII3;
}();
var Unicode = /* @__PURE__ */ function() {
  function Unicode2() {
  }
  ;
  Unicode2.value = new Unicode2();
  return Unicode2;
}();
var Nominal = /* @__PURE__ */ function() {
  function Nominal2() {
  }
  ;
  Nominal2.value = new Nominal2();
  return Nominal2;
}();
var Representational = /* @__PURE__ */ function() {
  function Representational2() {
  }
  ;
  Representational2.value = new Representational2();
  return Representational2;
}();
var Phantom = /* @__PURE__ */ function() {
  function Phantom2() {
  }
  ;
  Phantom2.value = new Phantom2();
  return Phantom2;
}();
var LF = /* @__PURE__ */ function() {
  function LF2() {
  }
  ;
  LF2.value = new LF2();
  return LF2;
}();
var CRLF = /* @__PURE__ */ function() {
  function CRLF2() {
  }
  ;
  CRLF2.value = new CRLF2();
  return CRLF2;
}();
var SmallInt = /* @__PURE__ */ function() {
  function SmallInt2(value0) {
    this.value0 = value0;
  }
  ;
  SmallInt2.create = function(value0) {
    return new SmallInt2(value0);
  };
  return SmallInt2;
}();
var BigInt2 = /* @__PURE__ */ function() {
  function BigInt3(value0) {
    this.value0 = value0;
  }
  ;
  BigInt3.create = function(value0) {
    return new BigInt3(value0);
  };
  return BigInt3;
}();
var BigHex = /* @__PURE__ */ function() {
  function BigHex2(value0) {
    this.value0 = value0;
  }
  ;
  BigHex2.create = function(value0) {
    return new BigHex2(value0);
  };
  return BigHex2;
}();
var TokLeftParen = /* @__PURE__ */ function() {
  function TokLeftParen2() {
  }
  ;
  TokLeftParen2.value = new TokLeftParen2();
  return TokLeftParen2;
}();
var TokRightParen = /* @__PURE__ */ function() {
  function TokRightParen2() {
  }
  ;
  TokRightParen2.value = new TokRightParen2();
  return TokRightParen2;
}();
var TokLeftBrace = /* @__PURE__ */ function() {
  function TokLeftBrace2() {
  }
  ;
  TokLeftBrace2.value = new TokLeftBrace2();
  return TokLeftBrace2;
}();
var TokRightBrace = /* @__PURE__ */ function() {
  function TokRightBrace2() {
  }
  ;
  TokRightBrace2.value = new TokRightBrace2();
  return TokRightBrace2;
}();
var TokLeftSquare = /* @__PURE__ */ function() {
  function TokLeftSquare2() {
  }
  ;
  TokLeftSquare2.value = new TokLeftSquare2();
  return TokLeftSquare2;
}();
var TokRightSquare = /* @__PURE__ */ function() {
  function TokRightSquare2() {
  }
  ;
  TokRightSquare2.value = new TokRightSquare2();
  return TokRightSquare2;
}();
var TokLeftArrow = /* @__PURE__ */ function() {
  function TokLeftArrow2(value0) {
    this.value0 = value0;
  }
  ;
  TokLeftArrow2.create = function(value0) {
    return new TokLeftArrow2(value0);
  };
  return TokLeftArrow2;
}();
var TokRightArrow = /* @__PURE__ */ function() {
  function TokRightArrow2(value0) {
    this.value0 = value0;
  }
  ;
  TokRightArrow2.create = function(value0) {
    return new TokRightArrow2(value0);
  };
  return TokRightArrow2;
}();
var TokRightFatArrow = /* @__PURE__ */ function() {
  function TokRightFatArrow2(value0) {
    this.value0 = value0;
  }
  ;
  TokRightFatArrow2.create = function(value0) {
    return new TokRightFatArrow2(value0);
  };
  return TokRightFatArrow2;
}();
var TokDoubleColon = /* @__PURE__ */ function() {
  function TokDoubleColon2(value0) {
    this.value0 = value0;
  }
  ;
  TokDoubleColon2.create = function(value0) {
    return new TokDoubleColon2(value0);
  };
  return TokDoubleColon2;
}();
var TokForall = /* @__PURE__ */ function() {
  function TokForall2(value0) {
    this.value0 = value0;
  }
  ;
  TokForall2.create = function(value0) {
    return new TokForall2(value0);
  };
  return TokForall2;
}();
var TokEquals = /* @__PURE__ */ function() {
  function TokEquals2() {
  }
  ;
  TokEquals2.value = new TokEquals2();
  return TokEquals2;
}();
var TokPipe = /* @__PURE__ */ function() {
  function TokPipe2() {
  }
  ;
  TokPipe2.value = new TokPipe2();
  return TokPipe2;
}();
var TokTick = /* @__PURE__ */ function() {
  function TokTick2() {
  }
  ;
  TokTick2.value = new TokTick2();
  return TokTick2;
}();
var TokDot = /* @__PURE__ */ function() {
  function TokDot2() {
  }
  ;
  TokDot2.value = new TokDot2();
  return TokDot2;
}();
var TokComma = /* @__PURE__ */ function() {
  function TokComma2() {
  }
  ;
  TokComma2.value = new TokComma2();
  return TokComma2;
}();
var TokUnderscore = /* @__PURE__ */ function() {
  function TokUnderscore2() {
  }
  ;
  TokUnderscore2.value = new TokUnderscore2();
  return TokUnderscore2;
}();
var TokBackslash = /* @__PURE__ */ function() {
  function TokBackslash2() {
  }
  ;
  TokBackslash2.value = new TokBackslash2();
  return TokBackslash2;
}();
var TokAt = /* @__PURE__ */ function() {
  function TokAt2() {
  }
  ;
  TokAt2.value = new TokAt2();
  return TokAt2;
}();
var TokLowerName = /* @__PURE__ */ function() {
  function TokLowerName2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TokLowerName2.create = function(value0) {
    return function(value12) {
      return new TokLowerName2(value0, value12);
    };
  };
  return TokLowerName2;
}();
var TokUpperName = /* @__PURE__ */ function() {
  function TokUpperName2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TokUpperName2.create = function(value0) {
    return function(value12) {
      return new TokUpperName2(value0, value12);
    };
  };
  return TokUpperName2;
}();
var TokOperator = /* @__PURE__ */ function() {
  function TokOperator2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TokOperator2.create = function(value0) {
    return function(value12) {
      return new TokOperator2(value0, value12);
    };
  };
  return TokOperator2;
}();
var TokSymbolName = /* @__PURE__ */ function() {
  function TokSymbolName2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TokSymbolName2.create = function(value0) {
    return function(value12) {
      return new TokSymbolName2(value0, value12);
    };
  };
  return TokSymbolName2;
}();
var TokSymbolArrow = /* @__PURE__ */ function() {
  function TokSymbolArrow2(value0) {
    this.value0 = value0;
  }
  ;
  TokSymbolArrow2.create = function(value0) {
    return new TokSymbolArrow2(value0);
  };
  return TokSymbolArrow2;
}();
var TokHole = /* @__PURE__ */ function() {
  function TokHole2(value0) {
    this.value0 = value0;
  }
  ;
  TokHole2.create = function(value0) {
    return new TokHole2(value0);
  };
  return TokHole2;
}();
var TokChar = /* @__PURE__ */ function() {
  function TokChar2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TokChar2.create = function(value0) {
    return function(value12) {
      return new TokChar2(value0, value12);
    };
  };
  return TokChar2;
}();
var TokString = /* @__PURE__ */ function() {
  function TokString2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TokString2.create = function(value0) {
    return function(value12) {
      return new TokString2(value0, value12);
    };
  };
  return TokString2;
}();
var TokRawString = /* @__PURE__ */ function() {
  function TokRawString2(value0) {
    this.value0 = value0;
  }
  ;
  TokRawString2.create = function(value0) {
    return new TokRawString2(value0);
  };
  return TokRawString2;
}();
var TokInt = /* @__PURE__ */ function() {
  function TokInt2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TokInt2.create = function(value0) {
    return function(value12) {
      return new TokInt2(value0, value12);
    };
  };
  return TokInt2;
}();
var TokNumber = /* @__PURE__ */ function() {
  function TokNumber2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TokNumber2.create = function(value0) {
    return function(value12) {
      return new TokNumber2(value0, value12);
    };
  };
  return TokNumber2;
}();
var TokLayoutStart = /* @__PURE__ */ function() {
  function TokLayoutStart2(value0) {
    this.value0 = value0;
  }
  ;
  TokLayoutStart2.create = function(value0) {
    return new TokLayoutStart2(value0);
  };
  return TokLayoutStart2;
}();
var TokLayoutSep = /* @__PURE__ */ function() {
  function TokLayoutSep2(value0) {
    this.value0 = value0;
  }
  ;
  TokLayoutSep2.create = function(value0) {
    return new TokLayoutSep2(value0);
  };
  return TokLayoutSep2;
}();
var TokLayoutEnd = /* @__PURE__ */ function() {
  function TokLayoutEnd2(value0) {
    this.value0 = value0;
  }
  ;
  TokLayoutEnd2.create = function(value0) {
    return new TokLayoutEnd2(value0);
  };
  return TokLayoutEnd2;
}();
var Infix = /* @__PURE__ */ function() {
  function Infix2() {
  }
  ;
  Infix2.value = new Infix2();
  return Infix2;
}();
var Infixl = /* @__PURE__ */ function() {
  function Infixl2() {
  }
  ;
  Infixl2.value = new Infixl2();
  return Infixl2;
}();
var Infixr = /* @__PURE__ */ function() {
  function Infixr2() {
  }
  ;
  Infixr2.value = new Infixr2();
  return Infixr2;
}();
var Comment = /* @__PURE__ */ function() {
  function Comment2(value0) {
    this.value0 = value0;
  }
  ;
  Comment2.create = function(value0) {
    return new Comment2(value0);
  };
  return Comment2;
}();
var Space = /* @__PURE__ */ function() {
  function Space2(value0) {
    this.value0 = value0;
  }
  ;
  Space2.create = function(value0) {
    return new Space2(value0);
  };
  return Space2;
}();
var Line2 = /* @__PURE__ */ function() {
  function Line3(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Line3.create = function(value0) {
    return function(value12) {
      return new Line3(value0, value12);
    };
  };
  return Line3;
}();
var FixityValue = /* @__PURE__ */ function() {
  function FixityValue2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  FixityValue2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new FixityValue2(value0, value12, value22);
      };
    };
  };
  return FixityValue2;
}();
var FixityType = /* @__PURE__ */ function() {
  function FixityType2(value0, value12, value22, value32) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
    this.value3 = value32;
  }
  ;
  FixityType2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return function(value32) {
          return new FixityType2(value0, value12, value22, value32);
        };
      };
    };
  };
  return FixityType2;
}();
var RecordPun = /* @__PURE__ */ function() {
  function RecordPun2(value0) {
    this.value0 = value0;
  }
  ;
  RecordPun2.create = function(value0) {
    return new RecordPun2(value0);
  };
  return RecordPun2;
}();
var RecordField = /* @__PURE__ */ function() {
  function RecordField2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  RecordField2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new RecordField2(value0, value12, value22);
      };
    };
  };
  return RecordField2;
}();
var DataAll = /* @__PURE__ */ function() {
  function DataAll2(value0) {
    this.value0 = value0;
  }
  ;
  DataAll2.create = function(value0) {
    return new DataAll2(value0);
  };
  return DataAll2;
}();
var DataEnumerated = /* @__PURE__ */ function() {
  function DataEnumerated2(value0) {
    this.value0 = value0;
  }
  ;
  DataEnumerated2.create = function(value0) {
    return new DataEnumerated2(value0);
  };
  return DataEnumerated2;
}();
var ExportValue = /* @__PURE__ */ function() {
  function ExportValue2(value0) {
    this.value0 = value0;
  }
  ;
  ExportValue2.create = function(value0) {
    return new ExportValue2(value0);
  };
  return ExportValue2;
}();
var ExportOp = /* @__PURE__ */ function() {
  function ExportOp2(value0) {
    this.value0 = value0;
  }
  ;
  ExportOp2.create = function(value0) {
    return new ExportOp2(value0);
  };
  return ExportOp2;
}();
var ExportType = /* @__PURE__ */ function() {
  function ExportType2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExportType2.create = function(value0) {
    return function(value12) {
      return new ExportType2(value0, value12);
    };
  };
  return ExportType2;
}();
var ExportTypeOp = /* @__PURE__ */ function() {
  function ExportTypeOp2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExportTypeOp2.create = function(value0) {
    return function(value12) {
      return new ExportTypeOp2(value0, value12);
    };
  };
  return ExportTypeOp2;
}();
var ExportClass = /* @__PURE__ */ function() {
  function ExportClass2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExportClass2.create = function(value0) {
    return function(value12) {
      return new ExportClass2(value0, value12);
    };
  };
  return ExportClass2;
}();
var ExportModule = /* @__PURE__ */ function() {
  function ExportModule2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExportModule2.create = function(value0) {
    return function(value12) {
      return new ExportModule2(value0, value12);
    };
  };
  return ExportModule2;
}();
var ImportValue = /* @__PURE__ */ function() {
  function ImportValue2(value0) {
    this.value0 = value0;
  }
  ;
  ImportValue2.create = function(value0) {
    return new ImportValue2(value0);
  };
  return ImportValue2;
}();
var ImportOp = /* @__PURE__ */ function() {
  function ImportOp2(value0) {
    this.value0 = value0;
  }
  ;
  ImportOp2.create = function(value0) {
    return new ImportOp2(value0);
  };
  return ImportOp2;
}();
var ImportType = /* @__PURE__ */ function() {
  function ImportType2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ImportType2.create = function(value0) {
    return function(value12) {
      return new ImportType2(value0, value12);
    };
  };
  return ImportType2;
}();
var ImportTypeOp = /* @__PURE__ */ function() {
  function ImportTypeOp2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ImportTypeOp2.create = function(value0) {
    return function(value12) {
      return new ImportTypeOp2(value0, value12);
    };
  };
  return ImportTypeOp2;
}();
var ImportClass = /* @__PURE__ */ function() {
  function ImportClass2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ImportClass2.create = function(value0) {
    return function(value12) {
      return new ImportClass2(value0, value12);
    };
  };
  return ImportClass2;
}();
var One = /* @__PURE__ */ function() {
  function One2(value0) {
    this.value0 = value0;
  }
  ;
  One2.create = function(value0) {
    return new One2(value0);
  };
  return One2;
}();
var Many = /* @__PURE__ */ function() {
  function Many2(value0) {
    this.value0 = value0;
  }
  ;
  Many2.create = function(value0) {
    return new Many2(value0);
  };
  return Many2;
}();
var TypeVarKinded = /* @__PURE__ */ function() {
  function TypeVarKinded2(value0) {
    this.value0 = value0;
  }
  ;
  TypeVarKinded2.create = function(value0) {
    return new TypeVarKinded2(value0);
  };
  return TypeVarKinded2;
}();
var TypeVarName = /* @__PURE__ */ function() {
  function TypeVarName2(value0) {
    this.value0 = value0;
  }
  ;
  TypeVarName2.create = function(value0) {
    return new TypeVarName2(value0);
  };
  return TypeVarName2;
}();
var TypeVar = /* @__PURE__ */ function() {
  function TypeVar2(value0) {
    this.value0 = value0;
  }
  ;
  TypeVar2.create = function(value0) {
    return new TypeVar2(value0);
  };
  return TypeVar2;
}();
var TypeConstructor = /* @__PURE__ */ function() {
  function TypeConstructor2(value0) {
    this.value0 = value0;
  }
  ;
  TypeConstructor2.create = function(value0) {
    return new TypeConstructor2(value0);
  };
  return TypeConstructor2;
}();
var TypeWildcard = /* @__PURE__ */ function() {
  function TypeWildcard2(value0) {
    this.value0 = value0;
  }
  ;
  TypeWildcard2.create = function(value0) {
    return new TypeWildcard2(value0);
  };
  return TypeWildcard2;
}();
var TypeHole = /* @__PURE__ */ function() {
  function TypeHole2(value0) {
    this.value0 = value0;
  }
  ;
  TypeHole2.create = function(value0) {
    return new TypeHole2(value0);
  };
  return TypeHole2;
}();
var TypeString = /* @__PURE__ */ function() {
  function TypeString2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TypeString2.create = function(value0) {
    return function(value12) {
      return new TypeString2(value0, value12);
    };
  };
  return TypeString2;
}();
var TypeInt = /* @__PURE__ */ function() {
  function TypeInt2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  TypeInt2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new TypeInt2(value0, value12, value22);
      };
    };
  };
  return TypeInt2;
}();
var TypeRow = /* @__PURE__ */ function() {
  function TypeRow2(value0) {
    this.value0 = value0;
  }
  ;
  TypeRow2.create = function(value0) {
    return new TypeRow2(value0);
  };
  return TypeRow2;
}();
var TypeRecord = /* @__PURE__ */ function() {
  function TypeRecord2(value0) {
    this.value0 = value0;
  }
  ;
  TypeRecord2.create = function(value0) {
    return new TypeRecord2(value0);
  };
  return TypeRecord2;
}();
var TypeForall = /* @__PURE__ */ function() {
  function TypeForall2(value0, value12, value22, value32) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
    this.value3 = value32;
  }
  ;
  TypeForall2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return function(value32) {
          return new TypeForall2(value0, value12, value22, value32);
        };
      };
    };
  };
  return TypeForall2;
}();
var TypeKinded = /* @__PURE__ */ function() {
  function TypeKinded2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  TypeKinded2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new TypeKinded2(value0, value12, value22);
      };
    };
  };
  return TypeKinded2;
}();
var TypeApp = /* @__PURE__ */ function() {
  function TypeApp2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TypeApp2.create = function(value0) {
    return function(value12) {
      return new TypeApp2(value0, value12);
    };
  };
  return TypeApp2;
}();
var TypeOp = /* @__PURE__ */ function() {
  function TypeOp2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TypeOp2.create = function(value0) {
    return function(value12) {
      return new TypeOp2(value0, value12);
    };
  };
  return TypeOp2;
}();
var TypeOpName = /* @__PURE__ */ function() {
  function TypeOpName2(value0) {
    this.value0 = value0;
  }
  ;
  TypeOpName2.create = function(value0) {
    return new TypeOpName2(value0);
  };
  return TypeOpName2;
}();
var TypeArrow = /* @__PURE__ */ function() {
  function TypeArrow2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  TypeArrow2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new TypeArrow2(value0, value12, value22);
      };
    };
  };
  return TypeArrow2;
}();
var TypeArrowName = /* @__PURE__ */ function() {
  function TypeArrowName2(value0) {
    this.value0 = value0;
  }
  ;
  TypeArrowName2.create = function(value0) {
    return new TypeArrowName2(value0);
  };
  return TypeArrowName2;
}();
var TypeConstrained = /* @__PURE__ */ function() {
  function TypeConstrained2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  TypeConstrained2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new TypeConstrained2(value0, value12, value22);
      };
    };
  };
  return TypeConstrained2;
}();
var TypeParens = /* @__PURE__ */ function() {
  function TypeParens2(value0) {
    this.value0 = value0;
  }
  ;
  TypeParens2.create = function(value0) {
    return new TypeParens2(value0);
  };
  return TypeParens2;
}();
var ForeignValue = /* @__PURE__ */ function() {
  function ForeignValue2(value0) {
    this.value0 = value0;
  }
  ;
  ForeignValue2.create = function(value0) {
    return new ForeignValue2(value0);
  };
  return ForeignValue2;
}();
var ForeignData = /* @__PURE__ */ function() {
  function ForeignData2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ForeignData2.create = function(value0) {
    return function(value12) {
      return new ForeignData2(value0, value12);
    };
  };
  return ForeignData2;
}();
var ForeignKind = /* @__PURE__ */ function() {
  function ForeignKind2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ForeignKind2.create = function(value0) {
    return function(value12) {
      return new ForeignKind2(value0, value12);
    };
  };
  return ForeignKind2;
}();
var FundepDetermined = /* @__PURE__ */ function() {
  function FundepDetermined2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  FundepDetermined2.create = function(value0) {
    return function(value12) {
      return new FundepDetermined2(value0, value12);
    };
  };
  return FundepDetermined2;
}();
var FundepDetermines = /* @__PURE__ */ function() {
  function FundepDetermines2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  FundepDetermines2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new FundepDetermines2(value0, value12, value22);
      };
    };
  };
  return FundepDetermines2;
}();
var BinderWildcard = /* @__PURE__ */ function() {
  function BinderWildcard2(value0) {
    this.value0 = value0;
  }
  ;
  BinderWildcard2.create = function(value0) {
    return new BinderWildcard2(value0);
  };
  return BinderWildcard2;
}();
var BinderVar = /* @__PURE__ */ function() {
  function BinderVar2(value0) {
    this.value0 = value0;
  }
  ;
  BinderVar2.create = function(value0) {
    return new BinderVar2(value0);
  };
  return BinderVar2;
}();
var BinderNamed = /* @__PURE__ */ function() {
  function BinderNamed2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  BinderNamed2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new BinderNamed2(value0, value12, value22);
      };
    };
  };
  return BinderNamed2;
}();
var BinderConstructor = /* @__PURE__ */ function() {
  function BinderConstructor2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  BinderConstructor2.create = function(value0) {
    return function(value12) {
      return new BinderConstructor2(value0, value12);
    };
  };
  return BinderConstructor2;
}();
var BinderBoolean = /* @__PURE__ */ function() {
  function BinderBoolean2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  BinderBoolean2.create = function(value0) {
    return function(value12) {
      return new BinderBoolean2(value0, value12);
    };
  };
  return BinderBoolean2;
}();
var BinderChar = /* @__PURE__ */ function() {
  function BinderChar2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  BinderChar2.create = function(value0) {
    return function(value12) {
      return new BinderChar2(value0, value12);
    };
  };
  return BinderChar2;
}();
var BinderString = /* @__PURE__ */ function() {
  function BinderString2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  BinderString2.create = function(value0) {
    return function(value12) {
      return new BinderString2(value0, value12);
    };
  };
  return BinderString2;
}();
var BinderInt = /* @__PURE__ */ function() {
  function BinderInt2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  BinderInt2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new BinderInt2(value0, value12, value22);
      };
    };
  };
  return BinderInt2;
}();
var BinderNumber = /* @__PURE__ */ function() {
  function BinderNumber2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  BinderNumber2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new BinderNumber2(value0, value12, value22);
      };
    };
  };
  return BinderNumber2;
}();
var BinderArray = /* @__PURE__ */ function() {
  function BinderArray2(value0) {
    this.value0 = value0;
  }
  ;
  BinderArray2.create = function(value0) {
    return new BinderArray2(value0);
  };
  return BinderArray2;
}();
var BinderRecord = /* @__PURE__ */ function() {
  function BinderRecord2(value0) {
    this.value0 = value0;
  }
  ;
  BinderRecord2.create = function(value0) {
    return new BinderRecord2(value0);
  };
  return BinderRecord2;
}();
var BinderParens = /* @__PURE__ */ function() {
  function BinderParens2(value0) {
    this.value0 = value0;
  }
  ;
  BinderParens2.create = function(value0) {
    return new BinderParens2(value0);
  };
  return BinderParens2;
}();
var BinderTyped = /* @__PURE__ */ function() {
  function BinderTyped2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  BinderTyped2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new BinderTyped2(value0, value12, value22);
      };
    };
  };
  return BinderTyped2;
}();
var BinderOp = /* @__PURE__ */ function() {
  function BinderOp2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  BinderOp2.create = function(value0) {
    return function(value12) {
      return new BinderOp2(value0, value12);
    };
  };
  return BinderOp2;
}();
var DoLet = /* @__PURE__ */ function() {
  function DoLet2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  DoLet2.create = function(value0) {
    return function(value12) {
      return new DoLet2(value0, value12);
    };
  };
  return DoLet2;
}();
var DoDiscard = /* @__PURE__ */ function() {
  function DoDiscard2(value0) {
    this.value0 = value0;
  }
  ;
  DoDiscard2.create = function(value0) {
    return new DoDiscard2(value0);
  };
  return DoDiscard2;
}();
var DoBind = /* @__PURE__ */ function() {
  function DoBind2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  DoBind2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new DoBind2(value0, value12, value22);
      };
    };
  };
  return DoBind2;
}();
var DoError = /* @__PURE__ */ function() {
  function DoError2(value0) {
    this.value0 = value0;
  }
  ;
  DoError2.create = function(value0) {
    return new DoError2(value0);
  };
  return DoError2;
}();
var LetBindingSignature = /* @__PURE__ */ function() {
  function LetBindingSignature2(value0) {
    this.value0 = value0;
  }
  ;
  LetBindingSignature2.create = function(value0) {
    return new LetBindingSignature2(value0);
  };
  return LetBindingSignature2;
}();
var LetBindingName = /* @__PURE__ */ function() {
  function LetBindingName2(value0) {
    this.value0 = value0;
  }
  ;
  LetBindingName2.create = function(value0) {
    return new LetBindingName2(value0);
  };
  return LetBindingName2;
}();
var LetBindingPattern = /* @__PURE__ */ function() {
  function LetBindingPattern2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  LetBindingPattern2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new LetBindingPattern2(value0, value12, value22);
      };
    };
  };
  return LetBindingPattern2;
}();
var LetBindingError = /* @__PURE__ */ function() {
  function LetBindingError2(value0) {
    this.value0 = value0;
  }
  ;
  LetBindingError2.create = function(value0) {
    return new LetBindingError2(value0);
  };
  return LetBindingError2;
}();
var Unconditional = /* @__PURE__ */ function() {
  function Unconditional2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  Unconditional2.create = function(value0) {
    return function(value12) {
      return new Unconditional2(value0, value12);
    };
  };
  return Unconditional2;
}();
var Guarded = /* @__PURE__ */ function() {
  function Guarded2(value0) {
    this.value0 = value0;
  }
  ;
  Guarded2.create = function(value0) {
    return new Guarded2(value0);
  };
  return Guarded2;
}();
var ExprHole = /* @__PURE__ */ function() {
  function ExprHole2(value0) {
    this.value0 = value0;
  }
  ;
  ExprHole2.create = function(value0) {
    return new ExprHole2(value0);
  };
  return ExprHole2;
}();
var ExprSection = /* @__PURE__ */ function() {
  function ExprSection2(value0) {
    this.value0 = value0;
  }
  ;
  ExprSection2.create = function(value0) {
    return new ExprSection2(value0);
  };
  return ExprSection2;
}();
var ExprIdent = /* @__PURE__ */ function() {
  function ExprIdent2(value0) {
    this.value0 = value0;
  }
  ;
  ExprIdent2.create = function(value0) {
    return new ExprIdent2(value0);
  };
  return ExprIdent2;
}();
var ExprConstructor = /* @__PURE__ */ function() {
  function ExprConstructor2(value0) {
    this.value0 = value0;
  }
  ;
  ExprConstructor2.create = function(value0) {
    return new ExprConstructor2(value0);
  };
  return ExprConstructor2;
}();
var ExprBoolean = /* @__PURE__ */ function() {
  function ExprBoolean2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExprBoolean2.create = function(value0) {
    return function(value12) {
      return new ExprBoolean2(value0, value12);
    };
  };
  return ExprBoolean2;
}();
var ExprChar = /* @__PURE__ */ function() {
  function ExprChar2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExprChar2.create = function(value0) {
    return function(value12) {
      return new ExprChar2(value0, value12);
    };
  };
  return ExprChar2;
}();
var ExprString = /* @__PURE__ */ function() {
  function ExprString2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExprString2.create = function(value0) {
    return function(value12) {
      return new ExprString2(value0, value12);
    };
  };
  return ExprString2;
}();
var ExprInt = /* @__PURE__ */ function() {
  function ExprInt2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExprInt2.create = function(value0) {
    return function(value12) {
      return new ExprInt2(value0, value12);
    };
  };
  return ExprInt2;
}();
var ExprNumber = /* @__PURE__ */ function() {
  function ExprNumber2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExprNumber2.create = function(value0) {
    return function(value12) {
      return new ExprNumber2(value0, value12);
    };
  };
  return ExprNumber2;
}();
var ExprArray = /* @__PURE__ */ function() {
  function ExprArray2(value0) {
    this.value0 = value0;
  }
  ;
  ExprArray2.create = function(value0) {
    return new ExprArray2(value0);
  };
  return ExprArray2;
}();
var ExprRecord = /* @__PURE__ */ function() {
  function ExprRecord2(value0) {
    this.value0 = value0;
  }
  ;
  ExprRecord2.create = function(value0) {
    return new ExprRecord2(value0);
  };
  return ExprRecord2;
}();
var ExprParens = /* @__PURE__ */ function() {
  function ExprParens2(value0) {
    this.value0 = value0;
  }
  ;
  ExprParens2.create = function(value0) {
    return new ExprParens2(value0);
  };
  return ExprParens2;
}();
var ExprTyped = /* @__PURE__ */ function() {
  function ExprTyped2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  ExprTyped2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new ExprTyped2(value0, value12, value22);
      };
    };
  };
  return ExprTyped2;
}();
var ExprInfix = /* @__PURE__ */ function() {
  function ExprInfix2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExprInfix2.create = function(value0) {
    return function(value12) {
      return new ExprInfix2(value0, value12);
    };
  };
  return ExprInfix2;
}();
var ExprOp = /* @__PURE__ */ function() {
  function ExprOp2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExprOp2.create = function(value0) {
    return function(value12) {
      return new ExprOp2(value0, value12);
    };
  };
  return ExprOp2;
}();
var ExprOpName = /* @__PURE__ */ function() {
  function ExprOpName2(value0) {
    this.value0 = value0;
  }
  ;
  ExprOpName2.create = function(value0) {
    return new ExprOpName2(value0);
  };
  return ExprOpName2;
}();
var ExprNegate = /* @__PURE__ */ function() {
  function ExprNegate2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExprNegate2.create = function(value0) {
    return function(value12) {
      return new ExprNegate2(value0, value12);
    };
  };
  return ExprNegate2;
}();
var ExprRecordAccessor = /* @__PURE__ */ function() {
  function ExprRecordAccessor2(value0) {
    this.value0 = value0;
  }
  ;
  ExprRecordAccessor2.create = function(value0) {
    return new ExprRecordAccessor2(value0);
  };
  return ExprRecordAccessor2;
}();
var ExprRecordUpdate = /* @__PURE__ */ function() {
  function ExprRecordUpdate2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExprRecordUpdate2.create = function(value0) {
    return function(value12) {
      return new ExprRecordUpdate2(value0, value12);
    };
  };
  return ExprRecordUpdate2;
}();
var ExprApp = /* @__PURE__ */ function() {
  function ExprApp2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExprApp2.create = function(value0) {
    return function(value12) {
      return new ExprApp2(value0, value12);
    };
  };
  return ExprApp2;
}();
var ExprLambda = /* @__PURE__ */ function() {
  function ExprLambda2(value0) {
    this.value0 = value0;
  }
  ;
  ExprLambda2.create = function(value0) {
    return new ExprLambda2(value0);
  };
  return ExprLambda2;
}();
var ExprIf = /* @__PURE__ */ function() {
  function ExprIf2(value0) {
    this.value0 = value0;
  }
  ;
  ExprIf2.create = function(value0) {
    return new ExprIf2(value0);
  };
  return ExprIf2;
}();
var ExprCase = /* @__PURE__ */ function() {
  function ExprCase2(value0) {
    this.value0 = value0;
  }
  ;
  ExprCase2.create = function(value0) {
    return new ExprCase2(value0);
  };
  return ExprCase2;
}();
var ExprLet = /* @__PURE__ */ function() {
  function ExprLet2(value0) {
    this.value0 = value0;
  }
  ;
  ExprLet2.create = function(value0) {
    return new ExprLet2(value0);
  };
  return ExprLet2;
}();
var ExprDo = /* @__PURE__ */ function() {
  function ExprDo2(value0) {
    this.value0 = value0;
  }
  ;
  ExprDo2.create = function(value0) {
    return new ExprDo2(value0);
  };
  return ExprDo2;
}();
var ExprAdo = /* @__PURE__ */ function() {
  function ExprAdo2(value0) {
    this.value0 = value0;
  }
  ;
  ExprAdo2.create = function(value0) {
    return new ExprAdo2(value0);
  };
  return ExprAdo2;
}();
var RecordUpdateLeaf = /* @__PURE__ */ function() {
  function RecordUpdateLeaf2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  RecordUpdateLeaf2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new RecordUpdateLeaf2(value0, value12, value22);
      };
    };
  };
  return RecordUpdateLeaf2;
}();
var RecordUpdateBranch = /* @__PURE__ */ function() {
  function RecordUpdateBranch2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  RecordUpdateBranch2.create = function(value0) {
    return function(value12) {
      return new RecordUpdateBranch2(value0, value12);
    };
  };
  return RecordUpdateBranch2;
}();
var InstanceBindingSignature = /* @__PURE__ */ function() {
  function InstanceBindingSignature2(value0) {
    this.value0 = value0;
  }
  ;
  InstanceBindingSignature2.create = function(value0) {
    return new InstanceBindingSignature2(value0);
  };
  return InstanceBindingSignature2;
}();
var InstanceBindingName = /* @__PURE__ */ function() {
  function InstanceBindingName2(value0) {
    this.value0 = value0;
  }
  ;
  InstanceBindingName2.create = function(value0) {
    return new InstanceBindingName2(value0);
  };
  return InstanceBindingName2;
}();
var DeclData = /* @__PURE__ */ function() {
  function DeclData2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  DeclData2.create = function(value0) {
    return function(value12) {
      return new DeclData2(value0, value12);
    };
  };
  return DeclData2;
}();
var DeclType = /* @__PURE__ */ function() {
  function DeclType2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  DeclType2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new DeclType2(value0, value12, value22);
      };
    };
  };
  return DeclType2;
}();
var DeclNewtype = /* @__PURE__ */ function() {
  function DeclNewtype2(value0, value12, value22, value32) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
    this.value3 = value32;
  }
  ;
  DeclNewtype2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return function(value32) {
          return new DeclNewtype2(value0, value12, value22, value32);
        };
      };
    };
  };
  return DeclNewtype2;
}();
var DeclClass = /* @__PURE__ */ function() {
  function DeclClass2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  DeclClass2.create = function(value0) {
    return function(value12) {
      return new DeclClass2(value0, value12);
    };
  };
  return DeclClass2;
}();
var DeclInstanceChain = /* @__PURE__ */ function() {
  function DeclInstanceChain2(value0) {
    this.value0 = value0;
  }
  ;
  DeclInstanceChain2.create = function(value0) {
    return new DeclInstanceChain2(value0);
  };
  return DeclInstanceChain2;
}();
var DeclDerive = /* @__PURE__ */ function() {
  function DeclDerive2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  DeclDerive2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new DeclDerive2(value0, value12, value22);
      };
    };
  };
  return DeclDerive2;
}();
var DeclKindSignature = /* @__PURE__ */ function() {
  function DeclKindSignature2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  DeclKindSignature2.create = function(value0) {
    return function(value12) {
      return new DeclKindSignature2(value0, value12);
    };
  };
  return DeclKindSignature2;
}();
var DeclSignature = /* @__PURE__ */ function() {
  function DeclSignature2(value0) {
    this.value0 = value0;
  }
  ;
  DeclSignature2.create = function(value0) {
    return new DeclSignature2(value0);
  };
  return DeclSignature2;
}();
var DeclValue = /* @__PURE__ */ function() {
  function DeclValue2(value0) {
    this.value0 = value0;
  }
  ;
  DeclValue2.create = function(value0) {
    return new DeclValue2(value0);
  };
  return DeclValue2;
}();
var DeclFixity = /* @__PURE__ */ function() {
  function DeclFixity2(value0) {
    this.value0 = value0;
  }
  ;
  DeclFixity2.create = function(value0) {
    return new DeclFixity2(value0);
  };
  return DeclFixity2;
}();
var DeclForeign = /* @__PURE__ */ function() {
  function DeclForeign2(value0, value12, value22) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
  }
  ;
  DeclForeign2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return new DeclForeign2(value0, value12, value22);
      };
    };
  };
  return DeclForeign2;
}();
var DeclRole = /* @__PURE__ */ function() {
  function DeclRole2(value0, value12, value22, value32) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
    this.value3 = value32;
  }
  ;
  DeclRole2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return function(value32) {
          return new DeclRole2(value0, value12, value22, value32);
        };
      };
    };
  };
  return DeclRole2;
}();
var DeclError = /* @__PURE__ */ function() {
  function DeclError2(value0) {
    this.value0 = value0;
  }
  ;
  DeclError2.create = function(value0) {
    return new DeclError2(value0);
  };
  return DeclError2;
}();

// output/PureScript.CST.Print/index.js
var unwrap18 = /* @__PURE__ */ unwrap();
var printQualified = function(moduleName2) {
  return function(name4) {
    if (moduleName2 instanceof Nothing) {
      return name4;
    }
    ;
    if (moduleName2 instanceof Just) {
      return unwrap18(moduleName2.value0) + ("." + name4);
    }
    ;
    throw new Error("Failed pattern match at PureScript.CST.Print (line 124, column 34 - line 126, column 38): " + [moduleName2.constructor.name]);
  };
};

// output/PureScript.CST.Errors/index.js
var UnexpectedEof = /* @__PURE__ */ function() {
  function UnexpectedEof2() {
  }
  ;
  UnexpectedEof2.value = new UnexpectedEof2();
  return UnexpectedEof2;
}();
var ExpectedEof = /* @__PURE__ */ function() {
  function ExpectedEof2(value0) {
    this.value0 = value0;
  }
  ;
  ExpectedEof2.create = function(value0) {
    return new ExpectedEof2(value0);
  };
  return ExpectedEof2;
}();
var UnexpectedToken = /* @__PURE__ */ function() {
  function UnexpectedToken2(value0) {
    this.value0 = value0;
  }
  ;
  UnexpectedToken2.create = function(value0) {
    return new UnexpectedToken2(value0);
  };
  return UnexpectedToken2;
}();
var ExpectedToken = /* @__PURE__ */ function() {
  function ExpectedToken2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExpectedToken2.create = function(value0) {
    return function(value12) {
      return new ExpectedToken2(value0, value12);
    };
  };
  return ExpectedToken2;
}();
var ExpectedClass = /* @__PURE__ */ function() {
  function ExpectedClass2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ExpectedClass2.create = function(value0) {
    return function(value12) {
      return new ExpectedClass2(value0, value12);
    };
  };
  return ExpectedClass2;
}();
var LexExpected = /* @__PURE__ */ function() {
  function LexExpected2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  LexExpected2.create = function(value0) {
    return function(value12) {
      return new LexExpected2(value0, value12);
    };
  };
  return LexExpected2;
}();
var LexInvalidCharEscape = /* @__PURE__ */ function() {
  function LexInvalidCharEscape2(value0) {
    this.value0 = value0;
  }
  ;
  LexInvalidCharEscape2.create = function(value0) {
    return new LexInvalidCharEscape2(value0);
  };
  return LexInvalidCharEscape2;
}();
var LexCharEscapeOutOfRange = /* @__PURE__ */ function() {
  function LexCharEscapeOutOfRange2(value0) {
    this.value0 = value0;
  }
  ;
  LexCharEscapeOutOfRange2.create = function(value0) {
    return new LexCharEscapeOutOfRange2(value0);
  };
  return LexCharEscapeOutOfRange2;
}();
var LexHexOutOfRange = /* @__PURE__ */ function() {
  function LexHexOutOfRange2(value0) {
    this.value0 = value0;
  }
  ;
  LexHexOutOfRange2.create = function(value0) {
    return new LexHexOutOfRange2(value0);
  };
  return LexHexOutOfRange2;
}();
var LexIntOutOfRange = /* @__PURE__ */ function() {
  function LexIntOutOfRange2(value0) {
    this.value0 = value0;
  }
  ;
  LexIntOutOfRange2.create = function(value0) {
    return new LexIntOutOfRange2(value0);
  };
  return LexIntOutOfRange2;
}();
var LexNumberOutOfRange = /* @__PURE__ */ function() {
  function LexNumberOutOfRange2(value0) {
    this.value0 = value0;
  }
  ;
  LexNumberOutOfRange2.create = function(value0) {
    return new LexNumberOutOfRange2(value0);
  };
  return LexNumberOutOfRange2;
}();
var printTokenError = function(v) {
  if (v instanceof TokLeftParen) {
    return "'('";
  }
  ;
  if (v instanceof TokRightParen) {
    return "')'";
  }
  ;
  if (v instanceof TokLeftBrace) {
    return "'{'";
  }
  ;
  if (v instanceof TokRightBrace) {
    return "'}'";
  }
  ;
  if (v instanceof TokLeftSquare) {
    return "'['";
  }
  ;
  if (v instanceof TokRightSquare) {
    return "']'";
  }
  ;
  if (v instanceof TokLeftArrow) {
    if (v.value0 instanceof ASCII2) {
      return "'<-'";
    }
    ;
    if (v.value0 instanceof Unicode) {
      return "'\u2190'";
    }
    ;
    throw new Error("Failed pattern match at PureScript.CST.Errors (line 72, column 5 - line 74, column 23): " + [v.value0.constructor.name]);
  }
  ;
  if (v instanceof TokRightArrow) {
    if (v.value0 instanceof ASCII2) {
      return "'->'";
    }
    ;
    if (v.value0 instanceof Unicode) {
      return "'\u2192'";
    }
    ;
    throw new Error("Failed pattern match at PureScript.CST.Errors (line 76, column 5 - line 78, column 23): " + [v.value0.constructor.name]);
  }
  ;
  if (v instanceof TokRightFatArrow) {
    if (v.value0 instanceof ASCII2) {
      return "'=>'";
    }
    ;
    if (v.value0 instanceof Unicode) {
      return "'\u21D2'";
    }
    ;
    throw new Error("Failed pattern match at PureScript.CST.Errors (line 80, column 5 - line 82, column 23): " + [v.value0.constructor.name]);
  }
  ;
  if (v instanceof TokDoubleColon) {
    if (v.value0 instanceof ASCII2) {
      return "'::'";
    }
    ;
    if (v.value0 instanceof Unicode) {
      return "'\u2237'";
    }
    ;
    throw new Error("Failed pattern match at PureScript.CST.Errors (line 84, column 5 - line 86, column 23): " + [v.value0.constructor.name]);
  }
  ;
  if (v instanceof TokForall) {
    if (v.value0 instanceof ASCII2) {
      return "forall";
    }
    ;
    if (v.value0 instanceof Unicode) {
      return "'\u2200'";
    }
    ;
    throw new Error("Failed pattern match at PureScript.CST.Errors (line 88, column 5 - line 90, column 23): " + [v.value0.constructor.name]);
  }
  ;
  if (v instanceof TokEquals) {
    return "'='";
  }
  ;
  if (v instanceof TokPipe) {
    return "'|'";
  }
  ;
  if (v instanceof TokTick) {
    return "`";
  }
  ;
  if (v instanceof TokDot) {
    return ".";
  }
  ;
  if (v instanceof TokComma) {
    return "','";
  }
  ;
  if (v instanceof TokUnderscore) {
    return "'_'";
  }
  ;
  if (v instanceof TokBackslash) {
    return "'\\'";
  }
  ;
  if (v instanceof TokAt) {
    return "'@'";
  }
  ;
  if (v instanceof TokLowerName) {
    return "identifier " + printQualified(v.value0)(v.value1);
  }
  ;
  if (v instanceof TokUpperName) {
    return "proper identifier " + printQualified(v.value0)(v.value1);
  }
  ;
  if (v instanceof TokOperator) {
    return "operator " + printQualified(v.value0)(v.value1);
  }
  ;
  if (v instanceof TokSymbolName) {
    return "symbol " + printQualified(v.value0)(v.value1);
  }
  ;
  if (v instanceof TokSymbolArrow) {
    if (v.value0 instanceof ASCII2) {
      return "(->)";
    }
    ;
    if (v.value0 instanceof Unicode) {
      return "(\u2192)";
    }
    ;
    throw new Error("Failed pattern match at PureScript.CST.Errors (line 116, column 5 - line 118, column 23): " + [v.value0.constructor.name]);
  }
  ;
  if (v instanceof TokHole) {
    return "hole ?" + v.value0;
  }
  ;
  if (v instanceof TokChar) {
    return "char literal '" + (v.value0 + "'");
  }
  ;
  if (v instanceof TokString) {
    return "string literal";
  }
  ;
  if (v instanceof TokRawString) {
    return "raw string literal";
  }
  ;
  if (v instanceof TokInt) {
    return "int literal " + v.value0;
  }
  ;
  if (v instanceof TokNumber) {
    return "number literal " + v.value0;
  }
  ;
  if (v instanceof TokLayoutStart) {
    return "start of indented block";
  }
  ;
  if (v instanceof TokLayoutSep) {
    return "new indented block item";
  }
  ;
  if (v instanceof TokLayoutEnd) {
    return "end of indented block";
  }
  ;
  throw new Error("Failed pattern match at PureScript.CST.Errors (line 58, column 19 - line 136, column 28): " + [v.constructor.name]);
};
var printParseError = function(v) {
  if (v instanceof UnexpectedEof) {
    return "Unexpected end of file";
  }
  ;
  if (v instanceof ExpectedEof) {
    return "Expected end of file, saw " + printTokenError(v.value0);
  }
  ;
  if (v instanceof UnexpectedToken) {
    return "Unexpected " + printTokenError(v.value0);
  }
  ;
  if (v instanceof ExpectedToken) {
    return "Expected " + (printTokenError(v.value0) + (", saw " + printTokenError(v.value1)));
  }
  ;
  if (v instanceof ExpectedClass) {
    return "Expected " + (v.value0 + (", saw " + printTokenError(v.value1)));
  }
  ;
  if (v instanceof LexExpected) {
    return "Expected " + (v.value0 + (", saw " + v.value1));
  }
  ;
  if (v instanceof LexInvalidCharEscape) {
    return "Invalid character escape \\" + v.value0;
  }
  ;
  if (v instanceof LexCharEscapeOutOfRange) {
    return "Character escape out of range \\" + v.value0;
  }
  ;
  if (v instanceof LexHexOutOfRange) {
    return "Hex integer out of range 0x" + v.value0;
  }
  ;
  if (v instanceof LexIntOutOfRange) {
    return "Int out of range " + v.value0;
  }
  ;
  if (v instanceof LexNumberOutOfRange) {
    return "Number out of range " + v.value0;
  }
  ;
  throw new Error("Failed pattern match at PureScript.CST.Errors (line 33, column 19 - line 55, column 34): " + [v.constructor.name]);
};

// output/PureScript.CST.Layout/index.js
var find4 = /* @__PURE__ */ find(foldableList);
var LytRoot = /* @__PURE__ */ function() {
  function LytRoot2() {
  }
  ;
  LytRoot2.value = new LytRoot2();
  return LytRoot2;
}();
var LytTopDecl = /* @__PURE__ */ function() {
  function LytTopDecl2() {
  }
  ;
  LytTopDecl2.value = new LytTopDecl2();
  return LytTopDecl2;
}();
var LytTopDeclHead = /* @__PURE__ */ function() {
  function LytTopDeclHead2() {
  }
  ;
  LytTopDeclHead2.value = new LytTopDeclHead2();
  return LytTopDeclHead2;
}();
var LytDeclGuard = /* @__PURE__ */ function() {
  function LytDeclGuard2() {
  }
  ;
  LytDeclGuard2.value = new LytDeclGuard2();
  return LytDeclGuard2;
}();
var LytCase = /* @__PURE__ */ function() {
  function LytCase2() {
  }
  ;
  LytCase2.value = new LytCase2();
  return LytCase2;
}();
var LytCaseBinders = /* @__PURE__ */ function() {
  function LytCaseBinders2() {
  }
  ;
  LytCaseBinders2.value = new LytCaseBinders2();
  return LytCaseBinders2;
}();
var LytCaseGuard = /* @__PURE__ */ function() {
  function LytCaseGuard2() {
  }
  ;
  LytCaseGuard2.value = new LytCaseGuard2();
  return LytCaseGuard2;
}();
var LytLambdaBinders = /* @__PURE__ */ function() {
  function LytLambdaBinders2() {
  }
  ;
  LytLambdaBinders2.value = new LytLambdaBinders2();
  return LytLambdaBinders2;
}();
var LytParen = /* @__PURE__ */ function() {
  function LytParen2() {
  }
  ;
  LytParen2.value = new LytParen2();
  return LytParen2;
}();
var LytBrace = /* @__PURE__ */ function() {
  function LytBrace2() {
  }
  ;
  LytBrace2.value = new LytBrace2();
  return LytBrace2;
}();
var LytSquare = /* @__PURE__ */ function() {
  function LytSquare2() {
  }
  ;
  LytSquare2.value = new LytSquare2();
  return LytSquare2;
}();
var LytIf = /* @__PURE__ */ function() {
  function LytIf2() {
  }
  ;
  LytIf2.value = new LytIf2();
  return LytIf2;
}();
var LytThen = /* @__PURE__ */ function() {
  function LytThen2() {
  }
  ;
  LytThen2.value = new LytThen2();
  return LytThen2;
}();
var LytProperty = /* @__PURE__ */ function() {
  function LytProperty2() {
  }
  ;
  LytProperty2.value = new LytProperty2();
  return LytProperty2;
}();
var LytForall = /* @__PURE__ */ function() {
  function LytForall2() {
  }
  ;
  LytForall2.value = new LytForall2();
  return LytForall2;
}();
var LytTick = /* @__PURE__ */ function() {
  function LytTick2() {
  }
  ;
  LytTick2.value = new LytTick2();
  return LytTick2;
}();
var LytLet = /* @__PURE__ */ function() {
  function LytLet2() {
  }
  ;
  LytLet2.value = new LytLet2();
  return LytLet2;
}();
var LytLetStmt = /* @__PURE__ */ function() {
  function LytLetStmt2() {
  }
  ;
  LytLetStmt2.value = new LytLetStmt2();
  return LytLetStmt2;
}();
var LytWhere = /* @__PURE__ */ function() {
  function LytWhere2() {
  }
  ;
  LytWhere2.value = new LytWhere2();
  return LytWhere2;
}();
var LytOf = /* @__PURE__ */ function() {
  function LytOf2() {
  }
  ;
  LytOf2.value = new LytOf2();
  return LytOf2;
}();
var LytDo = /* @__PURE__ */ function() {
  function LytDo2() {
  }
  ;
  LytDo2.value = new LytDo2();
  return LytDo2;
}();
var LytAdo = /* @__PURE__ */ function() {
  function LytAdo2() {
  }
  ;
  LytAdo2.value = new LytAdo2();
  return LytAdo2;
}();
var lytToken = function(pos) {
  return function(value4) {
    return {
      range: {
        start: pos,
        end: pos
      },
      leadingComments: [],
      trailingComments: [],
      value: value4
    };
  };
};
var isTopDecl = function(tokPos) {
  return function(v) {
    if (v instanceof Cons && (v.value0.value1 instanceof LytWhere && (v.value1 instanceof Cons && (v.value1.value0.value1 instanceof LytRoot && (v.value1.value1 instanceof Nil && tokPos.column === v.value0.value0.column))))) {
      return true;
    }
    ;
    return false;
  };
};
var isIndented = function(v) {
  if (v instanceof LytLet) {
    return true;
  }
  ;
  if (v instanceof LytLetStmt) {
    return true;
  }
  ;
  if (v instanceof LytWhere) {
    return true;
  }
  ;
  if (v instanceof LytOf) {
    return true;
  }
  ;
  if (v instanceof LytDo) {
    return true;
  }
  ;
  if (v instanceof LytAdo) {
    return true;
  }
  ;
  return false;
};
var eqLayoutDelim = {
  eq: function(x) {
    return function(y) {
      if (x instanceof LytRoot && y instanceof LytRoot) {
        return true;
      }
      ;
      if (x instanceof LytTopDecl && y instanceof LytTopDecl) {
        return true;
      }
      ;
      if (x instanceof LytTopDeclHead && y instanceof LytTopDeclHead) {
        return true;
      }
      ;
      if (x instanceof LytDeclGuard && y instanceof LytDeclGuard) {
        return true;
      }
      ;
      if (x instanceof LytCase && y instanceof LytCase) {
        return true;
      }
      ;
      if (x instanceof LytCaseBinders && y instanceof LytCaseBinders) {
        return true;
      }
      ;
      if (x instanceof LytCaseGuard && y instanceof LytCaseGuard) {
        return true;
      }
      ;
      if (x instanceof LytLambdaBinders && y instanceof LytLambdaBinders) {
        return true;
      }
      ;
      if (x instanceof LytParen && y instanceof LytParen) {
        return true;
      }
      ;
      if (x instanceof LytBrace && y instanceof LytBrace) {
        return true;
      }
      ;
      if (x instanceof LytSquare && y instanceof LytSquare) {
        return true;
      }
      ;
      if (x instanceof LytIf && y instanceof LytIf) {
        return true;
      }
      ;
      if (x instanceof LytThen && y instanceof LytThen) {
        return true;
      }
      ;
      if (x instanceof LytProperty && y instanceof LytProperty) {
        return true;
      }
      ;
      if (x instanceof LytForall && y instanceof LytForall) {
        return true;
      }
      ;
      if (x instanceof LytTick && y instanceof LytTick) {
        return true;
      }
      ;
      if (x instanceof LytLet && y instanceof LytLet) {
        return true;
      }
      ;
      if (x instanceof LytLetStmt && y instanceof LytLetStmt) {
        return true;
      }
      ;
      if (x instanceof LytWhere && y instanceof LytWhere) {
        return true;
      }
      ;
      if (x instanceof LytOf && y instanceof LytOf) {
        return true;
      }
      ;
      if (x instanceof LytDo && y instanceof LytDo) {
        return true;
      }
      ;
      if (x instanceof LytAdo && y instanceof LytAdo) {
        return true;
      }
      ;
      return false;
    };
  }
};
var eq114 = /* @__PURE__ */ eq(eqLayoutDelim);
var insertLayout = function(v) {
  return function(nextPos) {
    return function(stack) {
      var sepP = function(lytPos) {
        return v.range.start.column === lytPos.column && v.range.start.line !== lytPos.line;
      };
      var pushStack = function(lytPos) {
        return function(lyt) {
          return function(v1) {
            return new Tuple(new Cons(new Tuple(lytPos, lyt), v1.value0), v1.value1);
          };
        };
      };
      var popStack = function(v1) {
        return function(v2) {
          if (v2.value0 instanceof Cons && v1(v2.value0.value0.value1)) {
            return new Tuple(v2.value0.value1, v2.value1);
          }
          ;
          return v2;
        };
      };
      var offsideP = function(lytPos) {
        return function(lyt) {
          return isIndented(lyt) && v.range.start.column < lytPos.column;
        };
      };
      var offsideEndP = function(lytPos) {
        return function(lyt) {
          return isIndented(lyt) && v.range.start.column <= lytPos.column;
        };
      };
      var insertToken = function(token2) {
        return function(v1) {
          return new Tuple(v1.value0, snoc(v1.value1)(new Tuple(token2, v1.value0)));
        };
      };
      var insertStart = function(lyt) {
        return function(v1) {
          var v2 = find4(function($307) {
            return isIndented(snd($307));
          })(v1.value0);
          if (v2 instanceof Just && nextPos.column <= v2.value0.value0.column) {
            return v1;
          }
          ;
          return insertToken(lytToken(nextPos)(new TokLayoutStart(nextPos.column)))(pushStack(nextPos)(lyt)(v1));
        };
      };
      var insertEnd = function(indent3) {
        return insertToken(lytToken(v.range.start)(new TokLayoutEnd(indent3)));
      };
      var indentedP = $$const(isIndented);
      var indentSepP = function(lytPos) {
        return function(lyt) {
          return isIndented(lyt) && sepP(lytPos);
        };
      };
      var insertSep = function(v1) {
        var sepTok = lytToken(v.range.start)(new TokLayoutSep(v.range.start.column));
        if (v1.value0 instanceof Cons && (v1.value0.value0.value1 instanceof LytTopDecl && sepP(v1.value0.value0.value0))) {
          return insertToken(sepTok)(new Tuple(v1.value0.value1, v1.value1));
        }
        ;
        if (v1.value0 instanceof Cons && (v1.value0.value0.value1 instanceof LytTopDeclHead && sepP(v1.value0.value0.value0))) {
          return insertToken(sepTok)(new Tuple(v1.value0.value1, v1.value1));
        }
        ;
        if (v1.value0 instanceof Cons && indentSepP(v1.value0.value0.value0)(v1.value0.value0.value1)) {
          if (v1.value0.value0.value1 instanceof LytOf) {
            return pushStack(v.range.start)(LytCaseBinders.value)(insertToken(sepTok)(v1));
          }
          ;
          return insertToken(sepTok)(v1);
        }
        ;
        return v1;
      };
      var collapse = function(p) {
        var go = function($copy_v1) {
          return function($copy_v2) {
            var $tco_var_v1 = $copy_v1;
            var $tco_done = false;
            var $tco_result;
            function $tco_loop(v1, v2) {
              if (v1 instanceof Cons && p(v1.value0.value0)(v1.value0.value1)) {
                $tco_var_v1 = v1.value1;
                $copy_v2 = function() {
                  var $120 = isIndented(v1.value0.value1);
                  if ($120) {
                    return snoc(v2)(new Tuple(lytToken(v.range.start)(new TokLayoutEnd(v1.value0.value0.column)), v1.value1));
                  }
                  ;
                  return v2;
                }();
                return;
              }
              ;
              $tco_done = true;
              return new Tuple(v1, v2);
            }
            ;
            while (!$tco_done) {
              $tco_result = $tco_loop($tco_var_v1, $copy_v2);
            }
            ;
            return $tco_result;
          };
        };
        return uncurry(go);
      };
      var insertDefault = function(state2) {
        return insertToken(v)(insertSep(collapse(offsideP)(state2)));
      };
      var insertKwProperty = function(k) {
        return function(state2) {
          var v1 = insertDefault(state2);
          if (v1.value0 instanceof Cons && v1.value0.value0.value1 instanceof LytProperty) {
            return new Tuple(v1.value0.value1, v1.value1);
          }
          ;
          return k(v1);
        };
      };
      var insert20 = function(v1) {
        if (v.value instanceof TokLowerName && (v.value.value0 instanceof Nothing && v.value.value1 === "data")) {
          var v2 = insertDefault(v1);
          if (isTopDecl(v.range.start)(v2.value0)) {
            return pushStack(v.range.start)(LytTopDecl.value)(v2);
          }
          ;
          return popStack(function(v32) {
            return eq114(v32)(LytProperty.value);
          })(v2);
        }
        ;
        if (v.value instanceof TokLowerName && (v.value.value0 instanceof Nothing && v.value.value1 === "class")) {
          var v2 = insertDefault(v1);
          if (isTopDecl(v.range.start)(v2.value0)) {
            return pushStack(v.range.start)(LytTopDeclHead.value)(v2);
          }
          ;
          return popStack(function(v32) {
            return eq114(v32)(LytProperty.value);
          })(v2);
        }
        ;
        if (v.value instanceof TokLowerName && (v.value.value0 instanceof Nothing && v.value.value1 === "where")) {
          var whereP = function(v22) {
            return function(v32) {
              if (v32 instanceof LytDo) {
                return true;
              }
              ;
              return offsideEndP(v22)(v32);
            };
          };
          if (v1.value0 instanceof Cons && v1.value0.value0.value1 instanceof LytTopDeclHead) {
            return insertStart(LytWhere.value)(insertToken(v)(new Tuple(v1.value0.value1, v1.value1)));
          }
          ;
          if (v1.value0 instanceof Cons && v1.value0.value0.value1 instanceof LytProperty) {
            return insertToken(v)(new Tuple(v1.value0.value1, v1.value1));
          }
          ;
          return insertStart(LytWhere.value)(insertToken(v)(collapse(whereP)(v1)));
        }
        ;
        if (v.value instanceof TokLowerName && (v.value.value0 instanceof Nothing && v.value.value1 === "in")) {
          var inP = function(v22) {
            return function(v32) {
              if (v32 instanceof LytLet) {
                return false;
              }
              ;
              if (v32 instanceof LytAdo) {
                return false;
              }
              ;
              return isIndented(v32);
            };
          };
          var v2 = collapse(inP)(v1);
          if (v2.value0 instanceof Cons && (v2.value0.value0.value1 instanceof LytLetStmt && (v2.value0.value1 instanceof Cons && v2.value0.value1.value0.value1 instanceof LytAdo))) {
            return insertToken(v)(insertEnd(v2.value0.value1.value0.value0.column)(insertEnd(v2.value0.value0.value0.column)(new Tuple(v2.value0.value1.value1, v2.value1))));
          }
          ;
          if (v2.value0 instanceof Cons && isIndented(v2.value0.value0.value1)) {
            return insertToken(v)(insertEnd(v2.value0.value0.value0.column)(new Tuple(v2.value0.value1, v2.value1)));
          }
          ;
          return popStack(function(v32) {
            return eq114(v32)(LytProperty.value);
          })(insertDefault(v1));
        }
        ;
        if (v.value instanceof TokLowerName && (v.value.value0 instanceof Nothing && v.value.value1 === "let")) {
          var next2 = function(v22) {
            if (v22.value0 instanceof Cons && (v22.value0.value0.value1 instanceof LytDo && v22.value0.value0.value0.column === v.range.start.column)) {
              return insertStart(LytLetStmt.value)(v22);
            }
            ;
            if (v22.value0 instanceof Cons && (v22.value0.value0.value1 instanceof LytAdo && v22.value0.value0.value0.column === v.range.start.column)) {
              return insertStart(LytLetStmt.value)(v22);
            }
            ;
            return insertStart(LytLet.value)(v22);
          };
          return insertKwProperty(next2)(v1);
        }
        ;
        if (v.value instanceof TokLowerName && v.value.value1 === "do") {
          return insertKwProperty(insertStart(LytDo.value))(v1);
        }
        ;
        if (v.value instanceof TokLowerName && v.value.value1 === "ado") {
          return insertKwProperty(insertStart(LytAdo.value))(v1);
        }
        ;
        if (v.value instanceof TokLowerName && (v.value.value0 instanceof Nothing && v.value.value1 === "case")) {
          return insertKwProperty(pushStack(v.range.start)(LytCase.value))(v1);
        }
        ;
        if (v.value instanceof TokLowerName && (v.value.value0 instanceof Nothing && v.value.value1 === "of")) {
          var v2 = collapse(indentedP)(v1);
          if (v2.value0 instanceof Cons && v2.value0.value0.value1 instanceof LytCase) {
            return pushStack(nextPos)(LytCaseBinders.value)(insertStart(LytOf.value)(insertToken(v)(new Tuple(v2.value0.value1, v2.value1))));
          }
          ;
          return popStack(function(v32) {
            return eq114(v32)(LytProperty.value);
          })(insertDefault(v2));
        }
        ;
        if (v.value instanceof TokLowerName && (v.value.value0 instanceof Nothing && v.value.value1 === "if")) {
          return insertKwProperty(pushStack(v.range.start)(LytIf.value))(v1);
        }
        ;
        if (v.value instanceof TokLowerName && (v.value.value0 instanceof Nothing && v.value.value1 === "then")) {
          var v2 = collapse(indentedP)(v1);
          if (v2.value0 instanceof Cons && v2.value0.value0.value1 instanceof LytIf) {
            return pushStack(v.range.start)(LytThen.value)(insertToken(v)(new Tuple(v2.value0.value1, v2.value1)));
          }
          ;
          return popStack(function(v32) {
            return eq114(v32)(LytProperty.value);
          })(insertDefault(v1));
        }
        ;
        if (v.value instanceof TokLowerName && (v.value.value0 instanceof Nothing && v.value.value1 === "else")) {
          var v2 = collapse(indentedP)(v1);
          if (v2.value0 instanceof Cons && v2.value0.value0.value1 instanceof LytThen) {
            return insertToken(v)(new Tuple(v2.value0.value1, v2.value1));
          }
          ;
          var v3 = collapse(offsideP)(v1);
          if (isTopDecl(v.range.start)(v3.value0)) {
            return insertToken(v)(v3);
          }
          ;
          return popStack(function(v4) {
            return eq114(v4)(LytProperty.value);
          })(insertToken(v)(insertSep(v3)));
        }
        ;
        if (v.value instanceof TokForall) {
          return insertKwProperty(pushStack(v.range.start)(LytForall.value))(v1);
        }
        ;
        if (v.value instanceof TokBackslash) {
          return pushStack(v.range.start)(LytLambdaBinders.value)(insertDefault(v1));
        }
        ;
        if (v.value instanceof TokRightArrow) {
          var guardP = function(v22) {
            if (v22 instanceof LytCaseBinders) {
              return true;
            }
            ;
            if (v22 instanceof LytCaseGuard) {
              return true;
            }
            ;
            if (v22 instanceof LytLambdaBinders) {
              return true;
            }
            ;
            return false;
          };
          var arrowP = function(v22) {
            return function(v32) {
              if (v32 instanceof LytDo) {
                return true;
              }
              ;
              if (v32 instanceof LytOf) {
                return false;
              }
              ;
              return offsideEndP(v22)(v32);
            };
          };
          return insertToken(v)(popStack(guardP)(collapse(arrowP)(v1)));
        }
        ;
        if (v.value instanceof TokEquals) {
          var equalsP = function(v22) {
            return function(v32) {
              if (v32 instanceof LytWhere) {
                return true;
              }
              ;
              if (v32 instanceof LytLet) {
                return true;
              }
              ;
              if (v32 instanceof LytLetStmt) {
                return true;
              }
              ;
              return false;
            };
          };
          var v2 = collapse(equalsP)(v1);
          if (v2.value0 instanceof Cons && v2.value0.value0.value1 instanceof LytDeclGuard) {
            return insertToken(v)(new Tuple(v2.value0.value1, v2.value1));
          }
          ;
          return insertDefault(v1);
        }
        ;
        if (v.value instanceof TokPipe) {
          var v2 = collapse(offsideEndP)(v1);
          if (v2.value0 instanceof Cons && v2.value0.value0.value1 instanceof LytOf) {
            return insertToken(v)(pushStack(v.range.start)(LytCaseGuard.value)(v2));
          }
          ;
          if (v2.value0 instanceof Cons && v2.value0.value0.value1 instanceof LytLet) {
            return insertToken(v)(pushStack(v.range.start)(LytDeclGuard.value)(v2));
          }
          ;
          if (v2.value0 instanceof Cons && v2.value0.value0.value1 instanceof LytLetStmt) {
            return insertToken(v)(pushStack(v.range.start)(LytDeclGuard.value)(v2));
          }
          ;
          if (v2.value0 instanceof Cons && v2.value0.value0.value1 instanceof LytWhere) {
            return insertToken(v)(pushStack(v.range.start)(LytDeclGuard.value)(v2));
          }
          ;
          return insertDefault(v1);
        }
        ;
        if (v.value instanceof TokTick) {
          var v2 = collapse(indentedP)(v1);
          if (v2.value0 instanceof Cons && v2.value0.value0.value1 instanceof LytTick) {
            return insertToken(v)(new Tuple(v2.value0.value1, v2.value1));
          }
          ;
          return pushStack(v.range.start)(LytTick.value)(insertToken(v)(insertSep(collapse(offsideEndP)(v1))));
        }
        ;
        if (v.value instanceof TokComma) {
          var v2 = collapse(indentedP)(v1);
          if (v2.value0 instanceof Cons && v2.value0.value0.value1 instanceof LytBrace) {
            return pushStack(v.range.start)(LytProperty.value)(insertToken(v)(v2));
          }
          ;
          return insertToken(v)(v2);
        }
        ;
        if (v.value instanceof TokDot) {
          var v2 = insertDefault(v1);
          if (v2.value0 instanceof Cons && v2.value0.value0.value1 instanceof LytForall) {
            return new Tuple(v2.value0.value1, v2.value1);
          }
          ;
          return pushStack(v.range.start)(LytProperty.value)(v2);
        }
        ;
        if (v.value instanceof TokLeftParen) {
          return pushStack(v.range.start)(LytParen.value)(insertDefault(v1));
        }
        ;
        if (v.value instanceof TokLeftBrace) {
          return pushStack(v.range.start)(LytProperty.value)(pushStack(v.range.start)(LytBrace.value)(insertDefault(v1)));
        }
        ;
        if (v.value instanceof TokLeftSquare) {
          return pushStack(v.range.start)(LytSquare.value)(insertDefault(v1));
        }
        ;
        if (v.value instanceof TokRightParen) {
          return insertToken(v)(popStack(function(v22) {
            return eq114(v22)(LytParen.value);
          })(collapse(indentedP)(v1)));
        }
        ;
        if (v.value instanceof TokRightBrace) {
          return insertToken(v)(popStack(function(v22) {
            return eq114(v22)(LytBrace.value);
          })(popStack(function(v22) {
            return eq114(v22)(LytProperty.value);
          })(collapse(indentedP)(v1))));
        }
        ;
        if (v.value instanceof TokRightSquare) {
          return insertToken(v)(popStack(function(v22) {
            return eq114(v22)(LytSquare.value);
          })(collapse(indentedP)(v1)));
        }
        ;
        if (v.value instanceof TokString) {
          return popStack(function(v22) {
            return eq114(v22)(LytProperty.value);
          })(insertDefault(v1));
        }
        ;
        if (v.value instanceof TokLowerName && v.value.value0 instanceof Nothing) {
          return popStack(function(v22) {
            return eq114(v22)(LytProperty.value);
          })(insertDefault(v1));
        }
        ;
        if (v.value instanceof TokOperator) {
          return insertToken(v)(insertSep(collapse(offsideEndP)(v1)));
        }
        ;
        return insertDefault(v1);
      };
      return insert20(new Tuple(stack, []));
    };
  };
};
var currentIndent = /* @__PURE__ */ function() {
  var go = function($copy_v) {
    var $tco_done = false;
    var $tco_result;
    function $tco_loop(v) {
      if (v instanceof Cons) {
        if (isIndented(v.value0.value1)) {
          $tco_done = true;
          return new Just(v.value0.value0);
        }
        ;
        if (otherwise) {
          $copy_v = v.value1;
          return;
        }
        ;
      }
      ;
      $tco_done = true;
      return Nothing.value;
    }
    ;
    while (!$tco_done) {
      $tco_result = $tco_loop($copy_v);
    }
    ;
    return $tco_result;
  };
  return go;
}();

// output/PureScript.CST.TokenStream/index.js
var TokenEOF = /* @__PURE__ */ function() {
  function TokenEOF2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  TokenEOF2.create = function(value0) {
    return function(value12) {
      return new TokenEOF2(value0, value12);
    };
  };
  return TokenEOF2;
}();
var TokenError = /* @__PURE__ */ function() {
  function TokenError2(value0, value12, value22, value32) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
    this.value3 = value32;
  }
  ;
  TokenError2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return function(value32) {
          return new TokenError2(value0, value12, value22, value32);
        };
      };
    };
  };
  return TokenError2;
}();
var TokenCons = /* @__PURE__ */ function() {
  function TokenCons2(value0, value12, value22, value32) {
    this.value0 = value0;
    this.value1 = value12;
    this.value2 = value22;
    this.value3 = value32;
  }
  ;
  TokenCons2.create = function(value0) {
    return function(value12) {
      return function(value22) {
        return function(value32) {
          return new TokenCons2(value0, value12, value22, value32);
        };
      };
    };
  };
  return TokenCons2;
}();
var step2 = /* @__PURE__ */ function() {
  var $32 = unwrap();
  return function($33) {
    return force($32($33));
  };
}();
var unwindLayout = function(pos) {
  return function(eof3) {
    var go = function(stk) {
      return defer2(function(v) {
        if (stk instanceof Nil) {
          return step2(eof3);
        }
        ;
        if (stk instanceof Cons) {
          if (stk.value0.value1 instanceof LytRoot) {
            return step2(eof3);
          }
          ;
          if (isIndented(stk.value0.value1)) {
            return new TokenCons(lytToken(pos)(new TokLayoutEnd(stk.value0.value0.column)), pos, go(stk.value1), stk.value1);
          }
          ;
          if (otherwise) {
            return step2(go(stk.value1));
          }
          ;
          throw new Error("Failed pattern match at PureScript.CST.TokenStream (line 59, column 7 - line 66, column 27): " + [stk.value0.value1.constructor.name]);
        }
        ;
        throw new Error("Failed pattern match at PureScript.CST.TokenStream (line 56, column 43 - line 66, column 27): " + [stk.constructor.name]);
      });
    };
    return go;
  };
};
var layoutStack = function(stream3) {
  var v = step2(stream3);
  if (v instanceof TokenEOF) {
    return Nil.value;
  }
  ;
  if (v instanceof TokenError) {
    return v.value3;
  }
  ;
  if (v instanceof TokenCons) {
    return v.value3;
  }
  ;
  throw new Error("Failed pattern match at PureScript.CST.TokenStream (line 48, column 22 - line 51, column 29): " + [v.constructor.name]);
};
var consTokens = function(dictFoldable) {
  var go = function(v) {
    return function(v1) {
      return new Tuple(v.value0.range.start, defer2(function(v2) {
        return new TokenCons(v.value0, v1.value0, v1.value1, v.value1);
      }));
    };
  };
  return flip(foldr(dictFoldable)(go));
};

// output/PureScript.CST.Lexer/index.js
var add2 = /* @__PURE__ */ add(semiringInt);
var div4 = /* @__PURE__ */ div(euclideanRingInt);
var bindFlipped11 = /* @__PURE__ */ bindFlipped(bindMaybe);
var foldMap18 = /* @__PURE__ */ foldMap(foldableMaybe)(monoidString);
var fold20 = /* @__PURE__ */ fold(foldableMaybe)(monoidString);
var fold111 = /* @__PURE__ */ fold(foldableArray)(/* @__PURE__ */ monoidRecord()(/* @__PURE__ */ monoidRecordCons({
  reflectSymbol: function() {
    return "raw";
  }
})(monoidString)()(/* @__PURE__ */ monoidRecordCons({
  reflectSymbol: function() {
    return "string";
  }
})(monoidString)()(monoidRecordNil))));
var foldl15 = /* @__PURE__ */ foldl(foldableArray);
var consTokens2 = /* @__PURE__ */ consTokens(foldableArray);
var LexFail = /* @__PURE__ */ function() {
  function LexFail2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  LexFail2.create = function(value0) {
    return function(value12) {
      return new LexFail2(value0, value12);
    };
  };
  return LexFail2;
}();
var LexSucc = /* @__PURE__ */ function() {
  function LexSucc2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  LexSucc2.create = function(value0) {
    return function(value12) {
      return new LexSucc2(value0, value12);
    };
  };
  return LexSucc2;
}();
var Lex = function(x) {
  return x;
};
var isCharCodePoint = {
  fromChar: codePointFromChar,
  fromCharCode: /* @__PURE__ */ toEnum(boundedEnumCodePoint)
};
var isCharChar = {
  fromChar: /* @__PURE__ */ identity(categoryFn),
  fromCharCode: fromCharCode3
};
var $$try8 = function(v) {
  return function(str2) {
    var v1 = v(str2);
    if (v1 instanceof LexFail) {
      return new LexFail(v1.value0, str2);
    }
    ;
    if (v1 instanceof LexSucc) {
      return new LexSucc(v1.value0, v1.value1);
    }
    ;
    throw new Error("Failed pattern match at PureScript.CST.Lexer (line 102, column 3 - line 104, column 31): " + [v1.constructor.name]);
  };
};
var toModuleName = function(v) {
  if (v === "") {
    return Nothing.value;
  }
  ;
  return new Just(dropRight(1)(v));
};
var qualLength = /* @__PURE__ */ maybe(0)(/* @__PURE__ */ function() {
  var $305 = add2(1);
  var $306 = unwrap();
  return function($307) {
    return $305(length4($306($307)));
  };
}());
var optional8 = function(v) {
  return function(str2) {
    var v1 = v(str2);
    if (v1 instanceof LexFail) {
      if (length3(str2) === length3(v1.value1)) {
        return new LexSucc(Nothing.value, str2);
      }
      ;
      if (otherwise) {
        return new LexFail(v1.value0, v1.value1);
      }
      ;
    }
    ;
    if (v1 instanceof LexSucc) {
      return new LexSucc(new Just(v1.value0), v1.value1);
    }
    ;
    throw new Error("Failed pattern match at PureScript.CST.Lexer (line 151, column 3 - line 158, column 25): " + [v1.constructor.name]);
  };
};
var mkUnexpected = function(str2) {
  var start = take3(6)(str2);
  var len = length4(start);
  var $142 = len === 0;
  if ($142) {
    return "end of file";
  }
  ;
  var $143 = len < 6;
  if ($143) {
    return start;
  }
  ;
  return start + "...";
};
var regex3 = function(mkErr) {
  return function(regexStr) {
    var matchRegex = unsafeRegex("^(?:" + (regexStr + ")"))(unicode);
    return function(str2) {
      var v = match(matchRegex)(str2);
      var v1 = function(v2) {
        return new LexFail(function(v3) {
          return mkErr(mkUnexpected(str2));
        }, str2);
      };
      if (v instanceof Just) {
        var $145 = head2(v.value0);
        if ($145 instanceof Just) {
          return new LexSucc($145.value0, drop2(length3($145.value0))(str2));
        }
        ;
        return v1(true);
      }
      ;
      return v1(true);
    };
  };
};
var satisfy2 = function(mkErr) {
  return function(p) {
    return function(str2) {
      var v = charAt2(0)(str2);
      if (v instanceof Just && p(v.value0)) {
        return new LexSucc(v.value0, drop2(1)(str2));
      }
      ;
      return new LexFail(function(v1) {
        return mkErr(mkUnexpected(str2));
      }, str2);
    };
  };
};
var string6 = function(mkErr) {
  return function(match4) {
    return function(str2) {
      var $150 = take2(length3(match4))(str2) === match4;
      if ($150) {
        return new LexSucc(match4, drop2(length3(match4))(str2));
      }
      ;
      return new LexFail(function(v) {
        return mkErr(mkUnexpected(str2));
      }, str2);
    };
  };
};
var many6 = function(v) {
  return function(str2) {
    return function __do3() {
      var valuesRef = newSTArray();
      var strRef = str2;
      var contRef = true;
      var resRef = new LexSucc([], str2);
      (function() {
        while (contRef) {
          (function __do4() {
            var str$prime = strRef;
            var v1 = v(str$prime);
            if (v1 instanceof LexFail) {
              if (length3(str$prime) === length3(v1.value1)) {
                var values2 = unsafeFreeze(valuesRef)();
                resRef = new LexSucc(values2, v1.value1);
                contRef = false;
                return unit;
              }
              ;
              if (otherwise) {
                resRef = new LexFail(v1.value0, v1.value1);
                contRef = false;
                return unit;
              }
              ;
            }
            ;
            if (v1 instanceof LexSucc) {
              push(v1.value0)(valuesRef)();
              strRef = v1.value1;
              return unit;
            }
            ;
            throw new Error("Failed pattern match at PureScript.CST.Lexer (line 176, column 5 - line 190, column 18): " + [v1.constructor.name]);
          })();
        }
        ;
        return {};
      })();
      return resRef;
    }();
  };
};
var functorLex = {
  map: function(f) {
    return function(v) {
      return function(str2) {
        var v1 = v(str2);
        if (v1 instanceof LexFail) {
          return new LexFail(v1.value0, v1.value1);
        }
        ;
        if (v1 instanceof LexSucc) {
          return new LexSucc(f(v1.value0), v1.value1);
        }
        ;
        throw new Error("Failed pattern match at PureScript.CST.Lexer (line 64, column 5 - line 66, column 37): " + [v1.constructor.name]);
      };
    };
  }
};
var map78 = /* @__PURE__ */ map(functorLex);
var spaceComment = /* @__PURE__ */ function() {
  return map78(length3)(regex3(LexExpected.create("spaces"))(" +"));
}();
var fromCharCode4 = function(dict) {
  return dict.fromCharCode;
};
var fromChar = function(dict) {
  return dict.fromChar;
};
var fail4 = function($308) {
  return Lex(LexFail.create($$const($308)));
};
var char$prime = function(mkErr) {
  return function(res) {
    return function(match4) {
      return function(str2) {
        var $166 = singleton6(match4) === take2(1)(str2);
        if ($166) {
          return new LexSucc(res, drop2(1)(str2));
        }
        ;
        return new LexFail(function(v) {
          return mkErr(mkUnexpected(str2));
        }, str2);
      };
    };
  };
};
var $$char4 = function(mkErr) {
  return function(match4) {
    return function(str2) {
      var $167 = singleton6(match4) === take2(1)(str2);
      if ($167) {
        return new LexSucc(match4, drop2(1)(str2));
      }
      ;
      return new LexFail(function(v) {
        return mkErr(mkUnexpected(str2));
      }, str2);
    };
  };
};
var bumpText = function(v) {
  return function(colOffset) {
    return function(str2) {
      var go = function($copy_n) {
        return function($copy_ix) {
          var $tco_var_n = $copy_n;
          var $tco_done = false;
          var $tco_result;
          function $tco_loop(n, ix) {
            var v1 = indexOf$prime("\n")(ix)(str2);
            if (v1 instanceof Just) {
              $tco_var_n = n + 1 | 0;
              $copy_ix = v1.value0 + 1 | 0;
              return;
            }
            ;
            if (v1 instanceof Nothing) {
              if (n === 0) {
                $tco_done = true;
                return {
                  line: v.line,
                  column: (v.column + length4(str2) | 0) + (colOffset * 2 | 0) | 0
                };
              }
              ;
              if (otherwise) {
                $tco_done = true;
                return {
                  line: v.line + n | 0,
                  column: length4(drop2(ix)(str2)) + colOffset | 0
                };
              }
              ;
            }
            ;
            throw new Error("Failed pattern match at PureScript.CST.Lexer (line 338, column 13 - line 347, column 12): " + [v1.constructor.name]);
          }
          ;
          while (!$tco_done) {
            $tco_result = $tco_loop($tco_var_n, $copy_ix);
          }
          ;
          return $tco_result;
        };
      };
      return go(0)(0);
    };
  };
};
var bumpToken = function(v) {
  return function(v1) {
    if (v1 instanceof TokLeftParen) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokRightParen) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokLeftBrace) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokRightBrace) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokLeftSquare) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokRightSquare) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokLeftArrow && v1.value0 instanceof ASCII2) {
      return {
        line: v.line,
        column: v.column + 2 | 0
      };
    }
    ;
    if (v1 instanceof TokLeftArrow && v1.value0 instanceof Unicode) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokRightArrow && v1.value0 instanceof ASCII2) {
      return {
        line: v.line,
        column: v.column + 2 | 0
      };
    }
    ;
    if (v1 instanceof TokRightArrow && v1.value0 instanceof Unicode) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokRightFatArrow && v1.value0 instanceof ASCII2) {
      return {
        line: v.line,
        column: v.column + 2 | 0
      };
    }
    ;
    if (v1 instanceof TokRightFatArrow && v1.value0 instanceof Unicode) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokDoubleColon && v1.value0 instanceof ASCII2) {
      return {
        line: v.line,
        column: v.column + 2 | 0
      };
    }
    ;
    if (v1 instanceof TokDoubleColon && v1.value0 instanceof Unicode) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokForall && v1.value0 instanceof ASCII2) {
      return {
        line: v.line,
        column: v.column + 6 | 0
      };
    }
    ;
    if (v1 instanceof TokForall && v1.value0 instanceof Unicode) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokEquals) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokPipe) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokTick) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokDot) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokComma) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokUnderscore) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokBackslash) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokAt) {
      return {
        line: v.line,
        column: v.column + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokLowerName) {
      return {
        line: v.line,
        column: (v.column + qualLength(v1.value0) | 0) + length4(v1.value1) | 0
      };
    }
    ;
    if (v1 instanceof TokUpperName) {
      return {
        line: v.line,
        column: (v.column + qualLength(v1.value0) | 0) + length4(v1.value1) | 0
      };
    }
    ;
    if (v1 instanceof TokOperator) {
      return {
        line: v.line,
        column: (v.column + qualLength(v1.value0) | 0) + length4(v1.value1) | 0
      };
    }
    ;
    if (v1 instanceof TokSymbolName) {
      return {
        line: v.line,
        column: ((v.column + qualLength(v1.value0) | 0) + length4(v1.value1) | 0) + 2 | 0
      };
    }
    ;
    if (v1 instanceof TokSymbolArrow && v1.value0 instanceof Unicode) {
      return {
        line: v.line,
        column: v.column + 3 | 0
      };
    }
    ;
    if (v1 instanceof TokSymbolArrow && v1.value0 instanceof ASCII2) {
      return {
        line: v.line,
        column: v.column + 4 | 0
      };
    }
    ;
    if (v1 instanceof TokHole) {
      return {
        line: v.line,
        column: (v.column + length4(v1.value0) | 0) + 1 | 0
      };
    }
    ;
    if (v1 instanceof TokChar) {
      return {
        line: v.line,
        column: (v.column + length4(v1.value0) | 0) + 2 | 0
      };
    }
    ;
    if (v1 instanceof TokInt) {
      return {
        line: v.line,
        column: v.column + length4(v1.value0) | 0
      };
    }
    ;
    if (v1 instanceof TokNumber) {
      return {
        line: v.line,
        column: v.column + length4(v1.value0) | 0
      };
    }
    ;
    if (v1 instanceof TokString) {
      return bumpText(v)(1)(v1.value0);
    }
    ;
    if (v1 instanceof TokRawString) {
      return bumpText(v)(3)(v1.value0);
    }
    ;
    if (v1 instanceof TokLayoutStart) {
      return v;
    }
    ;
    if (v1 instanceof TokLayoutSep) {
      return v;
    }
    ;
    if (v1 instanceof TokLayoutEnd) {
      return v;
    }
    ;
    throw new Error("Failed pattern match at PureScript.CST.Lexer (line 255, column 34 - line 333, column 8): " + [v1.constructor.name]);
  };
};
var bumpComment = function(v) {
  return function(v1) {
    if (v1 instanceof Comment) {
      return bumpText(v)(0)(v1.value0);
    }
    ;
    if (v1 instanceof Space) {
      return {
        line: v.line,
        column: v.column + v1.value0 | 0
      };
    }
    ;
    if (v1 instanceof Line2) {
      return {
        line: v.line + v1.value1 | 0,
        column: 0
      };
    }
    ;
    throw new Error("Failed pattern match at PureScript.CST.Lexer (line 350, column 36 - line 356, column 34): " + [v1.constructor.name]);
  };
};
var applyLex = {
  apply: function(v) {
    return function(v1) {
      return function(str2) {
        var v2 = v(str2);
        if (v2 instanceof LexFail) {
          return new LexFail(v2.value0, v2.value1);
        }
        ;
        if (v2 instanceof LexSucc) {
          var v3 = v1(v2.value1);
          if (v3 instanceof LexFail) {
            return new LexFail(v3.value0, v3.value1);
          }
          ;
          if (v3 instanceof LexSucc) {
            return new LexSucc(v2.value0(v3.value0), v3.value1);
          }
          ;
          throw new Error("Failed pattern match at PureScript.CST.Lexer (line 73, column 9 - line 76, column 32): " + [v3.constructor.name]);
        }
        ;
        throw new Error("Failed pattern match at PureScript.CST.Lexer (line 70, column 5 - line 76, column 32): " + [v2.constructor.name]);
      };
    };
  },
  Functor0: function() {
    return functorLex;
  }
};
var applyFirst4 = /* @__PURE__ */ applyFirst(applyLex);
var applySecond7 = /* @__PURE__ */ applySecond(applyLex);
var apply22 = /* @__PURE__ */ apply2(applyLex);
var bindLex = {
  bind: function(v) {
    return function(k) {
      return function(str2) {
        var v1 = v(str2);
        if (v1 instanceof LexFail) {
          return new LexFail(v1.value0, v1.value1);
        }
        ;
        if (v1 instanceof LexSucc) {
          var v2 = k(v1.value0);
          return v2(v1.value1);
        }
        ;
        throw new Error("Failed pattern match at PureScript.CST.Lexer (line 83, column 5 - line 87, column 16): " + [v1.constructor.name]);
      };
    };
  },
  Apply0: function() {
    return applyLex;
  }
};
var bind120 = /* @__PURE__ */ bind(bindLex);
var applicativeLex = {
  pure: function($309) {
    return Lex(LexSucc.create($309));
  },
  Apply0: function() {
    return applyLex;
  }
};
var pure120 = /* @__PURE__ */ pure(applicativeLex);
var altLex = {
  alt: function(v) {
    return function(v1) {
      return function(str2) {
        var v2 = v(str2);
        if (v2 instanceof LexFail) {
          if (length3(str2) === length3(v2.value1)) {
            return v1(str2);
          }
          ;
          if (otherwise) {
            return new LexFail(v2.value0, v2.value1);
          }
          ;
        }
        ;
        if (v2 instanceof LexSucc) {
          return new LexSucc(v2.value0, v2.value1);
        }
        ;
        throw new Error("Failed pattern match at PureScript.CST.Lexer (line 91, column 5 - line 98, column 20): " + [v2.constructor.name]);
      };
    };
  },
  Functor0: function() {
    return functorLex;
  }
};
var alt28 = /* @__PURE__ */ alt(altLex);
var comment = /* @__PURE__ */ function() {
  return alt28(regex3(LexExpected.create("block comment"))("\\{-(-(?!\\})|[^-]+)*(-\\}|$)"))(regex3(LexExpected.create("line comment"))("--[^\\r\\n]*"));
}();
var lineComment = /* @__PURE__ */ function() {
  return alt28(map78(function() {
    var $310 = Line2.create(LF.value);
    return function($311) {
      return $310(length4($311));
    };
  }())(regex3(LexExpected.create("newline"))("\n+")))(map78(function() {
    var $312 = Line2.create(CRLF.value);
    return function($313) {
      return $312(function(v) {
        return div4(v)(2);
      }(length4($313)));
    };
  }())(regex3(LexExpected.create("newline"))("(?:\r\n)+")));
}();
var leadingComments = /* @__PURE__ */ function() {
  return many6(alt28(map78(Comment.create)(comment))(alt28(map78(Space.create)(spaceComment))(lineComment)));
}();
var token = /* @__PURE__ */ function() {
  var tokenTick = char$prime(LexExpected.create("backtick"))(TokTick.value)("`");
  var tokenRightSquare = char$prime(LexExpected.create("right square"))(TokRightSquare.value)("]");
  var tokenRightParen = char$prime(LexExpected.create("right paren"))(TokRightParen.value)(")");
  var tokenRightBrace = char$prime(LexExpected.create("right brace"))(TokRightBrace.value)("}");
  var tokenLeftSquare = char$prime(LexExpected.create("left square"))(TokLeftSquare.value)("[");
  var tokenLeftParen = char$prime(LexExpected.create("left paren"))(TokLeftParen.value)("(");
  var tokenLeftBrace = char$prime(LexExpected.create("left brace"))(TokLeftBrace.value)("{");
  var tokenComma = char$prime(LexExpected.create("comma"))(TokComma.value)(",");
  var stripUnderscores = replaceAll("_")("");
  var stringSpaceEscapeRegex = regex3(LexExpected.create("whitespace escape"))("\\\\[ \\r\\n]+\\\\");
  var stringCharsRegex = regex3(LexExpected.create("string characters"))('[^"\\\\]+');
  var rawStringCharsRegex = regex3(LexExpected.create("raw string characters"))('""""{0,2}([^"]+"{1,2})*[^"]*"""');
  var parseSymbolIdent = regex3(LexExpected.create("symbol"))("(?:[:!#$%&*+./<=>?@\\\\^|~-]|(?!\\p{P})\\p{S})+");
  var parseSymbol2 = map78(function(v) {
    return function(v1) {
      if (v1 instanceof Nothing) {
        if (v === "->") {
          return new TokSymbolArrow(ASCII2.value);
        }
        ;
        if (v === "\u2192") {
          return new TokSymbolArrow(Unicode.value);
        }
        ;
        return new TokSymbolName(Nothing.value, v);
      }
      ;
      return new TokSymbolName(v1, v);
    };
  })($$try8(applyFirst4(applySecond7(tokenLeftParen)(parseSymbolIdent))(tokenRightParen)));
  var parseStringSpaceEscape = map78(function(v) {
    return {
      raw: v,
      string: ""
    };
  })(stringSpaceEscapeRegex);
  var parseStringChars = map78(function(v) {
    return {
      raw: v,
      string: v
    };
  })(stringCharsRegex);
  var parseRawString = map78(function(v) {
    return new TokRawString(dropRight(3)(drop2(3)(v)));
  })(rawStringCharsRegex);
  var parseProper2 = regex3(LexExpected.create("proper name"))("\\p{Lu}[\\p{L}0-9_']*");
  var parseUpper = map78(flip(TokUpperName.create))(parseProper2);
  var parseOperator2 = map78(function(v) {
    return function(v1) {
      if (v1 instanceof Nothing) {
        if (v === "<-") {
          return new TokLeftArrow(ASCII2.value);
        }
        ;
        if (v === "\u2190") {
          return new TokLeftArrow(Unicode.value);
        }
        ;
        if (v === "->") {
          return new TokRightArrow(ASCII2.value);
        }
        ;
        if (v === "\u2192") {
          return new TokRightArrow(Unicode.value);
        }
        ;
        if (v === "=>") {
          return new TokRightFatArrow(ASCII2.value);
        }
        ;
        if (v === "\u21D2") {
          return new TokRightFatArrow(Unicode.value);
        }
        ;
        if (v === "::") {
          return new TokDoubleColon(ASCII2.value);
        }
        ;
        if (v === "\u2237") {
          return new TokDoubleColon(Unicode.value);
        }
        ;
        if (v === "\u2200") {
          return new TokForall(Unicode.value);
        }
        ;
        if (v === "=") {
          return TokEquals.value;
        }
        ;
        if (v === ".") {
          return TokDot.value;
        }
        ;
        if (v === "\\") {
          return TokBackslash.value;
        }
        ;
        if (v === "|") {
          return TokPipe.value;
        }
        ;
        if (v === "@") {
          return TokAt.value;
        }
        ;
        if (v === "`") {
          return TokTick.value;
        }
        ;
        return new TokOperator(Nothing.value, v);
      }
      ;
      return new TokOperator(v1, v);
    };
  })(parseSymbolIdent);
  var parseModuleNamePrefix = regex3(LexExpected.create("module name"))("(?:(?:\\p{Lu}[\\p{L}0-9_']*)\\.)*");
  var parseIdent2 = regex3(LexExpected.create("ident"))("[\\p{Ll}_][\\p{L}0-9_']*");
  var parseLower = map78(function(v) {
    return function(v1) {
      if (v1 instanceof Nothing) {
        if (v === "forall") {
          return new TokForall(ASCII2.value);
        }
        ;
        if (v === "_") {
          return TokUnderscore.value;
        }
        ;
        return new TokLowerName(Nothing.value, v);
      }
      ;
      return new TokLowerName(v1, v);
    };
  })(parseIdent2);
  var parseName = alt28(parseLower)(alt28(parseUpper)(alt28(parseOperator2)(parseSymbol2)));
  var parseModuleName2 = apply22(map78(function(v) {
    return function(v1) {
      return v1(toModuleName(v));
    };
  })(parseModuleNamePrefix))(parseName);
  var parseExponentSign = alt28(string6(LexExpected.create("negative"))("-"))(string6(LexExpected.create("positive"))("+"));
  var intPartRegex = regex3(LexExpected.create("int part"))("(0|[1-9][0-9_]*)");
  var parseExponentPart = apply22(map78(function(v) {
    return function(v1) {
      return {
        sign: v,
        exponent: v1
      };
    };
  })(optional8(parseExponentSign)))(intPartRegex);
  var hexIntRegex = regex3(LexExpected.create("hex int"))("[a-fA-F0-9]+");
  var hexIntPrefix = string6(LexExpected.create("hex int prefix"))("0x");
  var parseHexInt = bind120(applySecond7(hexIntPrefix)(hexIntRegex))(function(raw) {
    var v = fromStringAs(hexadecimal)(raw);
    if (v instanceof Just) {
      return pure120(new TokInt("0x" + raw, new SmallInt(v.value0)));
    }
    ;
    if (v instanceof Nothing) {
      return pure120(new TokInt("0x" + raw, new BigHex(raw)));
    }
    ;
    throw new Error("Failed pattern match at PureScript.CST.Lexer (line 602, column 5 - line 606, column 49): " + [v.constructor.name]);
  });
  var hexEscapeRegex = regex3(LexExpected.create("hex"))("[a-fA-F0-9]{1,6}");
  var parseHexEscape = function(dictIsChar) {
    var fromCharCode1 = fromCharCode4(dictIsChar);
    return bind120(hexEscapeRegex)(function(esc) {
      var v = bindFlipped11(fromCharCode1)(fromStringAs(hexadecimal)(esc));
      if (v instanceof Just) {
        return pure120({
          raw: "\\x" + esc,
          "char": v.value0
        });
      }
      ;
      if (v instanceof Nothing) {
        return fail4(new LexCharEscapeOutOfRange(esc));
      }
      ;
      throw new Error("Failed pattern match at PureScript.CST.Lexer (line 550, column 5 - line 554, column 43): " + [v.constructor.name]);
    });
  };
  var fractionPartRegex = regex3(LexExpected.create("fraction part"))("[0-9_]+");
  var charSingleQuote = $$char4(LexExpected.create("single quote"))("'");
  var charQuote = $$char4(LexExpected.create("quote"))('"');
  var charQuestionMark = $$char4(LexExpected.create("question mark"))("?");
  var parseHole2 = map78(function(v) {
    return new TokHole(v);
  })($$try8(applySecond7(charQuestionMark)(alt28(parseIdent2)(parseProper2))));
  var charExponent = $$char4(LexExpected.create("exponent"))("e");
  var parseNumberExponentPart = optional8(applySecond7(charExponent)(parseExponentPart));
  var charDot = $$char4(LexExpected.create("dot"))(".");
  var parseNumberFractionPart = optional8($$try8(applySecond7(charDot)(fractionPartRegex)));
  var parseNumber2 = bind120(intPartRegex)(function(intPart) {
    return bind120(parseNumberFractionPart)(function(fractionPart) {
      return bind120(parseNumberExponentPart)(function(exponentPart) {
        var $268 = isNothing(fractionPart) && isNothing(exponentPart);
        if ($268) {
          var intVal = stripUnderscores(intPart);
          var v = fromString2(intVal);
          if (v instanceof Just) {
            return pure120(new TokInt(intPart, new SmallInt(v.value0)));
          }
          ;
          if (v instanceof Nothing) {
            return pure120(new TokInt(intPart, new BigInt2(intVal)));
          }
          ;
          throw new Error("Failed pattern match at PureScript.CST.Lexer (line 614, column 7 - line 618, column 48): " + [v.constructor.name]);
        }
        ;
        var raw = intPart + (foldMap18(function(fr) {
          return "." + fr;
        })(fractionPart) + foldMap18(function(ex) {
          return "e" + (fold20(ex.sign) + ex.exponent);
        })(exponentPart));
        var v = fromString(stripUnderscores(raw));
        if (v instanceof Just) {
          return pure120(new TokNumber(raw, v.value0));
        }
        ;
        if (v instanceof Nothing) {
          return fail4(new LexNumberOutOfRange(raw));
        }
        ;
        throw new Error("Failed pattern match at PureScript.CST.Lexer (line 625, column 7 - line 629, column 41): " + [v.constructor.name]);
      });
    });
  });
  var parseNumericLiteral = alt28(parseHexInt)(parseNumber2);
  var charBackslash = $$char4(LexExpected.create("backslash"))("\\");
  var charAny = satisfy2(LexExpected.create("char"))($$const(true));
  var parseEscape = function(dictIsChar) {
    var fromChar1 = fromChar(dictIsChar);
    var parseHexEscape1 = parseHexEscape(dictIsChar);
    return bind120(charAny)(function(ch) {
      if (ch === "t") {
        return pure120({
          raw: "\\t",
          "char": fromChar1("	")
        });
      }
      ;
      if (ch === "r") {
        return pure120({
          raw: "\\r",
          "char": fromChar1("\r")
        });
      }
      ;
      if (ch === "n") {
        return pure120({
          raw: "\\n",
          "char": fromChar1("\n")
        });
      }
      ;
      if (ch === '"') {
        return pure120({
          raw: '\\"',
          "char": fromChar1('"')
        });
      }
      ;
      if (ch === "'") {
        return pure120({
          raw: "\\'",
          "char": fromChar1("'")
        });
      }
      ;
      if (ch === "\\") {
        return pure120({
          raw: "\\\\",
          "char": fromChar1("\\")
        });
      }
      ;
      if (ch === "x") {
        return parseHexEscape1;
      }
      ;
      return fail4(new LexInvalidCharEscape(singleton6(ch)));
    });
  };
  var parseEscape1 = parseEscape(isCharChar);
  var parseChar2 = bind120(charAny)(function(ch) {
    if (ch === "\\") {
      return parseEscape1;
    }
    ;
    if (ch === "'") {
      return fail4(new LexExpected("character", "empty character literal"));
    }
    ;
    return pure120({
      raw: singleton6(ch),
      "char": ch
    });
  });
  var parseCharLiteral = map78(function(v) {
    return new TokChar(v.raw, v["char"]);
  })(applyFirst4(applySecond7(charSingleQuote)(parseChar2))(charSingleQuote));
  var parseStringEscape = map78(function(v) {
    return {
      raw: v.raw,
      string: singleton7(v["char"])
    };
  })(applySecond7(charBackslash)(parseEscape(isCharCodePoint)));
  var parseStringPart = alt28(parseStringChars)(alt28(parseStringSpaceEscape)(parseStringEscape));
  var parseString2 = map78(function(v) {
    var v1 = fold111(v);
    return new TokString(v1.raw, v1.string);
  })(applyFirst4(applySecond7(charQuote)(many6(parseStringPart)))(charQuote));
  var parseStringLiteral = alt28(parseRawString)(parseString2);
  return alt28(parseHole2)(alt28(parseModuleName2)(alt28(parseCharLiteral)(alt28(parseStringLiteral)(alt28(parseNumericLiteral)(alt28(tokenLeftParen)(alt28(tokenRightParen)(alt28(tokenLeftBrace)(alt28(tokenRightBrace)(alt28(tokenLeftSquare)(alt28(tokenRightSquare)(alt28(tokenTick)(tokenComma))))))))))));
}();
var trailingComments = /* @__PURE__ */ function() {
  return many6(alt28(map78(Comment.create)(comment))(map78(Space.create)(spaceComment)));
}();
var lexWithState = /* @__PURE__ */ function() {
  var token$prime = apply22(apply22(map78(function(v) {
    return function(v1) {
      return function(v2) {
        return {
          token: v,
          trailing: v1,
          nextLeading: v2
        };
      };
    };
  })(token))(trailingComments))(leadingComments);
  var go = function(stack) {
    return function(startPos) {
      return function(leading) {
        return function(str2) {
          return defer2(function(v) {
            var $289 = str2 === "";
            if ($289) {
              return step2(unwindLayout(startPos)(defer2(function(v12) {
                return new TokenEOF(startPos, leading);
              }))(stack));
            }
            ;
            var v1 = token$prime(str2);
            if (v1 instanceof LexFail) {
              var errPos = bumpText(startPos)(0)(take2(length3(str2) - length3(v1.value1) | 0)(str2));
              return new TokenError(errPos, v1.value0(unit), Nothing.value, stack);
            }
            ;
            if (v1 instanceof LexSucc) {
              var endPos = bumpToken(startPos)(v1.value0.token);
              var nextStart = foldl15(bumpComment)(foldl15(bumpComment)(endPos)(v1.value0.trailing))(v1.value0.nextLeading);
              var posToken = {
                range: {
                  start: startPos,
                  end: endPos
                },
                leadingComments: leading,
                trailingComments: v1.value0.trailing,
                value: v1.value0.token
              };
              var v2 = insertLayout(posToken)(nextStart)(stack);
              return step2(snd(consTokens2(v2.value1)(new Tuple(nextStart, go(v2.value0)(nextStart)(v1.value0.nextLeading)(v1.value1)))));
            }
            ;
            throw new Error("Failed pattern match at PureScript.CST.Lexer (line 218, column 7 - line 237, column 63): " + [v1.constructor.name]);
          });
        };
      };
    };
  };
  var init4 = function(initStack) {
    return function(initPos) {
      return function(str2) {
        return defer2(function(v) {
          var v1 = leadingComments(str2);
          if (v1 instanceof LexFail) {
            return unsafeCrashWith("Leading comments can't fail.");
          }
          ;
          if (v1 instanceof LexSucc) {
            var nextPos = foldl15(bumpComment)(initPos)(v1.value0);
            return step2(go(initStack)(nextPos)(v1.value0)(v1.value1));
          }
          ;
          throw new Error("Failed pattern match at PureScript.CST.Lexer (line 205, column 5 - line 210, column 51): " + [v1.constructor.name]);
        });
      };
    };
  };
  return init4;
}();
var lex = /* @__PURE__ */ function() {
  return lexWithState(new Cons(new Tuple({
    line: 0,
    column: 0
  }, LytRoot.value), Nil.value))({
    line: 0,
    column: 0
  });
}();

// output/PureScript.CST.Parser.Monad/index.js
var $runtime_lazy13 = function(name4, moduleName2, init4) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2)
      return val;
    if (state2 === 1)
      throw new ReferenceError(name4 + " was needed before it finished initializing (module " + moduleName2 + ", line " + lineNumber + ")", moduleName2, lineNumber);
    state2 = 1;
    val = init4();
    state2 = 2;
    return val;
  };
};
var toUnfoldable25 = /* @__PURE__ */ toUnfoldable4(unfoldableArray);
var More2 = /* @__PURE__ */ function() {
  function More3(value0) {
    this.value0 = value0;
  }
  ;
  More3.create = function(value0) {
    return new More3(value0);
  };
  return More3;
}();
var Done2 = /* @__PURE__ */ function() {
  function Done3(value0) {
    this.value0 = value0;
  }
  ;
  Done3.create = function(value0) {
    return new Done3(value0);
  };
  return Done3;
}();
var ParseFail = /* @__PURE__ */ function() {
  function ParseFail2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ParseFail2.create = function(value0) {
    return function(value12) {
      return new ParseFail2(value0, value12);
    };
  };
  return ParseFail2;
}();
var ParseSucc = /* @__PURE__ */ function() {
  function ParseSucc2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ParseSucc2.create = function(value0) {
    return function(value12) {
      return new ParseSucc2(value0, value12);
    };
  };
  return ParseSucc2;
}();
var lazyParser = {
  defer: function(k) {
    var parser5 = defer2(k);
    return function(state2, more, resume3, done) {
      var v = force(parser5);
      return v(state2, more, resume3, done);
    };
  }
};
var functorParser = {
  map: function(f) {
    return function(v) {
      return function(state1, more, resume3, done) {
        return v(state1, more, resume3, function(state2, a) {
          return done(state2, f(a));
        });
      };
    };
  }
};
var map79 = /* @__PURE__ */ map(functorParser);
var applyParser = {
  apply: function(v) {
    return function(v1) {
      return function(state1, more, resume3, done) {
        return v(state1, more, resume3, function(state2, f) {
          return more(function(v2) {
            return v1(state2, more, resume3, function(state3, a) {
              return done(state3, f(a));
            });
          });
        });
      };
    };
  },
  Functor0: function() {
    return functorParser;
  }
};
var bindParser = {
  bind: function(v) {
    return function(k) {
      return function(state1, more, resume3, done) {
        return v(state1, more, resume3, function(state2, a) {
          return more(function(v1) {
            var v2 = k(a);
            return v2(state2, more, resume3, done);
          });
        });
      };
    };
  },
  Apply0: function() {
    return applyParser;
  }
};
var applicativeParser = {
  pure: function(a) {
    return function(state1, v, v1, done) {
      return done(state1, a);
    };
  },
  Apply0: function() {
    return applyParser;
  }
};
var pure66 = /* @__PURE__ */ pure(applicativeParser);
var altParser = {
  alt: function(v) {
    return function(v1) {
      return function(state1, more, resume3, done) {
        var state2 = function() {
          if (state1.consumed) {
            return {
              consumed: false,
              errors: state1.errors,
              stream: state1.stream
            };
          }
          ;
          return state1;
        }();
        return v(state2, more, function(state3, error4) {
          if (state3.consumed) {
            return resume3(state3, error4);
          }
          ;
          return v1(state1, more, resume3, done);
        }, done);
      };
    };
  },
  Functor0: function() {
    return functorParser;
  }
};
var alt29 = /* @__PURE__ */ alt(altParser);
var $$try9 = function(v) {
  return function(state1, more, resume3, done) {
    return v(state1, more, function(state2, error4) {
      return resume3({
        consumed: state1.consumed,
        errors: state2.errors,
        stream: state2.stream
      }, error4);
    }, done);
  };
};
var take6 = function(k) {
  return function(state2, v, resume3, done) {
    var v1 = step2(state2.stream);
    if (v1 instanceof TokenError) {
      return resume3(state2, {
        error: v1.value1,
        position: v1.value0
      });
    }
    ;
    if (v1 instanceof TokenEOF) {
      return resume3(state2, {
        error: UnexpectedEof.value,
        position: v1.value0
      });
    }
    ;
    if (v1 instanceof TokenCons) {
      var v2 = k(v1.value0);
      if (v2 instanceof Left) {
        return resume3(state2, {
          error: v2.value0,
          position: v1.value0.range.start
        });
      }
      ;
      if (v2 instanceof Right) {
        return done({
          consumed: true,
          stream: v1.value2,
          errors: state2.errors
        }, v2.value0);
      }
      ;
      throw new Error("Failed pattern match at PureScript.CST.Parser.Monad (line 172, column 11 - line 182, column 18): " + [v2.constructor.name]);
    }
    ;
    throw new Error("Failed pattern match at PureScript.CST.Parser.Monad (line 166, column 7 - line 182, column 18): " + [v1.constructor.name]);
  };
};
var runParser$prime = function(state1) {
  return function(v) {
    var run13 = function($copy_v1) {
      var $tco_done = false;
      var $tco_result;
      function $tco_loop(v1) {
        if (v1 instanceof More2) {
          $copy_v1 = v1.value0(unit);
          return;
        }
        ;
        if (v1 instanceof Done2) {
          $tco_done = true;
          return v1.value0;
        }
        ;
        throw new Error("Failed pattern match at PureScript.CST.Parser.Monad (line 241, column 9 - line 243, column 16): " + [v1.constructor.name]);
      }
      ;
      while (!$tco_done) {
        $tco_result = $tco_loop($copy_v1);
      }
      ;
      return $tco_result;
    };
    return run13(v(state1, More2.create, function(state2, error4) {
      return new Done2(new ParseFail(error4, state2));
    }, function(state2, value4) {
      return new Done2(new ParseSucc(value4, state2));
    }));
  };
};
var recover = function(k) {
  return function(v) {
    return function(state1, more, resume3, done) {
      return v({
        consumed: false,
        errors: state1.errors,
        stream: state1.stream
      }, more, function(state2, error4) {
        var v1 = k(error4)(state1.stream);
        if (v1 instanceof Nothing) {
          return resume3({
            consumed: state1.consumed,
            errors: state2.errors,
            stream: state2.stream
          }, error4);
        }
        ;
        if (v1 instanceof Just) {
          return done({
            consumed: true,
            errors: snoc(state2.errors)(error4),
            stream: v1.value0.value1
          }, v1.value0.value0);
        }
        ;
        throw new Error("Failed pattern match at PureScript.CST.Parser.Monad (line 149, column 13 - line 158, column 20): " + [v1.constructor.name]);
      }, done);
    };
  };
};
var optional9 = function(p) {
  return alt29(map79(Just.create)(p))(pure66(Nothing.value));
};
var many7 = function(v) {
  return function(state1, more, resume3, done) {
    var $lazy_go = $runtime_lazy13("go", "PureScript.CST.Parser.Monad", function() {
      return function(acc, state2) {
        var state2$prime = function() {
          if (state2.consumed) {
            return {
              consumed: false,
              errors: state2.errors,
              stream: state2.stream
            };
          }
          ;
          return state2;
        }();
        return v(state2$prime, more, function(state3, error4) {
          if (state3.consumed) {
            return resume3(state3, error4);
          }
          ;
          return done(state2, reverse(toUnfoldable25(acc)));
        }, function(state3, value4) {
          return $lazy_go(225)(new Cons(value4, acc), state3);
        });
      };
    });
    var go = $lazy_go(212);
    return go(Nil.value, state1);
  };
};
var lookAhead2 = function(v) {
  return function(state1, more, resume3, done) {
    return v(state1, more, function(v1, error4) {
      return resume3(state1, error4);
    }, function(v1, value4) {
      return done(state1, value4);
    });
  };
};
var initialParserState = function(stream3) {
  return {
    consumed: false,
    errors: [],
    stream: stream3
  };
};
var fromParserResult = function(v) {
  if (v instanceof ParseFail) {
    return new Left(v.value0);
  }
  ;
  if (v instanceof ParseSucc) {
    return new Right(new Tuple(v.value0, v.value1.errors));
  }
  ;
  throw new Error("Failed pattern match at PureScript.CST.Parser.Monad (line 253, column 20 - line 257, column 29): " + [v.constructor.name]);
};
var eof2 = function(state2, v, resume3, done) {
  var v1 = step2(state2.stream);
  if (v1 instanceof TokenError) {
    return resume3(state2, {
      error: v1.value1,
      position: v1.value0
    });
  }
  ;
  if (v1 instanceof TokenEOF) {
    return done({
      consumed: true,
      stream: state2.stream,
      errors: state2.errors
    }, new Tuple(v1.value0, v1.value1));
  }
  ;
  if (v1 instanceof TokenCons) {
    return resume3(state2, {
      error: new ExpectedEof(v1.value0.value),
      position: v1.value0.range.start
    });
  }
  ;
  throw new Error("Failed pattern match at PureScript.CST.Parser.Monad (line 188, column 7 - line 197, column 14): " + [v1.constructor.name]);
};

// output/PureScript.CST.Parser/index.js
var $runtime_lazy14 = function(name4, moduleName2, init4) {
  var state2 = 0;
  var val;
  return function(lineNumber) {
    if (state2 === 2)
      return val;
    if (state2 === 1)
      throw new ReferenceError(name4 + " was needed before it finished initializing (module " + moduleName2 + ", line " + lineNumber + ")", moduleName2, lineNumber);
    state2 = 1;
    val = init4();
    state2 = 2;
    return val;
  };
};
var bind51 = /* @__PURE__ */ bind(bindParser);
var pure67 = /* @__PURE__ */ pure(applicativeParser);
var apply23 = /* @__PURE__ */ apply2(applyParser);
var map80 = /* @__PURE__ */ map(functorParser);
var member9 = /* @__PURE__ */ member2(ordString);
var alt30 = /* @__PURE__ */ alt(altParser);
var applyFirst5 = /* @__PURE__ */ applyFirst(applyParser);
var applySecond8 = /* @__PURE__ */ applySecond(applyParser);
var defer5 = /* @__PURE__ */ defer(lazyParser);
var voidRight8 = /* @__PURE__ */ voidRight(functorParser);
var wrapped = function(openTok) {
  return function(closeTok) {
    return function(valueParser) {
      return bind51(openTok)(function(open2) {
        return bind51(valueParser)(function(value4) {
          return bind51(closeTok)(function(close2) {
            return pure67({
              open: open2,
              value: value4,
              close: close2
            });
          });
        });
      });
    };
  };
};
var separated = function(sepParser) {
  return function(valueParser) {
    return apply23(map80(function(v) {
      return function(v1) {
        return {
          head: v,
          tail: v1
        };
      };
    })(valueParser))(many7(apply23(map80(Tuple.create)(sepParser))(valueParser)));
  };
};
var reservedKeywords = /* @__PURE__ */ fromFoldable7(foldableArray)(ordString)(["ado", "case", "class", "data", "derive", "do", "else", "false", "foreign", "if", "import", "in", "infix", "infixl", "infixr", "instance", "let", "module", "newtype", "of", "then", "true", "type", "where"]);
var recoverTokensWhile = function(p) {
  return function(initStream) {
    var indent3 = maybe(0)(function(v) {
      return v.column;
    })(currentIndent(layoutStack(initStream)));
    var go = function($copy_acc) {
      return function($copy_stream) {
        var $tco_var_acc = $copy_acc;
        var $tco_done = false;
        var $tco_result;
        function $tco_loop(acc, stream3) {
          var v = step2(stream3);
          if (v instanceof TokenError) {
            $tco_done = true;
            return new Tuple(acc, stream3);
          }
          ;
          if (v instanceof TokenEOF) {
            $tco_done = true;
            return new Tuple(acc, stream3);
          }
          ;
          if (v instanceof TokenCons) {
            var $132 = p(v.value0)(indent3);
            if ($132) {
              $tco_var_acc = snoc(acc)(v.value0);
              $copy_stream = v.value2;
              return;
            }
            ;
            $tco_done = true;
            return new Tuple(acc, stream3);
          }
          ;
          throw new Error("Failed pattern match at PureScript.CST.Parser (line 1180, column 19 - line 1189, column 25): " + [v.constructor.name]);
        }
        ;
        while (!$tco_done) {
          $tco_result = $tco_loop($tco_var_acc, $copy_stream);
        }
        ;
        return $tco_result;
      };
    };
    return go([])(initStream);
  };
};
var recoverIndent = function(mkNode) {
  return recover(function(v) {
    return function(stream3) {
      var v1 = recoverTokensWhile(function(tok) {
        return function(indent3) {
          if (tok.value instanceof TokLayoutEnd) {
            return tok.value.value0 > indent3;
          }
          ;
          if (tok.value instanceof TokLayoutSep) {
            return tok.value.value0 > indent3;
          }
          ;
          return true;
        };
      })(stream3);
      var $142 = $$null(v1.value0);
      if ($142) {
        return Nothing.value;
      }
      ;
      return new Just(new Tuple(mkNode({
        position: v.position,
        error: v.error,
        tokens: v1.value0
      }), v1.value1));
    };
  });
};
var recoverLetBinding = /* @__PURE__ */ function() {
  return recoverIndent(LetBindingError.create);
}();
var recoverDoStatement = /* @__PURE__ */ function() {
  return recoverIndent(DoError.create);
}();
var recoverDecl = /* @__PURE__ */ function() {
  return recoverIndent(DeclError.create);
}();
var parseSmallInt = /* @__PURE__ */ take6(function(v) {
  if (v.value instanceof TokInt && v.value.value1 instanceof SmallInt) {
    return new Right(new Tuple(v, v.value.value1.value0));
  }
  ;
  if (v.value instanceof TokInt) {
    return new Left(new LexIntOutOfRange(v.value.value0));
  }
  ;
  return new Left(new UnexpectedToken(v.value));
});
var many13 = function(parser5) {
  return apply23(map80(cons$prime)(parser5))(many7(parser5));
};
var expectMap = function(k) {
  return take6(function(tok) {
    var v = k(tok);
    if (v instanceof Just) {
      return new Right(v.value0);
    }
    ;
    if (v instanceof Nothing) {
      return new Left(new UnexpectedToken(tok.value));
    }
    ;
    throw new Error("Failed pattern match at PureScript.CST.Parser (line 46, column 3 - line 50, column 39): " + [v.constructor.name]);
  });
};
var parseBoolean = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokLowerName && (v.value.value0 instanceof Nothing && v.value.value1 === "true")) {
    return new Just(new Tuple(v, true));
  }
  ;
  if (v.value instanceof TokLowerName && (v.value.value0 instanceof Nothing && v.value.value1 === "false")) {
    return new Just(new Tuple(v, false));
  }
  ;
  return Nothing.value;
});
var parseChar = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokChar) {
    return new Just(new Tuple(v, v.value.value1));
  }
  ;
  return Nothing.value;
});
var parseHole = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokHole) {
    return new Just({
      token: v,
      name: v.value.value0
    });
  }
  ;
  return Nothing.value;
});
var parseIdent = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokLowerName && (v.value.value0 instanceof Nothing && !member9(v.value.value1)(reservedKeywords))) {
    return new Just({
      token: v,
      name: v.value.value1
    });
  }
  ;
  return Nothing.value;
});
var $$parseInt2 = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokInt) {
    return new Just(new Tuple(v, v.value.value1));
  }
  ;
  return Nothing.value;
});
var parseLabel = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokRawString) {
    return new Just({
      token: v,
      name: v.value.value0
    });
  }
  ;
  if (v.value instanceof TokString) {
    return new Just({
      token: v,
      name: v.value.value1
    });
  }
  ;
  if (v.value instanceof TokLowerName && v.value.value0 instanceof Nothing) {
    return new Just({
      token: v,
      name: v.value.value1
    });
  }
  ;
  return Nothing.value;
});
var parseModuleName = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokUpperName && v.value.value0 instanceof Just) {
    return new Just({
      token: v,
      name: v.value.value0.value0 + ("." + v.value.value1)
    });
  }
  ;
  if (v.value instanceof TokUpperName && v.value.value0 instanceof Nothing) {
    return new Just({
      token: v,
      name: v.value.value1
    });
  }
  ;
  return Nothing.value;
});
var parseNumber = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokNumber) {
    return new Just(new Tuple(v, v.value.value1));
  }
  ;
  return Nothing.value;
});
var parseOperator = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokOperator && v.value.value0 instanceof Nothing) {
    return new Just({
      token: v,
      name: v.value.value1
    });
  }
  ;
  return Nothing.value;
});
var parseProper = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokUpperName && v.value.value0 instanceof Nothing) {
    return new Just({
      token: v,
      name: v.value.value1
    });
  }
  ;
  return Nothing.value;
});
var parseQualifiedIdent = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokLowerName && !member9(v.value.value1)(reservedKeywords)) {
    return new Just({
      token: v,
      module: v.value.value0,
      name: v.value.value1
    });
  }
  ;
  return Nothing.value;
});
var parseQualifiedIdentOrProper = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokLowerName) {
    return new Just({
      token: v,
      module: v.value.value0,
      name: new Left(v.value.value1)
    });
  }
  ;
  if (v.value instanceof TokUpperName) {
    return new Just({
      token: v,
      module: v.value.value0,
      name: new Right(v.value.value1)
    });
  }
  ;
  return Nothing.value;
});
var parseQualifiedOperator = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokOperator) {
    return new Just({
      token: v,
      module: v.value.value0,
      name: v.value.value1
    });
  }
  ;
  return Nothing.value;
});
var parseQualifiedProper = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokUpperName) {
    return new Just({
      token: v,
      module: v.value.value0,
      name: v.value.value1
    });
  }
  ;
  return Nothing.value;
});
var parseQualifiedSymbol = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokSymbolName) {
    return new Just({
      token: v,
      module: v.value.value0,
      name: v.value.value1
    });
  }
  ;
  return Nothing.value;
});
var parseString = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokString) {
    return new Just(new Tuple(v, v.value.value1));
  }
  ;
  if (v.value instanceof TokRawString) {
    return new Just(new Tuple(v, v.value.value0));
  }
  ;
  return Nothing.value;
});
var parseSymbol = /* @__PURE__ */ expectMap(function(v) {
  if (v.value instanceof TokSymbolName && v.value.value0 instanceof Nothing) {
    return new Just({
      token: v,
      name: v.value.value1
    });
  }
  ;
  return Nothing.value;
});
var expect = function(pred2) {
  return expectMap(function(tok) {
    var $241 = pred2(tok.value);
    if ($241) {
      return new Just(tok);
    }
    ;
    return Nothing.value;
  });
};
var tokAt = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokAt) {
    return true;
  }
  ;
  return false;
});
var tokBackslash = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokBackslash) {
    return true;
  }
  ;
  return false;
});
var tokComma = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokComma) {
    return true;
  }
  ;
  return false;
});
var tokDot = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokDot) {
    return true;
  }
  ;
  return false;
});
var parseRecordAccessor = function(expr) {
  return bind51(tokDot)(function(dot) {
    return bind51(separated(tokDot)(parseLabel))(function(path5) {
      return pure67(new ExprRecordAccessor({
        expr,
        dot,
        path: path5
      }));
    });
  });
};
var tokDoubleColon = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokDoubleColon) {
    return true;
  }
  ;
  return false;
});
var parseInstanceName = /* @__PURE__ */ function() {
  return apply23(map80(Tuple.create)(parseIdent))(tokDoubleColon);
}();
var tokEquals = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokEquals) {
    return true;
  }
  ;
  return false;
});
var tokForall = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokForall) {
    return true;
  }
  ;
  return false;
});
var tokKeyOperator = function(sym) {
  return expect(function(v) {
    if (v instanceof TokOperator && v.value0 instanceof Nothing) {
      return sym === v.value1;
    }
    ;
    return false;
  });
};
var parseBinderNegative = /* @__PURE__ */ bind51(/* @__PURE__ */ tokKeyOperator("-"))(function(negative) {
  return alt30(map80(uncurry(BinderInt.create(new Just(negative))))($$parseInt2))(map80(uncurry(BinderNumber.create(new Just(negative))))(parseNumber));
});
var parseRecordLabeled = function(valueParser) {
  var parseRecordField = apply23(map80(uncurry(RecordField.create))($$try9(apply23(map80(Tuple.create)(parseLabel))(tokKeyOperator(":")))))(valueParser);
  return alt30(parseRecordField)(map80(RecordPun.create)(parseIdent));
};
var parseTypeNegative = /* @__PURE__ */ bind51(/* @__PURE__ */ tokKeyOperator("-"))(function(negative) {
  return map80(uncurry(TypeInt.create(new Just(negative))))($$parseInt2);
});
var tokKeySymbol = function(sym) {
  return expect(function(v) {
    if (v instanceof TokSymbolName && v.value0 instanceof Nothing) {
      return sym === v.value1;
    }
    ;
    return false;
  });
};
var tokKeyword = function(kw) {
  return expect(function(v) {
    if (v instanceof TokLowerName && v.value0 instanceof Nothing) {
      return kw === v.value1;
    }
    ;
    return false;
  });
};
var parseFixityKeyword = /* @__PURE__ */ function() {
  return alt30(map80(flip(Tuple.create)(Infix.value))(tokKeyword("infix")))(alt30(map80(flip(Tuple.create)(Infixl.value))(tokKeyword("infixl")))(map80(flip(Tuple.create)(Infixr.value))(tokKeyword("infixr"))));
}();
var parseFixityOp = /* @__PURE__ */ function() {
  return alt30(apply23(apply23(apply23(map80(FixityType.create)(tokKeyword("type")))(parseQualifiedProper))(tokKeyword("as")))(parseOperator))(apply23(apply23(map80(FixityValue.create)(parseQualifiedIdentOrProper))(tokKeyword("as")))(parseOperator));
}();
var parseDeclFixity = /* @__PURE__ */ bind51(parseFixityKeyword)(function(keyword) {
  return bind51(parseSmallInt)(function(prec) {
    return bind51(parseFixityOp)(function(operator) {
      return pure67(new DeclFixity({
        keyword,
        prec,
        operator
      }));
    });
  });
});
var parseForeignKind = /* @__PURE__ */ function() {
  return $$try9(apply23(map80(ForeignKind.create)(tokKeyword("kind")))(parseProper));
}();
var parseRole = /* @__PURE__ */ function() {
  return alt30(map80(flip(Tuple.create)(Representational.value))(tokKeyword("representational")))(alt30(map80(flip(Tuple.create)(Nominal.value))(tokKeyword("nominal")))(map80(flip(Tuple.create)(Phantom.value))(tokKeyword("phantom"))));
}();
var parseDeclRole = function(keyword1) {
  return bind51(tokKeyword("role"))(function(keyword2) {
    return bind51(parseProper)(function(name4) {
      return bind51(many13(parseRole))(function(roles) {
        return pure67(new DeclRole(keyword1, keyword2, name4, roles));
      });
    });
  });
};
var tokLayoutEnd = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokLayoutEnd) {
    return true;
  }
  ;
  return false;
});
var tokLayoutSep = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokLayoutSep) {
    return true;
  }
  ;
  return false;
});
var parseInstanceChainSeparator = /* @__PURE__ */ applyFirst5(/* @__PURE__ */ tokKeyword("else"))(/* @__PURE__ */ optional9(tokLayoutSep));
var tokLayoutStart = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokLayoutStart) {
    return true;
  }
  ;
  return false;
});
var layoutNonEmpty = function(valueParser) {
  return apply23(map80(function(v) {
    return function(v1) {
      return cons$prime(v)(v1);
    };
  })(applySecond8(tokLayoutStart)(valueParser)))(applyFirst5(many7(applySecond8(tokLayoutSep)(valueParser)))(tokLayoutEnd));
};
var tokLeftArrow = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokLeftArrow) {
    return true;
  }
  ;
  return false;
});
var tokLeftBrace = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokLeftBrace) {
    return true;
  }
  ;
  return false;
});
var tokLeftFatArrow = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokOperator && v.value0 instanceof Nothing) {
    return v.value1 === "<=" || v.value1 === "\u21D0";
  }
  ;
  return false;
});
var tokLeftParen = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokLeftParen) {
    return true;
  }
  ;
  return false;
});
var tokLeftSquare = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokLeftSquare) {
    return true;
  }
  ;
  return false;
});
var tokPipe = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokPipe) {
    return true;
  }
  ;
  return false;
});
var tokQualifiedKeyword = function(kw) {
  return expect(function(v) {
    if (v instanceof TokLowerName) {
      return kw === v.value1;
    }
    ;
    return false;
  });
};
var tokRightArrow = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokRightArrow) {
    return true;
  }
  ;
  return false;
});
var parseFundep = /* @__PURE__ */ function() {
  return alt30(apply23(map80(FundepDetermined.create)(tokRightArrow))(many13(parseIdent)))(apply23(apply23(map80(FundepDetermines.create)(many13(parseIdent)))(tokRightArrow))(many13(parseIdent)));
}();
var tokRightBrace = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokRightBrace) {
    return true;
  }
  ;
  return false;
});
var tokRightFatArrow = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokRightFatArrow) {
    return true;
  }
  ;
  return false;
});
var tokRightParen = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokRightParen) {
    return true;
  }
  ;
  return false;
});
var parens2 = /* @__PURE__ */ wrapped(tokLeftParen)(tokRightParen);
var parseEmptyRow = function(open2) {
  return bind51(tokRightParen)(function(close2) {
    return pure67(new TypeRow({
      open: open2,
      value: {
        labels: Nothing.value,
        tail: Nothing.value
      },
      close: close2
    }));
  });
};
var tokRightSquare = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokRightSquare) {
    return true;
  }
  ;
  return false;
});
var tokSymbolArrow = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokSymbolArrow) {
    return true;
  }
  ;
  return false;
});
var tokTick = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokTick) {
    return true;
  }
  ;
  return false;
});
var tokUnderscore = /* @__PURE__ */ expect(function(v) {
  if (v instanceof TokUnderscore) {
    return true;
  }
  ;
  return false;
});
var delimited = function(openTok) {
  return function(closeTok) {
    return function(sepTok) {
      return function(valueParser) {
        var parseNonEmpty = function(open2) {
          return apply23(map80(function(v) {
            return function(v1) {
              return {
                open: open2,
                value: new Just(v),
                close: v1
              };
            };
          })(separated(sepTok)(valueParser)))(closeTok);
        };
        var parseEmpty = function(open2) {
          return map80(function(v) {
            return {
              open: open2,
              value: Nothing.value,
              close: v
            };
          })(closeTok);
        };
        return bind51(openTok)(function(open2) {
          return alt30(parseEmpty(open2))(parseNonEmpty(open2));
        });
      };
    };
  };
};
var parseDataMembers = /* @__PURE__ */ function() {
  return alt30(map80(DataAll.create)(tokKeySymbol("..")))(map80(DataEnumerated.create)(delimited(tokLeftParen)(tokRightParen)(tokComma)(parseProper)));
}();
var parseExport = /* @__PURE__ */ function() {
  return alt30(apply23(map80(ExportTypeOp.create)(tokKeyword("type")))(parseSymbol))(alt30(apply23(map80(ExportClass.create)(tokKeyword("class")))(parseProper))(alt30(apply23(map80(ExportModule.create)(tokKeyword("module")))(parseModuleName))(alt30(map80(ExportOp.create)(parseSymbol))(alt30(map80(ExportValue.create)(parseIdent))(apply23(map80(ExportType.create)(parseProper))(optional9(parseDataMembers)))))));
}();
var parseImport = /* @__PURE__ */ function() {
  return alt30(map80(ImportOp.create)(parseSymbol))(alt30(apply23(map80(ImportType.create)(parseProper))(optional9(parseDataMembers)))(alt30(apply23(map80(ImportTypeOp.create)(tokKeyword("type")))(parseSymbol))(alt30(apply23(map80(ImportClass.create)(tokKeyword("class")))(parseProper))(map80(ImportValue.create)(parseIdent)))));
}();
var parseImportDecl = /* @__PURE__ */ bind51(/* @__PURE__ */ tokKeyword("import"))(function(keyword) {
  return bind51(parseModuleName)(function(module_) {
    return bind51(optional9(apply23(map80(Tuple.create)(optional9(tokKeyword("hiding"))))(parens2(separated(tokComma)(parseImport)))))(function(names) {
      return bind51(optional9(apply23(map80(Tuple.create)(tokKeyword("as")))(parseModuleName)))(function(qualified) {
        return pure67({
          keyword,
          module: module_,
          names,
          qualified
        });
      });
    });
  });
});
var parseModuleImportDecls = /* @__PURE__ */ many7(/* @__PURE__ */ applyFirst5(parseImportDecl)(/* @__PURE__ */ alt30(tokLayoutSep)(/* @__PURE__ */ lookAhead2(tokLayoutEnd))));
var parseModuleHeader = /* @__PURE__ */ bind51(/* @__PURE__ */ tokKeyword("module"))(function(keyword) {
  return bind51(parseModuleName)(function(name4) {
    return bind51(optional9(parens2(separated(tokComma)(parseExport))))(function(exports) {
      return bind51(tokKeyword("where"))(function(where_) {
        return bind51(applySecond8(tokLayoutStart)(parseModuleImportDecls))(function(imports) {
          return pure67({
            keyword,
            name: name4,
            exports,
            where: where_,
            imports
          });
        });
      });
    });
  });
});
var braces = /* @__PURE__ */ wrapped(tokLeftBrace)(tokRightBrace);
var parseTypeParen = function(open2) {
  return bind51($lazy_parseType(507))(function(value4) {
    return bind51(tokRightParen)(function(close2) {
      return pure67(new TypeParens({
        open: open2,
        value: value4,
        close: close2
      }));
    });
  });
};
var parseRowTailParen = function(open2) {
  return bind51(apply23(map80(Tuple.create)(tokPipe))($lazy_parseType(477)))(function(tail3) {
    return bind51(tokRightParen)(function(close2) {
      return pure67(new TypeRow({
        open: open2,
        value: {
          labels: Nothing.value,
          tail: new Just(tail3)
        },
        close: close2
      }));
    });
  });
};
var parseRowParen = function(open2) {
  return bind51($$try9(apply23(map80(Tuple.create)(parseLabel))(tokDoubleColon)))(function(v) {
    return bind51($lazy_parseType(459))(function(value4) {
      return bind51(many7(apply23(map80(Tuple.create)(tokComma))($lazy_parseRowLabel(460))))(function(rest2) {
        return bind51(optional9(apply23(map80(Tuple.create)(tokPipe))($lazy_parseType(461))))(function(tail3) {
          return bind51(tokRightParen)(function(close2) {
            return pure67(new TypeRow({
              open: open2,
              value: {
                labels: new Just({
                  head: {
                    label: v.value0,
                    separator: v.value1,
                    value: value4
                  },
                  tail: rest2
                }),
                tail: tail3
              },
              close: close2
            }));
          });
        });
      });
    });
  });
};
var parseKindedVar = function(open2) {
  return bind51($$try9(apply23(map80(Tuple.create)(parens2(map80(TypeVar.create)(parseIdent))))(tokDoubleColon)))(function(v) {
    return bind51($lazy_parseType(497))(function(kind) {
      return bind51(tokRightParen)(function(close2) {
        return pure67(new TypeParens({
          open: open2,
          value: new TypeKinded(new TypeParens(v.value0), v.value1, kind),
          close: close2
        }));
      });
    });
  });
};
var $lazy_parseForall = /* @__PURE__ */ $runtime_lazy14("parseForall", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return apply23(apply23(apply23(map80(TypeForall.create)(tokForall))(many13($lazy_parseTypeVarBinding(528))))(tokDot))($lazy_parseType1(530));
  });
});
var $lazy_parseRow = /* @__PURE__ */ $runtime_lazy14("parseRow", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return bind51(optional9(separated(tokComma)($lazy_parseRowLabel(513))))(function(labels) {
      return bind51(optional9(apply23(map80(Tuple.create)(tokPipe))($lazy_parseType(514))))(function(tail3) {
        return pure67({
          labels,
          tail: tail3
        });
      });
    });
  });
});
var $lazy_parseRowLabel = /* @__PURE__ */ $runtime_lazy14("parseRowLabel", "PureScript.CST.Parser", function() {
  return bind51(parseLabel)(function(label) {
    return bind51(tokDoubleColon)(function(separator) {
      return bind51($lazy_parseType(521))(function(value4) {
        return pure67({
          label,
          separator,
          value: value4
        });
      });
    });
  });
});
var $lazy_parseType = /* @__PURE__ */ $runtime_lazy14("parseType", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return bind51($lazy_parseType1(393))(function(ty) {
      return alt30(apply23(map80(TypeKinded.create(ty))(tokDoubleColon))($lazy_parseType(394)))(pure67(ty));
    });
  });
});
var $lazy_parseType1 = /* @__PURE__ */ $runtime_lazy14("parseType1", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return alt30($lazy_parseForall(399))($lazy_parseType2(400));
  });
});
var $lazy_parseType2 = /* @__PURE__ */ $runtime_lazy14("parseType2", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return bind51($lazy_parseType3(404))(function(ty) {
      return alt30(apply23(map80(TypeArrow.create(ty))(tokRightArrow))($lazy_parseType1(405)))(alt30(apply23(map80(TypeConstrained.create(ty))(tokRightFatArrow))($lazy_parseType1(406)))(pure67(ty)));
    });
  });
});
var $lazy_parseType3 = /* @__PURE__ */ $runtime_lazy14("parseType3", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return bind51($lazy_parseType4(411))(function(ty) {
      return bind51(many7(apply23(map80(Tuple.create)(parseQualifiedOperator))($lazy_parseType4(412))))(function(ops) {
        return pure67(function() {
          var v1 = fromArray(ops);
          if (v1 instanceof Nothing) {
            return ty;
          }
          ;
          if (v1 instanceof Just) {
            return new TypeOp(ty, v1.value0);
          }
          ;
          throw new Error("Failed pattern match at PureScript.CST.Parser (line 413, column 8 - line 415, column 28): " + [v1.constructor.name]);
        }());
      });
    });
  });
});
var $lazy_parseType4 = /* @__PURE__ */ $runtime_lazy14("parseType4", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return alt30(parseTypeNegative)($lazy_parseType5(419));
  });
});
var $lazy_parseType5 = /* @__PURE__ */ $runtime_lazy14("parseType5", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return bind51($lazy_parseTypeAtom(423))(function(ty) {
      return bind51(many7($lazy_parseTypeAtom(424)))(function(args) {
        return pure67(function() {
          var v1 = fromArray(args);
          if (v1 instanceof Nothing) {
            return ty;
          }
          ;
          if (v1 instanceof Just) {
            return new TypeApp(ty, v1.value0);
          }
          ;
          throw new Error("Failed pattern match at PureScript.CST.Parser (line 425, column 8 - line 427, column 29): " + [v1.constructor.name]);
        }());
      });
    });
  });
});
var $lazy_parseTypeAtom = /* @__PURE__ */ $runtime_lazy14("parseTypeAtom", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return alt30(map80(TypeVar.create)(parseIdent))(alt30(map80(TypeConstructor.create)(parseQualifiedProper))(alt30(map80(uncurry(TypeString.create))(parseString))(alt30(map80(uncurry(TypeInt.create(Nothing.value)))($$parseInt2))(alt30($lazy_parseTypeParens(435))(alt30(map80(TypeRecord.create)(braces($lazy_parseRow(436))))(alt30(map80(TypeOpName.create)(parseQualifiedSymbol))(alt30(map80(TypeHole.create)(parseHole))(alt30(map80(TypeWildcard.create)(tokUnderscore))(map80(TypeArrowName.create)(tokSymbolArrow))))))))));
  });
});
var $lazy_parseTypeParens = /* @__PURE__ */ $runtime_lazy14("parseTypeParens", "PureScript.CST.Parser", function() {
  return bind51(tokLeftParen)(function(open2) {
    return alt30(parseRowParen(open2))(alt30(parseRowTailParen(open2))(alt30(parseKindedVar(open2))(alt30(parseTypeParen(open2))(parseEmptyRow(open2)))));
  });
});
var $lazy_parseTypeVarBinding = /* @__PURE__ */ $runtime_lazy14("parseTypeVarBinding", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return alt30($lazy_parseTypeVarKinded(534))(map80(TypeVarName.create)(parseIdent));
  });
});
var $lazy_parseTypeVarKinded = /* @__PURE__ */ $runtime_lazy14("parseTypeVarKinded", "PureScript.CST.Parser", function() {
  return map80(TypeVarKinded.create)(parens2(bind51(parseIdent)(function(label) {
    return bind51(tokDoubleColon)(function(separator) {
      return bind51($lazy_parseType(541))(function(value4) {
        return pure67({
          label,
          separator,
          value: value4
        });
      });
    });
  })));
});
var parseType = /* @__PURE__ */ $lazy_parseType(391);
var parseType3 = /* @__PURE__ */ $lazy_parseType3(409);
var parseType5 = /* @__PURE__ */ $lazy_parseType5(421);
var parseTypeAtom = /* @__PURE__ */ $lazy_parseTypeAtom(429);
var parseTypeVarBinding = /* @__PURE__ */ $lazy_parseTypeVarBinding(532);
var parseDataCtor = /* @__PURE__ */ apply23(/* @__PURE__ */ map80(function(v) {
  return function(v1) {
    return {
      name: v,
      fields: v1
    };
  };
})(parseProper))(/* @__PURE__ */ many7(parseTypeAtom));
var $lazy_parseBinder = /* @__PURE__ */ $runtime_lazy14("parseBinder", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return bind51($lazy_parseBinder1(811))(function(binder) {
      return alt30(apply23(map80(BinderTyped.create(binder))(tokDoubleColon))(parseType))(pure67(binder));
    });
  });
});
var $lazy_parseBinder1 = /* @__PURE__ */ $runtime_lazy14("parseBinder1", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return bind51($lazy_parseBinder2(817))(function(binder) {
      return bind51(many7(apply23(map80(Tuple.create)(parseQualifiedOperator))($lazy_parseBinder2(818))))(function(ops) {
        return pure67(function() {
          var v1 = fromArray(ops);
          if (v1 instanceof Nothing) {
            return binder;
          }
          ;
          if (v1 instanceof Just) {
            return new BinderOp(binder, v1.value0);
          }
          ;
          throw new Error("Failed pattern match at PureScript.CST.Parser (line 819, column 8 - line 821, column 34): " + [v1.constructor.name]);
        }());
      });
    });
  });
});
var $lazy_parseBinder2 = /* @__PURE__ */ $runtime_lazy14("parseBinder2", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return alt30(parseBinderNegative)(alt30($lazy_parseBinderConstructor(826))($lazy_parseBinderAtom(827)));
  });
});
var $lazy_parseBinderAtom = /* @__PURE__ */ $runtime_lazy14("parseBinderAtom", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return alt30($lazy_parseIdentBinder(843))(alt30(map80(flip(BinderConstructor.create)([]))(parseQualifiedProper))(alt30(map80(BinderWildcard.create)(tokUnderscore))(alt30(map80(uncurry(BinderString.create))(parseString))(alt30(map80(uncurry(BinderChar.create))(parseChar))(alt30(map80(uncurry(BinderBoolean.create))(parseBoolean))(alt30(map80(uncurry(BinderInt.create(Nothing.value)))($$parseInt2))(alt30(map80(uncurry(BinderNumber.create(Nothing.value)))(parseNumber))(alt30(map80(BinderArray.create)(delimited(tokLeftSquare)(tokRightSquare)(tokComma)($lazy_parseBinder(851))))(alt30(map80(BinderRecord.create)(delimited(tokLeftBrace)(tokRightBrace)(tokComma)(parseRecordLabeled($lazy_parseBinder(852)))))(map80(BinderParens.create)(parens2($lazy_parseBinder(853)))))))))))));
  });
});
var $lazy_parseBinderConstructor = /* @__PURE__ */ $runtime_lazy14("parseBinderConstructor", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return bind51(parseQualifiedProper)(function(name4) {
      return bind51(many7($lazy_parseBinderAtom(838)))(function(apps) {
        return pure67(new BinderConstructor(name4, apps));
      });
    });
  });
});
var $lazy_parseIdentBinder = /* @__PURE__ */ $runtime_lazy14("parseIdentBinder", "PureScript.CST.Parser", function() {
  return bind51(parseIdent)(function(ident) {
    return alt30(apply23(map80(BinderNamed.create(ident))(tokAt))($lazy_parseBinderAtom(858)))(pure67(new BinderVar(ident)));
  });
});
var parseBinder = /* @__PURE__ */ $lazy_parseBinder(809);
var parseBinder1 = /* @__PURE__ */ $lazy_parseBinder1(815);
var parseBinderAtom = /* @__PURE__ */ $lazy_parseBinderAtom(841);
var parseClassConstraints = function(parseOneConstraint) {
  return alt30(map80(Many.create)(parens2(separated(tokComma)(parseType))))(map80(One.create)(parseOneConstraint));
};
var parseDeclDerive = /* @__PURE__ */ bind51(/* @__PURE__ */ tokKeyword("derive"))(function(derive_) {
  return bind51(optional9(tokKeyword("newtype")))(function(newtype_) {
    return bind51(tokKeyword("instance"))(function(keyword) {
      return bind51(optional9(parseInstanceName))(function(name4) {
        return bind51(optional9($$try9(apply23(map80(Tuple.create)(parseClassConstraints(parseType3)))(tokRightFatArrow))))(function(constraints) {
          return bind51(parseQualifiedProper)(function(className) {
            return bind51(many7(parseTypeAtom))(function(types) {
              return pure67(new DeclDerive(derive_, newtype_, {
                keyword,
                name: name4,
                constraints,
                className,
                types
              }));
            });
          });
        });
      });
    });
  });
});
var parseClassMember = /* @__PURE__ */ bind51(parseIdent)(function(label) {
  return bind51(tokDoubleColon)(function(separator) {
    return bind51(parseType)(function(value4) {
      return pure67({
        label,
        separator,
        value: value4
      });
    });
  });
});
var parseDeclClassSignature = function(keyword) {
  return bind51($$try9(apply23(map80(Tuple.create)(parseProper))(tokDoubleColon)))(function(v) {
    return bind51(parseType)(function(value4) {
      return pure67(new DeclKindSignature(keyword, {
        label: v.value0,
        separator: v.value1,
        value: value4
      }));
    });
  });
};
var parseDeclKindSignature = function(keyword) {
  return function(label) {
    return bind51(tokDoubleColon)(function(separator) {
      return bind51(parseType)(function(value4) {
        return pure67(new DeclKindSignature(keyword, {
          label,
          separator,
          value: value4
        }));
      });
    });
  };
};
var parseDeclSignature = function(label) {
  return bind51(tokDoubleColon)(function(separator) {
    return bind51(parseType)(function(value4) {
      return pure67(new DeclSignature({
        label,
        separator,
        value: value4
      }));
    });
  });
};
var parseForeignData = /* @__PURE__ */ bind51(/* @__PURE__ */ tokKeyword("data"))(function(keyword) {
  return bind51(parseProper)(function(label) {
    return bind51(tokDoubleColon)(function(separator) {
      return bind51(parseType)(function(value4) {
        return pure67(new ForeignData(keyword, {
          label,
          separator,
          value: value4
        }));
      });
    });
  });
});
var parseForeignValue = /* @__PURE__ */ bind51(parseIdent)(function(label) {
  return bind51(tokDoubleColon)(function(separator) {
    return bind51(parseType)(function(value4) {
      return pure67(new ForeignValue({
        label,
        separator,
        value: value4
      }));
    });
  });
});
var parseDeclForeign = /* @__PURE__ */ bind51(/* @__PURE__ */ tokKeyword("foreign"))(function(keyword1) {
  return bind51(tokKeyword("import"))(function(keyword2) {
    return bind51(alt30(parseForeignData)(alt30(parseForeignKind)(parseForeignValue)))(function(foreign_) {
      return pure67(new DeclForeign(keyword1, keyword2, foreign_));
    });
  });
});
var parseInstanceBindingSignature = function(label) {
  return bind51(tokDoubleColon)(function(separator) {
    return bind51(parseType)(function(value4) {
      return pure67(new InstanceBindingSignature({
        label,
        separator,
        value: value4
      }));
    });
  });
};
var parseLetBindingSignature = function(label) {
  return bind51(tokDoubleColon)(function(separator) {
    return bind51(parseType)(function(value4) {
      return pure67(new LetBindingSignature({
        label,
        separator,
        value: value4
      }));
    });
  });
};
var parseRecordUpdates = function(expr) {
  return bind51($$try9(applyFirst5(tokLeftBrace)(lookAhead2(applySecond8(parseLabel)(alt30(tokEquals)(tokLeftBrace))))))(function(open2) {
    return bind51(separated(tokComma)($lazy_parseRecordUpdate(695)))(function(value4) {
      return bind51(tokRightBrace)(function(close2) {
        return pure67(new ExprRecordUpdate(expr, {
          open: open2,
          value: value4,
          close: close2
        }));
      });
    });
  });
};
var parseRecordUpdateLeaf = function(label) {
  return apply23(map80(RecordUpdateLeaf.create(label))(tokEquals))($lazy_parseExpr(709));
};
var parseRecordUpdateBranch = function(label) {
  return map80(RecordUpdateBranch.create(label))(braces(separated(tokComma)($lazy_parseRecordUpdate(714))));
};
var parseLetBindingName = function(name4) {
  return bind51(many7(parseBinderAtom))(function(binders) {
    return bind51(parseGuarded(tokEquals))(function(guarded) {
      return pure67(new LetBindingName({
        name: name4,
        binders,
        guarded
      }));
    });
  });
};
var parseGuarded = function(sepParser) {
  var parsePatternGuard = apply23(map80(function(v) {
    return function(v1) {
      return {
        binder: v,
        expr: v1
      };
    };
  })(optional9($$try9(apply23(map80(Tuple.create)(parseBinder))(tokLeftArrow)))))($lazy_parseExpr(800));
  var parseGuardedExpr = apply23(apply23(apply23(map80(function(v) {
    return function(v1) {
      return function(v2) {
        return function(v3) {
          return {
            bar: v,
            patterns: v1,
            separator: v2,
            where: v3
          };
        };
      };
    };
  })(tokPipe))(separated(tokComma)(parsePatternGuard)))(sepParser))($lazy_parseWhere(794));
  return alt30(apply23(map80(Unconditional.create)(sepParser))($lazy_parseWhere(786)))(map80(Guarded.create)(many13(parseGuardedExpr)));
};
var parseBadSingleCaseWhere = function(binder) {
  return bind51(tokRightArrow)(function(arrow) {
    return bind51(applySecond8(tokLayoutEnd)($lazy_parseWhere(651)))(function(body) {
      return pure67(singleton4(new Tuple({
        head: binder,
        tail: []
      }, new Unconditional(arrow, body))));
    });
  });
};
var parseBadSingleCaseGuarded = function(binder) {
  return bind51(applySecond8(tokLayoutEnd)(parseGuarded(tokRightArrow)))(function(body) {
    return pure67(singleton4(new Tuple({
      head: binder,
      tail: []
    }, body)));
  });
};
var $lazy_parseAdo = /* @__PURE__ */ $runtime_lazy14("parseAdo", "PureScript.CST.Parser", function() {
  return bind51(tokQualifiedKeyword("ado"))(function(keyword) {
    return bind51(function() {
      var valueParser = recoverDoStatement($lazy_parseDoStatement(676));
      var nonEmptyCase = apply23(map80(cons)(valueParser))(many7(applySecond8(tokLayoutSep)(valueParser)));
      return bind51(tokLayoutStart)(function() {
        return alt30(voidRight8([])(tokLayoutEnd))(applyFirst5(nonEmptyCase)(tokLayoutEnd));
      });
    }())(function(statements) {
      return bind51(tokKeyword("in"))(function(in_) {
        return bind51($lazy_parseExpr(683))(function(result) {
          return pure67(new ExprAdo({
            keyword,
            statements,
            "in": in_,
            result
          }));
        });
      });
    });
  });
});
var $lazy_parseBadSingleCaseBranch = /* @__PURE__ */ $runtime_lazy14("parseBadSingleCaseBranch", "PureScript.CST.Parser", function() {
  return bind51(applySecond8(tokLayoutStart)(parseBinder1))(function(binder) {
    return alt30(parseBadSingleCaseWhere(binder))(parseBadSingleCaseGuarded(binder));
  });
});
var $lazy_parseCase = /* @__PURE__ */ $runtime_lazy14("parseCase", "PureScript.CST.Parser", function() {
  return bind51(tokKeyword("case"))(function(keyword) {
    return bind51(separated(tokComma)($lazy_parseExpr(633)))(function(head6) {
      return bind51(tokKeyword("of"))(function(of_) {
        return bind51(alt30($$try9($lazy_parseBadSingleCaseBranch(635)))($lazy_parseCaseBranches(635)))(function(branches) {
          return pure67(new ExprCase({
            keyword,
            head: head6,
            of: of_,
            branches
          }));
        });
      });
    });
  });
});
var $lazy_parseCaseBranches = /* @__PURE__ */ $runtime_lazy14("parseCaseBranches", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return layoutNonEmpty(apply23(map80(Tuple.create)(separated(tokComma)(parseBinder1)))(parseGuarded(tokRightArrow)));
  });
});
var $lazy_parseDo = /* @__PURE__ */ $runtime_lazy14("parseDo", "PureScript.CST.Parser", function() {
  return bind51(tokQualifiedKeyword("do"))(function(keyword) {
    return bind51(layoutNonEmpty(recoverDoStatement($lazy_parseDoStatement(662))))(function(statements) {
      return pure67(new ExprDo({
        keyword,
        statements
      }));
    });
  });
});
var $lazy_parseDoStatement = /* @__PURE__ */ $runtime_lazy14("parseDoStatement", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return alt30(apply23(map80(DoLet.create)(tokKeyword("let")))(layoutNonEmpty(recoverLetBinding($lazy_parseLetBinding(757)))))(alt30(apply23(map80(uncurry(DoBind.create))($$try9(apply23(map80(Tuple.create)(parseBinder))(tokLeftArrow))))($lazy_parseExpr(758)))(map80(DoDiscard.create)($lazy_parseExpr(759))));
  });
});
var $lazy_parseExpr = /* @__PURE__ */ $runtime_lazy14("parseExpr", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return bind51($lazy_parseExpr1(546))(function(expr) {
      return alt30(apply23(map80(ExprTyped.create(expr))(tokDoubleColon))(parseType))(pure67(expr));
    });
  });
});
var $lazy_parseExpr1 = /* @__PURE__ */ $runtime_lazy14("parseExpr1", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return bind51($lazy_parseExpr2(552))(function(expr) {
      return bind51(many7(apply23(map80(Tuple.create)(parseQualifiedOperator))($lazy_parseExpr2(553))))(function(ops) {
        return pure67(function() {
          var v1 = fromArray(ops);
          if (v1 instanceof Nothing) {
            return expr;
          }
          ;
          if (v1 instanceof Just) {
            return new ExprOp(expr, v1.value0);
          }
          ;
          throw new Error("Failed pattern match at PureScript.CST.Parser (line 554, column 8 - line 556, column 30): " + [v1.constructor.name]);
        }());
      });
    });
  });
});
var $lazy_parseExpr2 = /* @__PURE__ */ $runtime_lazy14("parseExpr2", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return bind51($lazy_parseExpr3(560))(function(expr) {
      return bind51(many7(apply23(map80(Tuple.create)($lazy_parseTickExpr(561)))($lazy_parseExpr3(561))))(function(ops) {
        return pure67(function() {
          var v1 = fromArray(ops);
          if (v1 instanceof Nothing) {
            return expr;
          }
          ;
          if (v1 instanceof Just) {
            return new ExprInfix(expr, v1.value0);
          }
          ;
          throw new Error("Failed pattern match at PureScript.CST.Parser (line 562, column 8 - line 564, column 33): " + [v1.constructor.name]);
        }());
      });
    });
  });
});
var $lazy_parseExpr3 = /* @__PURE__ */ $runtime_lazy14("parseExpr3", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return alt30(apply23(map80(ExprNegate.create)(tokKeyOperator("-")))($lazy_parseExpr3(583)))($lazy_parseExpr4(584));
  });
});
var $lazy_parseExpr4 = /* @__PURE__ */ $runtime_lazy14("parseExpr4", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return bind51($lazy_parseExpr5(588))(function(expr) {
      return bind51(many7($lazy_parseExpr5(589)))(function(args) {
        return pure67(function() {
          var v1 = fromArray(args);
          if (v1 instanceof Nothing) {
            return expr;
          }
          ;
          if (v1 instanceof Just) {
            return new ExprApp(expr, v1.value0);
          }
          ;
          throw new Error("Failed pattern match at PureScript.CST.Parser (line 590, column 8 - line 592, column 31): " + [v1.constructor.name]);
        }());
      });
    });
  });
});
var $lazy_parseExpr5 = /* @__PURE__ */ $runtime_lazy14("parseExpr5", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return alt30($lazy_parseIf(596))(alt30($lazy_parseLetIn(597))(alt30($lazy_parseLambda(598))(alt30($lazy_parseCase(599))(alt30($lazy_parseDo(600))(alt30($lazy_parseAdo(601))($lazy_parseExpr6(602)))))));
  });
});
var $lazy_parseExpr6 = /* @__PURE__ */ $runtime_lazy14("parseExpr6", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return bind51($lazy_parseExpr7(688))(function(expr) {
      return alt30(parseRecordUpdates(expr))(pure67(expr));
    });
  });
});
var $lazy_parseExpr7 = /* @__PURE__ */ $runtime_lazy14("parseExpr7", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return bind51($lazy_parseExprAtom(718))(function(expr) {
      return alt30(parseRecordAccessor(expr))(pure67(expr));
    });
  });
});
var $lazy_parseExprAtom = /* @__PURE__ */ $runtime_lazy14("parseExprAtom", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return alt30(map80(ExprIdent.create)(parseQualifiedIdent))(alt30(map80(ExprConstructor.create)(parseQualifiedProper))(alt30(map80(ExprOpName.create)(parseQualifiedSymbol))(alt30(map80(ExprSection.create)(tokUnderscore))(alt30(map80(ExprHole.create)(parseHole))(alt30(map80(uncurry(ExprString.create))(parseString))(alt30(map80(uncurry(ExprChar.create))(parseChar))(alt30(map80(uncurry(ExprBoolean.create))(parseBoolean))(alt30(map80(uncurry(ExprInt.create))($$parseInt2))(alt30(map80(uncurry(ExprNumber.create))(parseNumber))(alt30(map80(ExprArray.create)(delimited(tokLeftSquare)(tokRightSquare)(tokComma)($lazy_parseExpr(740))))(alt30(map80(ExprRecord.create)(delimited(tokLeftBrace)(tokRightBrace)(tokComma)(parseRecordLabeled($lazy_parseExpr(741)))))(map80(ExprParens.create)(parens2($lazy_parseExpr(742)))))))))))))));
  });
});
var $lazy_parseIdentBinding = /* @__PURE__ */ $runtime_lazy14("parseIdentBinding", "PureScript.CST.Parser", function() {
  return bind51(parseIdent)(function(ident) {
    return alt30(parseLetBindingSignature(ident))(parseLetBindingName(ident));
  });
});
var $lazy_parseIf = /* @__PURE__ */ $runtime_lazy14("parseIf", "PureScript.CST.Parser", function() {
  return bind51(tokKeyword("if"))(function(keyword) {
    return bind51($lazy_parseExpr(607))(function(cond) {
      return bind51(tokKeyword("then"))(function(then_) {
        return bind51($lazy_parseExpr(609))(function(true_) {
          return bind51(tokKeyword("else"))(function(else_) {
            return bind51($lazy_parseExpr(611))(function(false_) {
              return pure67(new ExprIf({
                keyword,
                cond,
                then: then_,
                "true": true_,
                "else": else_,
                "false": false_
              }));
            });
          });
        });
      });
    });
  });
});
var $lazy_parseLambda = /* @__PURE__ */ $runtime_lazy14("parseLambda", "PureScript.CST.Parser", function() {
  return bind51(tokBackslash)(function(symbol) {
    return bind51(many13(parseBinderAtom))(function(binders) {
      return bind51(tokRightArrow)(function(arrow) {
        return bind51($lazy_parseExpr(627))(function(body) {
          return pure67(new ExprLambda({
            symbol,
            binders,
            arrow,
            body
          }));
        });
      });
    });
  });
});
var $lazy_parseLetBinding = /* @__PURE__ */ $runtime_lazy14("parseLetBinding", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return alt30($$try9($lazy_parseIdentBinding(763)))(apply23(apply23(map80(LetBindingPattern.create)(parseBinder1))(tokEquals))($lazy_parseWhere(764)));
  });
});
var $lazy_parseLetIn = /* @__PURE__ */ $runtime_lazy14("parseLetIn", "PureScript.CST.Parser", function() {
  return bind51(tokKeyword("let"))(function(keyword) {
    return bind51(layoutNonEmpty(recoverLetBinding($lazy_parseLetBinding(617))))(function(bindings) {
      return bind51(tokKeyword("in"))(function(in_) {
        return bind51($lazy_parseExpr(619))(function(body) {
          return pure67(new ExprLet({
            keyword,
            bindings,
            "in": in_,
            body
          }));
        });
      });
    });
  });
});
var $lazy_parseRecordUpdate = /* @__PURE__ */ $runtime_lazy14("parseRecordUpdate", "PureScript.CST.Parser", function() {
  return bind51(parseLabel)(function(label) {
    return alt30(parseRecordUpdateLeaf(label))(parseRecordUpdateBranch(label));
  });
});
var $lazy_parseTickExpr = /* @__PURE__ */ $runtime_lazy14("parseTickExpr", "PureScript.CST.Parser", function() {
  return bind51(tokTick)(function(open2) {
    return bind51($lazy_parseTickExpr1(569))(function(value4) {
      return bind51(tokTick)(function(close2) {
        return pure67({
          open: open2,
          value: value4,
          close: close2
        });
      });
    });
  });
});
var $lazy_parseTickExpr1 = /* @__PURE__ */ $runtime_lazy14("parseTickExpr1", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return bind51($lazy_parseExpr3(575))(function(expr) {
      return bind51(many7(apply23(map80(Tuple.create)(parseQualifiedOperator))($lazy_parseExpr3(576))))(function(ops) {
        return pure67(function() {
          var v1 = fromArray(ops);
          if (v1 instanceof Nothing) {
            return expr;
          }
          ;
          if (v1 instanceof Just) {
            return new ExprOp(expr, v1.value0);
          }
          ;
          throw new Error("Failed pattern match at PureScript.CST.Parser (line 577, column 8 - line 579, column 30): " + [v1.constructor.name]);
        }());
      });
    });
  });
});
var $lazy_parseWhere = /* @__PURE__ */ $runtime_lazy14("parseWhere", "PureScript.CST.Parser", function() {
  return defer5(function(v) {
    return bind51($lazy_parseExpr(805))(function(expr) {
      return bind51(optional9(apply23(map80(Tuple.create)(tokKeyword("where")))(layoutNonEmpty(recoverLetBinding($lazy_parseLetBinding(806))))))(function(bindings) {
        return pure67({
          expr,
          bindings
        });
      });
    });
  });
});
var parseDeclValue1 = function(name4) {
  return bind51(many7(parseBinderAtom))(function(binders) {
    return bind51(parseGuarded(tokEquals))(function(guarded) {
      return pure67(new DeclValue({
        name: name4,
        binders,
        guarded
      }));
    });
  });
};
var parseDeclValue = /* @__PURE__ */ bind51(parseIdent)(function(ident) {
  return alt30(parseDeclSignature(ident))(parseDeclValue1(ident));
});
var parseInstanceBindingName = function(name4) {
  return bind51(many7(parseBinderAtom))(function(binders) {
    return bind51(parseGuarded(tokEquals))(function(guarded) {
      return pure67(new InstanceBindingName({
        name: name4,
        binders,
        guarded
      }));
    });
  });
};
var parseInstanceBinding = /* @__PURE__ */ bind51(parseIdent)(function(ident) {
  return alt30(parseInstanceBindingSignature(ident))(parseInstanceBindingName(ident));
});
var parseInstance = /* @__PURE__ */ bind51(/* @__PURE__ */ tokKeyword("instance"))(function(keyword) {
  return bind51(optional9(parseInstanceName))(function(name4) {
    return bind51(optional9($$try9(apply23(map80(Tuple.create)(parseClassConstraints(parseType3)))(tokRightFatArrow))))(function(constraints) {
      return bind51(parseQualifiedProper)(function(className) {
        return bind51(many7(parseTypeAtom))(function(types) {
          return bind51(optional9(apply23(map80(Tuple.create)(tokKeyword("where")))(layoutNonEmpty(parseInstanceBinding))))(function(body) {
            return pure67({
              head: {
                keyword,
                name: name4,
                constraints,
                className,
                types
              },
              body
            });
          });
        });
      });
    });
  });
});
var parseDeclInstanceChain = /* @__PURE__ */ function() {
  return map80(DeclInstanceChain.create)(separated(parseInstanceChainSeparator)(parseInstance));
}();
var parseDeclClass1 = function(keyword) {
  return bind51(optional9($$try9(apply23(map80(Tuple.create)(parseClassConstraints(parseType5)))(tokLeftFatArrow))))(function($$super) {
    return bind51(parseProper)(function(name4) {
      return bind51(many7(parseTypeVarBinding))(function(vars) {
        return bind51(optional9(apply23(map80(Tuple.create)(tokPipe))(separated(tokComma)(parseFundep))))(function(fundeps) {
          return bind51(optional9(apply23(map80(Tuple.create)(tokKeyword("where")))(layoutNonEmpty(parseClassMember))))(function(members) {
            return pure67(new DeclClass({
              keyword,
              "super": $$super,
              name: name4,
              vars,
              fundeps
            }, members));
          });
        });
      });
    });
  });
};
var parseDeclClass = /* @__PURE__ */ bind51(/* @__PURE__ */ tokKeyword("class"))(function(keyword) {
  return alt30(parseDeclClassSignature(keyword))(parseDeclClass1(keyword));
});
var parseDeclData1 = function(keyword) {
  return function(name4) {
    return bind51(many7(parseTypeVarBinding))(function(vars) {
      return bind51(optional9(apply23(map80(Tuple.create)(tokEquals))(separated(tokPipe)(parseDataCtor))))(function(ctors) {
        return pure67(new DeclData({
          keyword,
          name: name4,
          vars
        }, ctors));
      });
    });
  };
};
var parseDeclData = /* @__PURE__ */ bind51(/* @__PURE__ */ tokKeyword("data"))(function(keyword) {
  return bind51(parseProper)(function(name4) {
    return alt30(parseDeclKindSignature(keyword)(name4))(parseDeclData1(keyword)(name4));
  });
});
var parseDeclNewtype1 = function(keyword) {
  return function(name4) {
    return bind51(many7(parseTypeVarBinding))(function(vars) {
      return bind51(tokEquals)(function(tok) {
        return bind51(parseProper)(function(wrapper) {
          return bind51(parseTypeAtom)(function(body) {
            return pure67(new DeclNewtype({
              keyword,
              name: name4,
              vars
            }, tok, wrapper, body));
          });
        });
      });
    });
  };
};
var parseDeclNewtype = /* @__PURE__ */ bind51(/* @__PURE__ */ tokKeyword("newtype"))(function(keyword) {
  return bind51(parseProper)(function(name4) {
    return alt30(parseDeclKindSignature(keyword)(name4))(parseDeclNewtype1(keyword)(name4));
  });
});
var parseDeclType2 = function(keyword) {
  return function(name4) {
    return bind51(many7(parseTypeVarBinding))(function(vars) {
      return bind51(tokEquals)(function(tok) {
        return bind51(parseType)(function(body) {
          return pure67(new DeclType({
            keyword,
            name: name4,
            vars
          }, tok, body));
        });
      });
    });
  };
};
var parseDeclType1 = function(keyword) {
  return bind51(parseProper)(function(name4) {
    return alt30(parseDeclKindSignature(keyword)(name4))(parseDeclType2(keyword)(name4));
  });
};
var parseDeclType = /* @__PURE__ */ bind51(/* @__PURE__ */ tokKeyword("type"))(function(keyword) {
  return alt30(parseDeclRole(keyword))(parseDeclType1(keyword));
});
var parseDecl = /* @__PURE__ */ alt30(parseDeclData)(/* @__PURE__ */ alt30(parseDeclNewtype)(/* @__PURE__ */ alt30(parseDeclType)(/* @__PURE__ */ alt30(parseDeclClass)(/* @__PURE__ */ alt30(parseDeclInstanceChain)(/* @__PURE__ */ alt30(parseDeclDerive)(/* @__PURE__ */ alt30(parseDeclValue)(/* @__PURE__ */ alt30(parseDeclForeign)(parseDeclFixity))))))));
var parseModuleDecls = /* @__PURE__ */ many7(/* @__PURE__ */ applyFirst5(/* @__PURE__ */ recoverDecl(parseDecl))(/* @__PURE__ */ alt30(tokLayoutSep)(/* @__PURE__ */ lookAhead2(tokLayoutEnd))));
var parseModuleBody = /* @__PURE__ */ bind51(/* @__PURE__ */ applyFirst5(parseModuleDecls)(tokLayoutEnd))(function(decls) {
  return bind51(eof2)(function(v) {
    return pure67({
      decls,
      trailingComments: v.value1,
      end: v.value0
    });
  });
});

// output/PureScript.CST/index.js
var bind52 = /* @__PURE__ */ bind(bindParser);
var pure68 = /* @__PURE__ */ pure(applicativeParser);
var ParseSucceeded = /* @__PURE__ */ function() {
  function ParseSucceeded2(value0) {
    this.value0 = value0;
  }
  ;
  ParseSucceeded2.create = function(value0) {
    return new ParseSucceeded2(value0);
  };
  return ParseSucceeded2;
}();
var ParseSucceededWithErrors = /* @__PURE__ */ function() {
  function ParseSucceededWithErrors2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  ParseSucceededWithErrors2.create = function(value0) {
    return function(value12) {
      return new ParseSucceededWithErrors2(value0, value12);
    };
  };
  return ParseSucceededWithErrors2;
}();
var ParseFailed = /* @__PURE__ */ function() {
  function ParseFailed2(value0) {
    this.value0 = value0;
  }
  ;
  ParseFailed2.create = function(value0) {
    return new ParseFailed2(value0);
  };
  return ParseFailed2;
}();
var toRecoveredParserResult = function(v) {
  var v1 = function(v2) {
    if (v instanceof Right && otherwise) {
      return new ParseSucceeded(v.value0.value0);
    }
    ;
    if (v instanceof Left) {
      return new ParseFailed(v.value0);
    }
    ;
    throw new Error("Failed pattern match at PureScript.CST (line 41, column 1 - line 44, column 29): " + [v.constructor.name]);
  };
  if (v instanceof Right) {
    var $21 = fromArray(v.value0.value1);
    if ($21 instanceof Just) {
      return new ParseSucceededWithErrors(v.value0.value0, $21.value0);
    }
    ;
    return v1(true);
  }
  ;
  return v1(true);
};
var parsePartialModule = function(src) {
  return toRecoveredParserResult(function() {
    var v = runParser$prime(initialParserState(lex(src)))(parseModuleHeader);
    if (v instanceof ParseSucc) {
      var res = {
        header: v.value0,
        full: defer2(function(v1) {
          return toRecoveredParserResult(fromParserResult(runParser$prime(v.value1)(bind52(parseModuleBody)(function(body) {
            return pure68({
              header: v.value0,
              body
            });
          }))));
        })
      };
      return new Right(new Tuple(res, v.value1.errors));
    }
    ;
    if (v instanceof ParseFail) {
      return new Left(v.value0);
    }
    ;
    throw new Error("Failed pattern match at PureScript.CST (line 85, column 29 - line 97, column 17): " + [v.constructor.name]);
  }());
};

// output/Registry.Operation.Validation/index.js
var lookup13 = /* @__PURE__ */ lookup3(ordVersion);
var eq211 = /* @__PURE__ */ eq(eqLocation);
var notElem3 = /* @__PURE__ */ notElem2(eqString);
var bind53 = /* @__PURE__ */ bind(bindAff);
var pure69 = /* @__PURE__ */ pure(applicativeAff);
var traverse11 = /* @__PURE__ */ traverse(traversableNonEmptyArray);
var foldMap19 = /* @__PURE__ */ foldMap2(monoidString);
var locationMatches = function(v) {
  return function(v1) {
    return eq211(v.location)(v1.location);
  };
};
var isNotUnpublished = function(v) {
  return function(v1) {
    return lookup13(v.version)(v1.unpublished);
  };
};
var isNotPublished = function(v) {
  return function(v1) {
    return lookup13(v.version)(v1.published);
  };
};
var isMetadataPackage = function(v) {
  return print2(v.name) === "metadata";
};
var forbiddenModules = ["Main", "Test.Main"];
var validatePursModule = function(moduleString) {
  var verifyHeader = function(v2) {
    var $93 = notElem3(v2.name.name)(forbiddenModules);
    if ($93) {
      return new Right(unit);
    }
    ;
    return new Left("Module name is " + (v2.name.name + (" but PureScript libraries cannot publish modules named: " + joinWith(", ")(forbiddenModules))));
  };
  var v = parsePartialModule(moduleString);
  if (v instanceof ParseFailed) {
    return new Left("Failed to parse PureScript module: " + printParseError(v.value0.error));
  }
  ;
  if (v instanceof ParseSucceededWithErrors) {
    return verifyHeader(v.value0.header);
  }
  ;
  if (v instanceof ParseSucceeded) {
    return verifyHeader(v.value0.header);
  }
  ;
  throw new Error("Failed pattern match at Registry.Operation.Validation (line 192, column 35 - line 198, column 24): " + [v.constructor.name]);
};
var validatePursModules = function(dictMonadAff) {
  var liftAff10 = liftAff(dictMonadAff);
  var Monad0 = dictMonadAff.MonadEffect0().Monad0();
  var bind122 = bind(Monad0.Bind1());
  var Applicative0 = Monad0.Applicative0();
  var traverse12 = traverse11(Applicative0);
  var pure122 = pure(Applicative0);
  return function(files) {
    var convertErrors = function() {
      var $124 = concatMap(function(v) {
        if (v.value1 instanceof Left) {
          return [new Tuple(v.value0, v.value1.value0)];
        }
        ;
        if (v.value1 instanceof Right) {
          return [];
        }
        ;
        throw new Error("Failed pattern match at Registry.Operation.Validation (line 170, column 53 - line 172, column 30): " + [v.constructor.name]);
      });
      return function($125) {
        return $124(toArray($125));
      };
    }();
    var acceptedPursModule = function(path5) {
      return liftAff10(bind53(attempt(readTextFile2(UTF8.value)(path5)))(function(eitherModule) {
        return pure69(new Tuple(path5, function() {
          if (eitherModule instanceof Left) {
            return new Left("Could not read PureScript module from disk at path " + (path5 + (": " + message(eitherModule.value0))));
          }
          ;
          if (eitherModule instanceof Right) {
            return validatePursModule(eitherModule.value0);
          }
          ;
          throw new Error("Failed pattern match at Registry.Operation.Validation (line 165, column 27 - line 167, column 62): " + [eitherModule.constructor.name]);
        }()));
      }));
    };
    return bind122(traverse12(acceptedPursModule)(files))(function(results) {
      var v = convertErrors(results);
      if (v.length === 0) {
        return pure122(new Right(unit));
      }
      ;
      return pure122(new Left(foldMap19(function(v1) {
        return "\n  - " + (v1.value0 + (": " + v1.value1));
      })(v)));
    });
  };
};

// output/Spago.Command.Publish/index.js
var bind54 = /* @__PURE__ */ bind(bindSpago);
var die10 = /* @__PURE__ */ die(monadEffectSpago)(monadAskSpago)(loggableString);
var pure70 = /* @__PURE__ */ pure(applicativeSpago);
var discard33 = /* @__PURE__ */ discard(discardUnit)(bindSpago);
var logDebug13 = /* @__PURE__ */ logDebug(monadEffectSpago)(monadAskSpago);
var logDebug14 = /* @__PURE__ */ logDebug13(loggableString);
var liftAff8 = /* @__PURE__ */ liftAff(monadAffSpago);
var notEq7 = /* @__PURE__ */ notEq(eqStatusCode);
var show41 = /* @__PURE__ */ show(showStatusCode);
var show116 = /* @__PURE__ */ show(showJsonDecodeError);
var ask13 = /* @__PURE__ */ ask(monadAskSpago);
var for_7 = /* @__PURE__ */ for_(applicativeSpago);
var for_1 = /* @__PURE__ */ for_7(foldableArray);
var toDoc7 = /* @__PURE__ */ toDoc2(loggableString);
var logDebug24 = /* @__PURE__ */ logDebug13(loggableDocc);
var logInfo8 = /* @__PURE__ */ logInfo(monadEffectSpago)(monadAskSpago);
var logInfo1 = /* @__PURE__ */ logInfo8(loggableDocc);
var logWarn6 = /* @__PURE__ */ logWarn(monadEffectSpago)(monadAskSpago)(loggableDocc);
var logError2 = /* @__PURE__ */ logError(monadEffectSpago)(monadAskSpago)(loggableDocc);
var logSuccess6 = /* @__PURE__ */ logSuccess(monadEffectSpago)(monadAskSpago)(loggableString);
var liftEffect10 = /* @__PURE__ */ liftEffect(monadEffectSpago);
var runSpago6 = /* @__PURE__ */ runSpago(monadAffSpago);
var map81 = /* @__PURE__ */ map(functorArray);
var toUnfoldable26 = /* @__PURE__ */ toUnfoldable5(unfoldableArray);
var unwrap19 = /* @__PURE__ */ unwrap();
var fromFoldable31 = /* @__PURE__ */ fromFoldable6(ordPackageName)(foldableArray);
var unless8 = /* @__PURE__ */ unless(applicativeSpago);
var toDoc16 = /* @__PURE__ */ toDoc2(/* @__PURE__ */ loggableArray(loggableDocc));
var toDoc24 = /* @__PURE__ */ toDoc2(/* @__PURE__ */ loggableArray(loggableString));
var fromFoldable114 = /* @__PURE__ */ fromFoldable(foldableArray);
var readPursFiles2 = /* @__PURE__ */ readPursFiles(monadAffSpago);
var validatePursModules2 = /* @__PURE__ */ validatePursModules(monadAffSpago);
var when12 = /* @__PURE__ */ when(applicativeSpago);
var for_22 = /* @__PURE__ */ for_7(foldableMaybe);
var append117 = /* @__PURE__ */ append(semigroupDoc);
var show212 = /* @__PURE__ */ show(showInt);
var die$prime3 = /* @__PURE__ */ die$prime(monadEffectSpago)(monadAskSpago)(loggableDocc);
var fromFoldable210 = /* @__PURE__ */ fromFoldable(foldableList);
var logInfo22 = /* @__PURE__ */ logInfo8(loggableString);
var map134 = /* @__PURE__ */ map(functorMap);
var callRegistry = function(url2) {
  return function(outputCodec) {
    return function(maybeInput) {
      var handleError = function(a) {
        return bind54(a)(function(v) {
          if (v instanceof Left) {
            return die10(v.value0);
          }
          ;
          if (v instanceof Right) {
            return pure70(v.value0);
          }
          ;
          throw new Error("Failed pattern match at Spago.Command.Publish (line 344, column 25 - line 346, column 26): " + [v.constructor.name]);
        });
      };
      return handleError(discard33(logDebug14("Calling registry at " + url2))(function() {
        return bind54(liftAff8(withBackoff$prime(function() {
          if (maybeInput instanceof Just) {
            return post2(string4)(url2)(new Just(json3(encode(maybeInput.value0.codec)(maybeInput.value0.data))));
          }
          ;
          if (maybeInput instanceof Nothing) {
            return get5(string4)(url2);
          }
          ;
          throw new Error("Failed pattern match at Spago.Command.Publish (line 330, column 40 - line 332, column 50): " + [maybeInput.constructor.name]);
        }())))(function(response) {
          if (response instanceof Nothing) {
            return pure70(new Left("Could not reach the registry at " + url2));
          }
          ;
          if (response instanceof Just && response.value0 instanceof Left) {
            return pure70(new Left("Error while calling the registry:\n  " + printError2(response.value0.value0)));
          }
          ;
          if (response instanceof Just && (response.value0 instanceof Right && notEq7(response.value0.value0.status)(200))) {
            return pure70(new Left("Registry did not like this and answered with status " + (show41(response.value0.value0.status) + (", got answer:\n  " + response.value0.value0.body))));
          }
          ;
          if (response instanceof Just && response.value0 instanceof Right) {
            return pure70(function() {
              var v = parseJson(outputCodec)(response.value0.value0.body);
              if (v instanceof Right) {
                return new Right(v.value0);
              }
              ;
              if (v instanceof Left) {
                return new Left("Could not parse response from the registry, error: " + show116(v.value0));
              }
              ;
              throw new Error("Failed pattern match at Spago.Command.Publish (line 339, column 14 - line 341, column 93): " + [v.constructor.name]);
            }());
          }
          ;
          throw new Error("Failed pattern match at Spago.Command.Publish (line 333, column 3 - line 341, column 93): " + [response.constructor.name]);
        });
      }));
    };
  };
};
var baseApi = "https://registry.purescript.org";
var waitForJobFinish = function(jobId) {
  var go = function(lastTimestamp) {
    return bind54(ask13)(function(v) {
      var url2 = baseApi + print8(routes)(new Job(jobId, {
        since: lastTimestamp,
        level: function() {
          if (v.logOptions.verbosity instanceof LogVerbose) {
            return new Just(Debug.value);
          }
          ;
          return new Just(Info.value);
        }()
      }));
      return bind54(callRegistry(url2)(jobCodec)(Nothing.value))(function(v1) {
        return discard33(for_1(v1.logs)(function(log5) {
          var line2 = indent(toDoc7(format(iso8601DateTime)(log5.timestamp) + (" " + log5.message)));
          if (log5.level instanceof Debug) {
            return logDebug24(line2);
          }
          ;
          if (log5.level instanceof Info) {
            return logInfo1(line2);
          }
          ;
          if (log5.level instanceof Warn) {
            return logWarn6(line2);
          }
          ;
          if (log5.level instanceof $$Error3) {
            return logError2(line2);
          }
          ;
          throw new Error("Failed pattern match at Spago.Command.Publish (line 367, column 7 - line 371, column 34): " + [log5.level.constructor.name]);
        }))(function() {
          if (v1.finishedAt instanceof Nothing) {
            var latestTimestamp = function(v2) {
              if (v2 instanceof Just) {
                return new Just(v2.value0.timestamp);
              }
              ;
              if (v2 instanceof Nothing) {
                return lastTimestamp;
              }
              ;
              throw new Error("Failed pattern match at Spago.Command.Publish (line 376, column 57 - line 378, column 37): " + [v2.constructor.name]);
            }(last(v1.logs));
            return discard33(liftAff8(delay(500)))(function() {
              return go(latestTimestamp);
            });
          }
          ;
          if (v1.finishedAt instanceof Just) {
            return discard33(logDebug14("Job: " + printJson(jobCodec)(v1)))(function() {
              if (v1.success) {
                return logSuccess6("Registry finished processing the package. Your package was published successfully!");
              }
              ;
              if (!v1.success) {
                return die10("Registry finished processing the package, but it failed. Please fix it and try again.");
              }
              ;
              throw new Error("Failed pattern match at Spago.Command.Publish (line 384, column 9 - line 386, column 113): " + [v1.success.constructor.name]);
            });
          }
          ;
          throw new Error("Failed pattern match at Spago.Command.Publish (line 372, column 5 - line 386, column 113): " + [v1.finishedAt.constructor.name]);
        });
      });
    });
  };
  return go(Nothing.value);
};
var publish = function(_args) {
  return bind54(liftEffect10($$new(new Left(Nil.value))))(function(resultRef) {
    var setResult = function(r) {
      return liftEffect10(modify_(function(v) {
        if (v instanceof Left && v.value0 instanceof Nil) {
          return new Right(r);
        }
        ;
        return v;
      })(resultRef));
    };
    var addError = function(err) {
      return liftEffect10(modify_(function(v) {
        if (v instanceof Left) {
          return new Left(new Cons(err, v.value0));
        }
        ;
        if (v instanceof Right) {
          return new Left(new Cons(err, Nil.value));
        }
        ;
        throw new Error("Failed pattern match at Spago.Command.Publish (line 80, column 11 - line 82, column 54): " + [v.constructor.name]);
      })(resultRef));
    };
    return bind54(ask13)(function(v) {
      var v1 = {
        hasTests: false,
        doc: v.selected.doc,
        "package": v["selected"]["package"],
        path: v.selected.path
      };
      var strName = print2(v1["package"].name);
      return discard33(logDebug14("Publishing package " + strName))(function() {
        return discard33(runSpago6({
          getManifestFromIndex: v.getManifestFromIndex,
          getMetadata: v.getMetadata,
          workspace: {
            selected: new Just(v1),
            backend: v.workspace.backend,
            buildOptions: v.workspace.buildOptions,
            compatibleCompiler: v.workspace.compatibleCompiler,
            doc: v.workspace.doc,
            lockfile: v.workspace.lockfile,
            originalConfig: v.workspace.originalConfig,
            packageSet: v.workspace.packageSet
          },
          logOptions: v.logOptions,
          git: v.git,
          purs: v.purs,
          selected: v.selected,
          dependencies: v.dependencies,
          censorBuildWarnings: Nothing.value,
          censorCodes: Nothing.value,
          filterCodes: Nothing.value,
          statVerbosity: Nothing.value,
          showSource: Nothing.value,
          strict: Nothing.value,
          persistWarnings: Nothing.value
        })(run3({
          depsOnly: false,
          pursArgs: [],
          jsonErrors: false
        })))(function() {
          var globs = getBuildGlobs({
            selected: [v1],
            withTests: false,
            dependencies: v.dependencies,
            depsOnly: false
          });
          return bind54(runGraphCheck(v1)(globs)([]))(function(graphCheckErrors) {
            return discard33(for_1(graphCheckErrors)(addError))(function() {
              var v2 = partitionEithers(map81(function(v3) {
                if (v3.value1 instanceof Nothing) {
                  return new Left(v3.value0);
                }
                ;
                if (v3.value1 instanceof Just) {
                  return new Right(new Tuple(v3.value0, v3.value1.value0));
                }
                ;
                throw new Error("Failed pattern match at Spago.Command.Publish (line 134, column 13 - line 136, column 64): " + [v3.constructor.name]);
              })(toUnfoldable26(unwrap19(v1["package"].dependencies))));
              var depsRanges = fromFoldable31(v2.success);
              return discard33(unless8($$null(v2.fail))(addError(toDoc16([toDoc7("The configuration is missing version bounds for some packages. Run `spago fetch --ensure-ranges` to add them:"), indent(toDoc24(map81(function(p) {
                return "- " + print2(p);
              })(fromFoldable114(v2.fail))))]))))(function() {
                return bind54(getTransitiveDepsFromRegistry(depsRanges)(empty3))(function(buildPlan) {
                  return discard33(function() {
                    if (v1["package"].publish instanceof Nothing) {
                      return addError(toDoc7("Did not find publishing config: add a valid one in package.publish"));
                    }
                    ;
                    if (v1["package"].publish instanceof Just) {
                      if (v1["package"].publish.value0.location instanceof Nothing) {
                        return addError(toDoc7("Need to specify a publish.location field."));
                      }
                      ;
                      if (v1["package"].publish.value0.location instanceof Just) {
                        return bind54(bind54(runSpago6({
                          logOptions: v.logOptions
                        })(v.getMetadata(v1["package"].name)))(function(v3) {
                          if (v3 instanceof Right) {
                            return pure70(v3.value0);
                          }
                          ;
                          if (v3 instanceof Left) {
                            return discard33(logDebug14("Got error while reading metadata file: " + v3.value0))(function() {
                              return pure70({
                                location: v1["package"].publish.value0.location.value0,
                                owners: Nothing.value,
                                published: empty3,
                                unpublished: empty3
                              });
                            });
                          }
                          ;
                          throw new Error("Failed pattern match at Spago.Command.Publish (line 159, column 68 - line 168, column 16): " + [v3.constructor.name]);
                        }))(function(metadata) {
                          var manifest = {
                            name: v1["package"].name,
                            location: v1["package"].publish.value0.location.value0,
                            description: v1["package"].description,
                            dependencies: depsRanges,
                            version: v1["package"].publish.value0.version,
                            license: v1["package"].publish.value0.license,
                            owners: Nothing.value,
                            files: Nothing.value
                          };
                          return discard33(unless8(locationMatches(manifest)(metadata))(addError(toDoc24(["The manifest file specifies a location (", stringifyJson(codec5)(manifest.location), ") that differs from the location in the registry metadata (", stringifyJson(codec5)(metadata.location), "). If you would like to change the location of your package you should ", "submit a transfer operation."]))))(function() {
                            var v3 = partitionEithers(map81(function(v4) {
                              if (v4.value1 instanceof RegistryVersion) {
                                return new Right(new Tuple(v4.value0, v4.value1.value0));
                              }
                              ;
                              return new Left(v4.value0);
                            })(toUnfoldable26(v.dependencies)));
                            var $138 = length(v3.fail) > 0;
                            if ($138) {
                              return addError(toDoc7("Could not find a suitable build plan, the following packages do not point to registry versions: " + stringifyJson(array(codec2))(v3.fail)));
                            }
                            ;
                            var expectedTag = "v" + print3(v1["package"].publish.value0.version);
                            return bind54(getCleanTag(Nothing.value))(function(v4) {
                              if (v4 instanceof Left) {
                                return addError(toDoc24(["The git tree is not clean, or you haven't checked out the tag you want to publish.", "Please commit or stash your changes, and checkout the tag you want to publish.", "To create the tag, you can run:", "", "  git tag " + expectedTag]));
                              }
                              ;
                              if (v4 instanceof Right) {
                                return discard33(function() {
                                  var v5 = v4.value0 !== expectedTag;
                                  if (v5) {
                                    return addError(toDoc24(["The tag (" + (v4.value0 + (") does not match the expected tag (" + (expectedTag + ")."))), "Please make sure to tag the correct version before publishing."]));
                                  }
                                  ;
                                  if (!v5) {
                                    return bind54(pushTag(Nothing.value)(v1["package"].publish.value0.version))(function(v6) {
                                      if (v6 instanceof Left) {
                                        return addError(toDoc16([v6.value0, toDoc7("You can try to push the tag manually by running:"), toDoc7(""), toDoc7("  git push origin " + expectedTag)]));
                                      }
                                      ;
                                      if (v6 instanceof Right) {
                                        return pure70(unit);
                                      }
                                      ;
                                      throw new Error("Failed pattern match at Spago.Command.Publish (line 225, column 72 - line 232, column 39): " + [v6.constructor.name]);
                                    });
                                  }
                                  ;
                                  throw new Error("Failed pattern match at Spago.Command.Publish (line 220, column 15 - line 232, column 39): " + [v5.constructor.name]);
                                }())(function() {
                                  return discard33(bind54(readPursFiles2(concat2([v1.path, "src"])))(function(v5) {
                                    if (v5 instanceof Nothing) {
                                      return addError(toDoc24(["This package has no PureScript files in its `src` directory. ", "All package sources must be in the `src` directory, with any additional ", "sources indicated by the `files` key in your manifest."]));
                                    }
                                    ;
                                    if (v5 instanceof Just) {
                                      return bind54(validatePursModules2(v5.value0))(function(v6) {
                                        if (v6 instanceof Left) {
                                          return addError(toDoc24(["This package has either malformed or disallowed PureScript module names ", "in its `src` directory. All package sources must be in the `src` directory, ", "with any additional sources indicated by the `files` key in your manifest.", v6.value0]));
                                        }
                                        ;
                                        if (v6 instanceof Right) {
                                          return pure70(unit);
                                        }
                                        ;
                                        throw new Error("Failed pattern match at Spago.Command.Publish (line 241, column 70 - line 248, column 41): " + [v6.constructor.name]);
                                      });
                                    }
                                    ;
                                    throw new Error("Failed pattern match at Spago.Command.Publish (line 234, column 86 - line 248, column 41): " + [v5.constructor.name]);
                                  }))(function() {
                                    return discard33(when12(isMetadataPackage(manifest))(addError(toDoc7("The `metadata` package cannot be uploaded to the registry because it is a protected package."))))(function() {
                                      return discard33(for_22(isNotPublished(manifest)(metadata))(function(info4) {
                                        return addError(toDoc24(["You tried to upload a version that already exists: " + print3(manifest.version), "Its metadata is:", "```json", printJson(publishedMetadataCodec)(info4), "```"]));
                                      }))(function() {
                                        return discard33(for_22(isNotUnpublished(manifest)(metadata))(function(info4) {
                                          return addError(toDoc24(["You tried to upload a version that has been unpublished: " + print3(manifest.version), "", "```json", printJson(unpublishedMetadataCodec)(info4), "```"]));
                                        }))(function() {
                                          return setResult({
                                            name: v1["package"].name,
                                            location: new Just(v1["package"].publish.value0.location.value0),
                                            ref: v4.value0,
                                            compiler: v.purs.version,
                                            resolutions: buildPlan
                                          });
                                        });
                                      });
                                    });
                                  });
                                });
                              }
                              ;
                              throw new Error("Failed pattern match at Spago.Command.Publish (line 209, column 39 - line 268, column 119): " + [v4.constructor.name]);
                            });
                          });
                        });
                      }
                      ;
                      throw new Error("Failed pattern match at Spago.Command.Publish (line 153, column 27 - line 268, column 119): " + [v1["package"].publish.value0.location.constructor.name]);
                    }
                    ;
                    throw new Error("Failed pattern match at Spago.Command.Publish (line 151, column 3 - line 268, column 119): " + [v1["package"].publish.constructor.name]);
                  }())(function() {
                    return bind54(liftEffect10(read(resultRef)))(function(result) {
                      if (result instanceof Left) {
                        return discard33(logError2(append117(bold(toDoc7("Your package " + (strName + (" is not ready for publishing yet, encountered " + (show212(length5(result.value0)) + " errors:"))))))($$break)))(function() {
                          return die$prime3(fromFoldable210(result.value0));
                        });
                      }
                      ;
                      if (result instanceof Right) {
                        return discard33(logInfo22("Building again with the build plan from the solver..."))(function() {
                          var buildPlanDependencies = map134(RegistryVersion.create)(result.value0.resolutions);
                          return discard33(runSpago6({
                            getManifestFromIndex: v.getManifestFromIndex,
                            getMetadata: v.getMetadata,
                            workspace: {
                              selected: new Just(v1),
                              backend: v.workspace.backend,
                              buildOptions: v.workspace.buildOptions,
                              compatibleCompiler: v.workspace.compatibleCompiler,
                              doc: v.workspace.doc,
                              lockfile: v.workspace.lockfile,
                              originalConfig: v.workspace.originalConfig,
                              packageSet: v.workspace.packageSet
                            },
                            logOptions: v.logOptions,
                            git: v.git,
                            purs: v.purs,
                            selected: v.selected,
                            dependencies: buildPlanDependencies,
                            censorBuildWarnings: Nothing.value,
                            censorCodes: Nothing.value,
                            filterCodes: Nothing.value,
                            statVerbosity: Nothing.value,
                            showSource: Nothing.value,
                            strict: Nothing.value,
                            persistWarnings: Nothing.value
                          })(run3({
                            depsOnly: false,
                            pursArgs: [],
                            jsonErrors: false
                          })))(function() {
                            return discard33(logDebug14(unsafeStringify(result.value0)))(function() {
                              return discard33(logSuccess6("Ready for publishing. Calling the registry.."))(function() {
                                var newPublishingData = {
                                  name: result.value0.name,
                                  location: result.value0.location,
                                  ref: result.value0.ref,
                                  compiler: result.value0.compiler,
                                  resolutions: new Just(result.value0.resolutions)
                                };
                                return bind54(callRegistry(baseApi + print8(routes)(Publish.value))(jobCreatedResponseCodec)(new Just({
                                  codec: publishCodec,
                                  data: newPublishingData
                                })))(function(v3) {
                                  return discard33(logSuccess6("Registry accepted the Publish request and is processing..."))(function() {
                                    return discard33(logDebug14("Job ID: " + unwrap19(v3.jobId)))(function() {
                                      return discard33(logInfo22("Logs from the Registry pipeline:"))(function() {
                                        return discard33(waitForJobFinish(v3.jobId))(function() {
                                          return pure70(newPublishingData);
                                        });
                                      });
                                    });
                                  });
                                });
                              });
                            });
                          });
                        });
                      }
                      ;
                      throw new Error("Failed pattern match at Spago.Command.Publish (line 271, column 3 - line 325, column 29): " + [result.constructor.name]);
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
  });
};

// output/Spago.Command.Registry/index.js
var discard34 = /* @__PURE__ */ discard(discardUnit)(bindSpago);
var logInfo9 = /* @__PURE__ */ logInfo(monadEffectSpago)(monadAskSpago)(loggableString);
var show43 = /* @__PURE__ */ show(showString);
var bind55 = /* @__PURE__ */ bind(bindSpago);
var ls3 = /* @__PURE__ */ ls(monadAffSpago);
var logError3 = /* @__PURE__ */ logError(monadEffectSpago)(monadAskSpago)(loggableString);
var output3 = /* @__PURE__ */ output(monadEffectSpago);
var die11 = /* @__PURE__ */ die(monadEffectSpago)(monadAskSpago);
var die14 = /* @__PURE__ */ die11(/* @__PURE__ */ loggableArray(loggableDocc));
var toDoc8 = /* @__PURE__ */ toDoc2(loggableString);
var pure71 = /* @__PURE__ */ pure(applicativeSpago);
var ask14 = /* @__PURE__ */ ask(monadAskSpago);
var runSpago7 = /* @__PURE__ */ runSpago(monadAffSpago);
var logDebug15 = /* @__PURE__ */ logDebug(monadEffectSpago)(monadAskSpago)(loggableString);
var die25 = /* @__PURE__ */ die11(loggableString);
var map83 = /* @__PURE__ */ map(functorArray);
var fromFoldable33 = /* @__PURE__ */ fromFoldable(foldableSet);
var lookup14 = /* @__PURE__ */ lookup3(ordVersion);
var search = function(searchString) {
  return discard34(logInfo9("Searching for " + (show43(searchString) + " in the Registry package names...")))(function() {
    return bind55(ls3(concat2([registryPath, "metadata"])))(function(metadataFiles) {
      var matches = filter(contains(searchString))(mapMaybe(stripSuffix(".json"))(metadataFiles));
      var $33 = $$null(matches);
      if ($33) {
        return logError3("Did not find any packages matching the search string.");
      }
      ;
      return discard34(output3(new OutputLines(matches)))(function() {
        return logInfo9("Use `spago registry info $package` to get more details on a package.");
      });
    });
  });
};
var info3 = function(args) {
  return bind55(function() {
    var v = parse3(args["package"]);
    if (v instanceof Left) {
      return die14([toDoc8("Could not parse package name, error:"), indent(toDoc8(show43(v.value0)))]);
    }
    ;
    if (v instanceof Right) {
      return pure71(v.value0);
    }
    ;
    throw new Error("Failed pattern match at Spago.Command.Registry (line 46, column 18 - line 48, column 28): " + [v.constructor.name]);
  }())(function(packageName) {
    return bind55(function() {
      if (args.maybeVersion instanceof Nothing) {
        return pure71(Nothing.value);
      }
      ;
      if (args.maybeVersion instanceof Just) {
        var v1 = parseLenientVersion(args.maybeVersion.value0);
        if (v1 instanceof Left) {
          return die14([toDoc8("Could not parse version, error:"), indent(toDoc8(show43(v1.value0)))]);
        }
        ;
        if (v1 instanceof Right) {
          return pure71(new Just(v1.value0));
        }
        ;
        throw new Error("Failed pattern match at Spago.Command.Registry (line 52, column 15 - line 54, column 43): " + [v1.constructor.name]);
      }
      ;
      throw new Error("Failed pattern match at Spago.Command.Registry (line 50, column 19 - line 54, column 43): " + [args.maybeVersion.constructor.name]);
    }())(function(maybeVersion2) {
      return bind55(ask14)(function(v) {
        return bind55(runSpago7({
          logOptions: v.logOptions
        })(v.getMetadata(packageName)))(function(v1) {
          if (v1 instanceof Left) {
            return discard34(logDebug15(v1.value0))(function() {
              return die25("Could not find package " + print2(packageName));
            });
          }
          ;
          if (v1 instanceof Right) {
            if (maybeVersion2 instanceof Nothing) {
              return discard34(output3(new OutputLines(map83(print3)(fromFoldable33(keys3(v1.value0.published))))))(function() {
                return logInfo9("Use `spago registry info " + (print2(packageName) + " $version` to get more details on a version."));
              });
            }
            ;
            if (maybeVersion2 instanceof Just) {
              var v2 = lookup14(maybeVersion2.value0)(v1.value0.published);
              if (v2 instanceof Nothing) {
                return die25("Version " + (print3(maybeVersion2.value0) + (" does not exist for package " + print2(packageName))));
              }
              ;
              if (v2 instanceof Just) {
                return output3(new OutputJson(publishedMetadataCodec, v2.value0));
              }
              ;
              throw new Error("Failed pattern match at Spago.Command.Registry (line 65, column 23 - line 68, column 84): " + [v2.constructor.name]);
            }
            ;
            throw new Error("Failed pattern match at Spago.Command.Registry (line 61, column 34 - line 68, column 84): " + [maybeVersion2.constructor.name]);
          }
          ;
          throw new Error("Failed pattern match at Spago.Command.Registry (line 57, column 57 - line 68, column 84): " + [v1.constructor.name]);
        });
      });
    });
  });
};

// output/Spago.Command.Run/index.js
var bind56 = /* @__PURE__ */ bind(bindSpago);
var discard35 = /* @__PURE__ */ discard(discardUnit)(bindSpago);
var logDebug16 = /* @__PURE__ */ logDebug(monadEffectSpago)(monadAskSpago)(loggableString);
var mkdirp5 = /* @__PURE__ */ mkdirp(monadAffSpago);
var fold21 = /* @__PURE__ */ fold2(monoidString);
var append39 = /* @__PURE__ */ append(semigroupArray);
var logWarn7 = /* @__PURE__ */ logWarn(monadEffectSpago)(monadAskSpago)(loggableString);
var when13 = /* @__PURE__ */ when(applicativeSpago);
var lookup15 = /* @__PURE__ */ lookup3(ordString);
var die15 = /* @__PURE__ */ die(monadEffectSpago)(monadAskSpago);
var die16 = /* @__PURE__ */ die15(/* @__PURE__ */ loggableArray(loggableString));
var show44 = /* @__PURE__ */ show(showString);
var writeTextFile7 = /* @__PURE__ */ writeTextFile3(monadAffSpago);
var chmod5 = /* @__PURE__ */ chmod4(monadAffSpago);
var showArray2 = /* @__PURE__ */ showArray(showString);
var show117 = /* @__PURE__ */ show(showArray2);
var exec6 = /* @__PURE__ */ exec(monadAffSpago);
var logSuccess7 = /* @__PURE__ */ logSuccess(monadEffectSpago)(monadAskSpago)(loggableString);
var pure72 = /* @__PURE__ */ pure(applicativeSpago);
var showRecord4 = /* @__PURE__ */ showRecord()();
var showMaybe7 = /* @__PURE__ */ showMaybe(showString);
var show213 = /* @__PURE__ */ show(/* @__PURE__ */ showRecord4(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "escapedCommand";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "exitCode";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "failed";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "isCanceled";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "killed";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "message";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "originalMessage";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "shortMessage";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "signal";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "signalDescription";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "stderr";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "stdout";
  }
})(/* @__PURE__ */ showRecordFieldsConsNil({
  reflectSymbol: function() {
    return "timedOut";
  }
})(showBoolean))(showString))(showString))(showMaybe7))(/* @__PURE__ */ showMaybe(/* @__PURE__ */ showEither(showInt)(showString))))(showString))(showMaybe7))(showString))(showBoolean))(showBoolean))(showBoolean))(/* @__PURE__ */ showMaybe(showInt)))(showString)));
var die26 = /* @__PURE__ */ die15(loggableString);
var show310 = /* @__PURE__ */ show(/* @__PURE__ */ showRecord4(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "args";
  }
})(/* @__PURE__ */ showRecordFieldsConsNil({
  reflectSymbol: function() {
    return "cmd";
  }
})(showString))(/* @__PURE__ */ showMaybe(showArray2))));
var run10 = /* @__PURE__ */ bind56(/* @__PURE__ */ ask(monadAskSpago))(function(v) {
  var execOptions = {
    pipeStdin: StdinPipeParent.value,
    cwd: defaultExecOptions.cwd,
    pipeStderr: defaultExecOptions.pipeStderr,
    pipeStdout: defaultExecOptions.pipeStdout
  };
  if (v.workspace.backend instanceof Nothing) {
    return discard35(logDebug16("Running with backend: nodejs"))(function() {
      var runDir = concat2([localCachePath, "run"]);
      return discard35(mkdirp5(runDir))(function() {
        var runJsPath = concat2([runDir, "run.js"]);
        var packageJsonPath = concat2([runDir, "package.json"]);
        var nodeContents = fold21(["import { main } from 'file://", replaceAll("\\")("/")(v.runOptions.sourceDir), "/", fromMaybe("output")(v.workspace.buildOptions.output), "/", v.runOptions.moduleName, "/", "index.js", "'\n\n", "main()"]);
        var nodeArgs = append39([runJsPath])(v.runOptions.execArgs);
        var globs = getBuildGlobs({
          dependencies: v.dependencies,
          depsOnly: false,
          withTests: true,
          selected: [v.selected]
        });
        return discard35(bind56(graph(globs)([]))(function(v1) {
          if (v1 instanceof Left) {
            return logWarn7("Could not decode the output of `purs graph`, error: " + printJsonDecodeError(v1.value0));
          }
          ;
          if (v1 instanceof Right) {
            return when13(isNothing(lookup15(v.runOptions.moduleName)(v1.value0)))(die16([v.runOptions.failureMessage, "Module " + (v.runOptions.moduleName + " not found! Are you including it in your build?")]));
          }
          ;
          throw new Error("Failed pattern match at Spago.Command.Run (line 108, column 31 - line 112, column 123): " + [v1.constructor.name]);
        }))(function() {
          return discard35(logDebug16("Writing " + show44(runJsPath)))(function() {
            return discard35(writeTextFile7(runJsPath)(nodeContents))(function() {
              return discard35(chmod5(runJsPath)(mkPerms(all4)(all4)(all4)))(function() {
                return discard35(logDebug16("Writing " + show44(packageJsonPath)))(function() {
                  return discard35(writeTextFile7(packageJsonPath)('{"type":"module" }'))(function() {
                    return discard35(logDebug16("Executing from: " + show44(v.runOptions.executeDir)))(function() {
                      return discard35(logDebug16("Running node command with args: `" + (show117(nodeArgs) + "`")))(function() {
                        return bind56(exec6(v.node.cmd)(nodeArgs)({
                          pipeStdin: execOptions.pipeStdin,
                          pipeStdout: execOptions.pipeStdout,
                          pipeStderr: execOptions.pipeStderr,
                          cwd: new Just(v.runOptions.executeDir)
                        }))(function(v1) {
                          if (v1 instanceof Right) {
                            if (v.runOptions.successMessage instanceof Just) {
                              return logSuccess7(v.runOptions.successMessage.value0);
                            }
                            ;
                            if (v.runOptions.successMessage instanceof Nothing) {
                              return pure72(unit);
                            }
                            ;
                            throw new Error("Failed pattern match at Spago.Command.Run (line 122, column 21 - line 124, column 31): " + [v.runOptions.successMessage.constructor.name]);
                          }
                          ;
                          if (v1 instanceof Left) {
                            return discard35(logDebug16(show213(v1.value0)))(function() {
                              return die26(v.runOptions.failureMessage);
                            });
                          }
                          ;
                          throw new Error("Failed pattern match at Spago.Command.Run (line 121, column 83 - line 127, column 34): " + [v1.constructor.name]);
                        });
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
  }
  ;
  if (v.workspace.backend instanceof Just) {
    var args = append39(["--run", v.runOptions.moduleName + ".main"])(v.runOptions.execArgs);
    return discard35(logDebug16("Running command `" + (v.workspace.backend.value0.cmd + (" " + (show117(args) + "`")))))(function() {
      return bind56(exec6(v.workspace.backend.value0.cmd)(args)(execOptions))(function(v1) {
        if (v1 instanceof Right) {
          if (v.runOptions.successMessage instanceof Just) {
            return logSuccess7(v.runOptions.successMessage.value0);
          }
          ;
          if (v.runOptions.successMessage instanceof Nothing) {
            return pure72(unit);
          }
          ;
          throw new Error("Failed pattern match at Spago.Command.Run (line 132, column 21 - line 134, column 31): " + [v.runOptions.successMessage.constructor.name]);
        }
        ;
        if (v1 instanceof Left) {
          return discard35(logDebug16(show213(v1.value0)))(function() {
            return die16([v.runOptions.failureMessage, "Backend " + (show310(v.workspace.backend.value0) + (" exited with error:" + v1.value0.shortMessage))]);
          });
        }
        ;
        throw new Error("Failed pattern match at Spago.Command.Run (line 131, column 49 - line 137, column 111): " + [v1.constructor.name]);
      });
    });
  }
  ;
  throw new Error("Failed pattern match at Spago.Command.Run (line 73, column 3 - line 137, column 111): " + [v.workspace.backend.constructor.name]);
});
var nodeVersion = /* @__PURE__ */ function() {
  return bind56(exec6("node")(["--version"])({
    pipeStdin: defaultExecOptions.pipeStdin,
    pipeStdout: false,
    pipeStderr: false,
    cwd: defaultExecOptions.cwd
  }))(function(v) {
    if (v instanceof Left) {
      return discard35(logDebug16(show213(v.value0)))(function() {
        return die16(["Failed to find node. Have you installed it, and is it in your PATH?"]);
      });
    }
    ;
    if (v instanceof Right) {
      var v1 = parseLenientVersion(v.value0.stdout);
      if (v1 instanceof Left) {
        return die26("Failed to parse NodeJS version. Was: " + v.value0.stdout);
      }
      ;
      if (v1 instanceof Right) {
        var $136 = major(v1.value0) >= 13;
        if ($136) {
          return pure72(v1.value0);
        }
        ;
        return die16(["Unsupported Node version " + print3(v1.value0), "Please install a Node v13 or higher."]);
      }
      ;
      throw new Error("Failed pattern match at Spago.Command.Run (line 55, column 16 - line 61, column 105): " + [v1.constructor.name]);
    }
    ;
    throw new Error("Failed pattern match at Spago.Command.Run (line 51, column 105 - line 61, column 105): " + [v.constructor.name]);
  });
}();
var getNode = /* @__PURE__ */ bind56(nodeVersion)(function(version) {
  return pure72({
    cmd: "node",
    version
  });
});

// output/Spago.Command.Sources/index.js
var bind57 = /* @__PURE__ */ bind(bindSpago);
var ask15 = /* @__PURE__ */ ask(monadAskSpago);
var foldMap20 = /* @__PURE__ */ foldMap(foldableArray)(monoidDependencies);
var union9 = /* @__PURE__ */ union3(ordPackageName);
var fromFoldable34 = /* @__PURE__ */ fromFoldable6(ordPackageName)(foldableArray);
var map84 = /* @__PURE__ */ map(functorArray);
var foldMap110 = /* @__PURE__ */ foldMap2(monoidArray);
var toUnfoldable27 = /* @__PURE__ */ toUnfoldable5(unfoldableArray);
var output4 = /* @__PURE__ */ output(monadEffectSpago);
var run11 = function(v) {
  return bind57(ask15)(function(v1) {
    var selectedPackages = function() {
      if (v1.workspace.selected instanceof Just) {
        return [v1.workspace.selected.value0];
      }
      ;
      if (v1.workspace.selected instanceof Nothing) {
        return getWorkspacePackages(v1.workspace.packageSet);
      }
      ;
      throw new Error("Failed pattern match at Spago.Command.Sources (line 20, column 24 - line 22, column 66): " + [v1.workspace.selected.constructor.name]);
    }();
    var deps = foldMap20(getWorkspacePackageDeps)(selectedPackages);
    return bind57(getTransitiveDeps(deps))(function(transitiveDeps) {
      var transitivePackages = union9(fromFoldable34(map84(function(p) {
        return new Tuple(p["package"].name, new WorkspacePackage(p));
      })(selectedPackages)))(transitiveDeps);
      var globs = foldMap110(function(v2) {
        return sourceGlob(WithTestGlobs.value)(v2.value0)(v2.value1);
      })(toUnfoldable27(transitivePackages));
      return output4(function() {
        if (v.json) {
          return new OutputJson(array(string), globs);
        }
        ;
        if (!v.json) {
          return new OutputLines(globs);
        }
        ;
        throw new Error("Failed pattern match at Spago.Command.Sources (line 35, column 10 - line 37, column 31): " + [v.json.constructor.name]);
      }());
    });
  });
};

// output/Spago.Command.Test/index.js
var $$void17 = /* @__PURE__ */ $$void(functorSpago);
var $$for9 = /* @__PURE__ */ $$for(applicativeSpago)(traversableNonEmptyArray);
var discard36 = /* @__PURE__ */ discard(discardUnit)(bindSpago);
var logInfo10 = /* @__PURE__ */ logInfo(monadEffectSpago)(monadAskSpago)(loggableString);
var runSpago8 = /* @__PURE__ */ runSpago(monadAffSpago);
var run12 = /* @__PURE__ */ bind(bindSpago)(/* @__PURE__ */ ask(monadAskSpago))(function(v) {
  return $$void17($$for9(v.selectedPackages)(function(v1) {
    var runOptions = {
      successMessage: new Just('Test succeeded for package "' + (print2(v1["selected"]["package"].name) + '".')),
      failureMessage: 'Tests failed for package "' + (print2(v1["selected"]["package"].name) + '".'),
      executeDir: v1.selected.path,
      sourceDir: cwd2,
      execArgs: v1.execArgs,
      moduleName: v1.moduleName
    };
    var runEnv = {
      logOptions: v.logOptions,
      workspace: v.workspace,
      selected: v1.selected,
      node: v.node,
      runOptions,
      dependencies: v.dependencies,
      purs: v.purs
    };
    return discard36(logInfo10("Running tests for package: " + print2(v1["selected"]["package"].name)))(function() {
      return runSpago8(runEnv)(run10);
    });
  }));
});

// output/Spago.Esbuild/index.js
var discard37 = /* @__PURE__ */ discard(discardUnit)(bindSpago);
var logDebug17 = /* @__PURE__ */ logDebug(monadEffectSpago)(monadAskSpago)(loggableString);
var showMaybe8 = /* @__PURE__ */ showMaybe(showString);
var show45 = /* @__PURE__ */ show(/* @__PURE__ */ showRecord()()(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "escapedCommand";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "exitCode";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "failed";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "isCanceled";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "killed";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "message";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "originalMessage";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "shortMessage";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "signal";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "signalDescription";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "stderr";
  }
})(/* @__PURE__ */ showRecordFieldsCons({
  reflectSymbol: function() {
    return "stdout";
  }
})(/* @__PURE__ */ showRecordFieldsConsNil({
  reflectSymbol: function() {
    return "timedOut";
  }
})(showBoolean))(showString))(showString))(showMaybe8))(/* @__PURE__ */ showMaybe(/* @__PURE__ */ showEither(showInt)(showString))))(showString))(showMaybe8))(showString))(showBoolean))(showBoolean))(showBoolean))(/* @__PURE__ */ showMaybe(showInt)))(showString)));
var die17 = /* @__PURE__ */ die(monadEffectSpago)(monadAskSpago)(/* @__PURE__ */ loggableArray(loggableString));
var pure73 = /* @__PURE__ */ pure(applicativeSpago);
var getEsbuild = /* @__PURE__ */ function() {
  return bind(bindSpago)(exec(monadAffSpago)("esbuild")(["--version"])({
    pipeStdin: defaultExecOptions.pipeStdin,
    pipeStdout: false,
    pipeStderr: false,
    cwd: defaultExecOptions.cwd
  }))(function(v) {
    if (v instanceof Left) {
      return discard37(logDebug17(show45(v.value0)))(function() {
        return die17(["Failed to find esbuild. See https://esbuild.github.io/getting-started/#install-esbuild for ways to install esbuild."]);
      });
    }
    ;
    if (v instanceof Right) {
      return pure73({
        cmd: "esbuild",
        version: v.value0.stdout
      });
    }
    ;
    throw new Error("Failed pattern match at Spago.Esbuild (line 14, column 106 - line 18, column 58): " + [v.constructor.name]);
  });
}();

// output/Main/index.js
var fromRecord2 = /* @__PURE__ */ fromRecord();
var backendArgsIsSymbol = {
  reflectSymbol: function() {
    return "backendArgs";
  }
};
var buildArgsCons2 = /* @__PURE__ */ buildArgsCons(backendArgsIsSymbol)()()();
var censorBuildWarningsIsSymbol = {
  reflectSymbol: function() {
    return "censorBuildWarnings";
  }
};
var buildArgsCons1 = /* @__PURE__ */ buildArgsCons(censorBuildWarningsIsSymbol)()()();
var censorCodesIsSymbol = {
  reflectSymbol: function() {
    return "censorCodes";
  }
};
var buildArgsCons22 = /* @__PURE__ */ buildArgsCons(censorCodesIsSymbol)()()();
var execArgsIsSymbol2 = {
  reflectSymbol: function() {
    return "execArgs";
  }
};
var buildArgsCons3 = /* @__PURE__ */ buildArgsCons(execArgsIsSymbol2)()()();
var filterCodesIsSymbol = {
  reflectSymbol: function() {
    return "filterCodes";
  }
};
var buildArgsCons4 = /* @__PURE__ */ buildArgsCons(filterCodesIsSymbol)()()();
var outputIsSymbol = {
  reflectSymbol: function() {
    return "output";
  }
};
var buildArgsCons5 = /* @__PURE__ */ buildArgsCons(outputIsSymbol)()()();
var pedanticPackagesIsSymbol = {
  reflectSymbol: function() {
    return "pedanticPackages";
  }
};
var buildArgsCons6 = /* @__PURE__ */ buildArgsCons(pedanticPackagesIsSymbol)()()();
var persistWarningsIsSymbol = {
  reflectSymbol: function() {
    return "persistWarnings";
  }
};
var buildArgsCons7 = /* @__PURE__ */ buildArgsCons(persistWarningsIsSymbol)()()();
var pursArgsIsSymbol = {
  reflectSymbol: function() {
    return "pursArgs";
  }
};
var buildArgsCons8 = /* @__PURE__ */ buildArgsCons(pursArgsIsSymbol)()()();
var selectedPackageIsSymbol = {
  reflectSymbol: function() {
    return "selectedPackage";
  }
};
var buildArgsCons9 = /* @__PURE__ */ buildArgsCons(selectedPackageIsSymbol)()()();
var showSourceIsSymbol = {
  reflectSymbol: function() {
    return "showSource";
  }
};
var buildArgsCons10 = /* @__PURE__ */ buildArgsCons(showSourceIsSymbol)()()();
var statVerbosityIsSymbol = {
  reflectSymbol: function() {
    return "statVerbosity";
  }
};
var buildArgsCons11 = /* @__PURE__ */ buildArgsCons(statVerbosityIsSymbol)()()();
var strictIsSymbol = {
  reflectSymbol: function() {
    return "strict";
  }
};
var buildArgsCons12 = /* @__PURE__ */ buildArgsCons(strictIsSymbol)()()();
var buildArgsCons13 = /* @__PURE__ */ buildArgsCons5(/* @__PURE__ */ buildArgsCons6(/* @__PURE__ */ buildArgsCons7(/* @__PURE__ */ buildArgsCons8(/* @__PURE__ */ buildArgsCons9(/* @__PURE__ */ buildArgsCons10(/* @__PURE__ */ buildArgsCons11(/* @__PURE__ */ buildArgsCons12(buildRecordArgsNil))))))));
var buildArgsCons14 = /* @__PURE__ */ buildArgsCons({
  reflectSymbol: function() {
    return "json";
  }
})()()();
var buildArgsCons15 = /* @__PURE__ */ buildArgsCons9(buildRecordArgsNil);
var discard38 = /* @__PURE__ */ discard(discardUnit)(bindSpago);
var ensureFileSync3 = /* @__PURE__ */ ensureFileSync2(monadEffectSpago);
var writeTextFile8 = /* @__PURE__ */ writeTextFile3(monadAffSpago);
var bind58 = /* @__PURE__ */ bind(bindSpago);
var logDebug18 = /* @__PURE__ */ logDebug(monadEffectSpago)(monadAskSpago);
var loggableArray7 = /* @__PURE__ */ loggableArray(loggableString);
var logDebug19 = /* @__PURE__ */ logDebug18(loggableArray7);
var show46 = /* @__PURE__ */ show(showError);
var pure74 = /* @__PURE__ */ pure(applicativeSpago);
var liftEffect11 = /* @__PURE__ */ liftEffect(monadEffectSpago);
var logDebug25 = /* @__PURE__ */ logDebug18(loggableString);
var ensureRangesIsSymbol = {
  reflectSymbol: function() {
    return "ensureRanges";
  }
};
var buildArgsCons16 = /* @__PURE__ */ buildArgsCons(ensureRangesIsSymbol)()()();
var mainIsSymbol2 = {
  reflectSymbol: function() {
    return "main";
  }
};
var buildArgsCons17 = /* @__PURE__ */ buildArgsCons8(buildArgsCons15);
var buildArgsCons18 = /* @__PURE__ */ buildArgsCons({
  reflectSymbol: function() {
    return "package";
  }
})()()()(buildRecordArgsNil);
var ask16 = /* @__PURE__ */ ask(monadAskSpago);
var showRecord5 = /* @__PURE__ */ showRecord()();
var showRecordFieldsCons3 = /* @__PURE__ */ showRecordFieldsCons(backendArgsIsSymbol);
var showRecordFieldsCons12 = /* @__PURE__ */ showRecordFieldsCons(censorBuildWarningsIsSymbol);
var showRecordFieldsCons23 = /* @__PURE__ */ showRecordFieldsCons(censorCodesIsSymbol);
var showRecordFieldsCons32 = /* @__PURE__ */ showRecordFieldsCons(execArgsIsSymbol2);
var showRecordFieldsCons4 = /* @__PURE__ */ showRecordFieldsCons(filterCodesIsSymbol);
var showRecordFieldsCons5 = /* @__PURE__ */ showRecordFieldsCons(outputIsSymbol);
var showRecordFieldsCons6 = /* @__PURE__ */ showRecordFieldsCons(pedanticPackagesIsSymbol);
var showRecordFieldsCons7 = /* @__PURE__ */ showRecordFieldsCons(persistWarningsIsSymbol);
var showRecordFieldsCons8 = /* @__PURE__ */ showRecordFieldsCons(pursArgsIsSymbol);
var showRecordFieldsCons9 = /* @__PURE__ */ showRecordFieldsCons(selectedPackageIsSymbol);
var showRecordFieldsCons10 = /* @__PURE__ */ showRecordFieldsCons(showSourceIsSymbol);
var showRecordFieldsCons11 = /* @__PURE__ */ showRecordFieldsCons(statVerbosityIsSymbol);
var showMaybe9 = /* @__PURE__ */ showMaybe(showBoolean);
var showMaybe1 = /* @__PURE__ */ showMaybe(showStatVerbosity);
var showMaybe22 = /* @__PURE__ */ showMaybe(showShowSourceCode);
var showMaybe32 = /* @__PURE__ */ showMaybe(showString);
var showList3 = /* @__PURE__ */ showList(showString);
var showRecordFieldsCons122 = /* @__PURE__ */ showRecordFieldsCons5(/* @__PURE__ */ showRecordFieldsCons6(/* @__PURE__ */ showRecordFieldsCons7(/* @__PURE__ */ showRecordFieldsCons8(/* @__PURE__ */ showRecordFieldsCons9(/* @__PURE__ */ showRecordFieldsCons10(/* @__PURE__ */ showRecordFieldsCons11(/* @__PURE__ */ showRecordFieldsConsNil(strictIsSymbol)(showMaybe9))(showMaybe1))(showMaybe22))(showMaybe32))(showList3))(showMaybe9))(showBoolean))(showMaybe32);
var showMaybe42 = /* @__PURE__ */ showMaybe(/* @__PURE__ */ showNonEmptySet(showString));
var showMaybe52 = /* @__PURE__ */ showMaybe(/* @__PURE__ */ showArray(showString));
var showMaybe62 = /* @__PURE__ */ showMaybe(showCensorBuildWarnings);
var show118 = /* @__PURE__ */ show(/* @__PURE__ */ showRecord5(/* @__PURE__ */ showRecordFieldsCons3(/* @__PURE__ */ showRecordFieldsCons12(/* @__PURE__ */ showRecordFieldsCons23(/* @__PURE__ */ showRecordFieldsCons32(/* @__PURE__ */ showRecordFieldsCons4(showRecordFieldsCons122)(showMaybe42))(showMaybe52))(showMaybe42))(showMaybe62))(showList3)));
var bind121 = /* @__PURE__ */ bind(bindMaybe);
var alt31 = /* @__PURE__ */ alt(altMaybe);
var map85 = /* @__PURE__ */ map(functorNonEmptyArray);
var die18 = /* @__PURE__ */ die(monadEffectSpago)(monadAskSpago);
var die19 = /* @__PURE__ */ die18(loggableString);
var showRecordFieldsCons13 = /* @__PURE__ */ showRecordFieldsCons(ensureRangesIsSymbol);
var show214 = /* @__PURE__ */ show(/* @__PURE__ */ showRecord5(/* @__PURE__ */ showRecordFieldsCons3(/* @__PURE__ */ showRecordFieldsCons12(/* @__PURE__ */ showRecordFieldsCons23(/* @__PURE__ */ showRecordFieldsCons13(/* @__PURE__ */ showRecordFieldsCons32(/* @__PURE__ */ showRecordFieldsCons4(/* @__PURE__ */ showRecordFieldsCons(mainIsSymbol2)(showRecordFieldsCons122)(showMaybe32))(showMaybe42))(showMaybe52))(showBoolean))(showMaybe42))(showMaybe62))(showList3)));
var die27 = /* @__PURE__ */ die18(/* @__PURE__ */ loggableArray(loggableDocc));
var toDoc9 = /* @__PURE__ */ toDoc2(loggableString);
var toDoc17 = /* @__PURE__ */ toDoc2(/* @__PURE__ */ loggableArray(loggablePackageName));
var map135 = /* @__PURE__ */ map(functorArray);
var show311 = /* @__PURE__ */ show(/* @__PURE__ */ showRecord5(/* @__PURE__ */ showRecordFieldsCons3(/* @__PURE__ */ showRecordFieldsCons8(/* @__PURE__ */ showRecordFieldsConsNil(selectedPackageIsSymbol)(showMaybe32))(showList3))(showList3)));
var fromFoldable35 = /* @__PURE__ */ fromFoldable(foldableList);
var mkdirp6 = /* @__PURE__ */ mkdirp(monadAffSpago);
var show47 = /* @__PURE__ */ show(showString);
var lookup16 = /* @__PURE__ */ lookup3(ordPackageName);
var lookup17 = /* @__PURE__ */ lookup3(ordVersion);
var liftAff9 = /* @__PURE__ */ liftAff(monadAffSpago);
var readEntryFile2 = /* @__PURE__ */ readEntryFile(monadAffAff);
var map221 = /* @__PURE__ */ map(functorSpago);
var toUnfoldable28 = /* @__PURE__ */ toUnfoldable2(unfoldableArray);
var logWarn8 = /* @__PURE__ */ logWarn(monadEffectSpago)(monadAskSpago)(loggableString);
var fromFoldable115 = /* @__PURE__ */ fromFoldable6(ordVersion)(foldableArray);
var insert19 = /* @__PURE__ */ insert3(ordPackageName);
var whenM3 = /* @__PURE__ */ whenM(monadSpago);
var logInfo11 = /* @__PURE__ */ logInfo(monadEffectSpago)(monadAskSpago)(loggableString);
var runSpago9 = /* @__PURE__ */ runSpago(monadAffSpago);
var $$try10 = /* @__PURE__ */ $$try2(monadErrorErrorSpago);
var union10 = /* @__PURE__ */ union5();
var bind214 = /* @__PURE__ */ bind(bindAff);
var liftEffect12 = /* @__PURE__ */ liftEffect(monadEffectAff);
var and2 = /* @__PURE__ */ and(foldableArray)(heytingAlgebraBoolean);
var pure121 = /* @__PURE__ */ pure(applicativeAff);
var partitionMap4 = /* @__PURE__ */ partitionMap(filterableArray);
var unless9 = /* @__PURE__ */ unless(applicativeSpago);
var append118 = /* @__PURE__ */ append(semigroupArray);
var $$for10 = /* @__PURE__ */ $$for(applicativeSpago)(traversableMaybe);
var show52 = /* @__PURE__ */ show(showMaybe32);
var minifyIsSymbol = {
  reflectSymbol: function() {
    return "minify";
  }
};
var moduleIsSymbol = {
  reflectSymbol: function() {
    return "module";
  }
};
var outfileIsSymbol = {
  reflectSymbol: function() {
    return "outfile";
  }
};
var platformIsSymbol = {
  reflectSymbol: function() {
    return "platform";
  }
};
var typeIsSymbol2 = {
  reflectSymbol: function() {
    return "type";
  }
};
var show62 = /* @__PURE__ */ show(/* @__PURE__ */ showRecord5(/* @__PURE__ */ showRecordFieldsCons3(/* @__PURE__ */ showRecordFieldsCons12(/* @__PURE__ */ showRecordFieldsCons23(/* @__PURE__ */ showRecordFieldsCons13(/* @__PURE__ */ showRecordFieldsCons4(/* @__PURE__ */ showRecordFieldsCons(minifyIsSymbol)(/* @__PURE__ */ showRecordFieldsCons(moduleIsSymbol)(/* @__PURE__ */ showRecordFieldsCons(outfileIsSymbol)(/* @__PURE__ */ showRecordFieldsCons5(/* @__PURE__ */ showRecordFieldsCons6(/* @__PURE__ */ showRecordFieldsCons7(/* @__PURE__ */ showRecordFieldsCons(platformIsSymbol)(/* @__PURE__ */ showRecordFieldsCons8(/* @__PURE__ */ showRecordFieldsCons9(/* @__PURE__ */ showRecordFieldsCons10(/* @__PURE__ */ showRecordFieldsCons11(/* @__PURE__ */ showRecordFieldsCons(strictIsSymbol)(/* @__PURE__ */ showRecordFieldsConsNil(typeIsSymbol2)(showMaybe32))(showMaybe9))(showMaybe1))(showMaybe22))(showMaybe32))(showList3))(showMaybe32))(showMaybe9))(showBoolean))(showMaybe32))(showMaybe32))(showMaybe32))(showBoolean))(showMaybe42))(showBoolean))(showMaybe42))(showMaybe62))(showList3)));
var bindFlipped12 = /* @__PURE__ */ bindFlipped(bindMaybe);
var map314 = /* @__PURE__ */ map(functorMaybe);
var buildArgsCons19 = /* @__PURE__ */ buildArgsCons({
  reflectSymbol: function() {
    return "packages";
  }
})()()();
var apply24 = /* @__PURE__ */ apply2(parserApply);
var map413 = /* @__PURE__ */ map(parserFunctor);
var fold22 = /* @__PURE__ */ fold(foldableArray)(modMonoid);
var append211 = /* @__PURE__ */ append(modSemigroup);
var runSpago1 = /* @__PURE__ */ runSpago(monadAffAff);
var mempty21 = /* @__PURE__ */ mempty(monoidList);
var $$void18 = /* @__PURE__ */ $$void(functorSpago);
var die33 = /* @__PURE__ */ die18(loggableArray7);
var merge3 = /* @__PURE__ */ merge()();
var toUnfoldable111 = /* @__PURE__ */ toUnfoldable4(unfoldableArray);
var mempty111 = /* @__PURE__ */ mempty(/* @__PURE__ */ monoidMaybe(semigroupString));
var exists9 = /* @__PURE__ */ exists2(monadEffectSpago);
var mkTemp3 = /* @__PURE__ */ mkTemp(monadAffSpago);
var fromFoldable211 = /* @__PURE__ */ fromFoldable5(foldableArray);
var union12 = /* @__PURE__ */ union3(ordPackageName);
var when14 = /* @__PURE__ */ when(applicativeAff);
var Init = /* @__PURE__ */ function() {
  function Init2(value0) {
    this.value0 = value0;
  }
  ;
  Init2.create = function(value0) {
    return new Init2(value0);
  };
  return Init2;
}();
var Fetch = /* @__PURE__ */ function() {
  function Fetch2(value0) {
    this.value0 = value0;
  }
  ;
  Fetch2.create = function(value0) {
    return new Fetch2(value0);
  };
  return Fetch2;
}();
var Install = /* @__PURE__ */ function() {
  function Install2(value0) {
    this.value0 = value0;
  }
  ;
  Install2.create = function(value0) {
    return new Install2(value0);
  };
  return Install2;
}();
var Build = /* @__PURE__ */ function() {
  function Build2(value0) {
    this.value0 = value0;
  }
  ;
  Build2.create = function(value0) {
    return new Build2(value0);
  };
  return Build2;
}();
var Bundle = /* @__PURE__ */ function() {
  function Bundle2(value0) {
    this.value0 = value0;
  }
  ;
  Bundle2.create = function(value0) {
    return new Bundle2(value0);
  };
  return Bundle2;
}();
var Repl = /* @__PURE__ */ function() {
  function Repl2(value0) {
    this.value0 = value0;
  }
  ;
  Repl2.create = function(value0) {
    return new Repl2(value0);
  };
  return Repl2;
}();
var Run = /* @__PURE__ */ function() {
  function Run2(value0) {
    this.value0 = value0;
  }
  ;
  Run2.create = function(value0) {
    return new Run2(value0);
  };
  return Run2;
}();
var Test = /* @__PURE__ */ function() {
  function Test2(value0) {
    this.value0 = value0;
  }
  ;
  Test2.create = function(value0) {
    return new Test2(value0);
  };
  return Test2;
}();
var Sources = /* @__PURE__ */ function() {
  function Sources2(value0) {
    this.value0 = value0;
  }
  ;
  Sources2.create = function(value0) {
    return new Sources2(value0);
  };
  return Sources2;
}();
var RegistrySearch = /* @__PURE__ */ function() {
  function RegistrySearch2(value0) {
    this.value0 = value0;
  }
  ;
  RegistrySearch2.create = function(value0) {
    return new RegistrySearch2(value0);
  };
  return RegistrySearch2;
}();
var RegistryInfo = /* @__PURE__ */ function() {
  function RegistryInfo2(value0) {
    this.value0 = value0;
  }
  ;
  RegistryInfo2.create = function(value0) {
    return new RegistryInfo2(value0);
  };
  return RegistryInfo2;
}();
var LsDeps = /* @__PURE__ */ function() {
  function LsDeps2(value0) {
    this.value0 = value0;
  }
  ;
  LsDeps2.create = function(value0) {
    return new LsDeps2(value0);
  };
  return LsDeps2;
}();
var LsPackages = /* @__PURE__ */ function() {
  function LsPackages2(value0) {
    this.value0 = value0;
  }
  ;
  LsPackages2.create = function(value0) {
    return new LsPackages2(value0);
  };
  return LsPackages2;
}();
var Publish2 = /* @__PURE__ */ function() {
  function Publish3(value0) {
    this.value0 = value0;
  }
  ;
  Publish3.create = function(value0) {
    return new Publish3(value0);
  };
  return Publish3;
}();
var SpagoCmd = /* @__PURE__ */ function() {
  function SpagoCmd2(value0, value12) {
    this.value0 = value0;
    this.value1 = value12;
  }
  ;
  SpagoCmd2.create = function(value0) {
    return function(value12) {
      return new SpagoCmd2(value0, value12);
    };
  };
  return SpagoCmd2;
}();
var testArgsParser = /* @__PURE__ */ fromRecord2(/* @__PURE__ */ buildArgsCons2(/* @__PURE__ */ buildArgsCons1(/* @__PURE__ */ buildArgsCons22(/* @__PURE__ */ buildArgsCons3(/* @__PURE__ */ buildArgsCons4(buildArgsCons13))))))({
  selectedPackage,
  pursArgs,
  backendArgs,
  execArgs,
  output: output2,
  pedanticPackages,
  strict,
  censorBuildWarnings,
  showSource,
  censorCodes,
  filterCodes,
  statVerbosity,
  persistWarnings
});
var sourcesArgsParser = /* @__PURE__ */ fromRecord2(/* @__PURE__ */ buildArgsCons14(buildArgsCons15))({
  selectedPackage,
  json: json2
});
var shouldFetchRegistryRepos = /* @__PURE__ */ function() {
  var touch = function(path5) {
    return discard38(ensureFileSync3(path5))(function() {
      return writeTextFile8(path5)("");
    });
  };
  var freshRegistryCanary = concat2([globalCachePath, "fresh-registry-canary.txt"]);
  return bind58(stat5(monadAffSpago)(freshRegistryCanary))(function(v) {
    if (v instanceof Left) {
      return discard38(logDebug19(["Could not stat " + freshRegistryCanary, show46(v.value0)]))(function() {
        return discard38(touch(freshRegistryCanary))(function() {
          return pure74(true);
        });
      });
    }
    ;
    if (v instanceof Right) {
      return bind58(liftEffect11(now))(function(now3) {
        var staleAfter = 1e3 * 60 * 15;
        var isOldEnough = getTime(now3) > getTime(v.value0.value0.mtime) + staleAfter;
        if (isOldEnough) {
          return discard38(logDebug25("Registry is old enough, refreshing canary"))(function() {
            return discard38(touch(freshRegistryCanary))(function() {
              return pure74(true);
            });
          });
        }
        ;
        return discard38(logDebug25("Registry index is fresh enough, moving on..."))(function() {
          return pure74(false);
        });
      });
    }
    ;
    throw new Error("Failed pattern match at Main (line 939, column 35 - line 958, column 19): " + [v.constructor.name]);
  });
}();
var runArgsParser = /* @__PURE__ */ fromRecord2(/* @__PURE__ */ buildArgsCons2(/* @__PURE__ */ buildArgsCons1(/* @__PURE__ */ buildArgsCons22(/* @__PURE__ */ buildArgsCons16(/* @__PURE__ */ buildArgsCons3(/* @__PURE__ */ buildArgsCons4(/* @__PURE__ */ buildArgsCons(mainIsSymbol2)()()()(buildArgsCons13))))))))({
  selectedPackage,
  pursArgs,
  backendArgs,
  execArgs,
  output: output2,
  pedanticPackages,
  main: moduleName,
  ensureRanges,
  strict,
  censorBuildWarnings,
  showSource,
  censorCodes,
  filterCodes,
  statVerbosity,
  persistWarnings
});
var replArgsParser = /* @__PURE__ */ fromRecord2(/* @__PURE__ */ buildArgsCons2(buildArgsCons17))({
  selectedPackage,
  pursArgs,
  backendArgs
});
var registrySearchArgsParser = /* @__PURE__ */ fromRecord2(buildArgsCons18)({
  "package": $$package
});
var registryInfoArgsParser = /* @__PURE__ */ fromRecord2(/* @__PURE__ */ buildArgsCons({
  reflectSymbol: function() {
    return "maybeVersion";
  }
})()()()(buildArgsCons18))({
  "package": $$package,
  maybeVersion
});
var publishArgsParser = /* @__PURE__ */ fromRecord2(buildArgsCons15)({
  selectedPackage
});
var mkTestEnv = function(testArgs) {
  return function(v) {
    return bind58(ask16)(function(v1) {
      return discard38(logDebug25("Test args: " + show118(testArgs)))(function() {
        return bind58(getNode)(function(node) {
          var mkSelectedTest = function(selected) {
            var testConf = function(f) {
              return bind121(selected["package"].test)(f);
            };
            var moduleName2 = fromMaybe("Test.Main")(testConf(function($682) {
              return Just.create(function(v2) {
                return v2.main;
              }($682));
            }));
            var execArgs2 = fromMaybe([])(alt31(testArgs.execArgs)(testConf(function(v2) {
              return v2.execArgs;
            })));
            return {
              moduleName: moduleName2,
              execArgs: execArgs2,
              selected
            };
          };
          return bind58(function() {
            if (v1.workspace.selected instanceof Just) {
              return pure74(singleton4(mkSelectedTest(v1.workspace.selected.value0)));
            }
            ;
            if (v1.workspace.selected instanceof Nothing) {
              var workspacePackages = getWorkspacePackages(v1.workspace.packageSet);
              var v2 = uncons(filter(function(v3) {
                return v3.hasTests;
              })(workspacePackages));
              if (v2 instanceof Just) {
                return pure74(map85(mkSelectedTest)(cons$prime(v2.value0.head)(v2.value0.tail)));
              }
              ;
              if (v2 instanceof Nothing) {
                return die19("No package found to test.");
              }
              ;
              throw new Error("Failed pattern match at Main (line 724, column 9 - line 726, column 53): " + [v2.constructor.name]);
            }
            ;
            throw new Error("Failed pattern match at Main (line 718, column 23 - line 726, column 53): " + [v1.workspace.selected.constructor.name]);
          }())(function(selectedPackages) {
            return discard38(logDebug25("Selected packages to test: " + stringifyJson(nonEmptyArray(codec2))(map85(function(v2) {
              return v2["selected"]["package"].name;
            })(selectedPackages))))(function() {
              var newWorkspace = {
                buildOptions: {
                  output: alt31(testArgs.output)(v1.workspace.buildOptions.output),
                  censorBuildWarnings: v1.workspace.buildOptions.censorBuildWarnings,
                  censorCodes: v1.workspace.buildOptions.censorCodes,
                  filterCodes: v1.workspace.buildOptions.filterCodes,
                  pedanticPackages: v1.workspace.buildOptions.pedanticPackages,
                  persistWarnings: v1.workspace.buildOptions.persistWarnings,
                  showSource: v1.workspace.buildOptions.showSource,
                  statVerbosity: v1.workspace.buildOptions.statVerbosity,
                  strict: v1.workspace.buildOptions.strict
                },
                packageSet: v1.workspace.packageSet,
                selected: v1.workspace.selected,
                backend: v1.workspace.backend,
                compatibleCompiler: v1.workspace.compatibleCompiler,
                doc: v1.workspace.doc,
                lockfile: v1.workspace.lockfile,
                originalConfig: v1.workspace.originalConfig
              };
              var testEnv = {
                logOptions: v1.logOptions,
                workspace: newWorkspace,
                selectedPackages,
                node,
                dependencies: v.dependencies,
                purs: v.purs
              };
              return pure74(testEnv);
            });
          });
        });
      });
    });
  };
};
var mkRunEnv = function(runArgs) {
  return function(v) {
    return bind58(ask16)(function(v1) {
      return discard38(logDebug25("Run args: " + show214(runArgs)))(function() {
        return bind58(getNode)(function(node) {
          return bind58(function() {
            if (v1.workspace.selected instanceof Just) {
              return pure74(v1.workspace.selected.value0);
            }
            ;
            if (v1.workspace.selected instanceof Nothing) {
              var workspacePackages = getWorkspacePackages(v1.workspace.packageSet);
              if (workspacePackages.length === 1) {
                return pure74(workspacePackages[0]);
              }
              ;
              return discard38(logDebug25(unsafeStringify(workspacePackages)))(function() {
                return die27([toDoc9("No package was selected for running. Please select (with -p) one of the following packages:"), indent(toDoc17(map135(function(v2) {
                  return v2["package"].name;
                })(workspacePackages)))]);
              });
            }
            ;
            throw new Error("Failed pattern match at Main (line 655, column 15 - line 669, column 16): " + [v1.workspace.selected.constructor.name]);
          }())(function(selected) {
            return discard38(logDebug25("Selected package to run: " + print2(selected["package"].name)))(function() {
              var runConf = function(f) {
                return bind121(selected["package"].run)(f);
              };
              var moduleName2 = fromMaybe("Main")(alt31(runArgs.main)(runConf(function(v2) {
                return v2.main;
              })));
              var execArgs2 = fromMaybe([])(alt31(runArgs.execArgs)(runConf(function(v2) {
                return v2.execArgs;
              })));
              var runOptions = {
                moduleName: moduleName2,
                execArgs: execArgs2,
                sourceDir: cwd2,
                executeDir: cwd2,
                successMessage: Nothing.value,
                failureMessage: "Running failed."
              };
              var newWorkspace = {
                buildOptions: {
                  output: alt31(runArgs.output)(v1.workspace.buildOptions.output),
                  censorBuildWarnings: v1.workspace.buildOptions.censorBuildWarnings,
                  censorCodes: v1.workspace.buildOptions.censorCodes,
                  filterCodes: v1.workspace.buildOptions.filterCodes,
                  pedanticPackages: v1.workspace.buildOptions.pedanticPackages,
                  persistWarnings: v1.workspace.buildOptions.persistWarnings,
                  showSource: v1.workspace.buildOptions.showSource,
                  statVerbosity: v1.workspace.buildOptions.statVerbosity,
                  strict: v1.workspace.buildOptions.strict
                },
                packageSet: v1.workspace.packageSet,
                selected: v1.workspace.selected,
                backend: v1.workspace.backend,
                compatibleCompiler: v1.workspace.compatibleCompiler,
                doc: v1.workspace.doc,
                lockfile: v1.workspace.lockfile,
                originalConfig: v1.workspace.originalConfig
              };
              var runEnv = {
                logOptions: v1.logOptions,
                workspace: newWorkspace,
                selected,
                node,
                runOptions,
                dependencies: v.dependencies,
                purs: v.purs
              };
              return pure74(runEnv);
            });
          });
        });
      });
    });
  };
};
var mkReplEnv = function(replArgs) {
  return function(dependencies) {
    return bind58(ask16)(function(v) {
      return discard38(logDebug25("Repl args: " + show311(replArgs)))(function() {
        return bind58(getPurs)(function(purs) {
          var selected = function() {
            if (v.workspace.selected instanceof Just) {
              return [v.workspace.selected.value0];
            }
            ;
            if (v.workspace.selected instanceof Nothing) {
              return getWorkspacePackages(v.workspace.packageSet);
            }
            ;
            throw new Error("Failed pattern match at Main (line 804, column 16 - line 806, column 66): " + [v.workspace.selected.constructor.name]);
          }();
          return pure74({
            purs,
            dependencies,
            depsOnly: false,
            logOptions: v.logOptions,
            pursArgs: fromFoldable35(replArgs.pursArgs),
            selected
          });
        });
      });
    });
  };
};
var mkRegistryEnv = /* @__PURE__ */ function() {
  return discard38(logDebug25("CWD: " + cwd2))(function() {
    return discard38(mkdirp6(globalCachePath))(function() {
      return discard38(mkdirp6(localCachePath))(function() {
        return discard38(mkdirp6(localCachePackagesPath))(function() {
          return discard38(logDebug25("Global cache: " + show47(globalCachePath)))(function() {
            return discard38(logDebug25("Local cache: " + show47(localCachePath)))(function() {
              return bind58(getGit)(function(git) {
                return bind58(liftEffect11($$new(empty3)))(function(indexRef) {
                  var getManifestFromIndex = function(name4) {
                    return function(version) {
                      return bind58(liftEffect11(read(indexRef)))(function(indexMap) {
                        var v = lookup16(name4)(indexMap);
                        if (v instanceof Just) {
                          return pure74(lookup17(version)(v.value0));
                        }
                        ;
                        if (v instanceof Nothing) {
                          return discard38(logDebug25("Reading package from Index: " + print2(name4)))(function() {
                            return bind58(liftAff9(readEntryFile2(registryIndexPath)(name4)))(function(maybeManifests) {
                              return bind58(map221(map135(function(v1) {
                                return new Tuple(v1.version, v1);
                              }))(function() {
                                if (maybeManifests instanceof Right) {
                                  return pure74(toUnfoldable28(maybeManifests.value0));
                                }
                                ;
                                if (maybeManifests instanceof Left) {
                                  return discard38(logWarn8("Could not read package manifests from index, proceeding anyways. Error: " + maybeManifests.value0))(function() {
                                    return pure74([]);
                                  });
                                }
                                ;
                                throw new Error("Failed pattern match at Main (line 863, column 75 - line 867, column 22): " + [maybeManifests.constructor.name]);
                              }()))(function(manifests) {
                                var versions = fromFoldable115(manifests);
                                return discard38(liftEffect11(write(insert19(name4)(versions)(indexMap))(indexRef)))(function() {
                                  return pure74(lookup17(version)(versions));
                                });
                              });
                            });
                          });
                        }
                        ;
                        throw new Error("Failed pattern match at Main (line 857, column 7 - line 870, column 45): " + [v.constructor.name]);
                      });
                    };
                  };
                  return bind58(liftEffect11($$new(empty3)))(function(metadataRef) {
                    var getMetadata = function(name4) {
                      return bind58(liftEffect11(read(metadataRef)))(function(metadataMap) {
                        var v = lookup16(name4)(metadataMap);
                        if (v instanceof Just) {
                          return pure74(new Right(v.value0));
                        }
                        ;
                        if (v instanceof Nothing) {
                          var metadataFilePath = concat2([registryPath, metadataDirectory, print2(name4) + ".json"]);
                          return discard38(logDebug25("Reading metadata from file: " + metadataFilePath))(function() {
                            return bind58(liftAff9(readJsonFile(codec10)(metadataFilePath)))(function(v1) {
                              if (v1 instanceof Left) {
                                return pure74(new Left(v1.value0));
                              }
                              ;
                              if (v1 instanceof Right) {
                                return discard38(liftEffect11(write(insert19(name4)(v1.value0)(metadataMap))(metadataRef)))(function() {
                                  return pure74(new Right(v1.value0));
                                });
                              }
                              ;
                              throw new Error("Failed pattern match at Main (line 884, column 73 - line 889, column 29): " + [v1.constructor.name]);
                            });
                          });
                        }
                        ;
                        throw new Error("Failed pattern match at Main (line 878, column 7 - line 889, column 29): " + [v.constructor.name]);
                      });
                    };
                    return bind58(ask16)(function(v) {
                      return discard38(whenM3(shouldFetchRegistryRepos)(discard38(logInfo11("Refreshing the Registry Index..."))(function() {
                        return runSpago9({
                          logOptions: v.logOptions,
                          git
                        })(parallelise([bind58($$try10(fetchRepo({
                          git: "https://github.com/purescript/registry-index.git",
                          ref: "main"
                        })(registryIndexPath)))(function(v1) {
                          if (v1 instanceof Right) {
                            return pure74(unit);
                          }
                          ;
                          if (v1 instanceof Left) {
                            return logWarn8("Couldn't refresh the registry-index, will proceed anyways");
                          }
                          ;
                          throw new Error("Failed pattern match at Main (line 901, column 130 - line 903, column 91): " + [v1.constructor.name]);
                        }), bind58($$try10(fetchRepo({
                          git: "https://github.com/purescript/registry.git",
                          ref: "main"
                        })(registryPath)))(function(v1) {
                          if (v1 instanceof Right) {
                            return pure74(unit);
                          }
                          ;
                          if (v1 instanceof Left) {
                            return logWarn8("Couldn't refresh the registry, will proceed anyways");
                          }
                          ;
                          throw new Error("Failed pattern match at Main (line 904, column 119 - line 906, column 85): " + [v1.constructor.name]);
                        })]));
                      })))(function() {
                        return pure74({
                          getManifestFromIndex,
                          getMetadata,
                          logOptions: v.logOptions,
                          git
                        });
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
  });
}();
var mkPublishEnv = function(dependencies) {
  return function(purs) {
    return bind58(ask16)(function(env3) {
      return bind58(function() {
        if (env3.workspace.selected instanceof Just) {
          return pure74(env3.workspace.selected.value0);
        }
        ;
        if (env3.workspace.selected instanceof Nothing) {
          var workspacePackages = getWorkspacePackages(env3.workspace.packageSet);
          if (workspacePackages.length === 1) {
            return pure74(workspacePackages[0]);
          }
          ;
          return discard38(logDebug25(unsafeStringify(workspacePackages)))(function() {
            return die27([toDoc9("No package was selected for publishing. Please select (with -p) one of the following packages:"), indent(toDoc17(map135(function(v) {
              return v["package"].name;
            })(workspacePackages)))]);
          });
        }
        ;
        throw new Error("Failed pattern match at Main (line 779, column 15 - line 793, column 16): " + [env3.workspace.selected.constructor.name]);
      }())(function(selected) {
        return pure74(union10({
          purs,
          selected,
          dependencies
        })(env3));
      });
    });
  };
};
var mkLsEnv = function(dependencies) {
  return bind58(ask16)(function(v) {
    return bind58(function() {
      if (v.workspace.selected instanceof Just) {
        return pure74(v.workspace.selected.value0);
      }
      ;
      if (v.workspace.selected instanceof Nothing) {
        var workspacePackages = getWorkspacePackages(v.workspace.packageSet);
        if (workspacePackages.length === 1) {
          return pure74(workspacePackages[0]);
        }
        ;
        return discard38(logDebug25(unsafeStringify(workspacePackages)))(function() {
          return die27([toDoc9("No package was selected. Please select (with -p) one of the following packages:"), indent(toDoc17(map135(function(v1) {
            return v1["package"].name;
          })(workspacePackages)))]);
        });
      }
      ;
      throw new Error("Failed pattern match at Main (line 919, column 15 - line 933, column 16): " + [v.workspace.selected.constructor.name]);
    }())(function(selected) {
      return pure74({
        logOptions: v.logOptions,
        workspace: v.workspace,
        dependencies,
        selected
      });
    });
  });
};
var mkLogOptions = function(v) {
  return bind214(liftEffect12(supportsColor2))(function(supports) {
    var color = and2([supports, !v.noColor]);
    var verbosity = function() {
      if (v.quiet) {
        return LogQuiet.value;
      }
      ;
      if (v.verbose) {
        return LogVerbose.value;
      }
      ;
      return LogNormal.value;
    }();
    return pure121({
      color,
      verbosity
    });
  });
};
var mkFetchEnv = function(args) {
  var parsePackageName = function(p) {
    var v2 = parse3(p);
    if (v2 instanceof Right) {
      return new Right(v2.value0);
    }
    ;
    if (v2 instanceof Left) {
      return new Left("- Could not parse package " + (show47(p) + (": " + v2.value0)));
    }
    ;
    throw new Error("Failed pattern match at Main (line 820, column 26 - line 822, column 79): " + [v2.constructor.name]);
  };
  var v = partitionMap4(parsePackageName)(fromFoldable35(args.packages));
  return discard38(unless9($$null(v.left))(die27(append118([toDoc9("Failed to parse some package name: ")])(map135(function($683) {
    return indent(toDoc9($683));
  })(v.left)))))(function() {
    return bind58($$for10(args.selectedPackage)(function($684) {
      return function(v1) {
        if (v1 instanceof Right) {
          return pure74(v1.value0);
        }
        ;
        if (v1 instanceof Left) {
          return die19("Failed to parse selected package name, was: " + show52(args.selectedPackage));
        }
        ;
        throw new Error("Failed pattern match at Main (line 827, column 76 - line 829, column 99): " + [v1.constructor.name]);
      }(parse3($684));
    }))(function(maybeSelectedPackage) {
      return bind58(mkRegistryEnv)(function(env3) {
        return bind58(runSpago9(env3)(readWorkspace(maybeSelectedPackage)))(function(workspace) {
          var fetchOpts = {
            packages: v.right,
            ensureRanges: args.ensureRanges
          };
          return pure74({
            fetchOpts,
            env: union10({
              workspace
            })(env3)
          });
        });
      });
    });
  });
};
var mkBundleEnv = function(bundleArgs) {
  return bind58(ask16)(function(v) {
    return discard38(logDebug25("Bundle args: " + show62(bundleArgs)))(function() {
      return bind58(function() {
        if (v.workspace.selected instanceof Just) {
          return pure74(v.workspace.selected.value0);
        }
        ;
        if (v.workspace.selected instanceof Nothing) {
          var workspacePackageNames = map135(function(v1) {
            return v1["package"].name;
          })(getWorkspacePackages(v.workspace.packageSet));
          return die27([toDoc9("No package was selected for bundling. Please select (with -p) one of the following packages:"), indent(toDoc17(workspacePackageNames))]);
        }
        ;
        throw new Error("Failed pattern match at Main (line 607, column 15 - line 613, column 155): " + [v.workspace.selected.constructor.name]);
      }())(function(selected) {
        return discard38(logDebug25("Selected package to bundle: " + print2(selected["package"].name)))(function() {
          var bundleConf = function(f) {
            return bind121(selected["package"].bundle)(f);
          };
          var minify2 = any(function(v1) {
            return v1 === true;
          })([bundleArgs.minify, fromMaybe(false)(bindFlipped12(function(v1) {
            return v1.minify;
          })(selected["package"].bundle))]);
          var entrypoint2 = fromMaybe("Main")(alt31(bundleArgs.module)(bundleConf(function(v1) {
            return v1.module;
          })));
          var outfile2 = fromMaybe("index.js")(alt31(bundleArgs.outfile)(bundleConf(function(v1) {
            return v1.outfile;
          })));
          var platform3 = fromMaybe(BundleBrowser.value)(alt31(bindFlipped12(parsePlatform)(bundleArgs.platform))(bundleConf(function(v1) {
            return v1.platform;
          })));
          var bundleType2 = fromMaybe(BundleApp.value)(alt31(bindFlipped12(parseBundleType)(bundleArgs.type))(bundleConf(function(v1) {
            return v1.type;
          })));
          var bundleOptions = {
            minify: minify2,
            module: entrypoint2,
            outfile: outfile2,
            platform: platform3,
            type: bundleType2
          };
          var newWorkspace = {
            buildOptions: {
              output: alt31(bundleArgs.output)(v.workspace.buildOptions.output),
              pedanticPackages: bundleArgs.pedanticPackages || v.workspace.buildOptions.pedanticPackages,
              censorBuildWarnings: v.workspace.buildOptions.censorBuildWarnings,
              censorCodes: v.workspace.buildOptions.censorCodes,
              filterCodes: v.workspace.buildOptions.filterCodes,
              persistWarnings: v.workspace.buildOptions.persistWarnings,
              showSource: v.workspace.buildOptions.showSource,
              statVerbosity: v.workspace.buildOptions.statVerbosity,
              strict: v.workspace.buildOptions.strict
            },
            packageSet: v.workspace.packageSet,
            selected: v.workspace.selected,
            backend: v.workspace.backend,
            compatibleCompiler: v.workspace.compatibleCompiler,
            doc: v.workspace.doc,
            lockfile: v.workspace.lockfile,
            originalConfig: v.workspace.originalConfig
          };
          return bind58(getEsbuild)(function(esbuild) {
            var bundleEnv = {
              esbuild,
              logOptions: v.logOptions,
              workspace: newWorkspace,
              selected,
              bundleOptions
            };
            return pure74(bundleEnv);
          });
        });
      });
    });
  });
};
var mkBuildEnv = function(buildArgs) {
  return function(dependencies) {
    return bind58(ask16)(function(v) {
      return bind58(getPurs)(function(purs) {
        var newWorkspace = {
          buildOptions: {
            output: alt31(buildArgs.output)(v.workspace.buildOptions.output),
            pedanticPackages: buildArgs.pedanticPackages || v.workspace.buildOptions.pedanticPackages,
            censorBuildWarnings: v.workspace.buildOptions.censorBuildWarnings,
            censorCodes: v.workspace.buildOptions.censorCodes,
            filterCodes: v.workspace.buildOptions.filterCodes,
            persistWarnings: v.workspace.buildOptions.persistWarnings,
            showSource: v.workspace.buildOptions.showSource,
            statVerbosity: v.workspace.buildOptions.statVerbosity,
            strict: v.workspace.buildOptions.strict
          },
          backend: map314(function(b) {
            var v2 = $$null3(buildArgs.backendArgs);
            if (v2) {
              return b;
            }
            ;
            if (!v2) {
              return {
                args: new Just(fromFoldable35(buildArgs.backendArgs)),
                cmd: b.cmd
              };
            }
            ;
            throw new Error("Failed pattern match at Main (line 761, column 19 - line 763, column 84): " + [v2.constructor.name]);
          })(v.workspace.backend),
          compatibleCompiler: v.workspace.compatibleCompiler,
          doc: v.workspace.doc,
          lockfile: v.workspace.lockfile,
          originalConfig: v.workspace.originalConfig,
          packageSet: v.workspace.packageSet,
          selected: v.workspace.selected
        };
        return pure74({
          logOptions: v.logOptions,
          purs,
          git: v.git,
          dependencies,
          workspace: newWorkspace
        });
      });
    });
  };
};
var lsPackagesArgsParser = /* @__PURE__ */ fromRecord2(/* @__PURE__ */ buildArgsCons14(buildRecordArgsNil))({
  json: json2
});
var lsDepsArgsParser = /* @__PURE__ */ fromRecord2(/* @__PURE__ */ buildArgsCons14(/* @__PURE__ */ buildArgsCons9(/* @__PURE__ */ buildArgsCons({
  reflectSymbol: function() {
    return "transitive";
  }
})()()()(buildRecordArgsNil))))({
  json: json2,
  transitive,
  selectedPackage
});
var installArgsParser = /* @__PURE__ */ fromRecord2(/* @__PURE__ */ buildArgsCons2(/* @__PURE__ */ buildArgsCons16(/* @__PURE__ */ buildArgsCons5(/* @__PURE__ */ buildArgsCons19(/* @__PURE__ */ buildArgsCons6(buildArgsCons17))))))({
  packages,
  selectedPackage,
  pursArgs,
  backendArgs,
  output: output2,
  pedanticPackages,
  ensureRanges
});
var initArgsParser = /* @__PURE__ */ fromRecord2(/* @__PURE__ */ buildArgsCons({
  reflectSymbol: function() {
    return "name";
  }
})()()()(/* @__PURE__ */ buildArgsCons({
  reflectSymbol: function() {
    return "setVersion";
  }
})()()()(buildRecordArgsNil)))({
  setVersion: maybeSetVersion,
  name: maybePackageName
});
var globalArgsParser = /* @__PURE__ */ fromRecord2(/* @__PURE__ */ buildArgsCons({
  reflectSymbol: function() {
    return "noColor";
  }
})()()()(/* @__PURE__ */ buildArgsCons({
  reflectSymbol: function() {
    return "quiet";
  }
})()()()(/* @__PURE__ */ buildArgsCons({
  reflectSymbol: function() {
    return "verbose";
  }
})()()()(buildRecordArgsNil))))({
  quiet,
  verbose,
  noColor
});
var fetchArgsParser = /* @__PURE__ */ fromRecord2(/* @__PURE__ */ buildArgsCons16(/* @__PURE__ */ buildArgsCons19(buildArgsCons15)))({
  packages,
  selectedPackage,
  ensureRanges
});
var commandParser = function(command_) {
  return function(parser_) {
    return function(description_) {
      return command(command_)(info(apply24(map413(SpagoCmd.create)(globalArgsParser))(parser_))(progDesc(description_)));
    };
  };
};
var bundleArgsParser = /* @__PURE__ */ fromRecord2(/* @__PURE__ */ buildArgsCons2(/* @__PURE__ */ buildArgsCons1(/* @__PURE__ */ buildArgsCons22(/* @__PURE__ */ buildArgsCons16(/* @__PURE__ */ buildArgsCons4(/* @__PURE__ */ buildArgsCons(minifyIsSymbol)()()()(/* @__PURE__ */ buildArgsCons(moduleIsSymbol)()()()(/* @__PURE__ */ buildArgsCons(outfileIsSymbol)()()()(/* @__PURE__ */ buildArgsCons5(/* @__PURE__ */ buildArgsCons6(/* @__PURE__ */ buildArgsCons7(/* @__PURE__ */ buildArgsCons(platformIsSymbol)()()()(/* @__PURE__ */ buildArgsCons8(/* @__PURE__ */ buildArgsCons9(/* @__PURE__ */ buildArgsCons10(/* @__PURE__ */ buildArgsCons11(/* @__PURE__ */ buildArgsCons12(/* @__PURE__ */ buildArgsCons(typeIsSymbol2)()()()(buildRecordArgsNil)))))))))))))))))))({
  minify,
  module: entrypoint,
  type: bundleType,
  outfile,
  platform: platform2,
  selectedPackage,
  pursArgs,
  backendArgs,
  output: output2,
  pedanticPackages,
  ensureRanges,
  strict,
  censorBuildWarnings,
  showSource,
  censorCodes,
  filterCodes,
  statVerbosity,
  persistWarnings
});
var buildArgsParser = /* @__PURE__ */ fromRecord2(/* @__PURE__ */ buildArgsCons2(/* @__PURE__ */ buildArgsCons1(/* @__PURE__ */ buildArgsCons22(/* @__PURE__ */ buildArgsCons16(/* @__PURE__ */ buildArgsCons4(/* @__PURE__ */ buildArgsCons({
  reflectSymbol: function() {
    return "jsonErrors";
  }
})()()()(buildArgsCons13)))))))({
  selectedPackage,
  pursArgs,
  backendArgs,
  output: output2,
  pedanticPackages,
  ensureRanges,
  jsonErrors,
  strict,
  censorBuildWarnings,
  showSource,
  censorCodes,
  filterCodes,
  statVerbosity,
  persistWarnings
});
var argParser = /* @__PURE__ */ function() {
  return hsubparser(fold22([commandParser("init")(map413(Init.create)(initArgsParser))("Initialise a new project"), commandParser("fetch")(map413(Fetch.create)(fetchArgsParser))("Downloads all of the project's dependencies"), commandParser("install")(map413(Install.create)(installArgsParser))("Compile the project's dependencies"), commandParser("build")(map413(Build.create)(buildArgsParser))("Compile the project"), commandParser("run")(map413(Run.create)(runArgsParser))("Run the project"), commandParser("test")(map413(Test.create)(testArgsParser))("Test the project"), commandParser("bundle")(map413(Bundle.create)(bundleArgsParser))("Bundle the project in a single file"), commandParser("sources")(map413(Sources.create)(sourcesArgsParser))("List all the source paths (globs) for the dependencies of the project"), commandParser("repl")(map413(Repl.create)(replArgsParser))("Start a REPL"), commandParser("publish")(map413(Publish2.create)(publishArgsParser))("Publish a package"), command("registry")(info(hsubparser(fold22([commandParser("search")(map413(RegistrySearch.create)(registrySearchArgsParser))("Search for package names in the Registry"), commandParser("info")(map413(RegistryInfo.create)(registryInfoArgsParser))("Query the Registry for information about packages and versions")])))(progDesc("Commands to interact with the Registry"))), command("ls")(info(hsubparser(fold22([commandParser("packages")(map413(LsPackages.create)(lsPackagesArgsParser))("List packages available in the local package set"), commandParser("deps")(map413(LsDeps.create)(lsDepsArgsParser))("List dependencies of the project")])))(progDesc("List packages or dependencies")))]));
}();
var parseArgs = /* @__PURE__ */ function() {
  return customExecParser(function(v) {
    return {
      prefMultiSuffix: v.prefMultiSuffix,
      prefDisambiguate: v.prefDisambiguate,
      prefShowHelpOnError: true,
      prefShowHelpOnEmpty: true,
      prefBacktrack: v.prefBacktrack,
      prefColumns: v.prefColumns
    };
  }(defaultPrefs))(info(apply24(helper)(alt(parserAlt)(map413(Left.create)(argParser))(map413(Right.create)($$switch(append211($$long(flagFieldsHasName)("version"))(append211($$short(flagFieldsHasName)("v"))(help("Show the current version"))))))))(progDesc("PureScript package manager and build tool")));
}();
var main = /* @__PURE__ */ function() {
  var printVersion = bind214(mkLogOptions({
    noColor: false,
    quiet: false,
    verbose: false
  }))(function(logOptions) {
    return runSpago1({
      logOptions
    })(logInfo11(buildInfo.spagoVersion));
  });
  return function __do3() {
    var c = parseArgs();
    return launchAff_(function() {
      if (c instanceof Left) {
        return bind214(mkLogOptions(c.value0.value0))(function(logOptions) {
          return runSpago1({
            logOptions
          })(function() {
            if (c.value0.value1 instanceof Sources) {
              return bind58(mkFetchEnv({
                packages: mempty21,
                selectedPackage: c.value0.value1.value0.selectedPackage,
                ensureRanges: false
              }))(function(v) {
                return $$void18(runSpago9(v.env)(run11({
                  json: c.value0.value1.value0.json
                })));
              });
            }
            ;
            if (c.value0.value1 instanceof Init) {
              return bind58(getPurs)(function(purs) {
                var candidateName = fromMaybe(take3(50)(basename(cwd2)))(c.value0.value1.value0.name);
                return discard38(logDebug19([show47(cwd2), show47(candidateName)]))(function() {
                  return bind58(function() {
                    var v = parse3(stripPureScriptPrefix(candidateName));
                    if (v instanceof Left) {
                      return die33(["Could not figure out a name for the new package. Error:", show47(v.value0)]);
                    }
                    ;
                    if (v instanceof Right) {
                      return pure74(v.value0);
                    }
                    ;
                    throw new Error("Failed pattern match at Main (line 441, column 28 - line 443, column 32): " + [v.constructor.name]);
                  }())(function(packageName) {
                    return bind58($$for10(c.value0.value1.value0.setVersion)(function($685) {
                      return function(v) {
                        if (v instanceof Left) {
                          return die33(["Could not parse provided set version. Error:", show47(v.value0)]);
                        }
                        ;
                        if (v instanceof Right) {
                          return pure74(v.value0);
                        }
                        ;
                        throw new Error("Failed pattern match at Main (line 444, column 73 - line 446, column 32): " + [v.constructor.name]);
                      }(parseLenientVersion($685));
                    }))(function(setVersion) {
                      return discard38(logDebug19(["Got packageName and setVersion:", print2(packageName), unsafeStringify(setVersion)]))(function() {
                        var initOpts = {
                          packageName,
                          setVersion
                        };
                        return discard38($$void18(mkRegistryEnv))(function() {
                          return discard38($$void18(runSpago9({
                            logOptions,
                            purs
                          })(run7(initOpts))))(function() {
                            return discard38(logInfo11("Set up a new Spago project."))(function() {
                              return logInfo11("Try running `spago run`");
                            });
                          });
                        });
                      });
                    });
                  });
                });
              });
            }
            ;
            if (c.value0.value1 instanceof Fetch) {
              return bind58(mkFetchEnv(c.value0.value1.value0))(function(v) {
                return $$void18(runSpago9(v.env)(run6(v.fetchOpts)));
              });
            }
            ;
            if (c.value0.value1 instanceof RegistrySearch) {
              return bind58(mkRegistryEnv)(function(env3) {
                return $$void18(runSpago9(env3)(search(c["value0"]["value1"]["value0"]["package"])));
              });
            }
            ;
            if (c.value0.value1 instanceof RegistryInfo) {
              return bind58(mkRegistryEnv)(function(env3) {
                return $$void18(runSpago9(env3)(info3(c.value0.value1.value0)));
              });
            }
            ;
            if (c.value0.value1 instanceof Install) {
              return bind58(mkFetchEnv({
                packages: c.value0.value1.value0.packages,
                selectedPackage: c.value0.value1.value0.selectedPackage,
                ensureRanges: c.value0.value1.value0.ensureRanges
              }))(function(v) {
                return bind58(runSpago9(v.env)(run6(v.fetchOpts)))(function(dependencies) {
                  var buildArgs = merge3(c.value0.value1.value0)({
                    censorBuildWarnings: Nothing.value,
                    censorCodes: Nothing.value,
                    filterCodes: Nothing.value,
                    statVerbosity: Nothing.value,
                    showSource: Nothing.value,
                    strict: Nothing.value,
                    persistWarnings: Nothing.value
                  });
                  return bind58(runSpago9(v.env)(mkBuildEnv(buildArgs)(dependencies)))(function(env$prime) {
                    var options = {
                      depsOnly: true,
                      pursArgs: toUnfoldable111(c.value0.value1.value0.pursArgs),
                      jsonErrors: false
                    };
                    return runSpago9(env$prime)(run3(options));
                  });
                });
              });
            }
            ;
            if (c.value0.value1 instanceof Build) {
              return bind58(mkFetchEnv({
                packages: mempty21,
                selectedPackage: c.value0.value1.value0.selectedPackage,
                ensureRanges: c.value0.value1.value0.ensureRanges
              }))(function(v) {
                return bind58(runSpago9(v.env)(run6(v.fetchOpts)))(function(dependencies) {
                  return bind58(runSpago9(v.env)(mkBuildEnv(c.value0.value1.value0)(dependencies)))(function(buildEnv) {
                    var options = {
                      depsOnly: false,
                      pursArgs: toUnfoldable111(c.value0.value1.value0.pursArgs),
                      jsonErrors: c.value0.value1.value0.jsonErrors
                    };
                    return runSpago9(buildEnv)(run3(options));
                  });
                });
              });
            }
            ;
            if (c.value0.value1 instanceof Publish2) {
              return bind58(mkFetchEnv({
                packages: mempty21,
                selectedPackage: c.value0.value1.value0.selectedPackage,
                ensureRanges: false
              }))(function(v) {
                return bind58(runSpago9(v.env)(run6(v.fetchOpts)))(function(dependencies) {
                  var buildArgs = {
                    selectedPackage: c.value0.value1.value0.selectedPackage,
                    backendArgs: mempty21,
                    output: mempty111,
                    pedanticPackages: false,
                    ensureRanges: false,
                    jsonErrors: false,
                    censorBuildWarnings: Nothing.value,
                    censorCodes: Nothing.value,
                    filterCodes: Nothing.value,
                    statVerbosity: Nothing.value,
                    showSource: Nothing.value,
                    strict: Nothing.value,
                    persistWarnings: Nothing.value
                  };
                  return bind58(runSpago9(v.env)(mkBuildEnv(buildArgs)(dependencies)))(function(v1) {
                    return bind58(runSpago9(v.env)(mkPublishEnv(dependencies)(v1.purs)))(function(publishEnv) {
                      return $$void18(runSpago9(publishEnv)(publish({})));
                    });
                  });
                });
              });
            }
            ;
            if (c.value0.value1 instanceof Repl) {
              return bind58(bind58(exists9("spago.yaml"))(function(v) {
                if (v) {
                  return pure74(mempty21);
                }
                ;
                if (!v) {
                  return discard38(logWarn8("No configuration found, creating a temporary project to run a repl in..."))(function() {
                    return bind58(mkTemp3)(function(tmpDir) {
                      return discard38(mkdirp6(tmpDir))(function() {
                        return discard38(logDebug25("Creating repl project in temp dir: " + tmpDir))(function() {
                          return discard38(liftEffect11(chdir(tmpDir)))(function() {
                            return bind58(getPurs)(function(purs) {
                              return discard38($$void18(runSpago9({
                                purs,
                                logOptions
                              })(run7({
                                setVersion: Nothing.value,
                                packageName: "repl"
                              }))))(function() {
                                return pure74(fromFoldable211(["effect", "console"]));
                              });
                            });
                          });
                        });
                      });
                    });
                  });
                }
                ;
                throw new Error("Failed pattern match at Main (line 514, column 52 - line 527, column 65): " + [v.constructor.name]);
              }))(function(packages2) {
                return bind58(mkFetchEnv({
                  packages: packages2,
                  selectedPackage: c.value0.value1.value0.selectedPackage,
                  ensureRanges: false
                }))(function(v) {
                  return bind58(runSpago9(v.env)(run6(v.fetchOpts)))(function(dependencies) {
                    return bind58(runSpago9(v.env)(supportPackage(v.env.workspace.packageSet)))(function(supportPackages) {
                      return bind58(runSpago9(v.env)(mkReplEnv(c.value0.value1.value0)(union12(dependencies)(supportPackages))))(function(replEnv) {
                        return $$void18(runSpago9(replEnv)(run5));
                      });
                    });
                  });
                });
              });
            }
            ;
            if (c.value0.value1 instanceof Bundle) {
              return bind58(mkFetchEnv({
                packages: mempty21,
                selectedPackage: c.value0.value1.value0.selectedPackage,
                ensureRanges: c.value0.value1.value0.ensureRanges
              }))(function(v) {
                return bind58(runSpago9(v.env)(run6(v.fetchOpts)))(function(dependencies) {
                  return bind58(runSpago9(v.env)(mkBuildEnv(c.value0.value1.value0)(dependencies)))(function(buildEnv) {
                    var options = {
                      depsOnly: false,
                      pursArgs: toUnfoldable111(c.value0.value1.value0.pursArgs),
                      jsonErrors: false
                    };
                    return discard38(runSpago9(buildEnv)(run3(options)))(function() {
                      return bind58(runSpago9(v.env)(mkBundleEnv(c.value0.value1.value0)))(function(bundleEnv) {
                        return runSpago9(bundleEnv)(run4);
                      });
                    });
                  });
                });
              });
            }
            ;
            if (c.value0.value1 instanceof Run) {
              return bind58(mkFetchEnv({
                packages: mempty21,
                selectedPackage: c.value0.value1.value0.selectedPackage,
                ensureRanges: c.value0.value1.value0.ensureRanges
              }))(function(v) {
                return bind58(runSpago9(v.env)(run6(v.fetchOpts)))(function(dependencies) {
                  return bind58(runSpago9(v.env)(mkBuildEnv(c.value0.value1.value0)(dependencies)))(function(buildEnv) {
                    var options = {
                      depsOnly: false,
                      pursArgs: toUnfoldable111(c.value0.value1.value0.pursArgs),
                      jsonErrors: false
                    };
                    return discard38(runSpago9(buildEnv)(run3(options)))(function() {
                      return bind58(runSpago9(v.env)(mkRunEnv(c.value0.value1.value0)(buildEnv)))(function(runEnv) {
                        return runSpago9(runEnv)(run10);
                      });
                    });
                  });
                });
              });
            }
            ;
            if (c.value0.value1 instanceof Test) {
              return bind58(mkFetchEnv({
                packages: mempty21,
                selectedPackage: c.value0.value1.value0.selectedPackage,
                ensureRanges: false
              }))(function(v) {
                return bind58(runSpago9(v.env)(run6(v.fetchOpts)))(function(dependencies) {
                  return bind58(runSpago9(v.env)(mkBuildEnv(union10(c.value0.value1.value0)({
                    ensureRanges: false
                  }))(dependencies)))(function(buildEnv) {
                    var options = {
                      depsOnly: false,
                      pursArgs: toUnfoldable111(c.value0.value1.value0.pursArgs),
                      jsonErrors: false
                    };
                    return discard38(runSpago9(buildEnv)(run3(options)))(function() {
                      return bind58(runSpago9(v.env)(mkTestEnv(c.value0.value1.value0)(buildEnv)))(function(testEnv) {
                        return runSpago9(testEnv)(run12);
                      });
                    });
                  });
                });
              });
            }
            ;
            if (c.value0.value1 instanceof LsPackages) {
              var fetchArgs = {
                packages: mempty21,
                selectedPackage: Nothing.value,
                ensureRanges: false
              };
              return bind58(mkFetchEnv(fetchArgs))(function(v) {
                return bind58(runSpago9(v.env)(run6(v.fetchOpts)))(function(dependencies) {
                  var lsEnv = {
                    workspace: v.env.workspace,
                    dependencies,
                    logOptions
                  };
                  return runSpago9(lsEnv)(listPackageSet(c.value0.value1.value0));
                });
              });
            }
            ;
            if (c.value0.value1 instanceof LsDeps) {
              var fetchArgs = {
                packages: mempty21,
                selectedPackage: c.value0.value1.value0.selectedPackage,
                ensureRanges: false
              };
              return bind58(mkFetchEnv(fetchArgs))(function(v) {
                return bind58(runSpago9(v.env)(run6(v.fetchOpts)))(function(dependencies) {
                  return bind58(runSpago9(v.env)(mkLsEnv(dependencies)))(function(lsEnv) {
                    return runSpago9(lsEnv)(listPackages({
                      json: c.value0.value1.value0.json,
                      transitive: c.value0.value1.value0.transitive
                    }));
                  });
                });
              });
            }
            ;
            throw new Error("Failed pattern match at Main (line 432, column 33 - line 581, column 66): " + [c.value0.value1.constructor.name]);
          }());
        });
      }
      ;
      if (c instanceof Right) {
        return when14(c.value0)(printVersion);
      }
      ;
      throw new Error("Failed pattern match at Main (line 429, column 26 - line 582, column 40): " + [c.constructor.name]);
    }())();
  };
}();

// <stdin>
main();
/*! Bundled license information:

is-extglob/index.js:
  (*!
   * is-extglob <https://github.com/jonschlinkert/is-extglob>
   *
   * Copyright (c) 2014-2016, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

is-glob/index.js:
  (*!
   * is-glob <https://github.com/jonschlinkert/is-glob>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

is-number/index.js:
  (*!
   * is-number <https://github.com/jonschlinkert/is-number>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

to-regex-range/index.js:
  (*!
   * to-regex-range <https://github.com/micromatch/to-regex-range>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

fill-range/index.js:
  (*!
   * fill-range <https://github.com/jonschlinkert/fill-range>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

queue-microtask/index.js:
  (*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

run-parallel/index.js:
  (*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
