-- | The main module of the CLI interface app.
module Docs.Search.Main where

import Prelude

import Docs.Search.IndexBuilder as IndexBuilder
import Docs.Search.Interactive as Interactive
import Docs.Search.Config (config)
import Docs.Search.Types (PackageName(..))

import Data.Generic.Rep (class Generic)
import Data.Generic.Rep.Show (genericShow)
import Data.List as List
import Data.List.NonEmpty as NonEmpty
import Data.Maybe (Maybe, fromMaybe, optional)
import Data.Newtype (unwrap)
import Data.Unfoldable (class Unfoldable)
import Effect (Effect)
import Effect.Console (log)
import Options.Applicative (Parser, command, execParser, flag, fullDesc, help, helper, info, long, metavar, progDesc, strOption, subparser, value, (<**>))
import Options.Applicative as CA


main :: Effect Unit
main = do

  args <- getArgs
  let defaultCommands = Search { docsFiles: defaultDocsFiles
                               , bowerFiles: defaultBowerFiles
                               , packageName: config.defaultPackageName
                               }

  case fromMaybe defaultCommands args of
    BuildIndex cfg -> IndexBuilder.run cfg
    Search cfg -> Interactive.run cfg
    Version -> log config.version


getArgs :: Effect (Maybe Commands)
getArgs = execParser opts
  where
    opts =
      info (commands <**> helper)
      ( fullDesc
     <> progDesc "Search frontend for the documentation generated by the PureScript compiler."
      )


data Commands
  = BuildIndex IndexBuilder.Config
  | Search Interactive.Config
  | Version


derive instance genericCommands :: Generic Commands _

instance showCommands :: Show Commands where
  show = genericShow


commands :: Parser (Maybe Commands)
commands = optional $ subparser
  ( command "build-index"
    ( info (buildIndex <**> helper)
      ( progDesc "Build the index used to search for definitions and patch the generated docs so that they include a search field."
      )
    )
 <> command "search"
    ( info (startInteractive <**> helper)
      ( progDesc "Run the search engine."
      )
    )
 <> command "version"
    ( info (pure Version <**> helper)
      ( progDesc "Show purescript-docs-search version."
      )
    )
  )


buildIndex :: Parser Commands
buildIndex = ado

  docsFiles <- docsFilesOption

  bowerFiles <- bowerFilesOption

  packageName <- packageNameOption

  generatedDocs <- strOption
    ( long "generated-docs"
   <> metavar "DIR"
   <> value "./generated-docs/"
    )

  noPatch <- flag false true
    ( long "no-patch"
   <> help "Do not patch the HTML docs, only build indices"
    )


  in BuildIndex { docsFiles, bowerFiles, generatedDocs, noPatch, packageName }


startInteractive :: Parser Commands
startInteractive = ado

  docsFiles <- docsFilesOption

  bowerFiles <- bowerFilesOption

  packageName <- packageNameOption

  in Search { docsFiles, bowerFiles, packageName }


docsFilesOption :: Parser (Array String)
docsFilesOption = fromMaybe defaultDocsFiles <$>
   optional
   ( some
     ( strOption
       ( long "docs-files"
      <> metavar "GLOB"
       )
     )
   )


bowerFilesOption :: Parser (Array String)
bowerFilesOption = fromMaybe defaultBowerFiles <$>
   optional
   ( some
     ( strOption
       ( long "bower-jsons"
      <> metavar "GLOB"
       )
     )
   )


packageNameOption :: Parser PackageName
packageNameOption =
  PackageName <$> strOption
  ( long "package-name"
 <> metavar "PACKAGE"
 <> value (unwrap $ config.defaultPackageName)
  )


defaultDocsFiles :: Array String
defaultDocsFiles = [ "output/**/docs.json" ]


defaultBowerFiles :: Array String
defaultBowerFiles = [ ".spago/*/*/bower.json", "bower_components/purescript-*/bower.json" ]


many :: forall a f. Unfoldable f => Parser a -> Parser (f a)
many x = CA.many x <#> List.toUnfoldable


some :: forall a f. Unfoldable f => Parser a -> Parser (f a)
some x = CA.some x <#> NonEmpty.toUnfoldable
